<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>English</title>
    <url>/2023/05/24/English/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h3><p>在英语语法中，有五种基本的简单句结构，它们分别是：</p>
<ol>
<li>主语 + 动词 (Subject + Verb)：这是最基本的简单句结构，主语是句子中的主要名词或代词，动词描述主语的动作或状态。例如：”She sings.”（她唱歌。）</li>
<li>主语 + 动词 + 宾语 (Subject + Verb + Object)：除了主语和动词，这种简单句还包括一个宾语，宾语是动作的接受者或影响者。例如：”I love you.”（我爱你。）</li>
<li>主语 + 动词 + 表语 (Subject + Verb + Predicative)：表语是对主语的描述或补充，通常使用形容词或名词。例如：”He is a doctor.”（他是一名医生。）</li>
<li>主语 + 动词 + 间接宾语 + 直接宾语 (Subject + Verb + Indirect Object + Direct Object)：这种结构中，动作的影响对象由直接宾语表示，而间接宾语表示受益人或间接对象。例如：”She gave me a book.”（她给了我一本书。）</li>
<li>主语 + 动词 + 宾语 + 宾补 (Subject + Verb + Object + Object Complement)：宾补是对宾语的进一步描述或补充，通常使用形容词或名词。例如：”They elected him president.”（他们选举他为总统。）</li>
</ol>
<p>所有句子都是基于以上的句子构成，至于修饰语是和主语结合形成一个新的“主语”。要单拿出来解释的有</p>
<h4 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h4><p>在英语中，补语通常出现在以下几种情况下：</p>
<ol>
<li><p>表语（Predicative Complement）：表语是用来描述或补充主语的成分。它可以是名词、形容词、代词或介词短语。例如：</p>
<ul>
<li><p>She is a doctor.（表语是名词）</p>
</li>
<li><p>He seems happy.（表语是形容词）</p>
</li>
<li><p>They elected her as the president.（表语是介词短语）</p>
<blockquote>
<p>作为表语的动词没有实际意义，只起到了链接主语和宾语的作用，相当于绳子一样系住，所以被称之为系动词。</p>
<p>同时，be动词单拿出来有一个含义是：存在的意思。</p>
<p><strong>To be or not to be, that is the question.</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>宾语补足语（Object Complement）：宾语补足语用来补充或描述及物动词后面的宾语。它通常是名词、形容词或介词短语。例如：</p>
<ul>
<li><p>They made him the captain.（宾语补足语是名词）</p>
</li>
<li><p>She painted the walls blue.（宾语补足语是形容词）</p>
<blockquote>
<p>宾补是用来描述宾语的状态，完善句子结构的一个词类。</p>
<p>宾补一般是形容词，如果是名词的话，我们可以理解宾语和宾补是一种主系表的关系，相当于宾语is宾补这样（去掉的be动词）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>主语补足语（Subject Complement）：主语补足语出现在系动词（be动词、感官动词、变化动词等）后面，用来补充或描述主语。它通常是名词、形容词或介词短语。例如：</p>
<ul>
<li><p>He is a teacher.（主语补足语是名词）</p>
</li>
<li><p>She became angry.（主语补足语是形容词）</p>
<blockquote>
<p>就是主系表，这里描述主语被修饰的部分。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="双宾语"><a href="#双宾语" class="headerlink" title="双宾语"></a>双宾语</h4><p>在句子中，宾语、宾语补足语和双宾语是不同的语法成分，它们在句子结构和功能上有所区别。下面是对它们的解释和区分：</p>
<ol>
<li><p>宾语（Object）：宾语是一个句子中的核心成分，它接受动作的影响或指示动作的对象。宾语通常是动词的直接接受者或受益者。在英语中，宾语通常是名词、代词或名词性短语。例如：</p>
<ul>
<li>她买了一本书。 She bought a book.</li>
<li>他给我一杯咖啡。 He gave me a cup of coffee.</li>
</ul>
<p>在这些例句中，”一本书”和”一杯咖啡”是宾语，它们接受动词的动作。</p>
</li>
<li><p>宾语补足语（Object Complement）：宾语补足语是用来进一步描述、补充或修改宾语的成分。它通常出现在及物动词或使役动词后面，用来提供额外的信息来描述宾语的性质、状态、身份等。宾语补足语可以是形容词、名词、介词短语等。例如：</p>
<ul>
<li>我发现他很聪明。 I found him intelligent.</li>
<li>她把那个男孩称为英雄。 She called that boy a hero.</li>
</ul>
<p>在这些例句中，”聪明”和”英雄”是宾语补足语，它们进一步描述了宾语的特征。</p>
</li>
<li><p>双宾语（Double Object）：双宾语结构是一种特殊的情况，其中动词可以带有两个宾语，一个直接宾语和一个间接宾语。直接宾语是接受动作的直接对象，而间接宾语是动作的受益者或间接对象。在英语中，直接宾语通常是名词或代词，而间接宾语通常是介词短语或代词。例如：</p>
<ul>
<li>我送给她一束花。 I gave her a bouquet of flowers.</li>
<li>他买了我一杯咖啡。 He bought me a cup of coffee.</li>
</ul>
<p>在这些例句中，”一束花”和”一杯咖啡”是直接宾语，”她”和”我”是间接宾语。直接宾语接受动作，而间接宾语是动作的受益者。</p>
</li>
</ol>
<h3 id="名词性成分"><a href="#名词性成分" class="headerlink" title="名词性成分"></a>名词性成分</h3><h4 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h4><p>在英语中，动名词（Gerund）可以作为动词的形式在句子中充当多种语法角色。以下是动名词可能出现的几种语法角色和用法：</p>
<ol>
<li>主语（Subject）：<ul>
<li>Swimming is my favorite hobby.（游泳是我最喜欢的爱好。）</li>
<li>Jogging helps me stay fit.（慢跑帮助我保持健康。）</li>
</ul>
</li>
<li>宾语（Object）：<ul>
<li>I enjoy swimming in the ocean.（我喜欢在海里游泳。）</li>
<li>She loves reading books.（她喜欢读书。）</li>
</ul>
</li>
<li>宾语补足语（Object Complement）：<ul>
<li>He made a living by teaching English.（他靠教英语谋生。）</li>
<li>They find joy in helping others.（他们从帮助他人中找到快乐。）</li>
</ul>
</li>
<li>介词宾语（Object of Preposition）：<ul>
<li>She is interested in painting.（她对绘画感兴趣。）</li>
<li>We talked about going on a trip.（我们谈论去旅行的事。）</li>
</ul>
</li>
<li>主格形式（Subjective Form）：<ul>
<li>Swimming is a great exercise.（游泳是一项很好的运动。）</li>
<li>Running can be tiring but rewarding.（跑步可能会令人疲劳，但是有回报。）</li>
</ul>
</li>
</ol>
<p>需要注意的是，动名词在功能上可以类似名词，但它保留了动词的性质和特点，可以带有动词的补语或修饰语。动名词以-ing 结尾，并且可以有自己的宾语、副词修饰等。</p>
<h4 id="名词短语"><a href="#名词短语" class="headerlink" title="名词短语"></a>名词短语</h4><p>名词短语（Noun Phrase）是由一个名词（或代词）充当核心，并且可能由其他修饰语或补语组成的短语。名词短语具有以下特点：</p>
<ol>
<li><p>名词核心：名词短语的核心是一个名词或代词，它给出短语所描述的事物、人或概念的基本标识。例如，”a book”（一本书）中的名词短语核心是”book”（书）。</p>
</li>
<li><p>修饰语：名词短语可以由多个修饰语组成，这些修饰语在语法上修饰或限定名词的含义、特征或属性。修饰语可以是形容词、限定词、副词或其他名词短语等。例如，”a beautiful old house”（一座美丽的古老房屋）中的”beautiful”（美丽的）和”old”（古老的）都是修饰语。</p>
</li>
<li><p>补语：名词短语还可以包含补语，补语是对名词的进一步补充或说明。常见的补语包括形容词短语、介词短语或从句等。例如，”the president of the company”（公司的总裁）中的”of the company”（公司的）是一个介词短语作为补语。</p>
</li>
<li><p>可拓展性：名词短语可以根据需要进行扩展，以提供更多的信息或详细描述。可以添加更多的修饰语、补语或其他成分来进一步丰富名词短语的含义。例如，”a small red leather-bound book on the shelf”（架子上一本小巧的红色皮封书）中的名词短语逐渐扩展，包含了多个修饰语和补语。</p>
</li>
<li><p>在句子中的作用：名词短语在句子中可以作为主语、宾语、表语、定语或同位语等。它们在句子中承担名词的角色，并根据语境和句子结构发挥不同的语法功能。</p>
<blockquote>
<p>名词短语包括 1.限定词 2.形容词 3.名词构成，任意一个部分都可能被省略</p>
</blockquote>
</li>
</ol>
<p>名词短语在语言中起到重要的作用，它们用来描述和指代具体的事物、人或概念，并且在句子中扮演多种语法角色。名词短语的特点包括核心名词、修饰语、补语、可拓展性和语法功能的多样性。</p>
<h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><p>名词性从句（Noun Clauses）是一种在句子中充当名词的从句，它可以担任名词在句子中的各种功能，例如主语、宾语、表语、补足语等。以下是名词性从句的几个特点：</p>
<ol>
<li>充当名词角色：名词性从句在句子中充当名词的角色，可以出现在与名词相同的位置。例如：<ul>
<li>主语：What she said is true.（她说的是真的。）</li>
<li>宾语：I don’t know where he went.（我不知道他去哪了。）</li>
<li>表语：Her dream is that she wants to travel the world.（她的梦想是她想环游世界。）</li>
<li>宾补：I made a promise that I would help him.（我许下承诺，我会帮助他。）</li>
</ul>
</li>
<li>引导词：名词性从句通常由引导词引导，常见的引导词包括：<ul>
<li>连接代词：who, whom, whose, which, what</li>
<li>连接副词：where, when, why, how</li>
</ul>
</li>
<li>可以包含陈述句、疑问句或感叹句的结构：名词性从句可以采用陈述句、疑问句或感叹句的结构，根据从句的具体功能和意义进行相应的语序调整。例如：<ul>
<li>陈述句结构：I know that he is coming.（我知道他要来。）</li>
<li>疑问句结构：Can you tell me where she lives?（你能告诉我她住在哪里吗？）</li>
<li>感叹句结构：What a beautiful day it is!（多么美好的一天啊！）</li>
</ul>
</li>
<li>可以包含其他从句或从句成分：名词性从句内部可以包含其他从句或从句成分，形成更复杂的句子结构。例如：<ul>
<li>I don’t know what he said when he left.（我不知道他离开时说了什么。）</li>
<li>The question is whether they will attend the party.（问题是他们是否会参加聚会。）</li>
</ul>
</li>
</ol>
<p>总之，名词性从句在句子中具有名词的功能，可以出现在与名词相同的位置，并由引导词引导。它可以采用陈述句、疑问句或感叹句的结构，还可以包含其他从句或从句成分。名词性从句在句子中起着重要的名词替代作用，丰富了句子的表达和结构。</p>
<h3 id="形容词成分"><a href="#形容词成分" class="headerlink" title="形容词成分"></a>形容词成分</h3><p>在英语中，以下成分可以充当形容词：</p>
<ol>
<li>形容词（Adjectives）：它们直接修饰名词或代词，描述其特征或性质。例如：beautiful（美丽的）、old（老的）。</li>
<li>限定词（Determiners）：这些词修饰名词并限定其范围。它们可以指示数量、所有权、特定性等。例如：a（一个）、my（我的）、this（这个）。</li>
<li>数词（Numerals）：它们表示数量，可以是基数词（cardinal numbers）或序数词（ordinal numbers）。例如：three（三）、first（第一）。</li>
<li>不定代词（Indefinite Pronouns）：这些代词在句子中充当形容词的角色，描述某种未指定的事物或人。例如：some（一些）、any（任何）。</li>
<li>分词（Participles）：它们是动词的非谓语形式，可以作为形容词使用。分词通常用来描述名词所具有的状态或特征。例如：broken（破碎的）、fascinating（迷人的）。</li>
<li>物质名词（Nouns as Adjectives）：有时，名词被用作形容词来描述其他名词。例如：water（水）可以修饰bottle（瓶子），形成water bottle（水瓶）。</li>
</ol>
<p>这些是一些常见的充当形容词的成分，它们在句子中起到描述或修饰名词的作用。</p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>在英语中，分词（Participles）具有以下特点：</p>
<ol>
<li>非谓语形式：分词是动词的非谓语形式，不具备时态和主语一致的特征。它们可以被用作形容词或副词，描述名词或修饰动词。</li>
<li>形容词性质：分词在形式上类似于形容词，可以用来描述名词的特征或状态。例如，”a broken cup”（一个破碎的杯子），其中的”broken”是现在分词作为形容词修饰”cup”。</li>
<li>副词性质：分词也可以作为副词修饰动词，表示动作的方式、原因或时间等。例如，”He ran, breathing heavily”（他跑着，大口喘着气），其中的”breathing”是现在分词作为副词修饰”ran”。</li>
<li>主动或被动：根据分词的形式，可以区分主动分词（Present Participle）和过去分词（Past Participle）。主动分词以-ing结尾（例如”running”），而过去分词通常以-ed、-en、-d、-t或其他变体结尾（例如”broken”）。它们在形式上不同，但在用法上有一些共同之处。</li>
<li>修饰名词：分词可以直接修饰名词或代词，描述其特征或状态。例如，”a sleeping baby”（一个正在睡觉的宝宝），其中的”sleeping”是现在分词作为形容词修饰”baby”。</li>
<li>时间关系：分词可以表达动作发生的时间关系，例如表示同时进行的动作、先后发生的动作或完成的动作等。这取决于上下文和其他句子成分的配合使用。</li>
</ol>
<p>分词是英语中一种灵活的语法结构，可以增加句子的表达能力和丰富性。了解分词的特点和用法，有助于正确使用和理解它们在句子中的作用。</p>
<h4 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h4><p>在英语中，定语从句（Relative Clause）是一种用来修饰名词或代词的从句。它提供了额外的信息，帮助我们更清楚地理解或限定被修饰的名词或代词。定语从句通常由一个关系词引导，如”who”、”whom”、”whose”、”which”、”that”等。</p>
<p>以下是一些示例：</p>
<blockquote>
<ol>
<li>The man who is standing over there is my brother. （站在那边的那个男人是我的兄弟。） 在这个例子中，定语从句 “who is standing over there” 修饰并进一步描述了名词 “man”。</li>
<li>The book that I borrowed from the library is very interesting. （我从图书馆借的那本书非常有趣。） 这个定语从句 “that I borrowed from the library” 修饰并描述了名词 “book”。</li>
<li>This is the house whose roof was damaged in the storm. （这是屋顶在风暴中受损的那所房子。） 定语从句 “whose roof was damaged in the storm” 修饰并限定了名词 “house”。</li>
</ol>
</blockquote>
<p>定语从句可以提供额外的信息，如对名词的身份、特征、归属关系等进行描述，使句子更加具体和明确。在构建定语从句时，需要注意关系词的选择和从句的位置，以确保句子的准确性和流畅性。</p>
<blockquote>
<p>定语从句可以被理解为形容词从句，因为它们都用来修饰名词或代词，提供额外的描述或限定。形容词从句描述或限定名词的方式与定语从句相似。</p>
<p>形容词从句通常由一个关系词引导，如”who”、”whom”、”whose”、”which”、”that”等。这些关系词在形容词从句中起到连接主句和从句的作用。</p>
<p>下面是一个示例，展示了形容词从句的使用：</p>
<p>原句：The girl is very intelligent. 改为形容词从句：The girl who is very intelligent is my sister. （那个非常聪明的女孩是我的姐妹。）</p>
<p>在这个例子中，形容词从句 “who is very intelligent” 修饰并进一步描述了名词 “girl”。这个形容词从句提供了关于女孩聪明程度的信息。</p>
<p>因此，定语从句可以被视为形容词从句，因为它们都在句子中充当形容词的角色，对名词进行修饰和描述。</p>
</blockquote>
<h3 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h3><p>在英语中，动词时态（Verb Tense）用于表示动作或状态发生的时间。英语中常见的动词时态包括以下几种（这里只讨论时态）：</p>
<ol>
<li>现在时态（Present Tense）：<ul>
<li>简单现在时（Simple Present）：表示经常性、习惯性的动作或普遍真理。例如：”I play tennis every Sunday.”（我每个星期天打网球。）</li>
<li>现在进行时（Present Continuous）：表示正在进行的动作。例如：”She is watching TV now.”（她正在看电视。）</li>
<li>现在完成时（Present Perfect）：表示过去发生的动作对现在的影响或状态。例如：”I have finished my homework.”（我已经完成作业。）</li>
</ul>
</li>
<li>过去时态（Past Tense）：<ul>
<li>简单过去时（Simple Past）：表示过去发生的具体动作或状态。例如：”He played football yesterday.”（他昨天踢足球。）</li>
<li>过去进行时（Past Continuous）：表示过去某一时刻正在进行的动作。例如：”They were watching a movie when I arrived.”（当我到达时，他们正在看电影。）</li>
<li>过去完成时（Past Perfect）：表示过去某一时刻之前已经发生的动作或状态。例如：”She had already left when I called her.”（我打电话给她时，她已经离开了。）</li>
</ul>
</li>
<li>将来时态（Future Tense）：<ul>
<li>简单将来时（Simple Future）：表示将来发生的动作或状态。例如：”I will go to the beach tomorrow.”（明天我会去海滩。）</li>
<li>将来进行时（Future Continuous）：表示将来某一时刻正在进行的动作。例如：”They will be having a party this weekend.”（他们将在这个周末举办派对。）</li>
<li>将来完成时（Future Perfect）：表示将来某一时刻之前已经完成的动作或状态。例如：”By the time you arrive, I will have finished cooking dinner.”（你到达时，我会已经做完晚饭了。）</li>
</ul>
</li>
</ol>
<p>此外，英语中还有其他时态形式，如进行完成时（Present Perfect Continuous、Past Perfect Continuous、Future Perfect Continuous）等，用于表示更加复杂的时间关系。正确使用动词时态可以帮助清晰地表达动作发生的时间和顺序。</p>
<blockquote>
<p>其实有更好理解的方法,时态只有两种: 1.简单式 2.完成式</p>
<p>将句子中的be单拿出来，作为我们的动词，剩下的“动词”作为我们be动词的形容词补语。简单式分为三个时间  1.过去时间 2.现在时间 3.未来时间</p>
<p>同时，在简单句中，时间范围我们可以想象为一个括号，时间我们可以想象成一个轴。简单句所表达的时态，都可以清晰的用括号圈出来。</p>
<p>例句（过去时间）：<strong>The movable print was introduced to England in 1485</strong></p>
<p>将这句话的动词，be和时间状语in 1485比对，发现动词要变状态为was。be动词变化体现了时态的变化。形容词补语（本来的动词变化，体现了语态的变化，后面会讲）。括弧时间就是，1485.</p>
<p>例句（现在时间）：<strong>I drink coffee every morning</strong></p>
<p>这句话的动词涵盖的时间范围比较大。括弧时间将now都给涵盖了。所以说用一般时就行。</p>
<p>例句（将来时间）：<strong>There will be a major election in March</strong></p>
<p>将来时态，就是在be动词前加上will。</p>
<p>反正不管怎么变，时态的变化只体现在be动词处。</p>
<p>完成句:在完成句中，时间范围就不是括弧了，就是箭头。因为完成式是会有时间结束的点的，表示持续一段时间后结束了。</p>
<p>具体的变形要看时间箭头结束的地方，也就是时间副词？</p>
<p>例句：（现在时间）<strong>I’m sure I have  seen this face somewhere</strong></p>
<p>例句：（过去时间）<strong>Many soldiers had died from pneumonia before the discovery of penicillin.</strong></p>
<p>例句：（未来时间）<strong>Next April,I will have worked here for 20 years</strong></p>
</blockquote>
<h3 id="语态"><a href="#语态" class="headerlink" title="语态"></a>语态</h3><p>在英语中，语态（Voice）是用来表示动作或状态与主语之间关系的一种语法特征。英语中有两种主要的语态：主动语态（Active Voice）和被动语态（Passive Voice）。</p>
<ol>
<li>主动语态（Active Voice）：主动语态是最常用的语态形式。在主动语态中，主语是执行动作的实施者或行为的主体。动作的执行者位于句子的主语位置，而动作的接受者或承受者通常位于动词后的宾语位置。例如：<ul>
<li>“John reads a book.”（约翰读一本书。）</li>
<li>“She ate an apple.”（她吃了一个苹果。）</li>
</ul>
</li>
<li>被动语态（Passive Voice）：被动语态用于强调动作的接受者或承受者，而不是动作的执行者。在被动语态中，动词由”be”（根据时态变化）和过去分词形式构成，并且动作的接受者成为句子的主语。动作的执行者通常作为介词短语（通常是”by”）或省略不表达。例如：<ul>
<li>“The book is read by John.”（这本书被约翰读了。）</li>
<li>“An apple was eaten by her.”（一个苹果被她吃了。）</li>
</ul>
</li>
</ol>
<p>被动语态常用于以下情况：</p>
<ul>
<li>强调动作的接受者或承受者，而不是执行者。</li>
<li>当执行者未知、不重要或明显时。</li>
<li>当描述一般真理或客观事实时。</li>
</ul>
<p>需要注意的是，被动语态的使用要根据上下文和需要选择，有时也可以使用主动语态来表达相同的意思。了解和正确使用语态对于准确表达和理解英语句子至关重要。</p>
<h4 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h4><p>被动语态（Passive Voice）在英语中具有以下特点：</p>
<ol>
<li>动作接受者为主语：在被动语态中，动作的接受者或承受者成为句子的主语，突出了接受动作的对象。主动语态中的宾语通常变为被动语态中的主语。例如，”John reads a book”（约翰读一本书）的被动语态是”The book is read by John”（这本书被约翰读了）。</li>
<li>动词形式变化：被动语态的动词由”be”（根据时态变化）和过去分词形式构成。”be”的形式根据时态的不同而变化，如”is”、”was”、”will be”等。过去分词形式是动词的第三态形式，通常以”-ed”或”-en”结尾。例如，”read”（读）的过去分词形式是”read”，在被动语态中变为”read”。</li>
<li>执行者省略或通过介词短语表示：在被动语态中，动作的执行者（主动语态中的主语）可以被省略不表达，尤其当执行者未知、不重要或明显时。但如果需要明确指出执行者，可以通过介词短语（通常是”by”）来表达。例如，”The book is read”（这本书被读）中的执行者未指定，而”The book is read by John”（这本书被约翰读）中的执行者为John。</li>
<li>强调动作接受者或承受者：被动语态常用于强调动作的接受者或承受者，而不是动作的执行者。通过使用被动语态，可以将注意力放在受影响的对象上，使其成为句子的焦点。例如，”The house was built by my grandfather”（这座房子是我爷爷建造的）强调的是房子被建造的事实和建造者。</li>
<li>用于一般真理或客观事实：被动语态常用于表达一般真理、客观事实或普遍规律。通过使用被动语态，可以使句子更加客观和中性，避免强调特定的个体或行为。例如，”Water is boiled at 100 degrees Celsius”（水在100摄氏度沸腾）表达的是一般真理。</li>
</ol>
<p>需要注意的是，被动语态并非在所有情况下都适用，而且过度使用被动语态可能会使句子显得笨拙或不自然。正确地运用被动语态需要根据上下文和意图进行</p>
<h3 id="读音"><a href="#读音" class="headerlink" title="读音"></a>读音</h3><h4 id="元音"><a href="#元音" class="headerlink" title="元音"></a>元音</h4><p>元音在语言中扮演着多个重要角色，它们的作用包括：</p>
<ol>
<li>声音的核心：元音是构成语言中音节的基本成分，可以说是语言的核心音素。它们通常具有较长的持续时间，起到音节的骨架作用。其他音素如辅音则常常围绕着元音而存在。</li>
<li>词汇和语法的区分：元音的使用可以区分不同的词汇和语法形式。在许多语言中，改变元音的音素可以改变词汇的意义，例如英语中的 “bit”（一点）和 “bat”（球拍）。元音还可以用来表示时态、人称、性别等语法上的差异。</li>
<li>发音的清晰度：元音对于清晰发音至关重要。它们通常具有较高的音量和音高，有助于使语音更加清晰明确。元音的正确发音可以帮助人们准确地表达和理解语言。</li>
<li>语音韵律和重音的形成：元音在语音韵律中起到重要作用。它们可以用来区分重音和非重音音节，进一步影响句子的语调和语气。元音的长短、音高和强度的变化也可以帮助构建句子的韵律和节奏。</li>
<li>语音系统的多样性：元音在不同语言中呈现出丰富多样的系统。不同语言中的元音数量、品质和分布都有所不同。通过对元音系统的研究，可以深入了解不同语言之间的差异和相似之处。</li>
</ol>
<p>总之，元音在语言中起到了连接词汇和语法、帮助发音清晰、形成韵律和重音、以及构建语音系统多样性等重要作用。它们是语言中不可或缺的一部分，对于有效的交流和理解起着至关重要的作用。</p>
<blockquote>
<p>英语中有五个元音字母，它们分别是：a、e、i、o、u。</p>
<p>此外，在一些特定的情况下，字母y也可以被视为元音。当y在单词的音节中表示元音音素时，它可以被视为元音。例如，在单词”myth”中，字母y表示元音音素 &#x2F;ɪ&#x2F;，因此可以视为元音。</p>
</blockquote>
<h4 id="元音定位单词"><a href="#元音定位单词" class="headerlink" title="元音定位单词"></a>元音定位单词</h4><p>一个单词如果失去元音，那么这个单词就不能发声。我们可以对a e i o u进行定位，使用元音定位来推断一个单词的拼写。元音定位是一种通过识别单词中的元音字母来猜测单词的方法。以下是一个示例：</p>
<p>假设你听到一个单词的发音，但不知道它的拼写。你可以通过以下步骤使用元音定位来推测单词的拼写：</p>
<ol>
<li>听单词的发音，尝试识别其中的元音音素。元音音素是构成单词的元音字母的音值。</li>
<li>确定元音在单词中的位置。元音可以出现在单词的开头、中间或结尾。尝试确定哪个元音在单词中的位置是关键。</li>
<li>根据已确定的元音音素和位置，尝试拼写单词。你可以使用字母组合来形成可能的单词。</li>
</ol>
<p>请注意，元音定位是一种猜测单词拼写的方法，可能存在不确定性。有时，不同的单词可能具有相同的元音音素和位置，因此你需要根据上下文和其他线索来做出最准确的推断。</p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><h3 id="简单句直译"><a href="#简单句直译" class="headerlink" title="简单句直译"></a>简单句直译</h3>]]></content>
  </entry>
  <entry>
    <title>Five</title>
    <url>/2023/04/28/Five/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第五章-数论"><a href="#第五章-数论" class="headerlink" title="第五章 - 数论"></a>第五章 - 数论</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>质数的作用<br><span class="hljs-number">2.</span>各种知识<br></code></pre></td></tr></table></figure>

<h2 id="1-费马小定理"><a href="#1-费马小定理" class="headerlink" title="1.费马小定理"></a>1.费马小定理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前置消息</span><br>辗转相除法 <span class="hljs-built_in">gcd</span>(a,b); <span class="hljs-comment">//求取最小公倍数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br>  <br><span class="hljs-comment">// Function to compute gcd of two numbers </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> a; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b); <br>&#125; <br>  <br><span class="hljs-comment">//main function</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">98</span>, b = <span class="hljs-number">56</span>; <br>    cout &lt;&lt; <span class="hljs-string">&quot;GCD of &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">gcd</span>(a, b); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//费马小定理</span><br><br><span class="hljs-comment">//它指出，如果一个自然数p是一个素数，并且a是一个不能被p整除的任意一个正整数，那么a的p次方一定模p等于a。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a, b, c;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two different numbers: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    c = a*a + b*b;<br>    <br>    <span class="hljs-keyword">if</span>(c % (a+b) == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;弗尔马尔的小定理得到验证。&quot;</span>;<br>    <span class="hljs-keyword">else</span> <br>        cout &lt;&lt; <span class="hljs-string">&quot;Felmar的小定理尚未得到验证&quot;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-欧拉函数-有啥用？"><a href="#2-欧拉函数-有啥用？" class="headerlink" title="2.欧拉函数(有啥用？)*"></a>2.欧拉函数(有啥用？)*</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//欧拉函数的理论</span><br> 欧拉函数是被称为有限欧拉定理的函数，它在数论中广泛使用。欧拉函数的定义是：<br>   Φ(N) = (p1^k1)*(p2^k2)…*(pr^kr)，<br>   其中p1、p2…pr是大于<span class="hljs-number">1</span>的所有不相等的质数，而k1、k2…kr是正整数。<br>   Φ(N)表示小于等于N的正整数中，与N互质的数之积。欧拉函数的意义就是计算满足特定限制条件的正整数值<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//欧拉函数的代码生成</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;iostream&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义欧拉函数</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> ans=n,i,j;<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            ans=ans-ans/i;<br>            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) <br>            &#123;<br>                n/=i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) <br>    &#123;<br>        ans=ans-ans/n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> n;<br> <br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入一个正整数：&quot;</span>;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;此数的欧拉函数值为：&quot;</span>&lt;&lt; <span class="hljs-built_in">euler</span>(n) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-扩展欧几里得算法"><a href="#3-扩展欧几里得算法" class="headerlink" title="3.扩展欧几里得算法"></a>3.扩展欧几里得算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前置知识 线性同余方程</span><br> 线性同余方程是一种数学模型，可以用来求解根据已知条件计算未知变量的问题。它是一个形如ax≡<span class="hljs-built_in">b</span> (modn) 的方程，其中a、b和n是已知常数，x是待求解的未知变量。<br>  线性同余方程是用来解决模运算的一种数学方法，它可以解决大多数的组合数学问题，包括数论和计算机科学等，在特定情况下甚至可以用来分析给定的数学问题。线性同余方程在破解加密算法以及模数运算中也有所应用。<br>              ax ≡ <span class="hljs-built_in">b</span> (mod n)<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法作用</span><br>扩展欧几里得算法是一个整数线性规划算法，用于通过有限的整数操作来求解ax + by = <span class="hljs-built_in">gcd</span> (a, b)的问题，其中a和b是两个正整数。它也可以用于计算多元最大公因子(gcd)，即求出多个整数的最大公约数。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">//扩展欧几里得算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123; x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a%b, x, y);<br>    <span class="hljs-type">int</span> t = x; y = x - a/b*y; x = t;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, x, y, ans;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    ans = <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br>    cout&lt;&lt;<span class="hljs-string">&quot;ax+by=d=&quot;</span>&lt;&lt;ans&lt;&lt;endl;<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂问题</span><br>  方法<span class="hljs-number">1</span>：最朴素的想法，<span class="hljs-number">7</span>*<span class="hljs-number">7</span>=<span class="hljs-number">49</span>，<span class="hljs-number">49</span>*<span class="hljs-number">7</span>=<span class="hljs-number">343</span>，... 一步一步算，共进行了<span class="hljs-number">9</span>次乘法。<br>  这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。<br>  方法<span class="hljs-number">2</span>：先算<span class="hljs-number">7</span>的<span class="hljs-number">5</span>次方，即<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>，再算它的平方，共进行了<span class="hljs-number">5</span>次乘法。但这并不是最优解，因为对于“<span class="hljs-number">7</span>的<span class="hljs-number">5</span>次方”，我们仍然可以拆分问题。<br>  方法<span class="hljs-number">3</span>：先算<span class="hljs-number">7</span>*<span class="hljs-number">7</span>得<span class="hljs-number">49</span>，则<span class="hljs-number">7</span>的<span class="hljs-number">5</span>次方为<span class="hljs-number">49</span>*<span class="hljs-number">49</span>*<span class="hljs-number">7</span>，再算它的平方，共进行了<span class="hljs-number">4</span>次乘法。模仿这样的过程，我们得到一个在 <span class="hljs-built_in">o</span>(log n)时间内计算出幂的算法，也就是快速幂。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法实现快速幂</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quick_mod</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> c)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(b) <br>    &#123; <br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) <br>            ans=(ans*a)%c; <br>        b=b&gt;&gt;<span class="hljs-number">1</span>; <br>        a=(a*a)%c; <br>    &#125; <br>    <span class="hljs-keyword">return</span> ans; <br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,b,c; <br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; <br>    cout&lt;&lt;<span class="hljs-built_in">quick_mod</span>(a,b,c); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-乘法逆元"><a href="#4-乘法逆元" class="headerlink" title="4.乘法逆元"></a>4.乘法逆元</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//乘法逆元</span><br>乘法逆元是乘法运算在模意义下的一个概念，即存在一个数a，使得a*b≡<span class="hljs-number">1</span>（mod n），其中a就叫做b的乘法逆元，记为b^(<span class="hljs-number">-1</span>) (mod n)。它的用处是在模意义下实现除法的目的，可以用来求模意义下的乘法对角线，解方程组等。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法实现逆元</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>    <span class="hljs-type">int</span> t = x;<br>    x = y;<br>    y = t - a / b * y;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> gcd = <span class="hljs-built_in">exgcd</span>(a, m, x, y);<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> ? x : x + m;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-贝祖定理"><a href="#5-贝祖定理" class="headerlink" title="5.贝祖定理"></a>5.贝祖定理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贝祖定理 </span><br>  贝祖定理是一个重要的概率论原理，用于求解含有多个独立随机变量的复合分布概率。它可以用来解决一些关于概率分布的问题，比如计算多个独立事件的概率之和，计算某个事件出现的概率，计算两个事件概率的乘积以及计算某个条件发生的概率等问题。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Please input two integers (n, k): &quot;</span>;<br>    cin&gt;&gt;n&gt;&gt;k;<br> <br>    <span class="hljs-comment">// Compute C(n, k) using the formula</span><br>    <span class="hljs-type">long</span> c = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        c = c * (n - i + <span class="hljs-number">1</span>) / i;<br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;C(&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>&lt;&lt;k&lt;&lt;<span class="hljs-string">&quot;) = &quot;</span>&lt;&lt;c&lt;&lt;endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6-中国剩余定理"><a href="#6-中国剩余定理" class="headerlink" title="6.中国剩余定理"></a>6.中国剩余定理</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">中国剩余定理的用途有： <br>      <span class="hljs-number">1</span>、在数论中，它可用于解决同余方程； <br>      <span class="hljs-number">2</span>、在密码学中，它可用于将私钥分成多份存放，并能通过合并多份共享私钥来解密信息；       <span class="hljs-number">3</span>、在密码学中，它还可以用于生成曲线密码，能够抗攻击； <br>    <span class="hljs-number">4</span>、在数值分析中，它可用于解决系统方程组； <br>    <span class="hljs-number">5</span>、在计算机科学中，它可用于解决复杂图形计算问题； <br>    <span class="hljs-number">6</span>、它还可以用于解决一系列复杂的模式识别问题； <br>    <span class="hljs-number">7</span>、在数据库领域，它可用于解决复杂的查询优化问题<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 中国剩余定理：求解一组数的方程组 x = ai (mod ni) 所有a_i, n_i都是正整数 </span><br><span class="hljs-comment">* 并且互质，即gcd(n_i, n_j) = 1 (1 ≤ i ≤ k, 1 ≤ j ≤ k, i ≠j)则存在这样一个整数x，</span><br><span class="hljs-comment">* 使得x≡ai(modni)成立，且0≤x&lt;n1 * n2 *...nk。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chinese_remainder</span><span class="hljs-params">(<span class="hljs-type">int</span> *n, <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> len)</span> </span>&#123;  <span class="hljs-comment">// 传入ni和ai的数组，len表示数组的长度</span><br> <span class="hljs-type">int</span> p, i, j, m, n_i, x; <span class="hljs-comment">//定义变量</span><br> x = <span class="hljs-number">0</span>;<br> p = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123; <span class="hljs-comment">// 求出n1 x n2 x ... nk</span><br>  p *= n[i];<br> &#125;<br><br> <span class="hljs-comment">// 中国剩余定理算法 </span><br> <span class="hljs-comment">// 之所以不影响x的值，是因为m == (p / n[i]) * ai mod n[i]</span><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>  n_i = p / n[i];<br>  m = <span class="hljs-built_in">extended_Euclid</span>(n_i, n[i]);  <span class="hljs-comment">//  扩展欧几里得算法计算出逆元</span><br>  x += a[i] * m * n_i;<br> &#125;<br><br> <span class="hljs-keyword">return</span> x % p;<br>&#125;<br><br><span class="hljs-comment">// 扩展欧几里得算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extended_Euclid</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br> <span class="hljs-type">int</span> x, y, d;<br> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">0</span>;<br>  d = a;<br>  <span class="hljs-keyword">return</span> d;<br> &#125;<br> <span class="hljs-type">int</span> x1, y1, d1;<br> d1 = <span class="hljs-built_in">extended_Euclid</span>(b, a % b);<br> x1 = y1;  <span class="hljs-comment">// 记录上一次的结果 </span><br> y1 = x1 - (a / b)* y1;<br> d = d1;<br> x = x1;<br> y = y1;<br><br> <span class="hljs-comment">// 由模线性方程性质可知 </span><br> <span class="hljs-comment">// 如果a, b互质， 那么对于模线性方程 ax + by = c 有唯一解， </span><br> <span class="hljs-comment">// 而该解恰好为 d = gcd(a, b) 的一组特解</span><br> <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) <br>  <span class="hljs-keyword">return</span> (x + b) % b; <span class="hljs-comment">// 返回模逆元 </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="7-高斯消元（不理解）"><a href="#7-高斯消元（不理解）" class="headerlink" title="7.高斯消元（不理解）"></a>7.高斯消元（不理解）</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高斯消元是一种数学计算方法，用于快速求解系数表示的线性方程组的解，它也被称为高斯-赛洛加算法，以著名的普林斯顿大学数学家高斯命名。该方法把方程组分为上三角形组和下三角形组，通过变换方程中的系数值，最终获得方程的解。</span><br><span class="hljs-comment">//高斯消元法用于解决线性方程组的系数矩阵形式，即通过将系数矩阵通过合并和分解，从而求解出给定线性方程组的参数值解</span><br><span class="hljs-comment">//解决多项式方程的算法 - 是线性代数的知识</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高斯消元的证明</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">gauss_jordan</span><span class="hljs-params">(<span class="hljs-type">double</span> a[][],<span class="hljs-type">double</span> b[],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//a为系数矩阵，b为常数项，n为未知数个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,j,k,r;<br>    <span class="hljs-type">double</span> m,s;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        r = i;<br>        <span class="hljs-keyword">for</span>(j = i+<span class="hljs-number">1</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[j][i]) &gt; <span class="hljs-built_in">fabs</span>(a[r][i])) <br>                r=j;<br>        <span class="hljs-comment">//将第r行与第i行交换</span><br>        <span class="hljs-keyword">if</span>(r != i) <br>        &#123;<br>            <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; n; k++) <br>            &#123;<br>                m = a[i][k];<br>                a[i][k] = a[r][k];<br>                a[r][k] = m;<br>            &#125;<br>            s = b[i];<br>            b[i] = b[r];<br>            b[r] = s;<br>        &#125;<br>        <span class="hljs-comment">//用第i行的元素除以第i列第一个元素</span><br>        m = a[i][i];<br>        b[i] = b[i]/m;<br>        <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>            a[i][k] = a[i][k]/m;<br>        <span class="hljs-comment">//化为型</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == i) <span class="hljs-keyword">continue</span>;<br>            s = a[j][i];<br>            <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>;k&lt;n;k++)<br>                a[j][k] = a[j][k] - a[i][k]*s;<br>            b[j] = b[j] - b[i]*s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出解</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x%d = %f\n&quot;</span>,i,b[i]);<br>    &#125;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计算质数的代码(暴力根源)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> i, j, count;  <br>    cout &lt;&lt; <span class="hljs-string">&quot; 它的2到100间的质数有: \n&quot;</span>;  <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">100</span>;i++)  <br>    &#123;  <br>        count = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>;j&lt;i;j++)<span class="hljs-comment">//判断i是否为质数，若count==0则为质数  </span><br>        &#123;  <br>            <span class="hljs-keyword">if</span>(i%j == <span class="hljs-number">0</span>)  <br>            &#123;  <br>                count++;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)  <br>        &#123;  <br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//加上合数优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">i_p</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//如果一个数是合数（不是素数），那么它的最小因数一定不会超过它的平方根</span><br>    <span class="hljs-comment">//这个属性可以用反陈述来证明。设 a 和 b 是 n 的两个因子，使得 a*b = n。如果两者都大于 √n，则 a.b &gt; √n， * √n，这与表达式 “a * b = n” 相矛盾。（可以理解为 a 和 b 最大就 √n）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <br>    <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">i_p</span>(x)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码模版</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">trial_division</span>(<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-comment">// n是要分解的整数</span><br>    <span class="hljs-comment">// 返回一个向量，包含n的所有质因数和它们的次数</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; factors; <span class="hljs-comment">// 存储质因数和次数的向量</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; <span class="hljs-comment">// 从2开始试除</span><br>    <span class="hljs-keyword">while</span> ( i &lt;= n/i) &#123; <span class="hljs-comment">// 只需要试到根号n就可以了</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录i出现的次数</span><br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果n能被i整除，就更新n和s</span><br>            n /= i; <span class="hljs-comment">// 用i约分n</span><br>            s++; <span class="hljs-comment">// 增加i的次数（当前质数的指数）</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果s大于0，说明i是n的一个质因数，把它加入factors向量</span><br>            factors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i, s));<br>        &#125;<br>        i++; <span class="hljs-comment">// 增加i，继续试除下一个数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果n最后大于1，说明它本身是一个质数，也要加入factors向量(理解)</span><br>        factors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(n, <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> factors; <span class="hljs-comment">// 返回factors向量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=x/i;i++)<br>    <span class="hljs-comment">//整除流入</span><br>        <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//如果i是质因数 - 塞入res数组中</span><br>            res.<span class="hljs-built_in">push_back</span>(i); <br>            <span class="hljs-comment">//除数相等的情况 就只有i了嘛</span><br>            <span class="hljs-keyword">if</span>(i!=x/i) res.<span class="hljs-built_in">push_back</span>(x/i);<br>        &#125;<br>        <span class="hljs-comment">//排个序 (可不可以用 set存储啊)</span><br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">while</span> (n -- )&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">get_divisors</span>(x);<br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> x:res) cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-comment">//题目的意思就是和mod取模的得数</span><br><br><span class="hljs-comment">//这个代码求约数是用约数个数定理12的方法。约数个数定理是：</span><br><span class="hljs-comment">//如果一个数可以分解为质因数的形式，如M = x^a * y^b * z^c * …，则M的约数个数 = (a+1) (b+1) (c+1)…。</span><br><span class="hljs-comment">//这个代码就是先把每个输入的数分解成质因数，然后用哈希表记录每个质因数的指数，最后用公式计算出所有输入的数的最小公倍数的约数个数。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-comment">//哈希表的键是质数，值是质数对应的指数</span><br>    <span class="hljs-comment">//primes[i], i是键，primes[i]是值</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; primes; <br>    <span class="hljs-comment">//unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。它的键值分别是迭代器的first和second属性12。</span><br>    <span class="hljs-comment">//例如，it-&gt;first就是键，it-&gt;second就是值。</span><br>    <span class="hljs-comment">//当然也不一定存储键值对 - 也可以存储二者</span><br>    <span class="hljs-keyword">while</span> (n -- )&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>            <span class="hljs-keyword">while</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                x/=i;<br>                primes[i]++; <span class="hljs-comment">//对应位置的质数记录 （算是记录指数）</span><br>            &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) primes[x]++; <span class="hljs-comment">//只剩下一个数据 这个数据必然是质数</span><br>    &#125;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:primes) res = res*(p.second+<span class="hljs-number">1</span>)%mod;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="定义"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.埃拉托色尼筛</span><br>埃拉托色尼筛的原理是这样的：<br>    首先，把所有小于等于n的自然数都列出来，从<span class="hljs-number">2</span>开始，把<span class="hljs-number">1</span>排除掉。<br>    然后，从<span class="hljs-number">2</span>开始，把它的所有倍数都标记为合数，也就是不是素数的数。<br>    接着，找到下一个没有被标记的数，它一定是素数，然后把它的所有倍数都标记为合数。<br>    重复这个过程，直到没有更多的没有被标记的数为止。<br>    最后，所有没有被标记的数就是素数<br><br> <span class="hljs-comment">/*质数筛法是一种经典的求解质数的方法，它利用筛过程来获得所有质数。这个算法强调效率，通常使用比较基本的操作，来求解比较大的质数。 筛法的原理是：从2开始，把2的倍数筛掉，然后3，4，5，把3的倍数筛掉，以此类推。最后剩下的就是质数。 如何实现质数筛法：  1. 首先设置一个长度为n的数组，并将数组初始化，其数字依次为2, 3, …, n。   </span><br><span class="hljs-comment">2. 从2开始遍历数组中的元素，依次筛除其2、3、4、… 倍数的数，即将数组中对应元素置0。  3. 筛完后，把数组中非0元素存入一个新数组中，这些非0元素即为质数。 </span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> primes[N],cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(st[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//1.primes[cnt++] = i;的作用是把i这个素数存入primes数组中</span><br>        <span class="hljs-comment">//  并且把cnt加一，表示素数的个数增加了一个。</span><br>        primes[cnt++] = i;<br>        <span class="hljs-comment">//2.;这个循环的作用是把i的所有倍数都标记为合数，也就是非素数。</span><br>        <span class="hljs-comment">//  这样，当i增加时，就可以跳过已经被标记为合数的数字，只考虑没有被标记的数字，因为它们可能是素数。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+i;j&lt;=n;j+=i) st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">get_primes</span>(n);<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//2.线性筛法（埃拉托色尼筛优化版）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">//如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-comment">//primes[j] * i这个数标记为合数</span><br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">get_primes</span>(n);<br><br>    cout &lt;&lt; cnt &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//约数</span><br>约数是一个数据的因子，可以用这个约数凑成我们的这个数据<br><span class="hljs-comment">//试除法</span><br>  测试除法是一种数学操作，用来衡量和检查两个数字的除法运算结果是否正确。它通常包括算术问题、实数求余以及其他形式的除法运算。<br><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//试除法，求约数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindDivisor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>            n /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <br>    &#123;<br>        cout &lt;&lt; n;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Please enter an integer:&quot;</span>;<br>    cin &gt;&gt; n;<br><br>    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;的约数有：&quot;</span> ;<br>    <span class="hljs-built_in">FindDivisor</span>(n);<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="组合数-不完整"><a href="#组合数-不完整" class="headerlink" title="组合数(不完整)"></a>组合数(不完整)</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<span class="hljs-comment">//定义二维数组，用来中间存储计算结果 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmn</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span>  </span><br><span class="hljs-function"></span>&#123;     <br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=m;++i)  <span class="hljs-comment">//循环m步，从0开始 </span><br>       <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=n;++j)  <span class="hljs-comment">//循环n步，也是从0开始  </span><br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||i==j)    <span class="hljs-comment">//当i等于0或者i等于j时，直接赋值为1 </span><br>           f[i][j]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <br>           f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">//其他的都是在上一步的计算结果上加+1，依次类推</span><br>     <span class="hljs-keyword">return</span> f[m][n];  <span class="hljs-comment">//返回结果 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>    cout&lt;&lt;<span class="hljs-string">&quot;请输入任意m.n来得到组合数：&quot;</span>;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-type">int</span> result=<span class="hljs-built_in">cmn</span>(m,n);<br>    cout&lt;&lt;m&lt;&lt;<span class="hljs-string">&quot;C&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;result&lt;&lt;endl; <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="欧几里得算法（求最大公约数）"><a href="#欧几里得算法（求最大公约数）" class="headerlink" title="欧几里得算法（求最大公约数）"></a>欧几里得算法（求最大公约数）</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230316143057971.png" alt="image-20230316143057971"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*辗转相除法，又称欧几里得算法，是一种求两个非负整数的最大公约数的算法1。最大公约数是能够同时整除两个整数的最大的正整数2。辗转相除法的基本思想是：如果a和b都能被c整除，那么a和b的余数也能被c整除。因此，可以用a和b的余数代替b，重复这个过程，直到余数为0为止。此时，a就是最大公约数3。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">例如，要求18和30的最大公约数，可以这样做：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">18 = 0 × 30 + 18</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">30 = 1 × 18 + 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">18 = 1 × 12 + 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">12 = 2 × 6 + 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">此时，余数为0，所以最大公约数是6。*/</span><br><br><span class="hljs-comment">//大除小，小除大除小的余数，这样反复直到一方变为0是这样吗</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;<span class="hljs-built_in">gcd</span>(a,b)&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="拓展：裴蜀定理"><a href="#拓展：裴蜀定理" class="headerlink" title="拓展：裴蜀定理"></a>拓展：裴蜀定理</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>裴蜀定理（Bézout’s identity）又称裴蜀引理，是数论中的一个重要定理。它指出，对于任意整数 a 和 b，如果它们的最大公约数为 d，那么一定存在整数 x 和 y，使得不定方程 ax + by = d 有解。<br><br><span class="hljs-number">2.</span>换句话说，对于任意整数 a 和 b，它们的线性组合（即形如 ax + by 的整数）一定包含它们的最大公约数。此外，根据裴蜀定理还可以推出：如果不定方程 ax + by = c 有整数解，则当且仅当 c 是 a 和 b 的最大公约数的倍数时成立。<br><br>裴蜀定理在求解不定方程、计算模逆元等问题中都有重要应用。<br><br><span class="hljs-comment">//简单来说：就是构造一个这样的 ax + by = gcd(a,b); 只要gcd(a,b)能被我们题目的数据整除，就说明有整数解</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">假设我们要求解不定方程 <span class="hljs-number">3</span>x + <span class="hljs-number">5</span>y = <span class="hljs-number">11</span>。首先，我们可以使用扩展欧几里得算法求出 <span class="hljs-number">3</span> 和 <span class="hljs-number">5</span> 的最大公约数以及不定方程 <span class="hljs-number">3</span>x + <span class="hljs-number">5</span>y = <span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) 的一组整数解。运算结果显示，<span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) = <span class="hljs-number">1</span>，且不定方程 <span class="hljs-number">3</span>x + <span class="hljs-number">5</span>y = <span class="hljs-number">1</span> 的一组整数解为 (x0,y0) = (<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)。<span class="hljs-comment">//就是只要 3x + 5y = 1 的解也就是1 -  能够被原来的 11 整除 那么就有整数解</span><br><br>由于 <span class="hljs-number">11</span> 是 <span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) 的倍数，因此原不定方程有整数解。它的一组特殊解为 (x0 * c/d, y0 * c/d) = (<span class="hljs-number">2</span> * <span class="hljs-number">11</span>/<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> * <span class="hljs-number">11</span>/<span class="hljs-number">1</span>) = (<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>)。此外，根据裴蜀定理，原不定方程的通解为 (<span class="hljs-number">22</span> + k * b/d,<span class="hljs-number">-11</span> - k * a/d) = (<span class="hljs-number">22</span> + k * <span class="hljs-number">5</span>,<span class="hljs-number">-11</span> - k * <span class="hljs-number">3</span>)（其中 k 为任意整数）。<br><br>因此，当 k=<span class="hljs-number">0</span> 时，(x,y)=(<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>) 是原不定方程的一组整数解；当 k=<span class="hljs-number">-1</span> 时，(x,y)=(<span class="hljs-number">17</span>,<span class="hljs-number">-8</span>) 是原不定方程的另一组整数解；当 k=<span class="hljs-number">1</span>时，(x,y)=(<span class="hljs-number">27</span>,<span class="hljs-number">-14</span>) 是原不定方程的第三组整数解。<br>   <br></code></pre></td></tr></table></figure>

<h3 id="扩展欧几里得算法-求不定方程"><a href="#扩展欧几里得算法-求不定方程" class="headerlink" title="扩展欧几里得算法(求不定方程)"></a>扩展欧几里得算法(求不定方程)</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230316150108768.png" alt="image-20230316150108768"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求不定方程 - 判断有无整数解是这个样子吗</span><br><span class="hljs-comment">//根据裴蜀定理，当且仅当 c 是 a 和 b 的最大公约数的倍数时，不定方程才有整数解。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,d;<br>    d = <span class="hljs-built_in">exgcd</span>(b,a%b,x1,y1);<br>    x = y1,y = x1-a/b*y1; <span class="hljs-comment">//用欧几里得构造</span><br>    <span class="hljs-keyword">return</span> d; <span class="hljs-comment">//这个就是被除的</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b,c,x,y;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a,b,x,y);<br>    <span class="hljs-keyword">if</span>(c%d == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,c/d*x,c/d*y); <span class="hljs-comment">//能整除就是有整数解 - 无就是无</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;none&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191357823.png" alt="image-20230317191357823"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*快速幂：</span><br><span class="hljs-comment">可以这样理解，将指数转化为二进制，有1就乘，没1就不乘。 是通过二进制 一次执行多次乘法来缩减算法复杂度的</span><br><span class="hljs-comment">快速幂算法就是通过二进制来判断哪些位需要乘，哪些位不需要乘，从而减少乘法的次数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">例如，如果要计算 7 的 13 次方，可以将 13 写成二进制的 1101，然后有：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">7^13 = 7(23 + 2^2 + 2^0) = 7(23) * 7(22) * 7(20)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">= (7 * 7)^4 * (7 * 7)^2 * (7 * 7)^1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">= (49)^4 * (49)^2 * (49)^1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">这样就只需要做三次乘法，而不是十二次。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    LL res = <span class="hljs-number">1</span>%p;<br>    <span class="hljs-comment">//把次数转化成二进制 - 有1就代表有一次</span><br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%p;<br>        a = a*(LL)a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        cout&lt;&lt;<span class="hljs-built_in">qmi</span>(a,b,c)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//根据费马小定理</span><br>a^(p<span class="hljs-number">-1</span>) ≡ <span class="hljs-number">1</span> (mod p)，所以a * a^(p<span class="hljs-number">-2</span>) ≡ <span class="hljs-number">1</span> (mod p)，也就是说x = a^(p<span class="hljs-number">-2</span>)就是a的逆元。<br><span class="hljs-comment">//就是要构造 a^(p-1) ≡ 1 (mod p) 那么有 a* a^(p-2) ≡ 1 (mod p)  a^(p-2)这个就是我们的目标值（用逆元是为了减少运算次数）</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-comment">//mod质数 这里就是快速幂啦</span><br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = a * (LL)a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <br>        <span class="hljs-type">int</span> a, p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);<br>        <span class="hljs-keyword">if</span> (a % p == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p));<br>        <span class="hljs-comment">//如果p是一个质数，那么根据费马小定理，我们有a^(p-1) ≡ 1 (mod p)</span><br>        <span class="hljs-comment">//所以a * a^(p-2) ≡ 1 (mod p)，也就是说x = a^(p-2)就是a的逆元。</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数*"></a>组合计数*</h2><p>​  本质上，求组合数就是按照公式就可以求出来的。</p>
<h3 id="线性筛法-求组合数"><a href="#线性筛法-求组合数" class="headerlink" title="线性筛法 - 求组合数"></a>线性筛法 - 求组合数</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317103427722.png" alt="image-20230317103427722"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性筛法板子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">//如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-comment">//primes[j] * i这个数标记为合数</span><br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">get_primes</span>(n);<br><br>    cout &lt;&lt; cnt &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用这个方法 - 就是减少阶层的计算次数</span><br><span class="hljs-comment">//同时，组合数太大了只能用高精度的数据存储</span><br><span class="hljs-comment">//n！（阶层）中的p的个数 ，p是质数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">//n容纳p的个数有上限的</span><br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n) s+=n/p,n/=p;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-comment">//c中的p的个数(算质数的个数) - 算组合数中的质数个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(n,p) - <span class="hljs-built_in">get</span>(m,p) - <span class="hljs-built_in">get</span>(n-m,p);<br>&#125;<br><br><span class="hljs-comment">//组合数公式 就是 - get/(get(n,p) - get(m,p) - get(n-m,p))</span><br><br><span class="hljs-comment">//数组乘质数？</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> C[],<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> &amp;len)</span></span>&#123;<br>    <span class="hljs-comment">//高精度</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        t+=C[i]*p;<br>        C[i] = t%<span class="hljs-number">10</span>;<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        C[len++] = t%<span class="hljs-number">10</span>;<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> C[N],len = <span class="hljs-number">1</span>,C[<span class="hljs-number">0</span>]= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        <span class="hljs-type">int</span> p = prim[i];<br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">getC</span>(n,m,p);<br>        <span class="hljs-keyword">while</span>(s--) <span class="hljs-built_in">mul</span>(C,p,len); <span class="hljs-comment">//这里算的结果是吗</span><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="快速幂-求组合数-乘法逆元-不太会"><a href="#快速幂-求组合数-乘法逆元-不太会" class="headerlink" title="快速幂 - 求组合数  - 乘法逆元(不太会)"></a>快速幂 - 求组合数  - 乘法逆元(不太会)</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317190202981.png" alt="image-20230317190202981"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂板子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    LL res = <span class="hljs-number">1</span>%p;<br>    <span class="hljs-comment">//把次数转化成二进制 - 有1就代表有一次</span><br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%p;<br>        a = a*(LL)a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        cout&lt;&lt;<span class="hljs-built_in">qmi</span>(a,b,c)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂求组合数</span><br><span class="hljs-function">LL <span class="hljs-title">qpow</span><span class="hljs-params">(LL a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%p;<br>        a = a*a%p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    f[<span class="hljs-number">0</span>] = g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>        f[i] = f[i<span class="hljs-number">-1</span>]*i%P;<br>        g[i] = g[i<span class="hljs-number">-1</span>]*<span class="hljs-built_in">qpow</span>(i,P<span class="hljs-number">-2</span>)%P;<br>    &#125;<br>    <span class="hljs-function">LL <span class="hljs-title">getC</span><span class="hljs-params">(LL n,LL m)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> f[n]*g[m]%P*g[n-m]%P;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//求出对应的次方 也就是a^b - 也可以用来求乘法逆元 a^(p-2)</span><br><span class="hljs-comment">//乘法逆元原理： a*a^(p-2) = 1(modp) 这样就行 我们要求a的乘法逆元就是a^(p-2)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) ans=<span class="hljs-number">1ll</span>*ans*a%mod;<br>        a=<span class="hljs-number">1ll</span>*a*a%mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(x,mod<span class="hljs-number">-2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        ans=<span class="hljs-number">1ll</span>*ans*(n-i+<span class="hljs-number">1</span>)%mod;<br>        ans=<span class="hljs-number">1ll</span>*ans*<span class="hljs-built_in">inv</span>(i)%mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="递推法-求组合数-杨辉三角形"><a href="#递推法-求组合数-杨辉三角形" class="headerlink" title="递推法 - 求组合数 - 杨辉三角形"></a>递推法 - 求组合数 - 杨辉三角形</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191900241.png" alt="image-20230317191900241"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191910081.png" alt="image-20230317191910081"></p>
<p><img src="C:\Users\Administrator\Pictures\杨辉三角形.jpg" alt="杨辉三角形"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//杨辉三角形求解组合数</span><br><span class="hljs-comment">//就是 当前这个数据 等于上面的左右数据的加和 - 那么就用动态规划解决这个问题就ok了</span><br><span class="hljs-comment">//但是怎么构造杨辉三角形呢 - 初始化三角形的两条边把</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;N;i++) <span class="hljs-comment">//N是上限 - 底的吗</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=i;j++)<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) C[i][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//j是尽头(把三角形当成是二分之一的正方形)</span><br>      <span class="hljs-keyword">else</span> C[i][j] = (C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        a[i][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        a[i][i]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>            a[i][j]=a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>        &#123;<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192018240.png" alt="image-20230317192018240"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192035378.png" alt="image-20230317192035378"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>

<h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192341534.png" alt="image-20230317192341534"></p>
<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192423405.png" alt="image-20230317192423405"></p>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193339194.png" alt="image-20230317193339194"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193528005.png" alt="image-20230317193528005"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193536881.png" alt="image-20230317193536881"></p>
<h3 id="中国剩余定理拓展"><a href="#中国剩余定理拓展" class="headerlink" title="中国剩余定理拓展"></a>中国剩余定理拓展</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193608034.png" alt="image-20230317193608034"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193627036.png" alt="image-20230317193627036"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193636294.png" alt="image-20230317193636294"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Four</title>
    <url>/2023/04/28/Four/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第四章-图论的拓展"><a href="#第四章-图论的拓展" class="headerlink" title="第四章 - 图论的拓展"></a>第四章 - 图论的拓展</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>基础图论模型<br><span class="hljs-number">2.</span>图论算法<br></code></pre></td></tr></table></figure>

<p>  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学习。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>  要了解上述两个遍历模型，就要了解二叉树。二叉树是图的一种特殊造型，二叉树有两种主要形式：满二叉树和完全二叉树.满二叉树的深度和结点是有关系的，一个深度为k的满二叉树，它的节点数是2^k - 1（每一层是两个，减去我们的头结点就ok了）</p>
<h4 id="1-完全二叉树"><a href="#1-完全二叉树" class="headerlink" title="1.完全二叉树"></a>1.完全二叉树</h4><p>  完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数 都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h层，则该层包含 1~ 2^h -1 个节点。（就是叶子结点左边可以不满，其他必须满是这个意思是吗）。</p>
<p>​        <img src="/2023/04/28/Four/image-20230216131827500-16923746582101.png" alt="image-20230216131827500"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉搜索树（建立在完全二叉树的基础之上吗）</span><br>有如下的规则（简单来说，左边的都是小于根节点，右边的都是大于根节点）<br> -若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； <br> -若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；<br> -它的左、右⼦树也分别为⼆叉排序树<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230216133015856-16923744832954.png" alt="image-20230216133015856"></p>
<h4 id="2-平衡二叉搜索树"><a href="#2-平衡二叉搜索树" class="headerlink" title="2.平衡二叉搜索树"></a>2.平衡二叉搜索树</h4><p>平衡⼆叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是 ⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。（高度差 注意是高度差！！！！！）</p>
<p><img src="/image-20230216133247245-16923744811933.png" alt="image-20230216133247245"></p>
<h4 id="3-用数组实现二叉树"><a href="#3-用数组实现二叉树" class="headerlink" title="3.用数组实现二叉树"></a>3.用数组实现二叉树</h4><p><img src="/2023/04/28/Four/image-20230216134441813-16923744802222.png" alt="image-20230216134441813"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">⽤数组来存储⼆叉树如何遍历的呢？ 如果⽗节点的数组下表是i，那么它的左孩⼦就是i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>，右孩⼦就是 i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>。 <br>但是⽤链式表⽰的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。<br>所以⼤家要了解，⽤数组依然可以表⽰⼆叉树<br></code></pre></td></tr></table></figure>

<h4 id="4-二叉树的链式实现"><a href="#4-二叉树的链式实现" class="headerlink" title="4.二叉树的链式实现"></a>4.二叉树的链式实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>  <span class="hljs-type">int</span> val;<br>  TreeNode *left;<span class="hljs-comment">//定义left指针 指向左子树</span><br>  TreeNode *right;<span class="hljs-comment">//right指针 指向右子树</span><br>  <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<span class="hljs-comment">//构造函数  </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-二叉树的遍历步骤"><a href="#5-二叉树的遍历步骤" class="headerlink" title="5.二叉树的遍历步骤"></a>5.二叉树的遍历步骤</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//实现递归的三要素</span><br><span class="hljs-number">1.</span> 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。<br><span class="hljs-number">2.</span> 确定终⽌条件： 写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者 终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果 递归没有终⽌，操作系统的内存栈必然就会溢出。<br><span class="hljs-number">3.</span> 确定单层递归的逻辑：<br>确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程<br><span class="hljs-comment">//前序遍历（就是前中后）</span><br><span class="hljs-number">1.</span> 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，<span class="hljs-string">&#x27;所以参数⾥需 要传⼊vector在放节点的数值，除了这⼀点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</span><br><span class="hljs-string">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) //（一个存放的是结构体的指针，一个存放的是存储数据的容器）</span><br><span class="hljs-string">2.确定终⽌条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点 是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</span><br><span class="hljs-string">if (cur == NULL) return;</span><br><span class="hljs-string">3.确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先 取中节点的数值，代码如下：</span><br><span class="hljs-string">vec.push_back(cur-&gt;val); // 中</span><br><span class="hljs-string">traversal(cur-&gt;left, vec); // 左</span><br><span class="hljs-string">traversal(cur-&gt;right, vec); // 右</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123; <br>  <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <br>   vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中</span><br>   <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>   <span class="hljs-comment">// 左 </span><br>   <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <br>   <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <br>   vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-built_in">traversal</span>(root, result); <span class="hljs-keyword">return</span> result;<br> &#125;<br>&#125;;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <br>  <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>  <span class="hljs-comment">// 左 </span><br>  vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中 </span><br>  <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec);<br>  <span class="hljs-comment">// 右</span><br>&#125;<br><br><span class="hljs-comment">//后续遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>  <span class="hljs-comment">// 左 </span><br>  <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <br>  <span class="hljs-comment">// 右</span><br>  vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230216135315873.png" alt="image-20230216135315873"></p>
<p><img src="/image-20230216135326265.png" alt="image-20230216135326265"></p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="0-前置知识-图的存储"><a href="#0-前置知识-图的存储" class="headerlink" title="0.前置知识 图的存储"></a>0.前置知识 图的存储</h4><p><img src="/image-20230305080127311.png" alt="image-20230305080127311"></p>
<h5 id="领接矩阵"><a href="#领接矩阵" class="headerlink" title="领接矩阵"></a>领接矩阵</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.领接矩阵</span><br> 领接矩阵声明，开一个二维数组； <span class="hljs-number">1.</span>二维数组w[u][v],存储u - v的边权（就是这个连线多长）<span class="hljs-number">2.</span>只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）<br>        <span class="hljs-comment">//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系</span><br><br><span class="hljs-type">int</span> w[N][N]; <span class="hljs-comment">//声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c</span><br><span class="hljs-type">int</span> vis[N];<span class="hljs-comment">//点集</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;v&lt;=n;v++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w[u][v]);<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        w[a][b] = c; <span class="hljs-comment">//赋予权值（a点 和 b点）（算是连线）</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h5><p><img src="/image-20230305080154969.png" alt="image-20230305080154969"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//边集数组</span><br><span class="hljs-comment">//结构体下标联系三者</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>()&#123;<br>    <span class="hljs-type">int</span> u,v,w; <span class="hljs-comment">//两点 和 权</span><br>&#125;e[M]; <span class="hljs-comment">//边集合</span><br><span class="hljs-type">int</span> vis[N]; <span class="hljs-comment">//点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> v = e[i].v,w = e[i].w; <span class="hljs-comment">//用结构体中对应的值</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d&quot;</span>,u,v,w); <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//这个点到过了</span><br>        <span class="hljs-built_in">dfs</span>(e[i].v);<span class="hljs-comment">//下一个点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        e[i] = &#123;a,b,c&#125;;<br>        <span class="hljs-comment">//e[i] = &#123;b,a,c&#125;; //无向图就要加上</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="领接表（重点）"><a href="#领接表（重点）" class="headerlink" title="领接表（重点）"></a>领接表（重点）</h5><p><img src="/image-20230302110544398.png" alt="image-20230302110544398"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//领接表（将图用dfs序输出）</span><br>出边数组e[u][i] 存储u点的所有出边&#123;终点 v ， 边权 w&#125;。<br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edga</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//声明结构体（代表每个点有的属性）</span><br>vector&lt;edga&gt; e[N];<span class="hljs-comment">//存储的是每一个起点（有n个）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span>  <span class="hljs-comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u]) <span class="hljs-comment">//遍历当前层的元素</span><br>    &#123;<br>        <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>        <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重（父节点记录父节点是否走过）（u和fa是交替使用的）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d，%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);<span class="hljs-comment">// （u,fa,v,u,v,u.......） //fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）</span><br>    &#125;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//无向图 两边都要连接</span><br>        e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>        e[b].<span class="hljs-built_in">push_back</span>(&#123;c,b&#125;);<br>    &#125;<br>    <span class="hljs-comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>    <br>&#125;<br><span class="hljs-comment">//父节点是相互的，我们用领接表存储的时候，只要连接就是父和子的叠加态（这也解释了为什么可以回溯）</span><br><br></code></pre></td></tr></table></figure>

<h5 id="链式领接表"><a href="#链式领接表" class="headerlink" title="链式领接表"></a>链式领接表</h5><p><img src="/image-20230302111110291.png" alt="image-20230302111110291"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式领接表</span><br>两个变量：<span class="hljs-number">1.</span>边集数组 <span class="hljs-number">2.</span>表头数组<br><span class="hljs-number">1.</span>边集数组存储的是第几条边的属性：e[j]存储第j条边的&#123;起点u，终点v，边权w&#125;<br><span class="hljs-number">2.</span>表头数组存储的是u点的所有出边的编号：h[u][j](u表示的是当前的点)（j表示的是当前点连接的出边）<br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> u,v,w&#125;;<br>vector&lt;edge&gt; e; <span class="hljs-comment">//边集合（边的属性）</span><br>vector&lt;<span class="hljs-type">int</span>&gt; h[N]; <span class="hljs-comment">//点的所有出边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e.<span class="hljs-built_in">push_back</span>(&#123;a,b,c&#125;); <span class="hljs-comment">// 对应边的属性压入</span><br>    h[a].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">szie</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">//当前边权数组的大小-1（这里的应该是桶数组）    </span><br>&#125;<br><span class="hljs-comment">//u当前节点 fa-父节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;h[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> j = h[u][j];<span class="hljs-comment">//表示的是当前的点？</span><br>        <span class="hljs-type">int</span> v = e[j].v,w = e[j].w;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//邻接表存储数据</span><br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="链式前向星（重点）"><a href="#链式前向星（重点）" class="headerlink" title="链式前向星（重点）"></a>链式前向星（重点）</h5><p><img src="/image-20230302112003101.png" alt="image-20230302112003101"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星 - 用边集数组和领接表结合成的 - （还是不理解）</span><br>数组<span class="hljs-number">1</span>：边集数组 - e[i]存储第i条出边的&#123;终点v,边权w，下一条边ne&#125;<br>数组<span class="hljs-number">2</span>：表头数组 - h[u]存储的是u点的第一条出边的编号（理解为第一条边就可以了）<br>边的编号：由idx分配<br><br><span class="hljs-comment">//输入 变量 1.点的个数 2.边的个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w,ne;&#125;;<span class="hljs-comment">//ne是下一条边</span><br>edge e[M]; <span class="hljs-comment">// 存储的是所有的边</span><br><span class="hljs-type">int</span> idx,h[N]; <span class="hljs-comment">//点的第一条出边（每个点都有）</span><br><span class="hljs-comment">//表头数组相当于给我们一个起点，让我们访问到别的边</span><br><br><span class="hljs-comment">//获取第一个出边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = &#123;b,c,h[a]&#125;; <span class="hljs-comment">// e结构体存储的是这个边的信息</span><br>    <span class="hljs-comment">//这样理解吗 b就是a的出边 - 每次进来的a都会标记 而且idx会变化 不用担心重复</span><br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">//每次添加一条边，都会把这条边的ne指针指向上一次添加的边的编号，这样就形成了一个链表。例如，如果先添加了a到b的边，再添加了a到c的边，那么h[a]就会指向a到c的边的编号，而a到c的边的ne指针就会指向a到b的边的编号，这样就可以通过h[a]和e[i].ne访问到a点的所有出边。</span><br><span class="hljs-comment">//这个函数的最后一个参数是e[idx].ne，表示这条边的下一条边的编号。赋值的是h[a]，表示a点的第一条出边的编号。这样就把这条边和a点的原来的第一条出边连接起来了，形成了一个链表。表头数组只存储了每个点的第一条出边的编号，而不是所有的边。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//横向遍历是为了回溯</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];~i;i=e[i].ne)&#123; <span class="hljs-comment">//~i表示i不等于-1</span><br>        <span class="hljs-type">int</span> v = e[i].v,w = e[i].w;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重 回溯</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);/深入<br>    &#125;    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化表头</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//无向图构图</span><br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <br>&#125;<br><br><span class="hljs-comment">//说人话就是，输入一组数据 a b c。 可以将a点作为出边点 那么b就是出边。重复构建图就是这样</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ai给的例子</span><br>好的，我可以给你举一个例子。假设有一个无向图，有三个点，分别是<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，有三条边，分别是<span class="hljs-number">1</span>到<span class="hljs-number">2</span>，<span class="hljs-number">2</span>到<span class="hljs-number">3</span>，<span class="hljs-number">1</span>到<span class="hljs-number">3</span>。那么输入数据的过程如下：<br><br>输入第一条边<span class="hljs-number">1</span>到<span class="hljs-number">2</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)来添加这条边。<br>此时e[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">1</span>到<span class="hljs-number">2</span>的边的信息，其中v=<span class="hljs-number">2</span>表示终点是<span class="hljs-number">2</span>，w=<span class="hljs-number">0</span>表示权值是<span class="hljs-number">0</span>（这里没有用到），ne=<span class="hljs-number">-1</span>表示没有下一条边。<br>同时h[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>，表示<span class="hljs-number">1</span>点的第一条出边的编号是<span class="hljs-number">0</span>。<br>e[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">2</span>到<span class="hljs-number">1</span>的边的信息。<br>h[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>，表示<span class="hljs-number">2</span>点的第一条出边的编号是<span class="hljs-number">1</span>。<br>输入第二条边<span class="hljs-number">2</span>到<span class="hljs-number">3</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)来添加这条边。<br>此时e[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;，表示从<span class="hljs-number">2</span>到<span class="hljs-number">3</span>的边的信息，其中ne=<span class="hljs-number">1</span>表示下一条边的编号是<span class="hljs-number">1</span>（即从<span class="hljs-number">2</span>到<span class="hljs-number">1</span>的边）。<br>同时h[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>，表示<span class="hljs-number">2</span>点的第一条出边的编号是<span class="hljs-number">2</span>（即从<span class="hljs-number">2</span>到<span class="hljs-number">3</span>的边）。<br>e[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">3</span>到<span class="hljs-number">2</span>的边的信息。<br>h[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>，表示<span class="hljs-number">3</span>点的第一条出边的编号是<span class="hljs-number">3</span>。<br>输入第三条边<span class="hljs-number">1</span>到<span class="hljs-number">3</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)来添加这条边。<br>此时e[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;，表示从<span class="hljs-number">1</span>到<span class="hljs-number">3</span>的边的信息，其中ne=<span class="hljs-number">0</span>表示下一条边的编号是<span class="hljs-number">0</span>（即从<span class="hljs-number">1</span>到<span class="hljs-number">2</span>的边）。<br>同时h[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>，表示<span class="hljs-number">1</span>点的第一条出边的编号是<span class="hljs-number">4</span>（即从<span class="hljs-number">1</span>到<span class="hljs-number">3</span>的边）。<br>e[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>&#125;，表示从<span class="hljs-number">3</span>到<span class="hljs-number">1</span>的边的信息，其中ne=<span class="hljs-number">3</span>表示下一条边的编号是<span class="hljs-number">3</span>（即从<span class="hljs-number">3</span>到<span class="hljs-number">2</span>的边）。<br>同时h[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>，表示<span class="hljs-number">3</span>点的第一条出边的编号是<span class="hljs-number">5</span>（即从<span class="hljs-number">3</span>到<span class="hljs-number">1</span>的边）。<br>这样就完成了输入数据和构建链式前向星存储结构。你明白了吗？<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302112236202.png" alt="image-20230302112236202"></p>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>dfs算法是一种深度优先搜索算法，它的特点是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。它可以用来解决许多不同类型的问题，如寻找最短路径、搜索树、图等。dfs又被称之为递归，算是一种用暴力方法求解全部点的连通性。这种方法使用于树（树是图的一种，它具有没有环的性质），下面我们用一种简单的二叉树的图进行讨论。</p>
<p><img src="/image-20230216151302883.png" alt="image-20230216151302883"></p>
<h5 id="1-dfs过程的实现"><a href="#1-dfs过程的实现" class="headerlink" title="1.dfs过程的实现"></a>1.dfs过程的实现</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>深搜的过程<br>   从根进入，向下走 - 走到底。 无路可走，回溯向上走，绕树根兜圈子，最后从根退出。<br><span class="hljs-number">2.</span>深搜的实现<br>   用系统栈实现的。递归调用的过程，系统自动通过栈去维护函数的状态空间。系统栈记录函数的返回地址，局部变量，参数传递。 向下走 压栈； 向上走，弹栈。 <span class="hljs-comment">// 可以看做 用栈维护不同的序列 - 弹出栈作为新的栈</span><br><span class="hljs-number">3.</span>代码（模板）<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N]; <span class="hljs-comment">// 表示一颗树（或者是图）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:e[N])&#123; <span class="hljs-comment">// v遍历我们的e数组（v变量维护我们的栈）</span><br>    <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 就相当于 在数组中构造树（有标记的数据我们不走?） - 这里才是回溯的重点 - 问ai</span><br>    <span class="hljs-built_in">dfs</span>(v,u);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;n&gt;&gt;m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  i = <span class="hljs-number">1</span>;i&lt;=m;i++)<br>  cin&gt;&gt;a&gt;&gt;b, e[a].<span class="hljs-built_in">push_back</span>(b),e[b] = <span class="hljs-built_in">push_back</span>(a); <span class="hljs-comment">//这个是啥意思</span><br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-number">4.</span>深搜的计算（暂时不想看）<br></code></pre></td></tr></table></figure>

<h5 id="2-dfs序列"><a href="#2-dfs序列" class="headerlink" title="2.dfs序列"></a>2.dfs序列</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>dfs模板（感觉是遍历 这个树hhh）<br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">//这个就是 表示树（宽度 和 深度）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span><span class="hljs-comment">//fa表示树的根结点（醍醐灌顶）</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 整个树的节点个数</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++) <span class="hljs-comment">// 遍历每一个节点</span><br>    &#123;<br>       <span class="hljs-keyword">if</span>(g[u][i]!=fa) <span class="hljs-comment">// u（代表当前层的一个数据）的i(表示下一层的数据)没用过</span><br>        &#123;<br>           <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//加一个辅助数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>  dfs_[++len] = u; <span class="hljs-comment">//遍历的就是当前的父节点 记录一下 （每次走过的就当是根 - 父节点的就可以了）</span><br>  <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>  &#123;<br>     <span class="hljs-keyword">if</span>(g[u][i]!=fa)&#123;<br>        <span class="hljs-built_in">dfs</span>(g[u][i],u);<span class="hljs-comment">//根节点替换</span><br>      &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//实例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//一维数组 可以用作二维数组吗</span><br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dfs_[<span class="hljs-number">200020</span>],len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfs_[++len]=u;  <br>    <span class="hljs-type">int</span> sz=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(g[u][i]!=fa)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>      <span class="hljs-comment">//两个点 不同方向都有一条边</span><br>        <span class="hljs-type">int</span> from,to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);<br>        g[from].<span class="hljs-built_in">push_back</span>(to);<br>        g[to].<span class="hljs-built_in">push_back</span>(from);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dfs_[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs序列作用</span><br><span class="hljs-number">1.</span>子树加权<br>   在dfs序列中，一个结点的子树序列是连续的。 - 看下面的树： abdegcfh 我们关注 b结点 发现b - deg 这一段是连续的，就可以利用差分的操作就行加权。然后我们可以发现B字树B-D-E-G，C子树C-F-H都在一段连续的区间中。那么这有什么好处呢？比如说现在有一道题：给你一颗树，给出m个x和w，意为将x子树中的所有点加上一个权值w，最后询问所有点的权值 - 既然dfs序中x和他的所有子节点都在连续的区间上，那么我们就可以将它简化成差分的问题。比如说给b节点加<span class="hljs-number">2</span>，就可以简化为给b的差分数组+<span class="hljs-number">2</span>，c的差分数组<span class="hljs-number">-2</span> 。（又涉及到了差分数组了）<br>   - 怎么找第一个不在B子树中的点 引入时间戳<br><span class="hljs-number">2.</span>时间戳<br>   作用：记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。（用数组记录时间）<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> x = len+<span class="hljs-number">1</span>;<span class="hljs-comment">//数组拓展</span><br>    s[++len] = ++time; <br>   dfs_[len] = u;<span class="hljs-comment">//存储dfs序列</span><br>   <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>       <span class="hljs-keyword">if</span>(g[u][i] == fa)&#123;<br>          <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>   e[x] = time;<span class="hljs-comment">//存储对应 根节点到子节点的时间区间</span><br>&#125;<br><span class="hljs-comment">//如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。（算导里称之为括号化定理）</span><br></code></pre></td></tr></table></figure>

<p><img src="/1188068-20171027104122883-1380446385.png" alt="img"></p>
<p><img src="/image-20230301212454581.png" alt="image-20230301212454581"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dfs_[<span class="hljs-number">200020</span>],len,time,s[<span class="hljs-number">200020</span>],e[<span class="hljs-number">200020</span>],pos[<span class="hljs-number">200020</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=len+<span class="hljs-number">1</span>;<br>    s[++len]=++time;<span class="hljs-comment">//当前点 时间起点</span><br>    dfs_[len]=u;<br>    pos[u]=len;<br>    <span class="hljs-type">int</span> sz=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(g[u][i]!=fa)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>    e[x]=time;<span class="hljs-comment">//时间终点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>  <span class="hljs-comment">//输入我们的树</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>   <span class="hljs-comment">//这段代码读入树中的边并将它们存储在邻接表 g 中。对于每条边，它都读入两个整数 from 和 to，表示边的两个端点。然后，它将 to 添加到 g[from] 的末尾，并将 from 添加到 g[to] 的末尾。这样，对于每个节点，其邻接表中都存储了与其相连的所有节点。</span><br>    &#123;<br>      <span class="hljs-comment">//用邻接表表示树</span><br>        <span class="hljs-type">int</span> from,to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);<br>        g[from].<span class="hljs-built_in">push_back</span>(to);<br>        g[to].<span class="hljs-built_in">push_back</span>(from);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        x=pos[x];<br>        y=pos[y];<br>        <span class="hljs-keyword">if</span>(s[x]&lt;=s[y]&amp;&amp;e[y]&lt;=e[x])<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//邻接表是一种常用的表示图的数据结构，它在存储稀疏图（即边数远小于节点数平方的图）时非常高效。邻接表通过为每个节点维护一个列表来存储与其相连的所有边，因此它只需要存储 2m 个整数（其中 m 是边数），空间复杂度为 O(m)。此外，使用邻接表可以快速访问与给定节点相连的所有边，时间复杂度为 O(度数)。当然，邻接表也有一些缺点。例如，它不适用于存储稠密图（即边数接近节点数平方的图），因为这样会浪费大量空间。此外，使用邻接表判断两个节点之间是否存在边需要遍历其中一个节点的邻接表，时间复杂度为 O(度数)，不如使用邻接矩阵来得快。</span><br></code></pre></td></tr></table></figure>

<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><h5 id="0-前置知识：队列"><a href="#0-前置知识：队列" class="headerlink" title="0.前置知识：队列"></a>0.前置知识：队列</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//队列是一种先进先出的线性表，它只允许在一端插入元素，另一端删除元素1。队列可以用数组或者链表来实现23。队列的常见操作有入队（enqueue），出队（dequeue），获取队首元素（peek），判断队列是否为空（isEmpty）等</span><br><br><span class="hljs-comment">//在bfs中： 队列的作用是存储待访问的顶点，保证按照图的宽度优先的顺序进行遍历。队列可以帮助我们记录当前层的顶点和下一层的顶点，从而找到最短路径或者最优解。队列也可以避免重复访问已经遍历过的顶点，提高搜索效率。</span><br><br><span class="hljs-comment">//1.用数组模拟队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> hh,tt; <span class="hljs-comment">//定义队头和队尾的下标 初始化 hh = 0,tt = -1;</span><br><br><span class="hljs-comment">//向队尾插入一个元素 x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    q[++tt] = x; <span class="hljs-comment">//理解tt是向右边延伸的</span><br>&#125;<br><br><span class="hljs-comment">//从队头弹出一个数（） - 队列先进先出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    hh++;<br>&#125;<br><br><span class="hljs-comment">//查询队头元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> q[hh];<br>&#125;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> hh &gt; tt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//输入操作次数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        string op; <span class="hljs-comment">//输入操作类型</span><br>        cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">//输入操作参数</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;push&quot;</span>) &#123; <span class="hljs-comment">//如果是入队操作</span><br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;pop&quot;</span>) &#123; <span class="hljs-comment">//如果是出队操作</span><br>            <span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;empty&quot;</span>) &#123; <span class="hljs-comment">//如果是判断空操作</span><br>            cout &lt;&lt; (<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果是查询对头操作</span><br>            cout &lt;&lt; <span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br><span class="hljs-comment">//2.用stl实现队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">//引入STL中的queue头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//定义一个int类型的队列q</span><br><br><span class="hljs-comment">//向队尾插入一个元素x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//调用STL中的push函数</span><br>&#125;<br><br><span class="hljs-comment">//从对头弹出一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//调用STL中的pop函数</span><br>&#125;<br><br><span class="hljs-comment">//查询对头元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//调用STL中的front函数</span><br>&#125;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//调用STL中的empty函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//输入操作次数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        string op; <span class="hljs-comment">//输入操作类型</span><br>        cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">//输入操作参数</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;push&quot;</span>) &#123; <span class="hljs-comment">//如果是入队操作</span><br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;pop&quot;</span>) &#123; <span class="hljs-comment">//如果是出队操作</span><br>            <span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;empty&quot;</span>) &#123; <span class="hljs-comment">//如果是判断空操作</span><br>            cout &lt;&lt; (<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果是查询对头操作</span><br>            cout &lt;&lt; <span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="1-bfs算法模版"><a href="#1-bfs算法模版" class="headerlink" title="1.bfs算法模版"></a>1.bfs算法模版</h5><p><img src="/image-20230216163555284.png" alt="image-20230216163555284"></p>
<p><img src="/image-20230310225256235.png" alt="image-20230310225256235"></p>
<p><img src="/image-20230310225331114.png" alt="image-20230310225331114"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码模版</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<span class="hljs-comment">//存储的领接表 - 输入的时候的数据</span><br><span class="hljs-type">int</span> vis[N];<span class="hljs-comment">//标记该点是否遍历过</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//起点标记 和 起点入队</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 这里可以打印 bfs 序列</span><br>        <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;endl;</span><br>        <br>        <span class="hljs-comment">//这一段是遍历e[x]中的所有相邻点y，如果y已经被访问过，就跳过，否则就标记为已访问，并把y入队，表示下一次要访问y的相邻点。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y: e[x])&#123;<br>            <span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;<br>            vis[y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//入队 - 起点连接的下一层出队</span><br>            <span class="hljs-comment">//cout&lt;&lt;y&lt;&lt;endl;</span><br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-bfs序列（树与图的遍历）"><a href="#2-bfs序列（树与图的遍历）" class="headerlink" title="2. bfs序列（树与图的遍历）"></a>2. bfs序列（树与图的遍历）</h5><p><img src="/image-20230310225353381.png" alt="image-20230310225353381"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bfs搜索树</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> vis[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//出队的元素 （这里输出就是bfs树）</span><br>        <span class="hljs-comment">//printf(&quot;%d\n&quot;,x);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:e[x])&#123;<br>            <span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;<br>            vis[y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 入队 &quot;</span>，y); <span class="hljs-comment">//伪代码</span><br>            q.<span class="hljs-built_in">push</span>(y); <span class="hljs-comment">//搜索同层序的 入队吗</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230310225411526.png" alt="image-20230310225411526"></p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><img src="/image-20230302193314874.png" alt="image-20230302193314874"></p>
<p><img src="/image-20230302195721755.png" alt="image-20230302195721755"></p>
<p><img src="/image-20230302195739338.png" alt="image-20230302195739338"></p>
<p><img src="/image-20230302195757415.png" alt="image-20230302195757415"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说就是 按照 前面点最少的顺序排序（也就是入度从小到大）</span><br><span class="hljs-number">1.</span>Kahn算法<br>   起点是从入度为<span class="hljs-number">0</span>的点开始的（这样才能入度从小到大），使用队列来维护我们的点；<span class="hljs-number">1.</span>初始化：将所有入度为<span class="hljs-number">0</span>的点压入我们的队列（顺序不重要）；<span class="hljs-number">2.</span>每次从q中取出一个点x放入数组tp（存储最终序列）；<span class="hljs-number">3.</span>将x的所有出边删除：这个时候的x是队头，边被删除那么对应的连接点的入度就变成<span class="hljs-number">0</span>，就可以压入队列；<span class="hljs-number">4.</span>重复<span class="hljs-number">23</span>步骤。<span class="hljs-number">5.</span>如果tp中的数据和我们的点的数量一样，那么就有拓扑序列，如果不一样，那就没有。（有向 无环图才有拓扑序列）<br><span class="hljs-comment">//***</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N],tp;<span class="hljs-comment">//tp是我们最终输出的拓扑序列</span><br><span class="hljs-type">int</span> din[N]<span class="hljs-comment">//存储着点的入度（画图是不是要用领接表）</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//让入度0的进入队伍</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(din[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// din数组记录的是入度</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//让队头出栈 并且删除对应的边</span><br>        tp.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:e[N])&#123;<br>            <span class="hljs-keyword">if</span>(--din[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<span class="hljs-comment">//删除对应的边 并且让对应的数据入队</span><br>        &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> tp.<span class="hljs-built_in">size</span>() = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        e[a].<span class="hljs-built_in">push_back</span>(b);<br>        din[b]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">toposort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>) ; <span class="hljs-comment">//如果数量不满足 则说明这个不是拓扑序列</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:tp) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,x); <span class="hljs-comment">//将拓扑序列输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs求拓扑序列(变色法)</span><br><span class="hljs-comment">//不懂翻转序列</span><br><span class="hljs-number">1.</span>染色法（yxc用的）<br>    每个点的颜色都会变化，从<span class="hljs-number">0</span> - <span class="hljs-number">-1</span> - <span class="hljs-number">1</span>，经历三次变色；<span class="hljs-number">1.</span>初始状态，所有点染色为<span class="hljs-number">0</span>；<span class="hljs-number">2.</span>枚举每一个点，进入x点（是我们的指针），把x染色为<span class="hljs-number">-1</span>，枚举x的儿子y，如果y的颜色为<span class="hljs-number">0</span>，那么说明没碰过该点，进入y继续走（这里应该是检测有无环 - 会不会回到x）；<span class="hljs-number">3.</span>如果枚举完x（当前数据 - 也算是队头）的儿子，将x压入tp数组；<span class="hljs-number">4.</span>如果发现，有<span class="hljs-number">-1</span>的出现（那么就是有环出现了），返回<span class="hljs-literal">false</span>，退出。<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N],tp;<span class="hljs-comment">//e[N] 应该是树，，或者是领接表画的图</span><br><span class="hljs-type">int</span> c[N]; <span class="hljs-comment">//染色数组</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    c[x] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:e[x])&#123;<br>        <span class="hljs-keyword">if</span>(c[y]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//有环</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    c[x] = <span class="hljs-number">1</span>;<br>    tp.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//当前这个数据遍历完成 压入我们的tp数组</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c)); <span class="hljs-comment">// 初始化 - 刚开始全部点的颜色为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;x&lt;=n;x++)<br>        <span class="hljs-keyword">if</span>(!c[x])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(x)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">reverse</span>(tp.<span class="hljs-built_in">begin</span>(),tp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//翻转序列 为啥？</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Dijkstra-最短路算法"><a href="#Dijkstra-最短路算法" class="headerlink" title="Dijkstra - 最短路算法"></a>Dijkstra - 最短路算法</h3><p><img src="/image-20230302202401928.png" alt="image-20230302202401928"></p>
<p><img src="/image-20230302204100958.png" alt="image-20230302204100958"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说：就是每次选择最短路线进行前进（画最小生成树）</span><br>三个数组： <span class="hljs-number">1.</span>e[u] 存储节点u的所有出边的终点和边权 <span class="hljs-number">2.</span>d[u] 存储u到源点的最小距离（源点就是当前连边的点）（d[u]需要遍历）<span class="hljs-number">3.</span>vis[u] 标记是否出圈<br>    <span class="hljs-number">1.</span>初始的时候，所有点都在圈中，vis = <span class="hljs-number">0</span>,d[s] = <span class="hljs-number">0</span>,d[其他点] = 正无穷<br>    <span class="hljs-number">2.</span>从圈中选择一个距离最小的点，u，打标记出圈（贪心）<br>    <span class="hljs-number">3.</span>对u的所有出边执行松弛操作 - 尝试更新邻点v的最小距离<br>    <span class="hljs-number">4.</span>重复<span class="hljs-number">2</span>,<span class="hljs-number">3</span>操作，直到圈内为空<br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">struct</span> edge&#123;<span class="hljs-type">int</span> v,w;&#125;;<span class="hljs-comment">//点 和 权</span><br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//边</span><br><span class="hljs-type">int</span> d[N],vis[N];<span class="hljs-comment">//d数组是存储当前点的最小距离 - vis标记当前集合中的点（有没有调用这个点）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<span class="hljs-comment">//初始化 全部点的距离都为无穷大</span><br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//枚举每个点 内部枚举全部的点比较他们的距离大小（选最小的边权） - 就是每个点都要比较它自身和其它点的距离关系  （图遍历就是两层 for的）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//枚举全部点（包括自身）</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="hljs-comment">//如果这个点没被测过 并且 当前边权小</span><br>        <br>        vis[u] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记u点（下次就选不到了）</span><br>        <span class="hljs-comment">//遍历全部的点 v点的距离更新为最短的点 ed是迭代器：用处是迭代全部的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<span class="hljs-comment">//无穷大 &gt; 其他（这样来筛数据）</span><br>                d[v] = d[u]+w;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//领接表插入图</span><br>        e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<span class="hljs-comment">//点 连接点 边权</span><br>    &#125;    <br>    <span class="hljs-built_in">dijkstra</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302204110774.png" alt="image-20230302204110774"></p>
<p><img src="/image-20230302205328621.png" alt="image-20230302205328621"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆优化 - 用优先队列维护别更新点的集合。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N];<br><span class="hljs-comment">//优先队列</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-comment">//大根堆（把距离取负值） - 距离最小的元素最大 - 一定在堆顶（懂了 距离从小到大优化）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.全部点的距离都是无穷大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>; q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-comment">//自己和自己距离为0</span><br>    <span class="hljs-comment">//2.枚举进入队列中的数据</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//u是点吗</span><br>        <span class="hljs-type">int</span> u = t.second;<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重</span><br>        vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//之前忘记标记出队了</span><br>        <span class="hljs-comment">//当前点 遍历全部点 出来的边权最小的数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                d[v] = d[u]+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v],v&#125;); <span class="hljs-comment">//大根堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302205410861.png" alt="image-20230302205410861"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//就是两个模板 优化的地方就是枚举的时候用队列维护</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N]; <span class="hljs-comment">//边 和 点</span><br><span class="hljs-comment">//s是起点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//无穷大的值</span><br>    d[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">//对于自己和自己的距离当然是0了</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//枚举次数</span><br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//优化 就是把这里优化了 取消了枚举全部点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++) <span class="hljs-comment">//枚举点</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j;<br>        vis[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123; <span class="hljs-comment">//ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）</span><br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w) &#123;<br>                d[v] = d[u]+w;<br>                q.<span class="hljs-built_in">push_back</span>(&#123;-d[v],v&#125;);<span class="hljs-comment">//插入到 大根堆上</span><br>            &#125;<br>        &#125;            <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302205417632.png" alt="image-20230302205417632"></p>
<h3 id="Bellman-Ford-处理负权边的最短路算法"><a href="#Bellman-Ford-处理负权边的最短路算法" class="headerlink" title="Bellman-Ford  - 处理负权边的最短路算法"></a>Bellman-Ford  - 处理负权边的最短路算法</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//llman-Ford 算法是一种用于求解带权图中单源最短路径的算法，可以处理负权边，但不能处理负权环。</span><br> 它的时间复杂度为 $<span class="hljs-built_in">O</span>(VE)$，其中 $V$ 是顶点数，$E$ 是边数。Bellman-Ford 算法的基本思想是对所有的边进行 $V<span class="hljs-number">-1</span>$ 轮松弛操作，以求出所有可能的最短路径。如果在第 $V$ 轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。<br>    <br><span class="hljs-comment">//Bellman-Ford算法是一种用于计算带权有向图中单源最短路径的算法。</span><br>    它由Richard Bellman和Lester Ford分别在<span class="hljs-number">1958</span>年和<span class="hljs-number">1956</span>年发表，而实际上Edward F. Moore也在<span class="hljs-number">1957</span>年发布了相同的算法，因此，此算法也常被称为Bellman-Ford-Moore算法<span class="hljs-number">1</span>。它比Dijkstra的算法慢，但更通用，因为它能够处理边权值为负数的图<span class="hljs-number">2</span>。<br><br><span class="hljs-comment">//单源最短路</span><br>    单源最短路问题是图论中的一个基本问题，它指的是给定一张有权图，如何求某两点之间的最短路径<span class="hljs-number">1</span>。解决这个问题的算法有很多，比如Dijkstra算法和Bellman-Ford算法等。<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230304212846831.png" alt="image-20230304212846831"></p>
<p><img src="/image-20230304210834724.png" alt="image-20230304210834724"></p>
<p><img src="/image-20230304212028882.png" alt="image-20230304212028882"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//目的是算出图中的最短路（单源最短路：是指在一个图中，给你一个起点（起点固定），然后终点不是固定的，求起点到任意终点的最短路径）</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//这里是 点 和 权</span><br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-comment">//内部变量是起点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellmanford</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化边集</span><br>    <span class="hljs-built_in">memset</span>(d,inf,<span class="hljs-keyword">sizeof</span> d);<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//标记</span><br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//n轮更新</span><br>        flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">//标记（看有无更新）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>;u&lt;=n;u++)&#123; <span class="hljs-comment">//每个点枚举出边</span><br>            <span class="hljs-keyword">if</span>(d[u] == inf) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//枚举u的领点 就行松弛操作</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123; <span class="hljs-comment">//u的出边</span><br>                <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>                <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                    d[v] = d[u] + w;<br>                    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//更新完成 就变true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//没有更新就退出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> flag; <span class="hljs-comment">//第n轮 = true 那么说明就有环    </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="spfa-算法-用bf就好了"><a href="#spfa-算法-用bf就好了" class="headerlink" title="spfa 算法 - 用bf就好了"></a>spfa 算法 - 用bf就好了</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">SPFA 算法是Bellman-Ford算法的队列优化算法的别称，通常用于求含负权边的单源最短路径，以及判负权环。SPFA 最坏情况下复杂度和朴素Bellman-Ford相同，为<span class="hljs-built_in">o</span>(VE).<br><span class="hljs-comment">//其实还不如直接用Bellman-ford</span><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230304212218685.png" alt="image-20230304212218685"></p>
<p><img src="/image-20230304212529352.png" alt="image-20230304212529352"></p>
<p><img src="/image-20230304212738052.png" alt="image-20230304212738052"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆优化 bellman 算法 - spfa算法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//点集合</span><br><span class="hljs-type">int</span> d[N],cnt[N],vis[N]; <span class="hljs-comment">//边 边数 开关</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//队列</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,inf,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集</span><br>    d[s] = <span class="hljs-number">0</span>; vis[s] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(s); <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//这里是将前面初始化的点操作的地方，每次都只操作一个点</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>(); vis[u] = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v , w = ed.w;<br>            <span class="hljs-comment">//比较枚举点和当前点 的长度 更新最短值</span><br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                d[v] = d[u]+w;<br>                cnt[v] = cnt[u]+<span class="hljs-number">1</span>; <span class="hljs-comment">//记录边数</span><br>                <span class="hljs-keyword">if</span>(cnt[v]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!vis[v]) q.<span class="hljs-built_in">push</span>(v),vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Floyd算法-点到点的最短路"><a href="#Floyd算法-点到点的最短路" class="headerlink" title="Floyd算法 - 点到点的最短路"></a>Floyd算法 - 点到点的最短路</h3><p><img src="/image-20230307160057133.png" alt="image-20230307160057133"></p>
<p><img src="/image-20230307160205801.png" alt="image-20230307160205801"></p>
<p><img src="/image-20230307160839691.png" alt="image-20230307160839691"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）</span><br><span class="hljs-comment">// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）</span><br><br><span class="hljs-comment">//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k;k&lt;=n;k++) <span class="hljs-comment">//以k为桥(k枚举的是所有点)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span> ;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>                d[i][j] = <span class="hljs-built_in">mid</span>(d[i][j],d[i][k]+d[k][j]); <span class="hljs-comment">//二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230307161152125.png" alt="image-20230307161152125"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//路径记录原理不了解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">fill</span>(d[<span class="hljs-number">0</span>],d[<span class="hljs-number">0</span>]+N*N,<span class="hljs-number">0x3f3f3f3f</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) d[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b],c);<br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> a,b; cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(d[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230307161434260.png" alt="image-20230307161434260"></p>
<h3 id="最小生成树-prim算法"><a href="#最小生成树-prim算法" class="headerlink" title="最小生成树 - prim算法"></a>最小生成树 - prim算法</h3><p><img src="/image-20230308192754299.png" alt="image-20230308192754299"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有优化版本 - 基于贪心算法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N];<span class="hljs-comment">//d是边的长度 </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="hljs-comment">//排除选过的点 - 这里是选领点的（懂了）</span><br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans+=d[u];<span class="hljs-comment">//边权和（最小生成树的边权和）</span><br>        <span class="hljs-keyword">if</span>(d[u]!=inf) cnt++; <span class="hljs-comment">//判断是否联通</span><br>        <span class="hljs-comment">//遍历到u这个点（u之前的也是一起的，算是连续的）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;w)&#123;<br>                d[v] = w;   <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n; <span class="hljs-comment">//返回true就是有最小生成树的 返回false</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230308110618789.png" alt="image-20230308110618789"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。</span><br><span class="hljs-type">int</span> n,m,s,a,b,c,ans,cnt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//构造一个结构体 内部有点和边的属性</span><br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//领点（也算是所有点？）</span><br><span class="hljs-type">int</span> d[N],vis[N];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">//这里创一个优先队列（就是堆）</span><br><span class="hljs-comment">//s是起点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf; <span class="hljs-comment">//先初始化全部的边 - 每个边都是无穷大</span><br>    <span class="hljs-comment">//起点</span><br>    d[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//取出q队列的点？ - 后面有进入点？</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>; <br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans+=d[u]; cnt++;<br>        <span class="hljs-comment">//这里应该就是插入 领点的步骤</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;w)&#123;<br>                d[v] = w; <span class="hljs-comment">//对应点v边权最小的边</span><br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v],v&#125;);<span class="hljs-comment">//大根堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n; <span class="hljs-comment">//这里判断的是啥？</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230308110724388.png" alt="image-20230308110724388"></p>
<h3 id="最小生成树-克鲁斯卡尔算法-并查集"><a href="#最小生成树-克鲁斯卡尔算法-并查集" class="headerlink" title="最小生成树 - 克鲁斯卡尔算法 - 并查集"></a>最小生成树 - 克鲁斯卡尔算法 - 并查集</h3><p><img src="/image-20230308125205044.png" alt="image-20230308125205044"></p>
<p><img src="/image-20230308125225033.png" alt="image-20230308125225033"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">克鲁斯卡尔算法（Kruskal）是一种使用贪婪方法的最小生成树算法。该算法初始将图视为森林，图中的每一个顶点视为一棵单独的树。一棵树只与它的邻接顶点中权值最小且不违反最小生成树属性（不构成环）的树之间建立连边。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>,M=<span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//结构体存储边的信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;e[M];<br><span class="hljs-comment">//比较函数 （用来作为排序算法的参数）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge x,edge y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.w&lt;y.w;<br>&#125;<br><span class="hljs-comment">//并查集</span><br><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);<br>    <span class="hljs-comment">//排序边权（我们是用贪心来筛选的）</span><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-comment">//每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）</span><br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a),b=<span class="hljs-built_in">find</span>(e[i].b),w=e[i].w;<br>        <span class="hljs-comment">//查一下是否是连通块</span><br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            <span class="hljs-comment">//纳入后宫</span><br>            p[a]=b;<br>            res+=w;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//成树</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<span class="hljs-comment">//输出边权</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/image-20230308100226384.png" alt="image-20230308100226384"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图*"></a>染色法判断二分图*</h3><p><img src="/image-20230314143817025.png" alt="image-20230314143817025"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//染色法判断二分图</span><br>首先随机选择一个未染色的顶点，将其染成红色或蓝色（或其他任意两种不同颜色）。<br>然后将与该顶点相邻的所有顶点染成与其不同的颜色。<br>重复上述过程，直到所有顶点都被染色或者发现某个顶点和它相邻的顶点已经被染成了相同的颜色。<br>如果所有顶点都被染色，那么这个图就是二分图；如果发现有冲突，那么这个图就不是二分图。<br><br><span class="hljs-comment">//二分图</span><br>二分图是图论中的一种特殊模型，它的定义是<span class="hljs-number">1234</span>：如果一个无向图的顶点集可以分成两个互不相交的子集，使得每条边的两个端点分别属于这两个子集，那么这个无向图就是二分图。例如，下图就是一个二分图：<br>    A   B   C<br>    | / | / |<br>    D   E   F<br>就是映射是吧，两个不同的集合中有连边，相同集合的不连边<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断此图是否是二分图</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,M = <span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],e[N],ne[M],idx; <span class="hljs-comment">//e是点集 ne是边集</span><br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">//存储每一个点的状态 一共有三种 起始0 染色 1 - 2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b, ne[idx] = h[a],h[a] = idx++; <span class="hljs-comment">//把h[a]理解为前面的桶形数组就好了</span><br>&#125;<br><span class="hljs-comment">//每次访问一个顶点u，就会先递归地访问它的所有邻接点，直到没有未访问的邻接点为止，</span><br><span class="hljs-comment">//然后再回溯到上一层。这样可以保证每个连通分量内的顶点都被染色。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c; <span class="hljs-comment">//c是什么意思 - 是当前点的染色状态 （只有三种 0 1 2 用3减去就前后不一样了）</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i;i = ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">//邻点</span><br>        <span class="hljs-keyword">if</span>(!color[j])&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(j,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//这个是递归地调用dfs函数，给顶点j和它的邻接点染色，并判断是否有冲突。</span><br>        <span class="hljs-comment">//如果返回false，就说明发现了不符合二分图的情况，就返回false。</span><br>        <span class="hljs-comment">//冲突是指同一个子集内的顶点颜色相同，或者不同子集内的顶点颜色不同。</span><br>        <span class="hljs-comment">//这些情况都不满足二分图的定义，所以要返回false。</span><br>            &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果顶点j已经被染色，并且与u的颜色相同，就说明同一个子集内有边相连，不符合二分图的定义，就返回false。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a); <span class="hljs-comment">//无向图</span><br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!color[i])<br>        &#123;<br>           <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))<br>           &#123;<br>               flag = <span class="hljs-literal">false</span>;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>        &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230314144148781.png" alt="image-20230314144148781"></p>
<p><img src="/image-20230314144232392.png" alt="image-20230314144232392"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>; <span class="hljs-comment">// 顶点数的最大值</span><br><span class="hljs-type">int</span> n1, n2; <span class="hljs-comment">// 二分图左右两边的顶点数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; g[N]; <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-type">int</span> match[N]; <span class="hljs-comment">// match[i]表示右边第i个点当前匹配的左边的点</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// st[i]表示右边第i个点是否已经被遍历过</span><br><br><span class="hljs-comment">// 在二分图中寻找增广路</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g[x].<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> j = g[x][i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求二分图最大匹配数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n1 &gt;&gt; n2;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">// 边数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大匹配数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res++;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法*"></a>匈牙利算法*</h4><p><img src="/image-20230314205307317.png" alt="image-20230314205307317"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>匈牙利算法 - 二分图的最大匹配<br> 二分图，简单来说就是不同集合有联系；同一集合不可以有联系； - 边数最多的一组匹配被称之为最大匹配<br> 在二分图的前提下： <span class="hljs-number">1.</span>交替路 <span class="hljs-number">2.</span>增广路  - 交替路就是匹配和不匹配边交替出现 - 增光路就是匹配和不匹配交换身份，看有没有多路径，多了就是增广路<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m,k,a,b,ans,idx;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,ne;&#125;e[M]; <span class="hljs-comment">//点（对应位置的妹子） ne 另一集合的点是吗</span><br><span class="hljs-type">int</span> h[N],idx;<br><span class="hljs-type">int</span> vis[N],match[M]; <span class="hljs-comment">//标记 和 匹配</span><br><br><span class="hljs-comment">//链式前向星</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++idx] = &#123;b,h[a]&#125;;<br>    h[a] = idx++; <span class="hljs-comment">//横置数组向右移动</span><br>&#125;<br><span class="hljs-comment">//男女匹配问题 (boy and girl）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">//每一个都要匹配看看</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i;i = e[i].ne)&#123;<br>        <span class="hljs-type">int</span> v = e[i].v; <span class="hljs-comment">//妹子</span><br>        <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记</span><br>        <span class="hljs-keyword">if</span>(!match[v]||<span class="hljs-built_in">dfs</span>(match[v]))&#123; <span class="hljs-comment">//没有匹配 || 能不能换（dfs的功能就是判断能不能换）</span><br>            match[v] = u;<span class="hljs-comment">//成对</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++) cin&gt;&gt;a&gt;&gt;b,<span class="hljs-built_in">add</span>(a,b); <span class="hljs-comment">//建图</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) ans++;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="染色法判断二分图-1"><a href="#染色法判断二分图-1" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p><img src="/image-20230315104701595.png" alt="image-20230315104701595"></p>
<p><img src="/image-20230315123714291.png" alt="image-20230315123714291"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.二分图的定义</span><br> 两个不同的集合，互相联通 - 相同集合不可能联通<br><span class="hljs-comment">//2.染色法</span><br>    可以用dfs和bfs来实现染色法，重点是怎么实现前后颜色不同。 我们运用两个标记来判断对应节点的状态： <span class="hljs-number">1</span> 表示这个节点是红 <span class="hljs-number">2</span>表示是黑 <span class="hljs-number">0</span>表示没选这个（加上个判重）<br>   <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,ne;&#125;e[M];<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">//颜色有三种 0 1 2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++idx] = &#123;b,h[a]&#125;; <span class="hljs-comment">//用链式前向星存储的</span><br>    h[a] = idx++;<br>&#125;<br><span class="hljs-comment">//u点的颜色c </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-comment">//枚举u的领边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];i;e[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span>(!color[v])&#123; <span class="hljs-comment">//还没有被访问</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(v,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//改变不同层的颜色</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[v] == c) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;   <br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        <span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!color[i])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))&#123;<br>                flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//有奇环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230314142804998.png" alt="image-20230314142804998"></p>
<p><img src="/image-20230314143439093.png" alt="image-20230314143439093"></p>
<p><img src="/image-20230314143503237.png" alt="image-20230314143503237"></p>
<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a><a href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">最近公共祖先</a></h3><h4 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h4><p><img src="/image-20230319121246852.png" alt="image-20230319121246852"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; tree[MAXN]; <span class="hljs-comment">// 邻接表存储树</span><br><span class="hljs-type">int</span> depth[MAXN], parent[MAXN]; <span class="hljs-comment">// 深度和父亲节点</span><br><br><span class="hljs-comment">// 深度优先搜索遍历计算深度和父亲节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    depth[u] = depth[p] + <span class="hljs-number">1</span>;<br>    parent[u] = p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : tree[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v != p) <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算两个节点的最近公共祖先</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (depth[u] &gt; depth[v]) u = parent[u];<br>    <span class="hljs-keyword">while</span> (depth[v] &gt; depth[u]) v = parent[v];<br>    <span class="hljs-keyword">while</span> (u != v) &#123;<br>        u = parent[u];<br>        v = parent[v];<br>    &#125;<br>    <span class="hljs-keyword">return</span> u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 读入节点数和查询数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 读入边</span><br>        tree[u].<span class="hljs-built_in">push_back</span>(v);<br>        tree[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 计算深度和父亲节点</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 读入查询</span><br>        cout &lt;&lt; <span class="hljs-built_in">lca</span>(u, v) &lt;&lt; endl; <span class="hljs-comment">// 输出结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>这个模板中，n 是树的节点数，m 是查询数量。对于每组查询，它读入两个节点编号 u 和 v，然后调用函数 <span class="hljs-built_in">lca</span>(u,v) 来获取它们的最近公共祖先。<br></code></pre></td></tr></table></figure>

<h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p><img src="/image-20230314144355261.png" alt="image-20230314144355261"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Tarjan算法是由Robert Tarjan发明的一种图算法。它可以用于解决许多不同类型的问题，包括寻找强连通分量、双连通分量、割点和割边等。其中一种应用是在树中查找节点对的最近公共祖先（LCA）。Tarjan算法通过深度优先搜索和并查集数据结构来高效地解决这个问题。</span><br><br><span class="hljs-comment">//tarjan算法 ： 利用并查集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; query[N];<br><span class="hljs-type">int</span> fa[N],vis[N],ans[M];<br><span class="hljs-comment">//并查集</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == fa[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">return</span> fa[u] = <span class="hljs-built_in">find</span>(fa[u]);    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    fa[u] = u; <span class="hljs-comment">// 初始化父亲为自己</span><br>    vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[v])&#123;<br>            tarjan[v];<br>            fa[v] = u;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q:query[u])&#123;<br>        <span class="hljs-type">int</span> v = q.first,i = q.second;<br>        <span class="hljs-keyword">if</span>(vis[v]) ans[i] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="树链剖分-不理解"><a href="#树链剖分-不理解" class="headerlink" title="树链剖分(不理解)"></a>树链剖分(不理解)</h4><p><img src="/image-20230315210121556.png" alt="image-20230315210121556"></p>
<p><img src="/image-20230315210610462.png" alt="image-20230315210610462"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> fa[N],dep[N],son[N],sz[N];<br><span class="hljs-type">int</span> top[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> father)</span></span>&#123;<br>    fa[u] = father, dep[u] = dep[father]+<span class="hljs-number">1</span>,sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v==father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(v,u);<br>        sz[u] += sz[v];<br>        <span class="hljs-keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u] = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    top[u] = t;<br>    <span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[u],t);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v,v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<br>        <span class="hljs-keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="hljs-built_in">swap</span>(u,v);<br>        u = fa[top[u]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dep[u]&lt;dep[v]?u:v;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="倍增算法（不理解）"><a href="#倍增算法（不理解）" class="headerlink" title="倍增算法（不理解）"></a>倍增算法（不理解）</h4><p><img src="/image-20230315210919875.png" alt="image-20230315210919875"></p>
<p><img src="/image-20230315210938761.png" alt="image-20230315210938761"></p>
<p><img src="/image-20230315210958755.png" alt="image-20230315210958755"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>

<h4 id="总"><a href="#总" class="headerlink" title="总"></a>总</h4><p><img src="/image-20230315210622550.png" alt="image-20230315210622550"></p>
<h2 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树*"></a>线段树*</h3><p><img src="/image-20230401100823894.png" alt="image-20230401100823894"></p>
<p><img src="/image-20230401100840271.png" alt="image-20230401100840271"></p>
<p><img src="/image-20230401100850209.png" alt="image-20230401100850209"></p>
<p><img src="/image-20230401100859800.png" alt="image-20230401100859800"></p>
<p><img src="/image-20230401100913730.png" alt="image-20230401100913730"></p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组*"></a>树状数组*</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/04/30/Linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础知识和起源"><a href="#基础知识和起源" class="headerlink" title="基础知识和起源"></a>基础知识和起源</h2><blockquote>
<p><a href="https://www.runoob.com/linux/linux-intro.html">https://www.runoob.com/linux/linux-intro.html</a></p>
</blockquote>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p><img src="/2023/04/30/Linux/%E5%8F%91%E8%A1%8C.jpg" alt="发行"></p>
<p><img src="/2023/04/30/Linux/linux%E5%92%8Cwindows%E5%8C%BA%E5%88%AB.png" alt="linux和windows区别"></p>
<blockquote>
<p>我们只要知道创始人很牛逼就行，然后知道Linux其实和window一样是一个操作系统。</p>
</blockquote>
<p>对于这个操作系统，并不是像我们常用的window系统一样是有图像图标的，对次系统的操作是通过命令行操作的</p>
<p><img src="/2023/04/30/Linux/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9B%BE%E7%89%87.png" alt="命令行演示"></p>
<p>当然，在对其操作之前，我们得把Linux启动,启动Linux分为5个阶段：</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<h3 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a><strong>内核引导</strong></h3><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>
<blockquote>
<p>BIOS，可以理解为自检，控制我们主板其他硬件的各种参数，比如可以调整CPU频率，修改内存时序。就是控制硬件的一个简单程序吧</p>
</blockquote>
<p>操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p>
<p><img src="/2023/04/30/Linux/%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC.png" alt="内核引导"></p>
<h3 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a><strong>运行init</strong></h3><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<blockquote>
<p>我们在算法中，init函数通常被声明为初始化函数，用在这里也可以这样理解。理解为初始化系统的一个程序吧。</p>
</blockquote>
<p>init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p>
<p><img src="/2023/04/30/Linux/init%E8%BF%9B%E7%A8%8B.png" alt="init()"></p>
<p>运行级别</p>
<p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p>
<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>
<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<p><img src="/2023/04/30/Linux/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB.png" alt="运行级别"></p>
<blockquote>
<p>可以理解为，为了适应不同的功能，才出对应的级别。让程序运行有针对性。</p>
</blockquote>
<p>Linux系统有7个运行级别(runlevel)：</p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li>
<li>运行级别2：多用户状态(没有NFS)</li>
<li>运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登录后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化*"></a><strong>系统初始化</strong>*</h3><blockquote>
<p>这里我就看不懂了，涉及到shell。&#x2F;etc&#x2F;init.d&#x2F;是一个目录，里面存放着很多系统服务的启动和停止脚本。它可以控制各种系统服务的运行状态，比如网络、防火墙、数据库等。您可以使用 &#x2F;etc&#x2F;init.d&#x2F;目录下的脚本来启动、停止或重启某个服务，比如 &#x2F;etc&#x2F;init.d&#x2F;network restart 就是重启网络服务。</p>
</blockquote>
<p>在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">l5:5:wait:/etc/rc.d/rc 5<br></code></pre></td></tr></table></figure>

<p>这一行表示以5为参数运行&#x2F;etc&#x2F;rc.d&#x2F;rc，&#x2F;etc&#x2F;rc.d&#x2F;rc是一个Shell脚本，它接受5作为参数，去执行&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录下的所有的rc启动脚本，&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下。</p>
<p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p>
<p>&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</p>
<p>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以&#x2F;var&#x2F;lock&#x2F;subsys&#x2F;下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</p>
<p>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p>
<p>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。</p>
<p><img src="/2023/04/30/Linux/etc-init.png" alt="etc"></p>
<blockquote>
<p>理解为系统的关键部分吧</p>
</blockquote>
<h3 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h3><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p>
<p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">1:2345:respawn:/sbin/mingetty tty1<br>2:2345:respawn:/sbin/mingetty tty2<br>3:2345:respawn:/sbin/mingetty tty3<br>4:2345:respawn:/sbin/mingetty tty4<br>5:2345:respawn:/sbin/mingetty tty5<br>6:2345:respawn:/sbin/mingetty tty6<br></code></pre></td></tr></table></figure>

<p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p>
<p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p>
<h3 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统*"></a>用户登录系统*</h3><p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>（1）命令行登录</li>
<li>（2）ssh登录</li>
<li>（3）图形界面登录</li>
</ul>
<p><img src="/2023/04/30/Linux/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.png" alt="img"></p>
<p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p>
<p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p>
<p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p>
<p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 &#x2F;etc&#x2F;nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p>
<p>这通常用来系统维护时防止非root用户登录。只有&#x2F;etc&#x2F;securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p>
<p>&#x2F;etc&#x2F;usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p>
<h3 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式*"></a>图形模式与文字模式的切换方式*</h3><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p>
<p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p>
<p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p>
<p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p>
<p>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1<del>F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1</del>F6 切换至命令窗口。</p>
<p><img src="/2023/04/30/Linux/%E5%88%87%E6%8D%A2.png" alt="切换"></p>
<h3 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机*"></a>Linux 关机*</h3><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p>
<p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p>
<p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p>
<p>例如你可以运行如下命令关机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sync 将数据由内存同步到硬盘中。<br><br>shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：<br><br>shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。<br><br>shutdown –h now 立马关机<br><br>shutdown –h 20:25 系统会在今天20:25关机<br><br>shutdown –h +10 十分钟后关机<br><br>shutdown –r now 系统立马重启<br><br>shutdown –r +10 系统十分钟后重启<br><br>reboot 就是重启，等同于 shutdown –r now<br><br>halt 关闭系统，等同于shutdown –h now 和 poweroff<br></code></pre></td></tr></table></figure>

<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p>
<p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p>
<h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><h3 id="基本文件介绍"><a href="#基本文件介绍" class="headerlink" title="基本文件介绍"></a>基本文件介绍</h3><p>登录系统后，在当前命令窗口下输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">ls / <br></code></pre></td></tr></table></figure>

<p>你会看到如下图所示:</p>
<p><img src="/2023/04/30/Linux/ls%E5%8A%9F%E8%83%BD.png" alt="ls功能"></p>
<p>树状目录结构：</p>
<p><img src="/2023/04/30/Linux/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="树状目录"></p>
<p>以下是对这些目录的解释：</p>
<ul>
<li><p><strong>&#x2F;bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>&#x2F;boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>&#x2F;dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>&#x2F;etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>&#x2F;home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
</li>
<li><p><strong>&#x2F;lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>&#x2F;lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>&#x2F;media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>&#x2F;mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>&#x2F;opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>&#x2F;proc</strong>：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>&#x2F;sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>&#x2F;selinux</strong>：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>&#x2F;srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>&#x2F;sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>&#x2F;tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>&#x2F;usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>&#x2F;var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>&#x2F;run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
</li>
</ul>
<p><strong>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</strong></p>
<p><strong>&#x2F;etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p>
<p><strong>&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin</strong>: 这是系统预设的执行文件的放置目录，比如 <strong>ls</strong> 就是在 <strong>&#x2F;bin&#x2F;ls</strong> 目录下的。</p>
<p>值得提出的是 <strong>&#x2F;bin</strong>、**&#x2F;usr&#x2F;bin** 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。</p>
<p><strong>&#x2F;var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。</p>
<h3 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性*"></a>文件基本属性*</h3><blockquote>
<p><a href="https://www.runoob.com/linux/linux-file-attr-permission.html">https://www.runoob.com/linux/linux-file-attr-permission.html</a></p>
</blockquote>
<h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 **&#x2F;**。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<ul>
<li><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</li>
<li><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</li>
</ul>
<h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<p><strong>操作演示：</strong></p>
<p><img src="/2023/04/30/Linux/image-20230503104713448.png" alt="ls演示"></p>
<p><img src="/2023/04/30/Linux/image-20230503104745656.png" alt="切换目录"></p>
<p><img src="/2023/04/30/Linux/image-20230503104833277.png" alt="显示目录"></p>
<h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称<br>[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称<br>[root@www ~]# ls [--full-time] 目录名称<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# ls -al ~<br></code></pre></td></tr></table></figure>

<h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"> cd [相对路径或绝对路径]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 <span class="hljs-built_in">mkdir</span> 命令创建 runoob 目录</span><br>[root@www ~]# mkdir runoob<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用绝对路径切换到 runoob 目录</span><br>[root@www ~]# cd /root/runoob/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用相对路径切换到 runoob 目录</span><br>[root@www ~]# cd ./runoob/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示回到自己的家目录，亦即是 /root 这个目录</span><br>[root@www runoob]# cd ~<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span><br>[root@www ~]# cd ..<br></code></pre></td></tr></table></figure>

<p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p>
<h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# pwd [-P]<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li>
</ul>
<p>实例：单纯显示出目前的工作目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# pwd<br>/root   &lt;== 显示出目录啦～<br></code></pre></td></tr></table></figure>

<p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个链接档<br>[root@www mail]# pwd<br>/var/mail         &lt;==列出目前的工作目录<br>[root@www mail]# pwd -P<br>/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～<br>[root@www mail]# ls -ld /var/mail<br>lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看到这里应该知道为啥了吧？因为 /var/mail 是链接档，链接到 /var/spool/mail</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以，加上 <span class="hljs-built_in">pwd</span> -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！</span><br></code></pre></td></tr></table></figure>

<h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">mkdir [-mp] 目录名称<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>实例：请到&#x2F;tmp底下尝试创建数个新目录看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# cd /tmp<br>[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录<br>[root@www tmp]# mkdir test1/test2/test3/test4<br>mkdir: cannot create directory `test1/test2/test3/test4&#x27;: <br>No such file or directory       &lt;== 没办法直接创建此目录啊！<br>[root@www tmp]# mkdir -p test1/test2/test3/test4<br></code></pre></td></tr></table></figure>

<p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p>
<p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www tmp]# mkdir -m 711 test2<br>[root@www tmp]# ls -l<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1<br>drwx--x--x  2 root  root 4096 Jul 18 12:54 test2<br></code></pre></td></tr></table></figure>

<p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p>
<p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p>
<h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rmdir [-p] 目录名称<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-p ：</strong>从该目录起，一次删除多级空目录</li>
</ul>
<p>删除 runoob 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www tmp]# rmdir runoob/<br></code></pre></td></tr></table></figure>

<p>将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www tmp]# ls -l   &lt;==看看有多少目录存在？<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1<br>drwx--x--x  2 root  root 4096 Jul 18 12:54 test2<br>[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题<br>[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！<br>rmdir: `test1&#x27;: Directory not empty<br>[root@www tmp]# rmdir -p test1/test2/test3/test4<br>[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！<br>drwx--x--x  2 root  root 4096 Jul 18 12:54 test2<br></code></pre></td></tr></table></figure>

<p>利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。</p>
<p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p>
<h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p>
<p>语法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)<br>[root@www ~]# cp [options] source1 source2 source3 .... directory<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式链接(hard link)的链接档创建，而非复制文件本身；</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-s：</strong>复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# cp ~/.bashrc /tmp/bashrc<br>[root@www ~]# cp -i ~/.bashrc /tmp/bashrc<br>cp: overwrite `/tmp/bashrc&#x27;? n  &lt;==n不覆盖，y为覆盖<br></code></pre></td></tr></table></figure>

<h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">rm [-fir] 文件或目录<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
<li></li>
</ul>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www tmp]# rm -i bashrc<br>rm: remove regular file `bashrc&#x27;? y<br></code></pre></td></tr></table></figure>

<p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>
<h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# mv [-fiu] source destination<br>[root@www ~]# mv [options] source1 source2 source3 .... directory<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# cd /tmp<br>[root@www tmp]# cp ~/.bashrc bashrc<br>[root@www tmp]# mkdir mvtest<br>[root@www tmp]# mv bashrc mvtest<br></code></pre></td></tr></table></figure>

<p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www tmp]# mv mvtest mvtest2<br></code></pre></td></tr></table></figure>

<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">cat [-AbEnTv]<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>检看 &#x2F;etc&#x2F;issue 这个文件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# cat /etc/issue<br>CentOS release 6.4 (Final)<br>Kernel \r on an \m<br></code></pre></td></tr></table></figure>

<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# tac /etc/issue<br><br>Kernel \r on an \m<br>CentOS release 6.4 (Final)<br></code></pre></td></tr></table></figure>

<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">nl [-bnw] 文件<br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>实例一：用 nl 列出 &#x2F;etc&#x2F;issue 的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# nl /etc/issue<br>     1  CentOS release 6.4 (Final)<br>     2  Kernel \r on an \m<br></code></pre></td></tr></table></figure>

<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# more /etc/man_db.config <br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Generated automatically from man.conf.in by the</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">configure script.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># man.conf from man-1.6d</span></span><br>....(中间省略)....<br><span class="hljs-meta prompt_">--More--(28%</span><span class="language-bash">)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></code></pre></td></tr></table></figure>

<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q       ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# less /etc/man.config<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Generated automatically from man.conf.in by the</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">configure script.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># man.conf from man-1.6d</span></span><br>....(中间省略)....<br>:   &lt;== 这里可以等待你输入命令！<br></code></pre></td></tr></table></figure>

<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串   ：向下搜寻『字串』的功能；</li>
<li>?字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">head [-n number] 文件 <br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# head /etc/man.config<br></code></pre></td></tr></table></figure>

<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@www ~]# head -n 20 /etc/man.config<br></code></pre></td></tr></table></figure>

<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">tail [-n number] 文件 <br></code></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">[root@www ~]<span class="hljs-meta"># tail /etc/man.config</span><br># 默认的情况中，显示最后的十行！若要显示最后的 <span class="hljs-number">20</span> 行，就得要这样：<br>[root@www ~]<span class="hljs-meta"># tail -n 20 /etc/man.config</span><br></code></pre></td></tr></table></figure>

<h2 id="调用代码演示"><a href="#调用代码演示" class="headerlink" title="调用代码演示"></a>调用代码演示</h2><p>常用命令介绍：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">(1) ctrl c: 取消命令，并且换行<br>(2) ctrl u: 清空本行命令<br>(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项<br>(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br>(5) pwd: 显示当前路径<br>(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录<br>(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt<br>(8) mkdir XXX: 创建目录XXX<br>(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹<br>(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令<br>(11) touch XXX: 创建一个文件<br>(12) cat XXX: 展示文件XXX中的内容<br>(13) 复制文本<br>    windows/Linux下：Ctrl + insert，Mac下：command + c<br>(14) 粘贴文本<br>    windows/Linux下：Shift + insert，Mac下：command + v<br></code></pre></td></tr></table></figure>

<p>作业：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：<br>(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c<br>(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak<br>(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt<br>(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下<br>(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除<br>(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除<br>(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作<br>(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，<br>    将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;<br>    将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;<br>    将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;<br>(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作<br>(9) 进入homework_9文件夹，将其中所有txt类型的文件删除<br></code></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>One 基本算法</title>
    <url>/2023/04/26/One/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h2 id="时间复杂度和空间复杂度的基本估计"><a href="#时间复杂度和空间复杂度的基本估计" class="headerlink" title="时间复杂度和空间复杂度的基本估计"></a>时间复杂度和空间复杂度的基本估计</h2><p><img src="/2023/04/26/One/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="时间复杂度"></p>
<h2 id="基本算法说明"><a href="#基本算法说明" class="headerlink" title="基本算法说明"></a>基本算法说明</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.枚举的定义</span><br>  枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。<br>  枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。<br><span class="hljs-comment">//2.简单来说，枚举就是在有限次的比对中，找到与正确答案符合的数据。</span><br>    枚举经常出现，算是最为基本的算法 - 之后对枚举的优化也是一些算法复杂度低的原因<br>    总体来说，枚举的复杂度需要看我们取得的数据的个数 一个那就是 <span class="hljs-built_in">o</span>(n) 多个就是<span class="hljs-built_in">o</span>(n^i)<br><span class="hljs-comment">//3.简单举例</span><br>    要求一个数组中，有多少个<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = i;i&lt;=n;i++) <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) ans++<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//深入研究</span><br> 枚举算法是我们在日常中使用到的最多的一个算法，它的核心思想就是:枚举所有的可能。<br> 枚举法的本质就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件：<br>  (<span class="hljs-number">1</span>)可预先确定候选答案的数量；<span class="hljs-comment">//可以确定答案就在我们枚举的范围之中</span><br>  (<span class="hljs-number">2</span>)候选答案的范围在求解之前必须有一个确定的集合。<span class="hljs-comment">//范围</span><br>  枚举算法简单粗暴，他暴力的枚举所有可能，尽可能地尝试所有的方法。虽然枚举算法非常暴力，而且速度可能很慢，但确实我们最应该优先考虑的！因为枚举法变成实现最简单，并且得到的结果总是正确的。<br> 枚举算法分为循环枚举、子集枚举、排列枚举三种。<br></code></pre></td></tr></table></figure>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//说白了 模拟题就是应用题 给出一个项目让你实现它</span><br><br><span class="hljs-comment">//写模拟题时，遵循以下的建议有可能会提升做题速度：</span><br>  <span class="hljs-number">1.</span>在动手写代码之前，在草纸上尽可能地写好要实现的流程。<br>  <span class="hljs-number">2.</span>在代码中，尽量把每个部分模块化，写成函数、结构体或类。<br>  <span class="hljs-number">3.</span>对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 <span class="hljs-string">&quot;YY-MM-DD 时：分&quot;</span> 把它抽取到一个函数，处理成秒，会减少概念混淆。<br>  <span class="hljs-number">4.</span>调试时分块调试。模块化的好处就是可以方便的单独调某一部分。<br>  <span class="hljs-number">5.</span>写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。<br></code></pre></td></tr></table></figure>

<h3 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.递归 </span><br> 函数调用自身。递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(传入数值)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (终止条件) <span class="hljs-keyword">return</span> 最小子问题解;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(缩小规模);<br>  &#125;<br><span class="hljs-comment">//2.递归的实现</span><br> 只需要在乎，把大问题分解为许多小问题就行了，不用在意子问题如何实现。 当然，我们得初始化刚开始的子问题（要不然后面的问题就无法按找 小问题变为大问题递推出来）<br><span class="hljs-comment">//3.缺点</span><br>    递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 栈溢出 的后果。（但是我没遇过）<br><span class="hljs-comment">//4.递归的要点</span><br>    明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。（明白每个函数能做的事，并相信他们能够完成和我之前想的不谋而合）<br><span class="hljs-comment">//举例 遍历二叉树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left);<br>     <span class="hljs-built_in">traverse</span>(root-&gt;right);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.分治</span><br> 说白了就是，将大问题分成多个小问题（一般都是 二分 logn 次啦），然后再对小问题得出的数据进行操作，归并排序就是将小问题按照既定规则拼回去.其他的也差不多<br><span class="hljs-comment">//2.分治法的流程</span><br> 大概的流程可以分为三步：分解 -&gt; 解决 -&gt; 合并。<br><span class="hljs-number">1.</span>分解原问题为结构相同的子问题。<br><span class="hljs-number">2.</span>分解到某个容易求解的边界之后，进行递归求解。<br><span class="hljs-number">3.</span>将子问题的解合并成原问题的解。<br><br><span class="hljs-comment">//分治法能解决的问题一般有如下特征：</span><br><span class="hljs-number">1.</span>该问题的规模缩小到一定的程度就可以容易地解决。<br><span class="hljs-number">2.</span>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。<br><span class="hljs-number">3.</span>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题（子问题独立）。（公共的子问题需要动态规划来解决）<br></code></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.概念</span><br> 贪心算法（英语：greedy algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。<br> 可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。一般来说，我们可以引用某一个步骤来反证我们的答案是否正确<br><span class="hljs-comment">//2.常见题型</span><br> 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。（离线 先处理在选择）<br>  「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）（边处理 边选择）<br><span class="hljs-comment">//3.两种方法</span><br>      <span class="hljs-number">01.</span>排序解法 用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。<br>      <span class="hljs-number">02.</span>后悔解法 思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。<br><span class="hljs-comment">//4.特殊性质</span><br>      贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。<br></code></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><blockquote>
<p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p>
</blockquote>
<h4 id="排序的时间复杂度分析"><a href="#排序的时间复杂度分析" class="headerlink" title="排序的时间复杂度分析"></a>排序的时间复杂度分析</h4><p><img src="/2023/04/26/One/sort.png" alt="sort"></p>
<p><img src="/2023/04/26/One/%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83.png" alt="排序数据比较"></p>
<h4 id="冒泡排序操作"><a href="#冒泡排序操作" class="headerlink" title="冒泡排序操作"></a>冒泡排序操作</h4><p><img src="/2023/04/26/One/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">冒泡排序<br> 冒泡排序的时间复杂度是 <span class="hljs-built_in">o</span>(n^<span class="hljs-number">2</span>),这个复杂度是由冒泡排序的操作约束的。冒泡排序的原理是，选择我们序列中的一个值，对其进行这样的操作：<br> -将当前这个值和下一个数据对比，如果当前这个值大于下一个数据，交换；否则，下一个值作为新的交换值代替之前的值执行交换程序。直到最后，没有数据进行比对，退出程序。<br><span class="hljs-comment">// 菜鸟 - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><br>    <br><span class="hljs-comment">//代码    </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>                        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>                                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">61</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">60</span>, <span class="hljs-number">72</span>, <span class="hljs-number">21</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">62</span> &#125;;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(*arr);<br>        <span class="hljs-built_in">bubble_sort</span>(arr, len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>                cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-type">float</span> arrf[] = &#123; <span class="hljs-number">17.5</span>, <span class="hljs-number">19.1</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">10.5</span>, <span class="hljs-number">12.4</span>, <span class="hljs-number">3.8</span>, <span class="hljs-number">19.7</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">28.6</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">23.8</span>, <span class="hljs-number">5.4</span> &#125;;<br>        len = (<span class="hljs-type">float</span>) <span class="hljs-built_in">sizeof</span>(arrf) / <span class="hljs-built_in">sizeof</span>(*arrf);<br>        <span class="hljs-built_in">bubble_sort</span>(arrf, len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>                cout &lt;&lt; arrf[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure>

<h4 id="选择排序操作"><a href="#选择排序操作" class="headerlink" title="选择排序操作"></a>选择排序操作</h4><p><img src="/2023/04/26/One/selectionSort.gif" alt="选择排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">2.</span>选择排序<br>    <br><span class="hljs-comment">//选择排序的时间复杂度是o(n^2) - 是因为选择排序需要进行 n-1 轮比较，每轮比较需要比较 n-i 次，所以总共需要比较 (n-1) + (n-2) + … + 1 = n(n-1)/2 次，因此时间复杂度为 O(n²)。</span><br><br> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。就是每次选中一个未排序序列的起点，然后在未排序序列中，找到一个“最小值”直到遍历完区间之后，将其标记未排序序列（区间缩小），重复直到全为排序区间，退出程序。<br>    <br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-type">int</span> min = i;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); j++)<br>                        <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])<br>                                min = j;<br>                std::<span class="hljs-built_in">swap</span>(arr[i], arr[min]);<br>        &#125;<br>&#125;     <br></code></pre></td></tr></table></figure>

<h4 id="插入排序操作"><a href="#插入排序操作" class="headerlink" title="插入排序操作"></a>插入排序操作</h4><p><img src="/2023/04/26/One/insertionSort.gif" alt="插入排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入排序的复杂度是 o(n^2) 每一个数据最多要比较（n-1)次，所以说n*(n-1) = n^2</span><br><br> 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<br> 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。   <br>        <br><span class="hljs-comment">//和打扑克牌是一个道理，开始的时候我们只有一张牌（假设），我们将这张牌当做一个有序序列，每次加入新的牌的时候和有序序列进行比较插入，按照插入的规则（从小到大 还是 从大到小）进行判断插入。（感觉就是和选择排序是相反的，从无序中抽数据和有序序列进行比对）</span><br><br><span class="hljs-comment">//代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>                <span class="hljs-type">int</span> key=arr[i];<br>                <span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;<br>                        arr[j+<span class="hljs-number">1</span>]=arr[j];<br>                        j--;<br>                &#125;<br>                arr[j+<span class="hljs-number">1</span>]=key;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="希尔排序操作"><a href="#希尔排序操作" class="headerlink" title="希尔排序操作"></a>希尔排序操作</h4><p><img src="/2023/04/26/One/Sorting_shellsort_anim.gif" alt="希尔排序"></p>
<blockquote>
<p>引用文章&lt;<a href="https://blog.csdn.net/qq_43473694/article/details/112197066">(106条消息) 排序算法 | 希尔shell排序，算法的图解、实现、复杂度和稳定性分析_shell排序时间复杂度_比特的一天的博客-CSDN博客</a>&gt;</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//希尔排序的时间复杂度是：O(n^1.3） 在最坏情况之下是o(n^2) - 因为是基于插入排序</span><br> 希尔排序：先追求部分元素有序，然后逼近全局有序！希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br> - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br> - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br> 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = <span class="hljs-number">1</span>；按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 <span class="hljs-number">1</span> 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>        <br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">shell_sort</span>(T array[], <span class="hljs-type">int</span> length) &#123;<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>) &#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;<br>                std::<span class="hljs-built_in">swap</span>(array[j], array[j - h]);<br>            &#125;<br>        &#125;<br>        h = h / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;   <br></code></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img src="/2023/04/26/One/mergeSort.gif" alt="归并排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//归并排序的时间复杂度是 o(log n)</span><br> 归并排序的算法思想是：分治法。 将大问题分解成许多的子问题，在将子问题合并成为我们的大问题<br><span class="hljs-comment">//实现方法</span><br> 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 <span class="hljs-number">2</span> 种方法）自下而上的迭代<br> 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 <span class="hljs-number">3</span> 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 <br><br><span class="hljs-comment">//非递归</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    T *a = arr;<br>    T *b = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; len; start += seg + seg) &#123;<br>            <span class="hljs-type">int</span> low = start, mid = <span class="hljs-built_in">min</span>(start + seg, len), high = <span class="hljs-built_in">min</span>(start + seg + seg, len);<br>            <span class="hljs-type">int</span> k = low;<br>            <span class="hljs-type">int</span> start1 = low, end1 = mid;<br>            <span class="hljs-type">int</span> start2 = mid, end2 = high;<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)<br>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1)<br>                b[k++] = a[start1++];<br>            <span class="hljs-keyword">while</span> (start2 &lt; end2)<br>                b[k++] = a[start2++];<br>        &#125;<br>        T *temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a != arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            b[i] = a[i];<br>        b = a;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] b;<br>&#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    T *a = arr;<br>    T *b = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; len; start += seg + seg) &#123;<br>            <span class="hljs-type">int</span> low = start, mid = <span class="hljs-built_in">min</span>(start + seg, len), high = <span class="hljs-built_in">min</span>(start + seg + seg, len);<br>            <span class="hljs-type">int</span> k = low;<br>            <span class="hljs-type">int</span> start1 = low, end1 = mid;<br>            <span class="hljs-type">int</span> start2 = mid, end2 = high;<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)<br>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1)<br>                b[k++] = a[start1++];<br>            <span class="hljs-keyword">while</span> (start2 &lt; end2)<br>                b[k++] = a[start2++];<br>        &#125;<br>        T *temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a != arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            b[i] = a[i];<br>        b = a;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] b;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img src="/2023/04/26/One/quickSort.gif" alt="快速排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速排序的时间复杂度是o(nlog n),一般而言是比其他nlogn排序是要快的</span><br><br> 从数列中挑出一个元素，称为 <span class="hljs-string">&quot;基准&quot;</span>（pivot）;<br> 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，<span class="hljs-string">&quot;该基准就处于数列的中间位置&quot;</span>。这个称为分区（partition）操作；<br>    递归（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br><br><span class="hljs-comment">//就是由基准分成两部分，再由两部分的基准分成另外两部分，以此类推。 - 直到所有部分都符合基准，即可退出。</span><br>        <br><span class="hljs-comment">//代码        </span><br><span class="hljs-comment">//严蔚敏《数据结构》标准分割函数</span><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Paritition1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>   <span class="hljs-type">int</span> pivot = A[low];<br>   <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>     <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;<br>       --high;<br>     &#125;<br>     A[low] = A[high];<br>     <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;<br>       ++low;<br>     &#125;<br>     A[high] = A[low];<br>   &#125;<br>   A[low] = pivot;<br>   <span class="hljs-keyword">return</span> low;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//快排母函数</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>     <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Paritition1</span>(A, low, high);<br>     <span class="hljs-built_in">QuickSort</span>(A, low, pivot - <span class="hljs-number">1</span>);<br>     <span class="hljs-built_in">QuickSort</span>(A, pivot + <span class="hljs-number">1</span>, high);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><img src="/2023/04/26/One/heapSort.gif" alt="堆排序"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="堆排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆排序 - 是利用数据结构中的堆的性质设计的算法，它的时间复杂度是o(nlogn)</span><br> 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br> 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br><span class="hljs-comment">//算法步骤</span><br> 创建一个堆 H[<span class="hljs-number">0</span>……n<span class="hljs-number">-1</span>]；<br> 把堆首（最大值）和堆尾互换；<br> 把堆的尺寸缩小 <span class="hljs-number">1</span>，并调用 <span class="hljs-built_in">shift_down</span>(<span class="hljs-number">0</span>)，目的是把新的数组顶端数据调整到相应位置；<br> 重复步骤 <span class="hljs-number">2</span>，直到堆的尺寸为 <span class="hljs-number">1</span>。<br><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 建立父節點指標和子節點指標</span><br>    <span class="hljs-type">int</span> dad = start;<br>    <span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span><br>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span><br>            son++;<br>        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span><br>            <span class="hljs-built_in">swap</span>(arr[dad], arr[son]);<br>            dad = son;<br>            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">max_heapify</span>(arr, i, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-built_in">max_heapify</span>(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(*arr);<br>    <span class="hljs-built_in">heap_sort</span>(arr, len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><img src="/2023/04/26/One/countingSort.gif" alt="计数排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</span><br><span class="hljs-comment">//计数排序的时间复杂度是o(n+K)</span><br> 简单说，就是用我们<span class="hljs-string">&quot;需要排序的序列的值&quot;</span>,创建一个标记数组，只要序列出现过的值，都标记成<span class="hljs-number">1</span>，就说明它出现了。但是，这种方法只对数来说比较方便。 - 可以说是数组下标和排序序列有映射关系<br>      <br><span class="hljs-comment">//算法步骤</span><br>（<span class="hljs-number">1</span>）找出待排序的数组中最大和最小的元素<br>（<span class="hljs-number">2</span>）统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>（<span class="hljs-number">3</span>）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>（<span class="hljs-number">4</span>）反向填充目标数组：将每个元素i放在新数组的第<span class="hljs-built_in">C</span>(i)项，每放一个元素就将<span class="hljs-built_in">C</span>(i)减去<span class="hljs-number">1</span><br><br><span class="hljs-comment">//代码（c）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *ini_arr, <span class="hljs-type">int</span> *sorted_arr, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> *count_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>        <span class="hljs-type">int</span> i, j, k;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++)<br>                count_arr[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                count_arr[ini_arr[i]]++;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">100</span>; k++)<br>                count_arr[k] += count_arr[k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (j = n; j &gt; <span class="hljs-number">0</span>; j--)<br>                sorted_arr[--count_arr[ini_arr[j - <span class="hljs-number">1</span>]]] = ini_arr[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">free</span>(count_arr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);<br>        <span class="hljs-type">int</span> *sorted_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);<br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                arr[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ini_array: &quot;</span>);<br>        <span class="hljs-built_in">print_arr</span>(arr, n);<br>        <span class="hljs-built_in">counting_sort</span>(arr, sorted_arr, n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sorted_array: &quot;</span>);<br>        <span class="hljs-built_in">print_arr</span>(sorted_arr, n);<br>        <span class="hljs-built_in">free</span>(arr);<br>        <span class="hljs-built_in">free</span>(sorted_arr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;        <br><br><br></code></pre></td></tr></table></figure>

<h4 id="桶排序-不懂"><a href="#桶排序-不懂" class="headerlink" title="桶排序 - 不懂"></a>桶排序 - 不懂</h4><p>元素分布在桶中：</p>
<p><img src="/2023/04/26/One/Bucket_sort_1.svg_.png" alt="桶"></p>
<p>然后，元素在每个桶中排序：</p>
<p><img src="/2023/04/26/One/Bucket_sort_2.svg_.png" alt="桶"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</span><br><span class="hljs-comment">//为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</span><br>计数排序每个位置只能装一种数据，而桶排序中，可以装入一个范围（集合）的数据是这个样子吗 - 感觉类似于哈希表<br>        <br>        <br><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];<br>    <span class="hljs-type">int</span> maxv = *<span class="hljs-built_in">max_element</span>(a, a + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) b[a[i]] ++ ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt;= maxv; i ++ )<br>        <span class="hljs-keyword">while</span> (b[i] -- ) a[j ++ ] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;        <br></code></pre></td></tr></table></figure>

<h4 id="基数排序-不懂"><a href="#基数排序-不懂" class="headerlink" title="基数排序 - 不懂"></a>基数排序 - 不懂</h4><p><img src="/2023/04/26/One/radixSort.gif" alt="基数排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//基数排序：根据键值的每位数字来分配桶；</span><br><span class="hljs-comment">//基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</span><br><br><br><span class="hljs-comment">//代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-type">int</span> data[], <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> maxData = data[<span class="hljs-number">0</span>];              <span class="hljs-comment">///&lt; 最大数</span><br>    <span class="hljs-comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (maxData &lt; data[i])<br>            maxData = data[i];<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (maxData &gt;= p)<br>    &#123;<br>        <span class="hljs-comment">//p *= 10; // Maybe overflow</span><br>        maxData /= <span class="hljs-number">10</span>;<br>        ++d;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br><span class="hljs-comment">/*    int d = 1; //保存最大的位数</span><br><span class="hljs-comment">    int p = 10;</span><br><span class="hljs-comment">    for(int i = 0; i &lt; n; ++i)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        while(data[i] &gt;= p)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            p *= 10;</span><br><span class="hljs-comment">            ++d;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return d;*/</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-type">int</span> data[], <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//基数排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">maxbit</span>(data, n);<br>    <span class="hljs-type">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    <span class="hljs-type">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//计数器</span><br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> radix = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= d; i++) <span class="hljs-comment">//进行d次排序</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次分配前清空计数器</span><br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>; <span class="hljs-comment">//统计每个桶中的记录数</span><br>            count[k]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = count[j - <span class="hljs-number">1</span>] + count[j]; <span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span><br>        <span class="hljs-keyword">for</span>(j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>;<br>            tmp[count[k] - <span class="hljs-number">1</span>] = data[j];<br>            count[k]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//将临时数组的内容复制到data中</span><br>            data[j] = tmp[j];<br>        radix = radix * <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>    <span class="hljs-keyword">delete</span> []count;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Question</title>
    <url>/2023/04/28/Question/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>six</title>
    <url>/2023/04/28/Six/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>背包问题<br><span class="hljs-number">2.</span>线性dp<br><span class="hljs-number">3.</span>各种dp<br></code></pre></td></tr></table></figure>

<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202209832.png" alt="image-20230319202209832"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319214127252.png" alt="image-20230319214127252"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">//动态规划重点的是状态转移方程</span><br><span class="hljs-comment">//01背包，代表着物品只有两种可能性 - 放和不放</span><br> f[i][j] 中的前i件物品放入容量为j的背包中。我们很容易可以看出，第一个维度我们存储的是物品的不同种类，第二个维度存储的是我们的背包容量。<br> 更新容量我们就使用：<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j-w[i]]+c[i],f[i<span class="hljs-number">-1</span>][j])<br><span class="hljs-comment">//两种情况，我们分别判断一下</span><br>     第一种：我们放入我们的i物品，那么f[i][j] = f[i<span class="hljs-number">-1</span>][j-w[i]]+c[i],就是这样子，我们从两个维度解释一下： 第一个维度f[i<span class="hljs-number">-1</span>]:很简单就是我们已经选择了i物品了，那么从全部物品中，就少了我们的i，因此就是i<span class="hljs-number">-1.</span> 第二个维度就是f[j-w[i]],就是我们既然选择了i，那么就把我们的背包中直接塞入我们的物品，这个物品就会占据位置嗯。<br>     第二种：不放我们的i物品，就是f[i][j] = f[i<span class="hljs-number">-1</span>][j],不放物品我们的j这容量肯定就不会变化，同时，我们不放这个物品的话，就只能从别的物品选择，那就是只剩下i<span class="hljs-number">-1</span>种物品了。<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202536339.png" alt="image-20230319202536339"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版思想研究</span><br><span class="hljs-comment">//用二维数组来理解</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i]) <span class="hljs-comment">//先决条件：这个位置放不了i这个物品了</span><br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>   <span class="hljs-keyword">else</span><br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-w[i]]+c[i]); <br> cout&lt;&lt;f[n][m];<br><span class="hljs-comment">//用滚动数组来理解</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>           <span class="hljs-keyword">if</span>(j&lt;w[i])<br>               f[j] = f[j]; <span class="hljs-comment">//容量没变化 - 就是没放入我们的i</span><br>     <span class="hljs-keyword">else</span><br>               f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]); <span class="hljs-comment">//c[i]存储的是我们装入这个物品带来的价值收入</span><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202555236.png" alt="image-20230319202555236"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用j逆序排序</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=<span class="hljs-number">1</span>;j--)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i])<br>                f[j] = f[j];<br>   <span class="hljs-keyword">else</span> f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202608455.png" alt="image-20230319202608455"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>;<br><br><span class="hljs-type">int</span> N, V; <span class="hljs-comment">// N表示物品个数，V表示背包容量</span><br><span class="hljs-type">int</span> w[MAXN], v[MAXN]; <span class="hljs-comment">// w[i]表示第i个物品的重量，v[i]表示第i个物品的价值</span><br><span class="hljs-type">int</span> dp[MAXN]; <span class="hljs-comment">// dp[i]表示容量为i的背包所能装下的最大价值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        cin &gt;&gt; w[i] &gt;&gt; v[i];<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 初始化dp数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= w[i]; j--) &#123; <span class="hljs-comment">// 从后往前遍历，避免重复选择物品</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]); <span class="hljs-comment">// 状态转移方程</span><br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; dp[V] &lt;&lt; endl; <span class="hljs-comment">// 输出结果</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320144822881.png" alt="image-20230320144822881"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320144830870.png" alt="image-20230320144830870"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320144922085.png" alt="image-20230320144922085"></p>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175854308.png" alt="image-20230320175854308"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175908237.png" alt="image-20230320175908237"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//完全背包问题  - 就是01背包的变形，物品可以无限次放入</span><br> f[i][j]依然和<span class="hljs-number">01</span>背包问题相同的，i表示的是我们物品的种类，j表示的是我们背包的容量。<br>    放入物品的时候，我们需要选择放入这个物品我们的价值是否会增加<br><span class="hljs-comment">//过程</span><br>     <span class="hljs-number">1.</span>背包容量放不下我们当前这个物品 条件就是j&lt;w[i] 所以说我们的容量还是不变<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j]; <span class="hljs-comment">//这也就解释了我们可以使用一维数组来维护我们的背包 - 这里的i-1表示的是前一个物品，就是我们不会改变当前的背包状态</span><br> <span class="hljs-number">2.</span>背包可以放入我们当前这个物品 条件也就是j&gt;=w[i]<br>        我们有两种选择 - 放入和不放入  <br>        <span class="hljs-comment">//放入的话就是</span><br>        f[i][j] = f[i][j-w[i]]+c[i] <span class="hljs-comment">//c[i]是我们的价值(这里的i的意思就是我们物品是无穷的，每一个i表示的意思就是取出当前i这个物品的其中一个)</span><br>        <span class="hljs-comment">//不放入就是</span><br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] <span class="hljs-comment">//j就不会变化</span><br>     <span class="hljs-number">3.</span>我们最终的转移方程就是 上面两个合并的结果<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] (j&lt;w[i])<br>        f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-w[i]]+c[i])<br>        <span class="hljs-comment">//重点就是理解，变量其实是我们选不选择这个物品！！！！ </span><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175946146.png" alt="image-20230320175946146"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175955400.png" alt="image-20230320175955400"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180004395.png" alt="image-20230320180004395"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180015757.png" alt="image-20230320180015757"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180027068.png" alt="image-20230320180027068"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遍历是怎么遍历的</span><br><span class="hljs-number">1.</span>我们每次遍历的是当前背包塞满了物品i最终的结果<br> 看上面的图都是这样子的。 <br><span class="hljs-comment">//代码</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i])<br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j]<span class="hljs-comment">//原状</span><br>            <span class="hljs-keyword">else</span><br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-w[i]]+c[i]);<span class="hljs-comment">//新状态</span><br>    &#125;<br> cout&lt;&lt;f[n][m];<br><span class="hljs-number">2.</span>为什么一维数组适合<br>    <span class="hljs-comment">//使用动态规划算法解决完全背包问题时，可以采用一维数组进行实现。这是因为完全背包问题具有“无后效性”和“最优子结构”这两个特点。</span><br>    <span class="hljs-comment">//无后效性指的是，当我们决定选择一个物品放入背包时，我们不需要再考虑该物品是否被选择过或未来是否还会选择该物品。也就是说，每个阶段的最优状态可以通过之前阶段的某个状态推导得到，而不受后续状态的影响。</span><br>    <span class="hljs-comment">//最优子结构指的是，每个阶段的最优状态可以由前一个阶段的最优状态推导得到，并且每个阶段的最优状态之间没有相互制约的关系，即它们是相互独立的。</span><br><br><span class="hljs-number">3.</span>一维数组实现 <span class="hljs-comment">// 不太理解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i]) f[j] = f[j];<br>     <span class="hljs-keyword">else</span> f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180039797.png" alt="image-20230320180039797"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180103129.png" alt="image-20230320180103129"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 完全背包问题的动态规划解法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> W, vector&lt;<span class="hljs-type">int</span>&gt;&amp; wt, vector&lt;<span class="hljs-type">int</span>&gt;&amp; val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = wt.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = wt[i<span class="hljs-number">-1</span>]; j &lt;= W; j++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - wt[i<span class="hljs-number">-1</span>]] + val[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[W];<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; wt = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; val = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> W = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;最大价值为：&quot;</span> &lt;&lt; <span class="hljs-built_in">knapsack</span>(W, wt, val) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320182532855.png" alt="image-20230320182532855"></p>
<h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145257361.png" alt="image-20230320145257361"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145415756.png" alt="image-20230320145415756"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在01背包的基础上，让每一件物品都有他们的数量</span><br> <span class="hljs-number">1.</span><span class="hljs-comment">//v[i],w[i] 体积和价值</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//物品种类</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j&gt;=v[i];j--) <span class="hljs-comment">//背包容量</span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    <span class="hljs-number">2.</span><span class="hljs-comment">//v[i],w[i],s[i]; 体积 价值 数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=v[i];j--)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++) <br>                    <span class="hljs-comment">//这里的k表示的是选择物品的数量 - s[i]表示的是当前位置的i物品的数量</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> v[N],w[N],s[N]; <span class="hljs-comment">//体积 价值 数量</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">//这个是我们的状态转移数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; <span class="hljs-comment">//这里就是输入对应的价值，由i下标规定数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i]*k]+w[i]*k); <span class="hljs-comment">//这里i-1是把这个i物品选择了（选够了就剔除） - 只要找到一个符合的k就行（我们不管怎么实现的就行）</span><br>    cout&lt;&lt;f[n][m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145513754.png" alt="image-20230320145513754"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145617888.png" alt="image-20230320145617888"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二进制的转化就是 - 我们不再是一个一个数了，我们现在是两个两个数的</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<span class="hljs-comment">//拆分计数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-comment">//v,w,s; 体积，价值，数量</span><br>    cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=s;j&lt;&lt;=<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//&lt;&lt;=是左移位赋值运算符，它将左操作数向左移动右操作数指定的位数，并将结果赋值给左操作数</span><br>        vv[num] = j*v; <span class="hljs-comment">//存体积</span><br>        ww[num++] = j*w; <span class="hljs-comment">//存价值</span><br>        s-=j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s)&#123;<br>        vv[num] = s*v;<br>        ww[num++] = s*w;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//01背包问题 - 基础</span><br> <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;num;i++)<br>        <span class="hljs-keyword">for</span>(j = m;j&gt;=vv[i];j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-vv[i]]+ww[i]);<br>cout&lt;&lt;f[m];<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>; <span class="hljs-comment">// 物品的最大数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXV = <span class="hljs-number">100005</span>; <span class="hljs-comment">// 背包的最大容量</span><br><span class="hljs-type">int</span> n, V; <span class="hljs-comment">// 物品的数量和背包的容量</span><br><span class="hljs-type">int</span> w[MAXN], v[MAXN], s[MAXN]; <span class="hljs-comment">// 分别表示物品的重量、价值和数量</span><br><span class="hljs-type">int</span> dp[MAXV]; <span class="hljs-comment">// dp[i]表示容量为i的情况下，可以获得的最大价值</span><br><br><span class="hljs-comment">// 二进制优化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binary_optimization</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= x; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[y] &amp;&amp; k * x &lt;= j; k++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - k * x] + k * y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">binary_optimization</span>(w[i] * j, v[i] * j); <span class="hljs-comment">// 调用二进制优化函数</span><br>            s[i] -= j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">binary_optimization</span>(w[i] * s[i], v[i] * s[i]);<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; dp[V] &lt;&lt; endl; <span class="hljs-comment">// 输出答案</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二进制优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12010</span>, M = <span class="hljs-number">2010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt ++ ;<br>            <span class="hljs-comment">//这里是二进制优化的核心 - 就是将s拆成2进制</span><br>            <span class="hljs-comment">//核心是将物品拆分为2的幂次方个物品</span><br>            <span class="hljs-comment">//每次都拿s拆开二进制的数量</span><br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br><br>    n = cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321174757054.png" alt="image-20230321174757054"></p>
<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181451351.png" alt="image-20230321181451351"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181510913.png" alt="image-20230321181510913"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//物品 - 组？ 我还是不理解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=V;j++)<span class="hljs-comment">//体积</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i];k++) &#123; <span class="hljs-comment">//决策</span><br>            <span class="hljs-keyword">if</span>(j&gt;=v[i][k])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i][k]]+w[i][k]);<br>                <span class="hljs-comment">//不选取i  选取i</span><br>        &#125;<br>cout&lt;&lt;f[n][V];<br><span class="hljs-comment">//为什么w[i][j] - 这里 i是组号 j是组内编号（组这个概念是啥）</span><br><span class="hljs-comment">//V这个是背包体积吗 - 啥意思</span><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181526186.png" alt="image-20230321181526186"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181540822.png" alt="image-20230321181540822"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//分组朴素做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=V;j++)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i];k++)<br>  &#123;<br>   <span class="hljs-keyword">if</span>(j&gt;=v[i][k])<br>    f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i][k]]+w[i][k]);<br>  &#125;<br>cout&lt;&lt;f[n][V];<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181555557.png" alt="image-20230321181555557"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12010</span>, M = <span class="hljs-number">2010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">//1.这段程序是将一个数量为n的物品分成若干组，每组物品有一个共同的体积上限，要求选出的物品不能超过各自的体积上限，且所有选出的物品的总体积不能超过背包容量。每组物品中的物品可以有不同的体积和价值。在这段程序中，将每个物品的数量s分成二进制，然后将每个物品拆分成若干个体积和价值相同的物品，这样就构造了一个二进制数组。最后将物品的数量n更新为拆分后的物品数量cnt。</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里是将s数量分二进制</span><br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里就构造二进制数组</span><br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br><br>    n = cnt;<br><br>    <span class="hljs-comment">//2.这里就是选择最大</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145732542.png" alt="image-20230320145732542"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145752872.png" alt="image-20230320145752872"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145806496.png" alt="image-20230320145806496"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//三个背包综合考虑</span><br></code></pre></td></tr></table></figure>

<h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><h3 id="大盗阿福"><a href="#大盗阿福" class="headerlink" title="大盗阿福"></a>大盗阿福</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151317664.png" alt="image-20230320151317664"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151339739.png" alt="image-20230320151339739"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性dp</span><br> 在这个题目中，f数组存储的是我们偷取的物品价值是吧，然后我们要选择偷取价值最大化，每一个下标都代表着一个店铺是这个样子？<br><span class="hljs-comment">//写</span><br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br> <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">1</span>] = w[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">//用下标代表选择 - 是这个样子的</span><br>        <span class="hljs-comment">//用数组存储价值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            f[i] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-2</span>]+w[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n]);<br>    &#125;<br> <br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151353844.png" alt="image-20230320151353844"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用二维数组构造</span><br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br> <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<br>        <span class="hljs-comment">//用第二维的数据表示选择 0不选 1选择</span><br>        f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = w[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//不选择i</span><br>            f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//选择了i这个物品</span><br>            f[i][<span class="hljs-number">1</span>] = f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+w[i];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">max</span>(f[n][<span class="hljs-number">0</span>],f[n][<span class="hljs-number">1</span>]));<br>        <br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151402877.png" alt="image-20230320151402877"></p>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//数字三角形</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> g[N][N],f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;j++)<br>        cin&gt;&gt;g[i][j];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=i+<span class="hljs-number">1</span>;j++)<br>        f[i][j] = -INF;<span class="hljs-comment">//j从0开始是为了确定子树的选择</span><br>    <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;j++)<br>        f[i][j] = g[i][j] + <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]);<br>    <br>    <span class="hljs-type">int</span> res = -INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) res = <span class="hljs-built_in">max</span>(res,f[n][i]);<span class="hljs-comment">//第n行 选择i的结果</span><br>    cout&lt;&lt;res&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="最长上升子序列-or-二分优化"><a href="#最长上升子序列-or-二分优化" class="headerlink" title="最长上升子序列 or 二分优化"></a>最长上升子序列 or 二分优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最长上升子序列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 只有a[i]一个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>        <span class="hljs-comment">//前小于后 严格单调</span><br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[i])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<span class="hljs-comment">//连续走 or 跳着走</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二分优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &lt; a[i]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//二分找目标值 更新len</span><br>        len = <span class="hljs-built_in">max</span>(len, l + <span class="hljs-number">1</span>);<br>        q[r + <span class="hljs-number">1</span>] = a[i];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, len);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求公共子序列"><a href="#求公共子序列" class="headerlink" title="求公共子序列"></a>求公共子序列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> f[N][N];<span class="hljs-comment">//一维指的是a前n个数据 - 二位指的是b前n个数据？</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            <span class="hljs-comment">//f[i-1][j] 表示删除a的第i个字符后与b的前j个字符的最长公共子序列长度；</span><br>     <span class="hljs-comment">//f[i][j-1] 表示删除b的第j个字符后与a的前i个字符的最长公共子序列长度；</span><br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//符合就选择两者变化的最大值</span><br>        &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326134216185.png" alt="image-20230326134216185"></p>
<h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326135739598.png" alt="image-20230326135739598"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//初始化竖和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++ ) f[<span class="hljs-number">0</span>][i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++ ) f[i][<span class="hljs-number">0</span>] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151438854.png" alt="image-20230320151438854"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151457211.png" alt="image-20230320151457211"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151516636.png" alt="image-20230320151516636"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">/<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151549135.png" alt="image-20230320151549135"></p>
<h2 id="数位统计dp"><a href="#数位统计dp" class="headerlink" title="数位统计dp"></a>数位统计dp</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153227900.png" alt="image-20230320153227900"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153241076.png" alt="image-20230320153241076"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153256785.png" alt="image-20230320153256785"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153310081.png" alt="image-20230320153310081"></p>
<h2 id="状态dp"><a href="#状态dp" class="headerlink" title="状态dp"></a>状态dp</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//状态压缩</span><br> 通过将每一种状态映射成一个整数 - 二进制数据。这样每一个数据都是一种状态，然后我们对状态处理出我们想要的结果即可<br><span class="hljs-comment">//具体</span><br>     一般一个<span class="hljs-type">int</span>整形是<span class="hljs-number">4</span>个字节，也就是<span class="hljs-number">32</span>位bit，我们通过这<span class="hljs-number">32</span>位bit上<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的组合可以表示多大<span class="hljs-number">21</span>亿个不同的数。如果我们把这<span class="hljs-number">32</span>位bit看成是一个集合，那么每一个数都应该对应集合的一种状态，并且每个数的状态都是不同的。(组合个数大)<br><span class="hljs-comment">//细节</span><br>     整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——我们可以用整数的加减表示状态之间的转移。   <br>     总结一下，我们用二进制的<span class="hljs-number">0</span>和<span class="hljs-number">1</span>表示一个二元集合的状态。可以简单认为某个物品存在或者不存在的状态。由于二进制的<span class="hljs-number">0</span>和<span class="hljs-number">1</span>可以转化成一个<span class="hljs-type">int</span>整数，也就是说我们用整数代表了一个集合的状态。这样一来，我们可以用整数的加减计算来代表集合状态的变化。   <br></code></pre></td></tr></table></figure>

<h3 id="蒙德里安的幻想"><a href="#蒙德里安的幻想" class="headerlink" title="蒙德里安的幻想"></a>蒙德里安的幻想</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164339347.png" alt="image-20230327164339347"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164353684.png" alt="image-20230327164353684"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164407998.png" alt="image-20230327164407998"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用二进制表示不同的状态</span><br>  <span class="hljs-comment">//预处理：判断合并列的状态i是否合法（这里的i应该用二进制表示是吧）</span><br>  <span class="hljs-comment">//如果合并列的某行是1表示横放，是0表示竖放(用二进制表示块摆放状态)</span><br>  <span class="hljs-comment">//如果合并列不存在连续的奇数个0，就是合法状态</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录合并列的连续0个数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=n;j++)<br>                <span class="hljs-keyword">if</span>(i&gt;&gt;j &amp; <span class="hljs-number">1</span>)<span class="hljs-comment">//判断二进制i中1的个数</span><br>                 <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果连续的0的个数是奇数</span><br>                    &#123;<br>                        st[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//记录i不合法</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<span class="hljs-keyword">else</span> cnt++; <span class="hljs-comment">//记录0的个数</span><br>            <br>            <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) st[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//处理高位0的个数            </span><br>        &#125;<br></code></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164424745.png" alt="image-20230327164424745"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164500795.png" alt="image-20230327164500795"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164516348.png" alt="image-20230327164516348"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版</span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N][M];<br><span class="hljs-type">bool</span> st[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) st[i] = <span class="hljs-literal">false</span>;<br>                    cnt = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> cnt ++ ;<br>            <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++ )<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">1</span> &lt;&lt; n; k ++ )<br>                    <span class="hljs-keyword">if</span> ((j &amp; k) == <span class="hljs-number">0</span> &amp;&amp; st[j | k])<br>                        f[i][j] += f[i - <span class="hljs-number">1</span>][k];<br><br>        cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="树型dp"><a href="#树型dp" class="headerlink" title="树型dp"></a>树型dp</h2><h3 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153539710.png" alt="image-20230320153539710"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153602922.png" alt="image-20230320153602922"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153621674.png" alt="image-20230320153621674"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153639330.png" alt="image-20230320153639330"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153645886.png" alt="image-20230320153645886"></p>
<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="树塔"><a href="#树塔" class="headerlink" title="树塔"></a>树塔</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153726163.png" alt="image-20230320153726163"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153741418.png" alt="image-20230320153741418"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153805063.png" alt="image-20230320153805063"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Three 基本数据结构</title>
    <url>/2023/04/27/Three/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第三章-数据结构"><a href="#第三章-数据结构" class="headerlink" title="第三章 - 数据结构"></a>第三章 - 数据结构</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230420172340030.png" alt="image-20230420172340030"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>基本数据结构<br>    链表 - 栈和堆 - 队列 - 哈希表的使用 - 并查集 - 字典树 - kmp - <br><span class="hljs-number">2.</span>离散数学基本知识<br><span class="hljs-number">3.</span>线段树<br></code></pre></td></tr></table></figure>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote>
<p><a href="https://blog.51cto.com/u_15018701/2616916">链表看这一篇就够了</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//个人学习的时候并不是很了解，就是，将一些没有联系的数据串起来。这样可以用当前的数据访问到下一个数据或者上一个数据。可以理解成为，数存储在一个数组中，然后我们再声明一个数组，存储着这些数据的位置。</span><br>就像火车一样，每一节车厢中装载的货物，和每一节车厢的编号两者互相独立，但是又互相联系；关系就仅仅是位置上的对应关系而已。<br>       <br>   <span class="hljs-comment">//链表是一种递归的数据结构，他或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</span><br>链表是一种常见且基础的数据结构，是一种线性表，但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址。我们也可以这样理解，链表是通过指针串联在一起的线性结构，每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向null。也就是我们所说的空指针。<br></code></pre></td></tr></table></figure>

<h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/2023/04/27/Three/format.webp" alt="单链表图解"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.单链表</span><br> 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。我们通过上面说到的可视化表示方法，将单链表可视化，如上图所示。<br><span class="hljs-comment">//2.实现</span><br> 知道了单链表的特性，我们使用数组来实现一下这个单链表，下面是代码。       <br><span class="hljs-comment">//实现细究</span><br>首先，我们要实现一个链表，应该有几个准备工作;<br><span class="hljs-number">1.</span>声明一个数组 用于存入我们的数据<br><span class="hljs-number">2.</span>声明位置数组，用来存储我们的数据下标（对应的车厢）<br><span class="hljs-number">3.</span>声明一个变量，用于插入操作 一般用我们的idx<br><span class="hljs-number">4.</span>声明开头的数据下标 head 和 尾坐标 nell<br><br><span class="hljs-comment">//链表使用的时候要初始化 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   head = <span class="hljs-number">-1</span>;<br>   idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//声明我们所需要的数据类型</span><br><span class="hljs-type">int</span> e[N],  ne[N],   idx ,   head;<br> 存储值  存储下标 操作变量  头指针<br> <span class="hljs-comment">//e[N] 和 ne[N] 这两个看着是错开的 实际上是因为我们的头指针占了一个位置（叫做指针 是因为它很像一个标尺一样）</span><br><br>实现的一些功能<br><span class="hljs-comment">//将x插入头指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ne[idx] = head;<br>    e[idx] = x;<br>    head = idx++;<br>    idx++;  <span class="hljs-comment">//指针移动位置 </span><br>  &#125;<br><span class="hljs-comment">//插入k位置 把x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//把head 换成 ne[k] 就好了</span><br>   ne[idx] = ne[k];<br>   e[idx] = x;<br>   ne[k] = idx++;<br>   idx++;  <br>&#125;<br><span class="hljs-comment">//将下标k后面的点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123; <br>  <span class="hljs-comment">//ne[k]表示的是k数据的下一个数据的位置</span><br>  <span class="hljs-comment">//那么 ne[ne[k]] 就是跳过了下一个数据 到第三个数据上了</span><br>  <span class="hljs-comment">//也就是当前数据的下一个位置 变成了第三个数据的位置了</span><br>  ne[k] = ne[ne[k]]; <span class="hljs-comment">//这里用递归来理解</span><br>  <span class="hljs-comment">//理解ne是下一个位置就行 实际上是用idx来构建序列的</span><br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://c.biancheng.net/view/1570.html">C++链表及其创建</a></p>
</blockquote>
<p><img src="/2023/04/27/Three/2-1Q20316324S20.gif" alt="结构"></p>
<p><img src="/2023/04/27/Three/2-1Q203163321H2.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链表的结构</span><br> 链表中的每个结点都包含一个或多个保存数据的成员。例如，存储在结点中的数据可以是库存记录；或者它可以是由客户的姓名、地址和电话号码等组成的客户信息记录。<br> 非空链表的第一个结点称为链表的头。要访问链表中的结点，需要有一个指向链表头的指针。从链表头开始，可以按照存储在每个结点中的后继指针访问链表中的其余结点。最后一个结点中的后继指针被设置为 <span class="hljs-literal">nullptr</span> 以指示链表的结束。<br><span class="hljs-comment">//个人理解</span><br>     链表就是用线串起来的数据块，每一个节点的两个值都有其特定的作用：next指针负责穿起来节点，数据块负责存储数据。数据的起点就是链表头head，数据的终点指向null。<br><br><span class="hljs-comment">//c++表示</span><br>     虽然说我们可以用数组实现我们的链表，但是这样实现的链表不够简洁，我们可以使用结构体来实现（本质上是一样的）<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>        &#123;<br>            <span class="hljs-type">double</span> value;<span class="hljs-comment">//数据</span><br>            ListNode *next;<span class="hljs-comment">//下一个数据的位置</span><br>        &#125;;<br> 在以上代码中，ListNode 就是要存储在链表中的结点的类型，结构成员 value 是结点的数据部分，而另一个结构成员 next 则被声明为 ListNode 的指针，它是指向下一个结点的后继指针。<br> 在已经声明了一个数据类型来表示结点之后，即可定义一个初始为空的链表，方法是定义一个用作链表头的指针并将其初始化为 <span class="hljs-literal">nullptr</span>，示例如下<br>        ListNode *head = <span class="hljs-literal">nullptr</span>;   <br></code></pre></td></tr></table></figure>

<h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><blockquote>
<p><a href="https://blog.csdn.net/slandarer/article/details/91863177">https://blog.csdn.net/slandarer/article/details/91863177</a></p>
<p><a href="http://c.biancheng.net/view/1570.html">http://c.biancheng.net/view/1570.html</a></p>
</blockquote>
<p><img src="/2023/04/27/Three/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//2.双向链表</span><br> 比起单链表，多了一个指向前的指针，双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接，所以双链表既能向前查询也可以向后查询。<br> 还有一个常用的链表则为循环单链表，则单链表尾部的指针指向头节点。<br><span class="hljs-comment">//用数组构造双链表</span><br> 比起单链表中，多了一个指向前面的指针<br><span class="hljs-comment">//那就多声明一个前继路线</span><br><span class="hljs-type">int</span> l[N],r[N],idx,e[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  l[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>  idx = <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-comment">//往k的右边 插入数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  e[idx] = x;<br>  r[idx] = r[k];<br>  l[idx] = l[k];<br>  l[r[k]] = idx;<br>  r[k] = idx;<br>  <br>&#125;<br><span class="hljs-comment">//往k的左边插入数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  e[idx] = k;<br>  l[idx] = l[k];<br>  r[idx] = r[k];<br><span class="hljs-comment">//理解 l[k] 是k左边的位置 那么r[l[k]] 就是 k这个位置</span><br>  r[l[k]] = idx;<br>  l[k] = idx;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//上述使用多个数组来构造我们的链表，但实际使用的时候我们并不会这样子做（有时候会），我们可以学习一种新的构造方法（其实是一样的），利用结构体和指针关系来构造我们的链表</span><br><br><span class="hljs-comment">//用这样的思路来构造：就是说你现在有一个小纸条，上面写着一个抽屉的地址，那个抽屉里有一些你需要的东西，和一个新的写着地址的小纸条，这个小纸条又指向了一个新的抽屉，大体可以这么理解</span><br><br><span class="hljs-comment">//第一部分—构建抽屉 </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listpoint</span> <span class="hljs-comment">//这里是抽屉的结构体</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<span class="hljs-comment">//我们存储的数据</span><br>    listpoint *next;<span class="hljs-comment">//指向下一个抽屉的指针</span><br>&#125;listpoint;<br><br><span class="hljs-comment">//我们在抽屉里不仅仅可以放一个数，我们可以往里面放一个收纳盒，例如，在下面的结构体中包含了另一个结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">int</span> number;<br>    string name;<br>    string sex;<br>&#125;data;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listpoint</span><br>&#123;<br>    data *information;<span class="hljs-comment">//收纳盒</span><br>    listpoint *next;<span class="hljs-comment">//下一个箱子（的地址）</span><br>    listpoint *last;<span class="hljs-comment">//上一个箱子（的地址）</span><br>&#125;listpoint;<br><br><span class="hljs-comment">//第二部分—创建一个链表</span><br><span class="hljs-comment">/*链表每一个节点都是指向  listpoint结构的指针，所以返回值是listpoint *,n是指创建的链表的节点数目*/</span><br><span class="hljs-function">listpoint *<span class="hljs-title">create_normal_list</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>     </span><br><span class="hljs-function"></span>&#123;<br>    listpoint *head,*normal,*end;<span class="hljs-comment">/*创建头节点，其他节点，和尾节点*/</span><br>    head=(listpoint*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listpoint));<br>    head-&gt;information=(data*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(data));<br>    <span class="hljs-comment">/*分配内存*/</span><br>    end=head;<span class="hljs-comment">/*最开始最后一个节点就是头节点，注意因为通过指针可以直接对地址上的东西进行操作，此时end和head指向同一个地址，对end所指向地址进行操作，等同于对head地址所做的操作*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        normal=(listpoint*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listpoint));<br>        normal-&gt;information=(data*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(data));<br>        <span class="hljs-comment">/*给新节点分配内存*/</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;input the number :&quot;</span>;<br>        cin&gt;&gt;normal-&gt;information-&gt;number;<br>        cout&lt;&lt;<span class="hljs-string">&quot;input the name   :&quot;</span>;<br>        cin&gt;&gt;normal-&gt;information-&gt;name;<br>        cout&lt;&lt;<span class="hljs-string">&quot;input the sex    :&quot;</span>;<br>        cin&gt;&gt;normal-&gt;information-&gt;sex;<br>        cout&lt;&lt;<span class="hljs-string">&quot;----------------------------------&quot;</span>&lt;&lt;endl;<br>       <span class="hljs-comment">/* 往新节点存入数据，注意我们只给后面的节点存入数据，head不存数据*/</span><br>        end-&gt;next=normal;<span class="hljs-comment">/*往end后增添新节点*/</span><br>        normal-&gt;last=end;<span class="hljs-comment">/*新节点的上一个节点就是end*/</span><br>        end=normal;<span class="hljs-comment">/*最后一个节点变成新节点*/</span><br>    &#125;<br>    end-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*链表的最后指向一个新地址*/</span><br>    head-&gt;last=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*链表最开始的节点没有上一个节点*/</span><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><h5 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表*"></a>循环单链表*</h5><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/107808443">数据结构——从单链表到单向循环链表 - 知乎 (zhihu.com)</a></p>
</blockquote>
<p> 就是在单链表的基础之上，将最后本指向null的改为指向链表头。</p>
<p><img src="/2023/04/27/Three/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8.png" alt="循环单链表"></p>
<p> 循环链表主要用于操作系统中的任务维护。有许多例子，循环链表用于计算机科学，包括浏览器，记录用户过去访问过的页面记录也可以以循环链表的形式保存，并且可以在点击前一个按钮时再次访问。</p>
<p> 对单向链表中任一个节点的访问都需要从头结点开始；而对单向循环链表从任意节点出发都能遍历整个列表<strong>，</strong>极大的增强了其灵活性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++实现</span><br><span class="hljs-comment">//1.节点类，</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">int</span> data;<br> Node *pointer=<span class="hljs-literal">NULL</span>;<br>&#125;;<br><span class="hljs-comment">//2.链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">SingleLinkedList</span>();<br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>     Node *head;<br>&#125;;<br><span class="hljs-comment">//3.构造函数</span><br>SingleLinkedList::<span class="hljs-built_in">SingleLinkedList</span>() &#123;<br> head = <span class="hljs-keyword">new</span> Node;<br> head-&gt;data = <span class="hljs-number">0</span>;<br> head-&gt;pointer = head;<br>&#125;<br><span class="hljs-comment">//4.判断是否为空：isEmpty()</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SingleLinkedList::isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 头结点不指向任何结点，为空</span><br> <span class="hljs-keyword">if</span> (head-&gt;pointer == head) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br>&#125;<br><span class="hljs-comment">//5.头插法：add()</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleLinkedList::add</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br> <span class="hljs-comment">// 当原列表仅有头结点时，直接插入新节点即可</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>  head-&gt;pointer = <span class="hljs-keyword">new</span> Node;<br>  head-&gt;pointer-&gt;pointer = head;<br>  head-&gt;pointer-&gt;data = data;<br> &#125;<br> <span class="hljs-comment">// 列表非空时</span><br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 临时存储头结点的直接后继</span><br>  Node *temp = head-&gt;pointer;<br>  head-&gt;pointer = <span class="hljs-keyword">new</span> Node;<br>  head-&gt;pointer-&gt;data = data;<br>  head-&gt;pointer-&gt;pointer = temp;<br> &#125;<br>&#125;<br><span class="hljs-comment">//6.遍历：traversal()</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleLinkedList::traversal</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 链表为空，结束函数</span><br> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>()) &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  Node *current;<br>  <span class="hljs-comment">// 指向头结点的直接后继</span><br>  current = head-&gt;pointer;<br>  <span class="hljs-type">int</span> counter = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 遍历链表，输出每个节点的值</span><br>  <span class="hljs-keyword">while</span> (current != head)<br>  &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Element in %d is %d \n&quot;</span>, counter, current-&gt;data);<br>   counter++;<br>   current = current-&gt;pointer;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表*"></a>循环双链表*</h5><blockquote>
<p><a href="https://blog.csdn.net/sum_TW/article/details/61624039?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8=">循环双链表</a></p>
</blockquote>
<p> 和循环单链表一样，只是多了双链表的属性。</p>
<p><img src="/2023/04/27/Three/Center.png" alt="img"></p>
<p>双向循环链表初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//存储新的节点</span><br>    Node* p=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头节点的替身</span><br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    pn-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//next指向空</span><br>    pn-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre指向空</span><br>    sum=<span class="hljs-number">1</span>;<br>    *h=pn;<br>    p=*h;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//创建到最后一个节点时，最后一个节点next为头节点</span><br>            p-&gt;next=*h;<br>            (*h)-&gt;pre=p;<span class="hljs-comment">//头节点的pre为最后一个节点</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pn=<span class="hljs-built_in">creteNode</span>(d);<br>        p-&gt;next=pn;<br>        pn-&gt;pre=p;<br>        p=p-&gt;next;<br>        sum++;<span class="hljs-comment">//元素个数++</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>插入操作</p>
<p><img src="/2023/04/27/Three/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.png" alt="双向循环链表插入"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFont</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//修改头节点  传入二级指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    Node* p=*h;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pn-&gt;next=*h;<span class="hljs-comment">//新节点成为头节点</span><br>    p-&gt;next=pn;<span class="hljs-comment">//最后一个节点p的下一个节点为新节点pn</span><br>    pn-&gt;pre=p;<span class="hljs-comment">//新的头节点的pre为p</span><br> <br>    (*h)-&gt;pre=pn;<span class="hljs-comment">//原头节点的前一个节点为新节点</span><br> <br>    *h=pn;<span class="hljs-comment">//新节点为头节点</span><br> <br>    sum++;<br>&#125;<br> <br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//在n位置插入d</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((n&lt;<span class="hljs-number">1</span>)||(*h==<span class="hljs-literal">NULL</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置不合法||链表为空!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>     Node* pn=<span class="hljs-built_in">creteNode</span>(d);<span class="hljs-comment">//创建新的节点</span><br>    <span class="hljs-comment">//插入位置为1，即插入头节点的位置</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">addFont</span>(d,h);<span class="hljs-comment">//调用头插法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==sum)<br>    &#123;<br>        <span class="hljs-built_in">addBack</span>(d,*h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>       Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>); <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>       pn-&gt;next=pf-&gt;next;<span class="hljs-comment">//前一个节点的next等于新的节点的next</span><br>       pf-&gt;next-&gt;pre=pn;<span class="hljs-comment">//pf的next节点的pre应该为pn</span><br>       pf-&gt;next=pn;<span class="hljs-comment">//前一个节点的next等于新的节点</span><br>       pn-&gt;pre=pf;<span class="hljs-comment">//新节点的前一个节点为找到的前一个节点pf</span><br>       sum++;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>删除操作</p>
<p><img src="/2023/04/27/Three/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelectFont</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">//DelectFont(h);</span><br>    <span class="hljs-type">int</span> i, n1=sum;<br>    Node* p=*h;<br>    Node* pd=<span class="hljs-literal">NULL</span>;;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n1<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pd=*h;<br>    *h=pd-&gt;next;<span class="hljs-comment">//头节点的下一个节点成头节点</span><br>    <br>    p-&gt;next=*h;<span class="hljs-comment">//最后一个节点的next为头节点</span><br>    <br>    (*h)-&gt;pre=p;<span class="hljs-comment">//pd节点成为了头节点，它的前驱为p</span><br>    sum--;<span class="hljs-comment">//元素个数-1</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-comment">//删除第n个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int i;//循环变量</span><br>    <span class="hljs-comment">//判断头节点是否为空，位置是不是合法</span><br>    <span class="hljs-keyword">if</span>((*h==<span class="hljs-literal">NULL</span>)||(n&lt;<span class="hljs-number">1</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的链表为空||删除的位置不合法！so 插入失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    Node* pd=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//删除头节点</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">DelectFont</span>(h);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//删除</span><br>    <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>    Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>);<br>    pd=pf-&gt;next;<span class="hljs-comment">//将要删除的节点的给pd</span><br>    pf-&gt;next=pd-&gt;next;<span class="hljs-comment">//将删除元素的前一个的next指向删除元素的后一个元素</span><br>    pd-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pd的pre指向空</span><br>   <br>    pd-&gt;next-&gt;pre=pf;<span class="hljs-comment">//将删除元素的后一个元素的前驱给pf</span><br>    pd-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pdnext指向空</span><br>    sum--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>总</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* pre;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> Node;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE sizeof(Node)</span><br><span class="hljs-type">int</span> sum;<span class="hljs-comment">//节点个数</span><br> <br><span class="hljs-function">Node* <span class="hljs-title">creteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span>;<span class="hljs-comment">//创建节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">(Node** h)</span>；<span class="hljs-comment">//创建链表</span></span><br><span class="hljs-function">Node* <span class="hljs-title">findNode</span><span class="hljs-params">(Node* h,<span class="hljs-type">int</span> n)</span>；<span class="hljs-comment">//查找某个节点的位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addBack</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node* h)</span>；<span class="hljs-comment">//末尾增加一个新的节点</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFont</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node** h)</span>；<span class="hljs-comment">//修改头节点  传入二级指针</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> d,Node** h)</span>；<span class="hljs-comment">//在n位置插入d</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelectFont</span><span class="hljs-params">(Node** h)</span></span>;<span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,Node** h)</span></span>;<span class="hljs-comment">//删除第n个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Node* h)</span></span>;<span class="hljs-comment">//打印链表</span><br> <br><span class="hljs-comment">//创建节点</span><br><span class="hljs-function">Node* <span class="hljs-title">creteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* pn=(Node*)<span class="hljs-built_in">malloc</span>(SIZE);<br>    pn-&gt;data=d;<br>    pn-&gt;next=<span class="hljs-literal">NULL</span>;<br>    pn-&gt;pre=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> pn;<br>&#125;<br> <br><span class="hljs-comment">//创建链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//存储新的节点</span><br>    Node* p=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头节点的替身</span><br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    pn-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//next指向空</span><br>    pn-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre指向空</span><br>    sum=<span class="hljs-number">1</span>;<br>    *h=pn;<br>    p=*h;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//创建到最后一个节点时，最后一个节点next为头节点</span><br>            p-&gt;next=*h;<br>            (*h)-&gt;pre=p;<span class="hljs-comment">//头节点的pre为最后一个节点</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pn=<span class="hljs-built_in">creteNode</span>(d);<br>        p-&gt;next=pn;<br>        pn-&gt;pre=p;<br>        p=p-&gt;next;<br>        sum++;<span class="hljs-comment">//元素个数++</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//查找某个节点的位置</span><br><span class="hljs-function">Node* <span class="hljs-title">findNode</span><span class="hljs-params">(Node* h,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>((h==<span class="hljs-literal">NULL</span>)||(n&lt;<span class="hljs-number">0</span>)||(n&gt;sum))<br>    &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查找位置不合法||链表为空！\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    &#123;<br>        h=h-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125; <br> <br><span class="hljs-comment">//末尾增加一个新的节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addBack</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node* h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    Node *pn=<span class="hljs-literal">NULL</span>;<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    Node* p=h;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//此时的p指向了最后一个元素</span><br>    p-&gt;next=pn;<span class="hljs-comment">//最后一个节点p的next为新节点</span><br>    pn-&gt;pre=p;<span class="hljs-comment">//新节点的前一个节点为p</span><br>    pn-&gt;next=h;<span class="hljs-comment">//pn的最后一个节点为头节点</span><br>    h-&gt;pre=pn;<span class="hljs-comment">//头节点的pre为新节点</span><br>    sum++;<br>&#125;<br> <br><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFont</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//修改头节点  传入二级指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    Node* p=*h;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pn-&gt;next=*h;<span class="hljs-comment">//新节点成为头节点</span><br>    p-&gt;next=pn;<span class="hljs-comment">//最后一个节点p的下一个节点为新节点pn</span><br>    pn-&gt;pre=p;<span class="hljs-comment">//新的头节点的pre为p</span><br> <br>    (*h)-&gt;pre=pn;<span class="hljs-comment">//原头节点的前一个节点为新节点</span><br> <br>    *h=pn;<span class="hljs-comment">//新节点为头节点</span><br> <br>    sum++;<br>&#125;<br> <br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//在n位置插入d</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((n&lt;<span class="hljs-number">1</span>)||(*h==<span class="hljs-literal">NULL</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置不合法||链表为空!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>     Node* pn=<span class="hljs-built_in">creteNode</span>(d);<span class="hljs-comment">//创建新的节点</span><br>    <span class="hljs-comment">//插入位置为1，即插入头节点的位置</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">addFont</span>(d,h);<span class="hljs-comment">//调用头插法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==sum)<br>    &#123;<br>        <span class="hljs-built_in">addBack</span>(d,*h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>       Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>); <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>       pn-&gt;next=pf-&gt;next;<span class="hljs-comment">//前一个节点的next等于新的节点的next</span><br>       pf-&gt;next-&gt;pre=pn;<span class="hljs-comment">//pf的next节点的pre应该为pn</span><br>       pf-&gt;next=pn;<span class="hljs-comment">//前一个节点的next等于新的节点</span><br>       pn-&gt;pre=pf;<span class="hljs-comment">//新节点的前一个节点为找到的前一个节点pf</span><br>       sum++;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelectFont</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">//DelectFont(h);</span><br>    <span class="hljs-type">int</span> i, n1=sum;<br>    Node* p=*h;<br>    Node* pd=<span class="hljs-literal">NULL</span>;;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n1<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pd=*h;<br>    *h=pd-&gt;next;<span class="hljs-comment">//头节点的下一个节点成头节点</span><br>    <br>    p-&gt;next=*h;<span class="hljs-comment">//最后一个节点的next为头节点</span><br>    <br>    (*h)-&gt;pre=p;<span class="hljs-comment">//pd节点成为了头节点，它的前驱为p</span><br>    sum--;<span class="hljs-comment">//元素个数-1</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-comment">//删除第n个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int i;//循环变量</span><br>    <span class="hljs-comment">//判断头节点是否为空，位置是不是合法</span><br>    <span class="hljs-keyword">if</span>((*h==<span class="hljs-literal">NULL</span>)||(n&lt;<span class="hljs-number">1</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的链表为空||删除的位置不合法！so 插入失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    Node* pd=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//删除头节点</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">DelectFont</span>(h);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//删除</span><br>    <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>    Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>);<br>    pd=pf-&gt;next;<span class="hljs-comment">//将要删除的节点的给pd</span><br>    pf-&gt;next=pd-&gt;next;<span class="hljs-comment">//将删除元素的前一个的next指向删除元素的后一个元素</span><br>    pd-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pd的pre指向空</span><br>   <br>    pd-&gt;next-&gt;pre=pf;<span class="hljs-comment">//将删除元素的后一个元素的前驱给pf</span><br>    pd-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pdnext指向空</span><br>    sum--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-comment">//打印链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Node* h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;list:\n&quot;</span>);<br>    Node* p=h;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正序遍历：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//上面遍历到第一个节点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;反序遍历：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;pre-&gt;data);<br>        p=p-&gt;pre;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* head=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">creatList</span>(&amp;head);<br>    <span class="hljs-built_in">deleteNode</span>(<span class="hljs-number">2</span>,&amp;head);<br>    <span class="hljs-built_in">print</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="随机链表-（暂时不学）"><a href="#随机链表-（暂时不学）" class="headerlink" title="随机链表*（暂时不学）"></a>随机链表*（暂时不学）</h5><p><img src="/2023/04/27/Three/list.png" alt="list"></p>
<h4 id="链表实现的功能"><a href="#链表实现的功能" class="headerlink" title="链表实现的功能*"></a>链表实现的功能*</h4><blockquote>
<p><a href="https://www.jianshu.com/p/5f148c3e4f7d">数据结构中堆、栈和队列的理解</a></p>
</blockquote>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈的定义：</strong></p>
<p>栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</p>
<p>而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。</p>
<p>堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</p>
<p><img src="/2023/04/27/Three/%E6%A0%88.png" alt="栈"></p>
<p>用我们的数组实现的栈，最关键的点在于：我们是否可以直接不管我们插入栈的数据。 栈的原理就是 先进后出 这个我们知道，那么我们只要声明一个数组就可以实现这个功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用数组实现栈功能</span><br><span class="hljs-comment">//栈 和 操作栈的变量</span><br><span class="hljs-type">int</span> stk[N],tt;<span class="hljs-comment">//变量用来控制我们的栈的容量</span><br><br><span class="hljs-comment">//插入栈的数据</span><br>stk[++tt] = x;<br><span class="hljs-comment">//pop弹出 这样的数据会直接消失 记得保存stk[kk] 栈顶数据 </span><br>tt--; <br><span class="hljs-comment">//判断栈顶是否为空 (这里是伪代码)</span><br><span class="hljs-keyword">if</span>(tt&gt;<span class="hljs-number">0</span>) no empty;<br><span class="hljs-keyword">else</span> empty;<br><span class="hljs-comment">//栈顶</span><br>stk[kk]<br>  <br><span class="hljs-comment">//总结 </span><br>    栈的作用就是实现两个操作 <span class="hljs-number">1.</span>压栈 <span class="hljs-number">2.</span>弹栈 - 压栈的操作在用数组实现的时候，我们可以理解 竖向数组的增高（但实际上在现实中更像手枪压弹夹一样）弹栈 - 就是去顶（更像手枪把子弹打出去）<br> 通常，声明一个栈的时候，我们会用一个变量来维护我们这个栈。 这个变量起到实现上述两个操作的作用 - 例如： h[N]是我们的一个栈 top是我们维护栈的变量<br> 那么： push操作就是 h[++top] = <span class="hljs-built_in">a</span>(你塞入的子弹)；pop操作就是  top--;<br><span class="hljs-built_in">query</span>(栈头) h[top] <span class="hljs-comment">//重点是插入的时候是先 ++ 在赋值位置的 这样可以保证沉底</span><br><span class="hljs-comment">//stl中的栈</span><br> &lt;stack&gt; 是栈的头文件名称，用的时候声明一下就好了。<br></code></pre></td></tr></table></figure>

<p>栈的应用——递归</p>
<p>在高级语言中，调用自己和其它函数没有本质的不同。我们把一个直接用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。每个递归函数必须至少有一个条件，满足时递归不再执行，即不再引用自身而是返回值退出。</p>
<p>递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。 递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。</p>
<p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
<h4 id="用栈实现计算器"><a href="#用栈实现计算器" class="headerlink" title="用栈实现计算器"></a><strong>用栈实现计算器</strong></h4><p>中缀表达式实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//不支持括号</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span> || i == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>                <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">top</span>();<br>                nums.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n * num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n / num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(-num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>            num = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!nums.<span class="hljs-built_in">empty</span>()) &#123;<br>        res += nums.<span class="hljs-built_in">top</span>();<br>        nums.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;3+2*2&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">calculate</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//支持括号</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, cnt = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (cnt != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;(&#x27;</span>) cnt++;<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;)&#x27;</span>) cnt--;<br>                j++;<br>            &#125;<br>            num = <span class="hljs-built_in">calculate</span>(s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, j - i - <span class="hljs-number">2</span>));<br>            i = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span> || i == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>                <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">top</span>();<br>                nums.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n * num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n / num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(-num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>            num = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!nums.<span class="hljs-built_in">empty</span>()) &#123;<br>        res += nums.<span class="hljs-built_in">top</span>();<br>        nums.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;3+2*(2+1)&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">calculate</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>逆波兰式实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        string s = tokens[i];<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;+&quot;</span> || s == <span class="hljs-string">&quot;-&quot;</span> || s == <span class="hljs-string">&quot;*&quot;</span> || s == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>            <span class="hljs-type">int</span> num2 = nums.<span class="hljs-built_in">top</span>();<br>            nums.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> num1 = nums.<span class="hljs-built_in">top</span>();<br>            nums.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 + num2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 - num2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 * num2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 / num2);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(s));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;string&gt; tokens = &#123;<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">evalRPN</span>(tokens) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：<br> （1）堆中某个节点的值总是不大于或不小于其父节点的值；<br> （2）堆总是一棵完全二叉树。</p>
<p>堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。</p>
<p>堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
<p><img src="/2023/04/27/Three/%E4%BA%8C%E5%8F%89%E6%A0%91.webp" alt="优先队列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-comment">// 定义堆的最大容量 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>; <br><span class="hljs-comment">// 定义堆的数据结构 </span><br><span class="hljs-type">int</span> heap[MAX_SIZE]; <br><span class="hljs-type">int</span> heapSize; <br><span class="hljs-comment">// 向堆中插入一个元素 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 如果堆已满，则不能插入 </span><br>    <span class="hljs-keyword">if</span> (heapSize == MAX_SIZE) <br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-comment">// 将新元素插入到堆的末尾 </span><br>    heap[heapSize] = data; <br>    heapSize++; <br>    <span class="hljs-comment">// 将新元素上浮到正确的位置 </span><br>    <span class="hljs-type">int</span> current = heapSize - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-number">0</span> &amp;&amp; heap[current] &gt; heap[(current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) <br>    &#123; <br>        <span class="hljs-type">int</span> temp = heap[(current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]; <br>        heap[(current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = heap[current]; <br>        heap[current] = temp; <br>        current = (current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <br>    &#125; <br>&#125; <br><span class="hljs-comment">// 从堆中删除一个元素 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteElement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 如果堆为空，则不能删除 </span><br>    <span class="hljs-keyword">if</span> (heapSize == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-comment">// 将堆的最后一个元素放到堆顶 </span><br>    heap[<span class="hljs-number">0</span>] = heap[heapSize - <span class="hljs-number">1</span>]; <br>    heapSize--; <br>    <span class="hljs-comment">// 将堆顶元素下沉到正确的位置 </span><br>    <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span> (current * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; heapSize) <br>    &#123; <br>        <span class="hljs-type">int</span> largest = current; <br>        <span class="hljs-keyword">if</span> (heap[largest] &lt; heap[current * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) <br>            largest = current * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">if</span> (current * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &lt; heapSize &amp;&amp; heap[largest] &lt; heap[current * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]) <br>            largest = current * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <br>        <span class="hljs-keyword">if</span> (largest == current) <br>            <span class="hljs-keyword">break</span>; <br>        <span class="hljs-type">int</span> temp = heap[current]; <br>        heap[current] = heap[largest]; <br>        heap[largest] = temp; <br>        current = largest; <br>    &#125; <br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 初始化堆 </span><br>    heapSize = <span class="hljs-number">0</span>; <br>    <span class="hljs-comment">// 向堆中插入元素 </span><br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>); <br>    <span class="hljs-comment">// 从堆中删除元素 </span><br>    <span class="hljs-built_in">deleteElement</span>(); <br>    <span class="hljs-comment">// 输出堆中的元素 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heapSize; i++) <br>        cout &lt;&lt; heap[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>    cout &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><img src="/2023/04/27/Three/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png" alt="优先队列"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p>
<p>而且队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。</p>
<p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<p>队列和游标卡尺差不多，就是一个区间和线段组成的数据类型</p>
<p><img src="/2023/04/27/Three/%E9%98%9F%E5%88%97.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明变量 队列的性质就是先进先出</span><br><span class="hljs-type">int</span> q[N],hh,tt;<br><span class="hljs-comment">//插入数据</span><br>q[++tt];<span class="hljs-comment">//hh是头（头是向右边移动的） tt是转移元素的变量（tt是新入队的成员）</span><br><span class="hljs-comment">//可以将 hh 和 tt看做是一个区间</span><br>hh++<span class="hljs-comment">//pop</span><br><span class="hljs-comment">//判断队列是否为空</span><br>  <span class="hljs-keyword">if</span>(hh&lt;=tt) <span class="hljs-keyword">not</span> empty<br>  <span class="hljs-keyword">else</span> empty;<br><span class="hljs-comment">//取出队头元素</span><br>q[hh];<br></code></pre></td></tr></table></figure>

<h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>在中学的时候，我们会学一种函数的性质，叫做单调性。单调性是指，在一个区间内部我们可以预测这个数据类型的运行方向。那么显而易见的，单调队列指的是，我们可以预计和控制这个数据类型的运行方向。</p>
<p>队列的性质上面有提到，是一种先进先出的数据结构。我们可以利用这个结构，做一个可动的队列或者说，让数据集通过我们的队列，在通过的时候记录他们的数据变化。这样的操作，就叫做单调队列。</p>
<p>以一个较简单的例子：滑动窗口，大概题意就是，有一个数据条，需要通过我们的窗口（队列），通过的时候记录这个时候队列的最大值和最小值（或者别的什么东西 - 变化一下题目嘛）。</p>
<p><img src="/2023/04/27/Three/image-20230504225237230.png" alt="滑动窗口"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//维护窗口</span><br><span class="hljs-type">int</span> h = <span class="hljs-number">1</span>,t = <span class="hljs-number">0</span>; <span class="hljs-comment">//清空队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;;i&lt;=n;i++)&#123; <span class="hljs-comment">//枚举数据集</span><br>    <span class="hljs-keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&gt;=a[i]) t--;<span class="hljs-comment">//队尾出队</span><br>    q[++t] = i;<span class="hljs-comment">//队尾入队</span><br>    <span class="hljs-keyword">if</span>(q[h]&lt;i-k+<span class="hljs-number">1</span>) h++;<span class="hljs-comment">//对头出队（滑出窗口）</span><br>    <span class="hljs-keyword">if</span>(i&gt;=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[q[h]]);<span class="hljs-comment">//打印最值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/27/Three/image-20230504230354394.png" alt="维护窗口最小值"></p>
<h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种树形的数据结构，支持两种操作，并：将两个不同的元素合并成一个集合；查：查找一个数据的所在集合</p>
<p>在模拟树状结构的时候，fa[x]存储的是节点的父节点，可以理解为特定集合的编号。这里的x和赋值给f[x]的值的关系，可以理解为<strong>节点和父节点连接</strong>的关系。初始化的时候，将每一个节点编号都初始化为自己(自己为一个集合)。</p>
<p><img src="/2023/04/27/Three/image-20230503221426175.png" alt="并查集"></p>
<h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>可以理解为顺着当前节点向上爬，找到我们当前集合的根节点。但实际上，我们并不是这样做，我们可以将这个操作进行优化，我们在找根节点的过程，可以顺便将每一个经过的节点的<strong>“父节点”都改为我们的“根节点”</strong>，一个查找循环下来，整一个集合的值都是我们的，根节点（也就是我们当前集合编号），下面是代码解释。</p>
<p><img src="/2023/04/27/Three/image-20230503222836310.png" alt="路径压缩"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//未用路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果当前这个节点指向的是根节点，说明我们找到了目标集合，返回就行。</span><br> <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-comment">//如果不是，那就递归查找，直到找到我们的目标集合（一定找得到）。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]); <br>&#125;<br><br><span class="hljs-comment">//使用路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(f[a]); <span class="hljs-comment">//这里就是给路过的节点赋值 - 用的是递归</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a><strong>合并</strong></h4><p><img src="/2023/04/27/Three/image-20230503224008918.png" alt="合并"></p>
<p>合并操作，可以理解为两个集合的根节点指向即可。这里举个例子，A集合和B集合，那么B集合序号指向A集合序号即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//合并代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionset</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-comment">//将x的集合编号，赋值成y的集合编号</span><br>    <span class="hljs-comment">//如果再次路径压缩，那么所有x集合的编号都会变成y的编号</span><br>    fa[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y); <br>&#125;<br></code></pre></td></tr></table></figure>

<p>但是，这样合并可以进行优化，我们可以这样想，如果我们合并两个集合的数量级不在一个级别上，比如一个集合元素个数为2，一个集合元素个数为2e10，这样将集合元素为2的集合作为新集合的标号，确实不太合适。所以说，我们可以直接给每一个集合标记他们的元素数量，然后对其进行合并即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">siz</span><span class="hljs-params">(N,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unioset</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    x = <span class="hljs-built_in">find</span>(x),y = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">//找到各自的集合编号</span><br>    <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(siz[x]&gt;siz[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//判断哪个集合更大</span><br>    fa[x] = y;<span class="hljs-comment">//小集合指向大集合</span><br>    siz[y]+=siz[x]; <span class="hljs-comment">//合并一个大集合要加数量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/27/Three/image-20230503230130914.png" alt="并查集的变化"></p>
<h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p>
<p>Trie的核心思想是空间换时间。利用字符串的<strong>公共前缀</strong>来降低查询时间的开销以达到提高效率的目的。</p>
<p><img src="/2023/04/27/Three/image-20230504131211298.png" alt="字典树"></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>Trie树，就是利用字符串的相同前缀，来节省我们查找的时间。这个树的根没有意义，只是为了构造这个树存在。可以说，根衔接的都是一个独立的单词（子树）。</p>
<p><img src="/2023/04/27/Three/image-20230504132336132.png" alt="字典树"></p>
<p>我们可以想象一下，在一个根下面链接一个一个单词会是什么样子，是不是像一个拂尘一样。我们可以在这个基础之上，对这些单词进行处理：单词是由26个字母排列组合成的，所以说不管单词怎么变，肯定有些单词的前缀是相等的。例如：appear 和 apple。这两个前缀相同，那么我们就可以让”app”为同一支，从p分出两个枝e和p。（当然分支最多26个）以此类推构建字典树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//字典树构造</span><br><span class="hljs-type">char</span> s[N]<br>    <br><span class="hljs-type">int</span> ch[N][<span class="hljs-number">26</span>];<span class="hljs-comment">//儿子数组：存储从节点p沿着j这条路走到的子节点。26是26个字母的映射值（就是1代表a，2代表b以此类推）</span><br><br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//存储以节点p结尾的单词的插入次数</span><br><br><span class="hljs-type">int</span> idx;<span class="hljs-comment">//用来节点编号</span><br><br><span class="hljs-comment">//插入字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//遍历全部字符串的字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;s[i];i++)&#123;<br>        <span class="hljs-type">int</span> j = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//字母映射 - 变为0-25的编号</span><br>        <span class="hljs-keyword">if</span>(!ch[p][j]) ch[p][j]=++idx;<span class="hljs-comment">//不存在这个值（就是树中无这个子树）</span><br>        p = ch[p][j];<br>    &#125;<br>    cnt[p]++;<span class="hljs-comment">//插入次数 - 表示当前节点子树个数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>和插入的操作差不多，只要找到我们插入的时候做的标记就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;s[i];i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//映射</span><br>        <span class="hljs-keyword">if</span>(!ch[p][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;;<br>        p = ch[p][j]; <span class="hljs-comment">//查找符合，直到子串末尾。都符合则成立</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/27/Three/image-20230504140704449.png" alt="总结"></p>
<h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>在学习kmp算法之前，我们先弄清楚暴力求解字符串匹配问题。</p>
<p>给出一个主串S，判断字符串F是否是S的子串，如果是返回T在S中出现的第一个位置，否则返回0.</p>
<p>使用暴力算法解题，从主串S的第一个字符开始和模式串T的第一个字符进行比较，若相等则比较二者后续字符，否则，主串回溯到第二个字符，模式串回溯到第一个字符；继续比较，不匹配，主串回溯到第三个字符，模式串回溯到第一个字符。重新上述过程，直到模式串T中的字符全部比较完毕，说明匹配成功；否则匹配失败。<br>暴力算法将每一种情况都列举了出来，时间复杂度很高(大概是o(n^2))</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BF</span><span class="hljs-params">(<span class="hljs-type">char</span> *S,<span class="hljs-type">char</span> *T)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(S[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;T[j])&#123;<br>        <span class="hljs-keyword">if</span>(S[i]==T[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i=i-j+<span class="hljs-number">1</span>;<span class="hljs-comment">//主串回溯到上次回溯位置的下一个位置</span><br>            j=<span class="hljs-number">0</span>;<span class="hljs-comment">//模式串回溯到第一个位置</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(T[j]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>        <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>; <span class="hljs-comment">//返回T在S中第一次出现的位置</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">char</span> S[<span class="hljs-number">50</span>]=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> T[<span class="hljs-number">50</span>]=&#123;<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-built_in">BF</span>(S,T)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在使用暴力匹配的时候，我们不难发现，每一轮如果匹配失效，那么就会直接放弃这一轮匹配的所有信息；进入到下一轮就重新匹配了。</p>
<p>Kmp算法就是将这一部分信息利用起来，使得下一轮匹配的时候不用重新开始，而是在前面的基础之上回退我们匹配串和前移我们的主串。这样就保留了匹配的信息。</p>
<p><img src="/2023/04/27/Three/image-20230504163459568.png" alt="比较"></p>
<p>那我们怎么利用信息呢：我们需要找到匹配串的相等前后缀，将其记录起来：这里就用next数组存储信息</p>
<h4 id="next函数"><a href="#next函数" class="headerlink" title="next函数"></a>next函数</h4><p><img src="/2023/04/27/Three/image-20230504164818659.png" alt="相等前后缀"></p>
<p>那这个next数组有什么用，我们找到相等前后缀的目的是为了保留信息，如果在7这个位置匹配失败了，那么只要找到在6这个位置的前后缀相等的，跳回到最大相等前后缀就行。因为在7之前我们的字符串是完全匹配的，可以吧ne数组理解为匹配位置的长度。</p>
<p><img src="/2023/04/27/Three/image-20230504170809559.png" alt="next数组"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">ne[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>,j = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;P[i]!=P[j+<span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span>(P[i] == P[j+<span class="hljs-number">1</span>]) j++;<br>    ne[i] = j;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/27/Three/image-20230504171245977.png" alt="next构造"></p>
<h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>这里，使用了双指针思想。i指针维护主串，j指针维护匹配串，i指针只能向前移动，j指针可以来回调整。</p>
<p><img src="/2023/04/27/Three/image-20230504172311018.png" alt="匹配过程"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;S[i]!=P[j+<span class="hljs-number">1</span>]) j = ne[j];<span class="hljs-comment">//回调操作 - ne数组存储的是最大匹配串长度（1-j的），这里赋值相当于将j回调到最大匹配的位置</span><br>    <span class="hljs-keyword">if</span>(S[i] == P[j+<span class="hljs-number">1</span>]) j++;<br>    <span class="hljs-keyword">if</span>(j==n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-n+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/27/Three/image-20230504172557271.png" alt="kmp时间复杂度"></p>
<p>那么总的时间复杂度就是O(m+n)</p>
<p><img src="/2023/04/27/Three/image-20230504173358331.png" alt="总结"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Two 对数据的基本操作</title>
    <url>/2023/04/26/Two/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第二章-对数据的简单操作"><a href="#第二章-对数据的简单操作" class="headerlink" title="第二章 - 对数据的简单操作"></a>第二章 - 对数据的简单操作</h2><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>高精度<br><span class="hljs-number">2.</span>简单字符串匹配问题<br><span class="hljs-number">3.</span>数组运用<br></code></pre></td></tr></table></figure>

<h3 id="前缀和-and-差分"><a href="#前缀和-and-差分" class="headerlink" title="前缀和 and 差分"></a>前缀和 and 差分</h3><blockquote>
<p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">(112条消息) 前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_林小鹿@的博客-CSDN博客</a></p>
</blockquote>
<h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p><img src="/.png" alt="前缀和"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。</span><br> 前缀和可以解决区间和的问题，可以理解一个s数组，下标表示我们的数组a（构造前缀和的数组）元素个数的加和。<br><br><span class="hljs-comment">//用朴素方法解决：&quot;输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和&quot;</span><br><span class="hljs-comment">//代码</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i++)<br>    &#123; <br>        sum += a[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>&#125;<br><span class="hljs-comment">//时间复杂度为O(n * m) - 两个循环，每次都要重新计算sum的值</span><br><br><span class="hljs-comment">//用前缀和 可以将复杂度降低点到o(n+m)</span><br><br><span class="hljs-comment">//我们给一个递增的数组</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><span class="hljs-comment">//这个数组 如果我要求 前面4项的和你怎么求</span><br><span class="hljs-comment">//  自然而然 a1+...+a4 是吧</span><br>那么我们可以构造一个数组 来实现这种类似的功能<br>cin&gt;&gt;a[i]; <span class="hljs-comment">//伪代码省略操作  </span><br><span class="hljs-type">int</span> sum[];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++) sum[i] = sum[i<span class="hljs-number">-1</span>]+a[i]; 这样就可以实现了<br><span class="hljs-comment">//这样子 sum 中存储的数据 都是对应i值的前n项和</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> sum[N], a[N]; <span class="hljs-comment">//sum[i]=a[1]+a[2]+a[3].....a[i];</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; i++)<br>&#123; <br>    sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i]; <span class="hljs-comment">//一次性全部算出来 - 只用一个循环的时间   </span><br>&#125;<br><br><span class="hljs-comment">//说白了，就是一个提前把所有数据处理出来，一个没有</span><br></code></pre></td></tr></table></figure>

<h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p><img src="/2023/04/26/Two/%E5%B7%AE%E5%88%86.png" alt="差分"></p>
<p><img src="/2023/04/26/Two/%E5%B7%AE%E5%88%861.png" alt="差分1"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//差分数组：</span><br> 首先给定一个原数组a：a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>],,,,,, a[n];<br> 然后我们构造一个数组b ： b[<span class="hljs-number">1</span>], b[<span class="hljs-number">2</span>], b[<span class="hljs-number">3</span>],,,,,, b[i];<br> 使得 a[i] = b[<span class="hljs-number">1</span>] + b[<span class="hljs-number">2</span>] + b[<span class="hljs-number">3</span>] + ,,,,,, + b[i]<br>    <span class="hljs-comment">//i表示a[i]需要i个b数组元素构成</span><br><span class="hljs-comment">//也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E5%B7%AE%E5%88%86%E6%9E%84%E6%88%90.png" alt="差分构成"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">b[l] + c，效果使得a数组中 a[l] 及以后的数都加上了<span class="hljs-built_in">c</span>(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 b[r + <span class="hljs-number">1</span>] - c,让a数组中 a[r + <span class="hljs-number">1</span>]及往后的区间再减去<span class="hljs-built_in">c</span>(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。<br>因此我们得出一维差分结论：给a数组中的[ l, r] 区间中的每一个数都加上c,只需对差分数组b做 b[l] + = c, b[r+<span class="hljs-number">1</span>] - = c 。时间复杂度为<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>), 大大提高了效率。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//差分是解决 - 在数组中的某一个区间中插入或者剔除一个值的问题</span><br> 我们设原数组是：a[i]<br>    b数组的一部分:b[i] = a[i]-a[i<span class="hljs-number">-1</span>];<br> 那么就有： (b[i]+c) = (a[i]+c)-(a[i<span class="hljs-number">-1</span>]+c);<span class="hljs-comment">//这样恒成立</span><br>    (b[i]-c) = (a[i]-c)-(a[i]-c);<br><span class="hljs-comment">//所以我们就要在区间中构造一个这样的b[i] - insert函数</span><br> <span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)<br>    &#123;<br>        b[l]+=c;<br>        b[r+<span class="hljs-number">1</span>]-=c;<span class="hljs-comment">//这里是为了构造 b[i] = a[i]-a[i-1]; - 每次都超减一位</span><br>    &#125;<br><span class="hljs-comment">//梳理</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<span class="hljs-comment">//这里是输入我们目的处理的数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//这里是构造差分数组 - 构造完的由b数组存储</span><br> <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(l,r,c);<span class="hljs-comment">//这里就是对我们的差分数组处理数据 - 最终结果就是b数组</span><br>    &#125;<br><span class="hljs-comment">//输出结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) c[i] = c[i<span class="hljs-number">-1</span>]+b[i];<span class="hljs-comment">//b数组的所有元素加起来就是a数组</span><br> <span class="hljs-comment">//也就  b[i] = a[i] - a[i-1] 那么把b数组前缀和起来之后就是构造的a数组的序列</span><br> <span class="hljs-comment">//就是  差分数组整合就是构造差分数组的原序列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//构造差分数组的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//输入构造差分数组的原数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-comment">//构造差分序列 - b就是差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<br>    <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-comment">//插入更改的值</span><br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-comment">//这里是析出原数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) c[i] = c[i<span class="hljs-number">-1</span>]+b[i];<br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二维前缀和and二维差分"><a href="#二维前缀和and二维差分" class="headerlink" title="二维前缀和and二维差分"></a>二维前缀和and二维差分</h3><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png" alt="二维前缀和"></p>
<p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E5%88%86%E8%A7%A3.png" alt="二维前缀和分解"></p>
<p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86.png" alt="二维前缀和预处理"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用了容斥原理 - 将我们需要的区间分离出来</span><br> 同一维前缀和一样，我们先来定义一个二维数组s[][] , s[i][j] 表示二维数组中，左上角(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)到右下角(i, j)所包围的矩阵元素的和。接下来推导二维前缀和的公式。<span class="hljs-comment">//但是，要是起点不定怎么办呢~~~</span><br>     紫色面积是指(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(i, j - <span class="hljs-number">1</span>)右下角的矩形面积, 绿色面积是指(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(i - <span class="hljs-number">1</span>, j )右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。<br>     从图中我们很容易看出，整个外围蓝色矩形面积s[i][j] = 绿色面积s[i - <span class="hljs-number">1</span>][j] + 紫色面积s[i][j - <span class="hljs-number">1</span>] - 重复加的红色的面积s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + 小方块的面积a[i][j];<br> 因此得出二维前缀和预处理公式 s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span> ] + a[i] [j] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E6%B1%82%E8%B5%B7%E7%82%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="求起点不同的子矩阵"></p>
<p><img src="/2023/04/26/Two/%E5%88%86%E8%A7%A3%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="分解子矩阵"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</span><br> 紫色面积是指 (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(x1 - <span class="hljs-number">1</span>, y2)右下角的矩形面积 ，黄色面积是指(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(x2, y1 - <span class="hljs-number">1</span>)右下角的矩形面积；<br> 绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - <span class="hljs-number">1</span>] - 紫色面积s[x1 - <span class="hljs-number">1</span>, y2] + 重复减去的红色面积 s[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br>    因此二维前缀和的结论为：<br>    以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：s[x2, y2] - s[x1 - <span class="hljs-number">1</span>, y2] - s[x2, y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure>

<h4 id="二维差分-不太懂"><a href="#二维差分-不太懂" class="headerlink" title="二维差分 - 不太懂"></a>二维差分 - 不太懂</h4><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.png" alt="二维差分"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。</span><br> a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组<br>  原数组： a[i][j]<br>  我们去构造差分数组： b[i][j]<br> 使得a数组中a[i][j]是b数组左上角(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)到右下角(i,j)所包围矩形元素的和。<br><span class="hljs-comment">//如何构造b数组呢？</span><br> 其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。<br> 同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由<span class="hljs-built_in">O</span>(n*n)的时间复杂度优化成<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br> 已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;<br> 始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往后的每一个数。<br> 假定我们已经构造好了b数组，类比一维差分，我们执行以下操作来使被选中的子矩阵中的每个元素的值加上c：<br>  b[x1][y1] + = c ;<br>  b[x1,][y2+<span class="hljs-number">1</span>] - = c;<br>  b[x2+<span class="hljs-number">1</span>][y1] - = c;<br>  b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] + = c;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86%E5%88%86%E8%A7%A3.png" alt="二维差分分解"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">b[x1][y1] += c ; 对应图<span class="hljs-number">1</span> ,让整个a数组中蓝色矩形面积的元素都加上了c。<br>b[x1,][y2 + <span class="hljs-number">1</span>] -= c ; 对应图<span class="hljs-number">2</span> ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。<br>b[x2 + <span class="hljs-number">1</span>][y1] -= c ; 对应图<span class="hljs-number">3</span> ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。<br>b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c; 对应图<span class="hljs-number">4</span>,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。<br>    <br><span class="hljs-comment">//封装插入函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c</span><br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><span class="hljs-comment">//构造</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>  &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++)<br>      &#123;<br>          <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);    <span class="hljs-comment">//构建差分数组</span><br>      &#125;<br>  &#125;<br><br><span class="hljs-comment">//理解</span><br> 我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 c = a[i][j] ，等价于原数组a中(i,j) 到(i,j)范围内 加上了 a[i][j] ,因此执行 n*m次插入操作，就成功构建了差分b数组.<br></code></pre></td></tr></table></figure>

<h3 id="双指针维护区间"><a href="#双指针维护区间" class="headerlink" title="双指针维护区间"></a>双指针维护区间</h3><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/71643340">算法一招鲜——双指针问题 - 知乎 (zhihu.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//什么是双指针（对撞指针、快慢指针）</span><br> 双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。<br></code></pre></td></tr></table></figure>

<h4 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。</span><br> 对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。<br>        <br><span class="hljs-comment">//伪代码</span><br><span class="hljs-function">function <span class="hljs-title">fn</span> <span class="hljs-params">(list)</span> </span>&#123;<br>  var left = <span class="hljs-number">0</span>;<br>  var right = list.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//遍历数组</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    left++;<br>    <span class="hljs-comment">// 一些条件判断 和处理</span><br>    ... ...<br>    right--;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//对撞指针能够解决：：1.二分查找 2.两数之和 II - 输入有序数组 3.反转字符串 4.反转字符串中的元音字母 5.回文字符串</span><br></code></pre></td></tr></table></figure>

<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"> 快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。<br><br><span class="hljs-comment">//伪代码</span><br>slow = head;<br>fast = head;<br><span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>    slow = slow-&gt;next;<br>    fast = fast-&gt;next-&gt;next;<br>    <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//快慢指针能够解决：链表中倒数第k个节点  1.链表的中间节点 2.链表是否有环 3.链表环的长度 4.链表环的起点</span><br><span class="hljs-comment">//判断链表是否有环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    ListNode *slow = head; <span class="hljs-comment">// 慢指针</span><br>    ListNode *fast = head-&gt;next; <span class="hljs-comment">// 快指针</span><br>    <span class="hljs-keyword">while</span> (slow != fast) &#123; <span class="hljs-comment">// 当快慢指针不相遇时</span><br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">NULL</span> || fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 如果快指针到达链表尾部，说明链表没有环</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        slow = slow-&gt;next; <span class="hljs-comment">// 慢指针走一步</span><br>        fast = fast-&gt;next-&gt;next; <span class="hljs-comment">// 快指针走两步</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果快慢指针相遇，说明链表有环</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/144296454">图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//哈希表是散列表 - 可以理解为哈希是映射的因子（我瞎编），哈希表本质上就是两个不同的数据集合映射的过程</span><br>简介：<br> 哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。<br>    哈希表采用的是一种转换思想，其中一个中要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标。我们先来通过一个例子来理解这句话。<span class="hljs-comment">//数字和数字有映射关系，数字和字符要创造映射关系（虽然说字符也是数字，但是他们并没有映射关系：例如 1 - 1有映射，1 - 10086 没有，所以说我们需要用哈希创造他们的映射关系 - 是这样吗？） </span><br> 我们上学的时候，大家都会有一个学号「<span class="hljs-number">1</span>-n号」中的一个号码，如果我们用哈希表来存放班级里面学生信息的话，我们利用学号作为「键」或者「关键字」，这个「键」或者「关键字」就可以直接作为数据的下标，不需要通过哈希函数进行转化。如果我们需要安装学生姓名作为「键」或者「关键字」，这时候我们就需要哈希函数来帮我们转换成数组的下标。<span class="hljs-comment">//键对应关键字 - 这就是映射关系</span><br>    <br><span class="hljs-comment">//哈希函数</span><br>    哈希函数的作用是帮我们把非<span class="hljs-type">int</span>的「键」或者「关键字」转化成<span class="hljs-type">int</span>，可以用来做数组的下标。比如我们上面说的将学生的姓名作为「键」或者「关键字」，这是就需要哈希函数来完成，下图是哈希函数的转换示意图。<span class="hljs-comment">//就是将数据离散化是吧</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/hash.jpg" alt="hash"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//哈希函数的写法有很多中，我们来看看「HashMap」中的哈希函数</span><br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == null) ? <span class="hljs-number">0</span> : (h = key.<span class="hljs-built_in">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">//「HashMap」中利用了「hashCode」来完成这个转换。哈希函数不管怎么实现，都应该满足下面三个基本条件：</span><br><br><span class="hljs-comment">//散列函数计算得到的散列值是一个非负整数</span><br> 如果 key1 = key2，那 <span class="hljs-built_in">hash</span>(key1) == <span class="hljs-built_in">hash</span>(key2)<br> 如果 key1 ≠ key2，那 <span class="hljs-built_in">hash</span>(key1) ≠ <span class="hljs-built_in">hash</span>(key2)  <br> 第一点：因为数组的下标是从<span class="hljs-number">0</span>开始，所以哈希函数生成的哈希值也应该是非负数<br> 第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据<span class="hljs-comment">//因为key是查找散列表中的值，如果两个相等的key映射的位置不同的话，那么我们就无法查找散列表的值</span><br> 第三点：看起来非常合理，但是两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突<span class="hljs-comment">//数据足够大的时候，映射的格子不够多，那么就会出现哈希冲突 - 原因是因为映射关系这个本质，我们只是把一一对应离散化了，还是可能出现重复的</span><br><br><span class="hljs-comment">//哈希冲突</span><br>     哈希冲突是不可避免的，我们常用解决哈希冲突的方法有两种「开放地址法」和「链表法」<br></code></pre></td></tr></table></figure>

<h4 id="链表查找"><a href="#链表查找" class="headerlink" title="链表查找"></a>链表查找</h4><p> 在开放地址法中，若数据不能直接存放在哈希函数计算出来的数组下标时，就需要寻找其他位置来存放。在开放地址法中有三种方式来寻找其他的位置，分别是「线性探测」、「二次探测」、「再哈希法」</p>
<h5 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性探查  </span><br>  在线性探测哈希表中，数据的插入是线性的查找空白单元，例如我们将数<span class="hljs-number">88</span>经过哈希函数后得到的数组下标是<span class="hljs-number">16</span>，但是在数组下标为<span class="hljs-number">16</span>的地方已经存在元素，那么就找<span class="hljs-number">17</span>,<span class="hljs-number">17</span>还存在元素就找<span class="hljs-number">18</span>，一直往下找，直到找到空白地方存放元素。我们来看下面这张图 <br>    我们向哈希表中添加一个元素钱多多，钱多多经过哈希函数后得到的数组下标为<span class="hljs-number">0</span>，但是在<span class="hljs-number">0</span>的位置已经有张三了，所以下标往前移，直到下标<span class="hljs-number">4</span>才为空，所以就将元素钱多多添加到数组下标为<span class="hljs-number">4</span>的地方。<span class="hljs-comment">//有位填数，没位向下搜索空白的位置 </span><br><span class="hljs-comment">//代码</span><br><span class="hljs-comment">//哈希函数 - size一般是质数？</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (key % size);<br>&#125;<br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>    <span class="hljs-type">int</span> key = student.<span class="hljs-built_in">getKey</span>();<br>    <span class="hljs-type">int</span> hashVal = <span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-keyword">while</span> (array[hashVal] != <span class="hljs-literal">NULL</span> &amp;&amp; array[hashVal].<span class="hljs-built_in">getKey</span>() != <span class="hljs-number">-1</span>) &#123;<br>        ++hashVal;<br>        <span class="hljs-comment">//超过数组大小 - 从第一个开始找</span><br>        hashVal %= size;<br>    &#125;<br>    array[hashVal] = student;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinearProbingHash hash = <span class="hljs-built_in">LinearProbingHash</span>(<span class="hljs-number">10</span>);<br>    Student student = <span class="hljs-built_in">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>    Student student1 = <span class="hljs-built_in">Student</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;王强&quot;</span>);<br>    Student student2 = <span class="hljs-built_in">Student</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;张伟&quot;</span>);<br>    Student student3 = <span class="hljs-built_in">Student</span>(<span class="hljs-number">11</span>,<span class="hljs-string">&quot;宝强&quot;</span>);<br>    hash.<span class="hljs-built_in">insert</span>(student);<br>    hash.<span class="hljs-built_in">insert</span>(student1);<br>    hash.<span class="hljs-built_in">insert</span>(student2);<br>    hash.<span class="hljs-built_in">insert</span>(student3);<br>    hash.<span class="hljs-built_in">disPlayTable</span>();<br>&#125;<br><br><span class="hljs-comment">//查找</span><br><span class="hljs-function">Student* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-type">int</span> hashVal = <span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-keyword">while</span> (array[hashVal] !=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span> (array[hashVal]-&gt;<span class="hljs-built_in">getKey</span>() == key)&#123;<br>            <span class="hljs-keyword">return</span> array[hashVal];<br>        &#125;<br>        ++hashVal;<br>        hashVal %=size;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%9F%A5.webp" alt="线性探查"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性筛查删除</span><br> 线性探测哈希表的删除相对来说比较复杂一点，我们不能简单的把这一项数据删除，让它变成空，为什么呢？<br> 线性探测哈希表在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。？<br> 因此我们需要一个特殊的数据来顶替这个被删除的数据，因为我们的学生学号都是正数，所以我们用学号等于<span class="hljs-number">-1</span>来代表被删除的数据。<br><span class="hljs-comment">//后果</span><br> 这样会带来一个问题，如何在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为<span class="hljs-number">-1</span>的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-type">int</span> hashVal = <span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-keyword">while</span> (array[hashVal] !=null)&#123;<br>        <span class="hljs-keyword">if</span> (array[hashVal].<span class="hljs-built_in">getKey</span>() == key)&#123;<br>            Student temp = array[hashVal];<br>            array[hashVal]= noStudent;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        ++hashVal;<br>        hashVal %=size;<br>    &#125;<br>    <span class="hljs-keyword">return</span> null;<br>&#125;        <br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/hash%E5%88%A0%E9%99%A4.webp" alt="hash删除"></p>
<h5 id="二次筛查"><a href="#二次筛查" class="headerlink" title="二次筛查"></a>二次筛查</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//当然 二次筛查也不是完美的操作 </span><br> 在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。这个就像我们在逛超市一样，当某个地方人很多时，人只会越来越多，大家都只是想知道这里在干什么。<br> 二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+<span class="hljs-number">1</span>,x+<span class="hljs-number">2</span>,x+<span class="hljs-number">3.</span>.....，以此类推，而在二次探测中，探测过程是x+<span class="hljs-number">1</span>,x+<span class="hljs-number">4</span>,x+<span class="hljs-number">9</span>,x+<span class="hljs-number">16</span>,x+<span class="hljs-number">25.</span>.....,以此类推，到原始距离的步数平方，为了方便理解，我们来看下面这张图<span class="hljs-comment">//就是，我们通过记录前面的探查，可以减少探查的次数</span><br> 还是使用线性探测中的例子，在线性探测中，我们从原始探测位置每次往后推一位，最后找到空位置，在线性探测中我们找到钱多多的存储位置需要经过<span class="hljs-number">4</span>步。在二次探测中，每次是原始距离步数的平方，所以我们只需要两次就找到钱多多的存储位置。<br> 二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。<br> 比如讲<span class="hljs-number">1</span>、<span class="hljs-number">11</span>、<span class="hljs-number">21</span>、<span class="hljs-number">31</span>、<span class="hljs-number">41</span>依次插入到哈希表中，它们映射的位置都是<span class="hljs-number">1</span>，那么<span class="hljs-number">11</span>需要以一为步长探测，<span class="hljs-number">21</span>需要以四为步长探测，<span class="hljs-number">31</span>需要为九为步长探测，<span class="hljs-number">41</span>需要以十六为步长探测，只要有一项映射到<span class="hljs-number">1</span>的位置，就需要更长的步长来探测，这个现象叫做二次聚集。<br></code></pre></td></tr></table></figure>

<p><img src="https://pic2.zhimg.com/80/v2-0f9eb8694b479a0a5a034251a2b93135_720w.webp" alt="img"></p>
<h5 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。</span><br>第二个哈希函数必须具备如下特点:<br>  <span class="hljs-number">1.</span>和第一个哈希函数不一样<br>         <span class="hljs-number">2.</span>不能输出为<span class="hljs-number">0</span>，因为步长为<span class="hljs-number">0</span>，每次探测都是指向同一个位置，将进入死循环，经过试验得出stepSize = constant-(key%constant);形式的哈希函数效果非常好，constant是一个质数并且小于数组容量<br><span class="hljs-comment">//我们将上面的添加改变成双哈希探测，示意图如下：           </span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E5%8F%8C%E5%93%88%E5%B8%8C.webp" alt="双哈希"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双哈希</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],nxt[N],idx;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=(x%N+N)%N; <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=nxt[i]) <span class="hljs-comment">// 遍历哈希表中的链表</span><br>        <span class="hljs-keyword">if</span>(e[i]==x)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果找到了键 x，返回 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否则返回 0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=(x%N+N)%N; <span class="hljs-comment">// 计算哈希值</span><br>    e[idx]=x;nxt[idx]=h[t];h[t]=idx++; <span class="hljs-comment">// 将键值对插入到哈希表中</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">// 初始化哈希表为空</span><br>    <span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">char</span> op;cin&gt;&gt;op;<br>        <span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;I&#x27;</span>)<span class="hljs-built_in">insert</span>(x); <span class="hljs-comment">// 如果是插入操作，将键 x 插入到哈希表中</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x))<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-comment">// 如果键 x 在哈希表中，输出 Yes</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-comment">// 否则输出 No</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p><img src="/2023/04/26/Two/%E6%8B%89%E9%93%BE%E6%B3%95.png" alt="拉链"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>;          <span class="hljs-comment">// 选取的质数为100003</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;     <span class="hljs-comment">// 构建邻接表</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;             <span class="hljs-comment">// 头插法</span><br>    <span class="hljs-type">int</span> k = (x % N + N) % N;    <span class="hljs-comment">// 除留余数法</span><br>    e[idx] = x;   ne[idx] = h[k];   h[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;              <span class="hljs-comment">// 查找</span><br>    <span class="hljs-type">int</span> n = (k % N + N) % N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[n]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(e[i] == k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br>    <span class="hljs-comment">// 初始化邻接表</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)       h[i] = <span class="hljs-number">-1</span>;    <br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-type">int</span> x;          <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <br>        <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;I&#x27;</span>)  <span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(x))        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><blockquote>
<p><a href="https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">字符串哈希</a></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//字符串hash</span><br> 构造唯一数据表示字符串，可以理解为 <span class="hljs-built_in">f</span>(x) = y。就是通过某种方法转化，使得两个毫无相关的数据产生关系。但是为了将映射关系进行一一对应，也就是，一个字符串对应一个数字，那么一个数字也对应一个字符串。<br> 用字符串Hash的目的是，我们如果要比较一个字符串，我们不直接比较字符串，而是比较它对应映射的数字，这样子就知道两个“子串”是否相等。从而达到，子串的Hash值的时间为 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，进而可以利用“空间换时间”来节省时间复杂的。<br>    我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。不用担心，接下来的内容正要讲解。<span class="hljs-comment">//我们只需要用到数字来匹配数据，这样对数字操作就可以得到我们想要的操作了</span><br></code></pre></td></tr></table></figure>

<h5 id="构造字符串hash"><a href="#构造字符串hash" class="headerlink" title="构造字符串hash"></a>构造字符串hash</h5><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单例子</span><br> 假如给你一个数字<span class="hljs-number">1166</span>，形式上你只知道它只是<span class="hljs-number">1</span>和<span class="hljs-number">6</span>的组合，但你知道它代表的实际大<span class="hljs-number">1</span>*<span class="hljs-number">10</span>^<span class="hljs-number">3</span>+<span class="hljs-number">1</span>*<span class="hljs-number">10</span>^<span class="hljs-number">2</span>+<span class="hljs-number">6</span>*<span class="hljs-number">10</span>^<span class="hljs-number">1</span>+<span class="hljs-number">6</span>*<span class="hljs-number">10</span>^<span class="hljs-number">0</span>。<br> 同理，给你一个字符串，要把它转换为数字，就可以先把每一个字符都先对应一个数字，然后把它们按照顺序乘以进制（Base）的幂进行相加，然后这个数可能很大，所以一般会取余数（MOD）。    <br><span class="hljs-comment">//具体操作</span><br>    根据上面的理解，其实将字符串映射成数字，和我们平时的将一个 某Base进制数，变为一个十进制数，相类似。<span class="hljs-comment">//把字符串当成 某种进制的数据，把字符串拆成很多位，然后对每一个位置的字符都进行哈希操作，再用进制的乘法操作将他们拼接起来。</span><br> 我们先定义以下：<br> 给定一个字符串 S = s1s2s3...sn，对于每一个si就是一个字母，那么我们规定<br>         <span class="hljs-built_in">idx</span>(si) = si-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span> （当然也可以直接用其ASCII值）<br> 构造字符串Hash总共有三种方法。每一种方法，主要都是用使用 Base 和 MOD（都要求是素数），一般都是 Base  &lt; MOD，同时将Base和MOD尽量取大即可，这种情况下，冲突（即不同字符串却有着相同的hash值）的概率是很低的<br><br><span class="hljs-comment">//1.自然溢出方法 - 后面还有</span><br> 对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> 整数的自然溢出<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//怎么构建我们的字符串前缀</span><br>  <span class="hljs-number">1.</span>将整个数组 当做是一个p进制的数。 通过这样的方式，将我们的字符串变成数字进行操作（本质上 字符串也是数字） - 但是我们这个数组转化完成可能会非常大 那么我们就mod一个大的数据 - 通过这样的方法映射到小区间中 <span class="hljs-comment">//取模会重复怎么办 还是说随机存储</span><br>    <span class="hljs-number">2.</span>字符串哈希完全不考虑冲突的情况 <br>    <span class="hljs-number">3.</span> p = <span class="hljs-number">131</span> <span class="hljs-keyword">or</span> <span class="hljs-number">13331</span> - Q = <span class="hljs-number">2e64</span> 这样可以忽略冲突 （溢出等价于 mod <span class="hljs-number">2e64</span>）<br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C.png" alt="image-20230226201946750"></p>
<p>标准流程</p>
<p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2hash1.png" alt="原理"></p>
<p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2hash2.png" alt="原理2"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//相当于将字符型映射为整型（本来就是 将字符串映射成一个p进制的数据 - p一般为质数）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br><span class="hljs-comment">// p[i] = P^i, h[i] = s[1~i]的hash值</span><br>ULL p[N],h[N];<br><br><span class="hljs-comment">//预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//字符串长度就是对应的进制 p^n - 也可以说是长度是项数的个数</span><br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>,h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        p[i] = p[i<span class="hljs-number">-1</span>]*P; <span class="hljs-comment">//P是进制</span><br>        h[i] = h[i<span class="hljs-number">-1</span>]*P+s[i];<span class="hljs-comment">//s是对应字符的ASCII值是吧</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//计算s[l~r]的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//判断两个子串是否相等</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(l1,r1) == <span class="hljs-built_in">get</span>(l2,r2);<br>&#125;<br><br><span class="hljs-comment">//总结：字符串哈希使用来解决字符串匹配，查找去重的问题的。</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E5%8E%9F%E7%90%863.png" alt="原理3"></p>
<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="高精度加法计算"><a href="#高精度加法计算" class="headerlink" title="高精度加法计算"></a><strong>高精度加法计算</strong></h4><p>  如果我们要将一个很大的数据与一个很小的数据相加应该怎么办，你可能会想，直接加就行了嘛，10000+1&#x3D;10001，很简单。但是，在计算机中，我们使用的数据类型在计算的时候，往往会将小的数据忽略掉，也就是，1e99+1 &#x3D; 1e99,而1就不见了。我们需要的是保持精度的情况下进行加法，这个时候我们可以利用我们的线性表，数组来实现这个保留精度的加法。</p>
<p>A+B（这里的情况是一个大的数据加上另一个大的数据）</p>
<p>  依照上面的说法，我们就开辟两个字符串数组（比较好分离数据），一个a【】存A这个数据，一个b【】存B这个数据。但为了方便接下来的操作，我们还是开辟两个Vector(向量：是个容器)，然后将输入的a,b中的数据导入到我们的vector中，这个时候注意一个细节。</p>
<p>  我们插入的数据是要倒着插入的，举个例子：123456789，这是一个大的数据，倒着插入意味着个位在数组（容器）的前面（之后的数据以此类推）。在数组中就变成了987654321，这样做的好处是进位不用移动数组中的元素，你看我们的目的是要计算这些大数据的加和，在加和的过程中免不了会产生进位，如果用123456789，进一位的话就要移动整个数组，就十分复杂。如果反过来，我们只需要在进的那位尾插一个数据就行。</p>
<p>  同时，计算方法其实就和我们手工计算的差不多，对位计算加上进位即可，举个例子：1+9 &#x3D; 10，其实就是十位上面+进位t&#x3D;1 &#x3D; 10,就是这样。</p>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C = A+B c是我们要实现的结果</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<span class="hljs-comment">//这是结果</span><br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span><span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//只要没遍历完最长的就继续</span><br>    &#123;<br>        <span class="hljs-comment">//下面实现的是 t在i这个位置的值，然后%10就是这个位置剩下的值，/10就是进位的值保留到i+1（下一位）</span><br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//将对应位置的数据插入结果</span><br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//进大位，出来t/10还有剩，那肯定进位了（我们是倒叙输入的嘛）</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">//倒叙输入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//自己输入两个大的数据</span><br>    <span class="hljs-comment">//为啥是size-1，就是0到i有i-1个数据嘛</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//倒着插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-comment">//自动判断是啥类型</span><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A,B);<span class="hljs-comment">//调用模板</span><br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<h4 id="高精度减法计算"><a href="#高精度减法计算" class="headerlink" title="高精度减法计算"></a><strong>高精度减法计算</strong></h4><p>  减法的计算其实和加法差不多，但是我们需要满足一些条件；1.A&gt;&#x3D;B 不满足就要交换两个数据的值（加上负号）2.向前借位是+10（对于当前位数）所以说方向就很明确了，加上一个判断A,B大小的关系，对 t 改一下就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//C = A-B c是我们要实现的结果</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span>/模板</span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<span class="hljs-comment">//这是结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//只要没遍历完最长的就继续</span><br>    &#123;<br>  t = A[i] - t;<span class="hljs-comment">//t是借位的</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//这里的t有两种情况，一种减完之&lt;0，那就需要借位+10.一种是减完之后&gt;=0，不需要借位。这个时候，(t+10)%10这两种情况都满足，举个例子：1.你减完之后变成了-9，那就是要借一位，就是-9+10 = 1,1%10还是1.2.你减完之后，还剩下9，那么9%10还是9.</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()== <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br><span class="hljs-comment">//倒叙输入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//自己输入两个大的数据</span><br>    <span class="hljs-comment">//为啥是size-1，就是0到i有i-1个数据嘛</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//倒着插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-comment">//用上面的判断，计算A-B 或者 B-A</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))<br>    &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i --) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(B,A);<span class="hljs-comment">//B&gt;A</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="高精度乘法计算"><a href="#高精度乘法计算" class="headerlink" title="高精度乘法计算"></a>高精度乘法计算</h4><p>大数据乘小数据</p>
<p> 在人工计算乘法的时候，我们一般是一位一位的计算，例如：123乘12，那么一般是2 <em>123+10</em> 123。但是这样其实比较繁琐，我们在计算高精度的时候，可以把这两个数据中的小数据，单独拿出来做一个整体，就上面那个来说，就变成了1 <em>12</em> 100+2 <em>12</em> 10+3 <em>12</em> 1，竖式就由两个变成一个了。</p>
<p> 同时，在计算的时候，每一个位的位数t也需要注意，举个例子：123456789<em>12，这里的 （第一位）a &#x3D; 9,进位就变成了 t &#x3D; 9</em> 12&#x2F;10，输入到结果C的就变成了 (第一位)C &#x3D; 9*12%10，这样就定下来了。下面是代码演示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//b比较小就直接用int表示（整体）</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||t;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i]*b;<span class="hljs-comment">//遍历位置乘完的数据</span><br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//插进去计算完成之后这个位置的具体数</span><br>        t/=<span class="hljs-number">10</span>;<span class="hljs-comment">//进位</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>    <br>&#125;<br><span class="hljs-comment">//插入数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<span class="hljs-comment">//数据大用字符串存储</span><br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//这里是把字符串转化成具体的数，由ASCII决定的，在字符&#x27;0&#x27;代表的是48</span><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A,b);<span class="hljs-comment">//调用容器</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="高精度除法计算"><a href="#高精度除法计算" class="headerlink" title="高精度除法计算"></a>高精度除法计算</h4><p>大数据除小数据（一般用的不多）</p>
<p> 在人工计算除法的时候，一般是从大到小位去除的。但是，一个题目难免会出现加减乘除多种运算，所以说我们还是尾插大数据把。具体做法和乘法差不多，就是把小的看成整体（平常我们算除法是这样）下面是代码演示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span><span class="hljs-comment">//b是小的</span></span><br><span class="hljs-function"></span>&#123;<br> vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        r = r*<span class="hljs-number">10</span>+A[i];<span class="hljs-comment">//计算的时候，和我们把上一位除不了移下来算是一个样子的</span><br>        C.<span class="hljs-built_in">push_back</span>(r/b);<span class="hljs-comment">//余数插入结果中</span><br>        r%=b;<span class="hljs-comment">//除完之后的余数</span><br>        <br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//翻转</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//去除前端0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">//插入数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<span class="hljs-comment">//数据大用字符串存储</span><br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//这里是把字符串转化成具体的数，由ASCII决定的，在字符&#x27;0&#x27;代表的是48</span><br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A,b,r);<span class="hljs-comment">//调用容器</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Web</title>
    <url>/2023/04/30/Web/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML超文本标记语言"><a href="#HTML超文本标记语言" class="headerlink" title="HTML超文本标记语言"></a>HTML超文本标记语言</h2><p>HTML（HyperText Markup Language）是一种用于创建网页结构和内容的标记语言。它使用标签（tag）来定义网页中的各种元素，如标题、段落、链接、图像等。HTML文件由一系列标签和文本内容组成，浏览器根据这些标签解析并显示网页的结构和内容。</p>
<p>HTML相当于我们文章的文本，内部存在一些标签，来对这些文本修饰和美化，相当于我们的大纲，通过与CSS结合使用，可以通过样式规则控制文本的外观和呈现方式。下面我们来介绍一些基础的标签。</p>
<h3 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol>
<li><code>&lt;!DOCTYPE html&gt;</code>：声明文档类型，告诉浏览器这是一个HTML5文档。</li>
<li><code>&lt;html&gt;</code>：根元素，表示整个HTML文档的开始和结束。</li>
<li><code>&lt;head&gt;</code>：头部元素，用于定义文档的元数据和引入外部资源，如CSS和JavaScript文件等。</li>
<li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：指定文档的字符编码为UTF-8，确保网页中的文本可以正确地显示。</li>
<li><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>：定义浏览器的兼容性模式，确保在Internet Explorer浏览器中以最新的渲染模式显示。</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>：设置视口的宽度和初始缩放级别，使网页在移动设备上能够适应屏幕大小。</li>
<li><code>&lt;title&gt;</code>：定义网页的标题，显示在浏览器的标题栏或标签页上。</li>
<li><code>&lt;body&gt;</code>：主体元素，包含了网页的可见内容，如文本、图像、链接等。</li>
</ol>
<h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p>在介绍完基础框架后，我们来学习一下基本构建网站的标签。它们通常都是书写在我们的body标签处</p>
<h4 id="h标签"><a href="#h标签" class="headerlink" title="h标签"></a><strong>h标签</strong></h4><p> h标签是文章的标题，一共有6个级别，h1…h6。每一个级别代表着一个标签头。我们书写一个这样的案例，按照6个级别分别输出我们的标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 试试打开全部的标签 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是标题3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是标题4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>我是标题5<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>我是标题6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517201250588.png" alt="image-20230517201250588"></p>
<h4 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a><strong>p标签</strong></h4><p>p标签是文章的段落，被p标签修饰的字段，会有执行文章段落的规则，浏览器通常会在段落前后添加一些默认的空间和换行，以显示段落的分隔效果。</p>
<p>块级元素：<code>&lt;p&gt;</code>标签是一个块级元素，它会占据一行或多行的空间。相邻的<code>&lt;p&gt;</code>标签会在页面上垂直排列，每个<code>&lt;p&gt;</code>标签之间会有一定的间距。</p>
<blockquote>
<p>块级元素：块级元素（Block-level elements）是HTML中的一个概念，用于描述元素在文档流中的布局和行为方式。以下是块级元素的特点：</p>
<ol>
<li>独占一行：块级元素通常会在页面上独占一行，即使它的内容没有填满整行。相邻的块级元素会在页面上垂直排列。</li>
<li>宽度默认为100%：块级元素的默认宽度会填满其父元素的可用宽度，除非通过CSS显式设置其宽度。</li>
<li>可以设置宽度、高度、内边距和外边距：块级元素可以通过CSS属性设置其宽度、高度、内边距和外边距，以调整布局和样式。</li>
<li>可以包含内联元素和其他块级元素：块级元素可以包含其他块级元素和内联元素。这使得可以构建复杂的布局结构，并且在其中放置各种内容。</li>
<li>默认情况下会产生一些垂直间距：块级元素通常会在其上下产生一些默认的垂直间距，例如段落之间的间距。</li>
</ol>
<p>一些常见的块级元素包括<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;form&gt;</code>等。这些元素在默认情况下都是块级元素，但也可以通过CSS进行样式上的修改。</p>
<p>相对于块级元素，还有另一类元素称为内联元素（Inline elements），它们通常不会独占一行，而是在同一行内水平排列。内联元素的特点包括不能设置宽度和高度，不能独占一行，只能容纳其他内联元素或者文本内容。常见的内联元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等。</p>
</blockquote>
<p>文本包裹：<code>&lt;p&gt;</code>标签用于包裹一段文本，该文本可以是普通的纯文本，也可以包含其他内联元素或标记。例如，你可以在<code>&lt;p&gt;</code>标签内使用<code>&lt;strong&gt;</code>或<code>&lt;em&gt;</code>标签来加粗或斜体显示文本。</p>
<p>默认样式：浏览器会对<code>&lt;p&gt;</code>标签应用一些默认样式，例如设定一定的行间距、字体样式和段落缩进。这些样式可以通过CSS进行自定义调整。</p>
<blockquote>
<p>以下是一些常见的CSS属性，可以用来修饰段落：</p>
<ol>
<li><code>color</code>：设置文本的颜色。</li>
<li><code>font-size</code>：设置文本的字体大小。</li>
<li><code>font-family</code>：设置文本的字体系列。</li>
<li><code>font-weight</code>：设置文本的粗细程度，例如使用值<code>bold</code>加粗文本。</li>
<li><code>text-align</code>：设置文本的对齐方式，例如使用值<code>center</code>使文本居中对齐。</li>
<li><code>line-height</code>：设置行高，控制行与行之间的垂直间距。</li>
<li><code>padding</code>：设置段落的内边距，即段落内容与边框之间的空间。</li>
<li><code>margin</code>：设置段落的外边距，即段落与相邻元素之间的空间。</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- css样式 - 建议封装在外部 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">165</span>, <span class="hljs-number">42</span>, <span class="hljs-number">128</span>);</span><br><span class="language-css">            <span class="hljs-comment">/* 字体大小 */</span></span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">            <span class="hljs-comment">/* css样式居中 */</span></span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>试试段落的特点<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 这个段落是一个块 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落，它有什么特点<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 尝试用css来修饰这个段落 --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517203408632.png" alt="image-20230517203408632"></p>
<h4 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a><strong>a标签</strong></h4><p>a标签是HTML中用于创建超链接的标签，它具有以下特点：</p>
<ol>
<li><p>超链接功能：<code>&lt;a&gt;</code>标签用于创建链接到其他网页、文档或特定位置的超链接。通过设置<code>href</code>属性来指定链接目标的URL或文档片段标识符。</p>
</li>
<li><p>文本或图像链接：<code>&lt;a&gt;</code>标签可以包裹文本或图像，使其成为可点击的链接。例如，可以使用<code>&lt;a&gt;</code>标签将文本或图像转换为链接，使用户能够点击并导航到链接目标。</p>
</li>
<li><p>打开新窗口：使用<code>target</code>属性可以控制链接在新窗口或当前窗口中打开。例如，设置<code>target=&quot;_blank&quot;</code>可以在新的浏览器窗口或选项卡中打开链接。</p>
</li>
<li><p>可以包含其他元素：<code>&lt;a&gt;</code>标签可以包含其他内联元素或块级元素，例如文本、图像、按钮等。这样可以在链接中添加更丰富的内容和样式。</p>
</li>
<li><p>可以添加标题：使用<code>title</code>属性可以为链接添加鼠标悬停时显示的标题文本，提供额外的描述或信息。</p>
</li>
<li><p>可以与JavaScript交互：<code>&lt;a&gt;</code>标签可以与JavaScript代码结合使用，例如通过添加事件处理程序来实现自定义行为或交互效果。  </p>
<blockquote>
<p>通过添加事件处理程序，你可以为<code>&lt;a&gt;</code>标签或其它元素添加自定义的行为或交互效果。事件处理程序是一段JavaScript代码，用于响应用户与页面元素的交互，例如点击、鼠标移入、键盘按下等事件。</p>
<p>在HTML中，你可以通过在元素上添加事件属性来指定事件处理程序。常见的事件属性包括<code>onclick</code>（点击事件）、<code>onmouseover</code>（鼠标悬停事件）、<code>onkeydown</code>（键盘按下事件）等。</p>
<p>就是一些按钮啊，点击啊之类的(＾▽＾)</p>
</blockquote>
</li>
</ol>
<p>需要注意的是，<code>&lt;a&gt;</code>标签本身并没有默认的样式，它可以通过CSS进行样式上的修改，如更改颜色、添加下划线等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>超链接实验<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.创建连接指向我们的hexo --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span>&gt;</span>hexo<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.控制链接跳转，生成新的网页 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>hexo_open<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 3.包括其他块级元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你说我这个算不算链接啊<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>试一下第二行有没有用<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 4.添加标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;这是通向hexo的链接&quot;</span>&gt;</span>?????<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 5.图片链接 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\Different from the usual of you.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517204933935.png" alt="image-20230517204933935"></p>
<h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a><strong>img标签</strong></h4><p>img标签是HTML中用于插入图像的标签，它具有以下特点：</p>
<ol>
<li><p>插入图像：<code>&lt;img&gt;</code>标签用于在网页中插入图像。通过设置<code>src</code>属性来指定要插入的图像的路径或URL。</p>
</li>
<li><p>自闭合标签：<code>&lt;img&gt;</code>标签是一个自闭合标签，不需要闭合标签。例如：<code>&lt;img src=&quot;image.jpg&quot; alt=&quot;图像&quot;&gt;</code></p>
</li>
<li><p>显示图像：<code>&lt;img&gt;</code>标签会在网页中显示指定的图像。网页加载时，图像会根据<code>src</code>属性指定的路径下载并显示在指定位置。</p>
</li>
<li><p>替代文本：通过<code>alt</code>属性可以提供替代文本（alternative text），当图像无法加载时，或用于辅助技术（如屏幕阅读器）读取图像时，会显示替代文本。</p>
</li>
<li><p>调整尺寸：通过<code>width</code>和<code>height</code>属性可以设置图像的宽度和高度。可以使用具体像素值或百分比来调整图像的大小。</p>
</li>
<li><p>添加标题：使用<code>title</code>属性可以为图像添加鼠标悬停时显示的标题文本，提供额外的描述或信息。</p>
</li>
<li><p>响应式设计：通过CSS或使用<code>width</code>属性设置百分比值，可以使图像在不同屏幕尺寸下自动调整大小，实现响应式设计。</p>
<blockquote>
<p>响应式设计（Responsive Design）是一种设计方法和技术，旨在使网页或应用程序能够根据不同设备（如桌面电脑、平板电脑、手机等）和屏幕尺寸的变化而自动调整其布局和外观。</p>
<p>传统的网页设计通常是为特定的屏幕尺寸和设备进行优化，这导致在不同设备上访问同一网页时可能会出现布局错乱、内容溢出等问题。而响应式设计的目标是提供一种灵活的布局和界面，使网页能够适应不同的屏幕尺寸，从而提供更好的用户体验。</p>
<p>在响应式设计中，通过使用CSS媒体查询（Media Queries）和流式布局（Fluid Layouts），可以根据屏幕宽度、高度、像素密度等特性，动态地调整网页元素的大小、位置和样式。这样，网页的内容和布局会根据设备的大小和方向进行自适应，以适应不同的屏幕。</p>
<p>就是，可以随着用户的放大和缩小图片的大小，或者设定图片的格式固定啥的。<br>(￣▽￣)ノ</p>
</blockquote>
</li>
<li><p>支持多种图像格式：<code>&lt;img&gt;</code>标签可以加载多种图像格式，如JPEG、PNG、GIF等。</p>
</li>
</ol>
<p>需要注意的是，图像的实际大小和显示效果会受到浏览器窗口大小、图像本身尺寸以及CSS样式的影响。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 默认样式 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.responsive-img</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-comment">/* 图片宽度填满父容器 */</span></span><br><span class="language-css">            <span class="hljs-attribute">height</span>: auto;</span><br><span class="language-css">            <span class="hljs-comment">/* 根据宽度等比例调整高度 */</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 在屏幕宽度小于等于600px时调整图片大小 */</span></span><br><span class="language-css">        <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;</span><br><span class="language-css">            <span class="hljs-selector-class">.responsive-img</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">                <span class="hljs-comment">/* 图片宽度为父容器宽度的50% */</span></span><br><span class="language-css">            &#125;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>插入图片试试<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.简单插入图片 由于尺寸太大了 限制一下--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\照片素材\800 (1).jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;报错了QAQ&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.alt用法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;im\照片素材\800 (1).jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;我是故意的&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 3.加个标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\照片素材\市.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;你好&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 4.响应式设计 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;responsive-img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\照片素材\雪山.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;响应式图片&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517213938193.png" alt="image-20230517213938193"></p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><h4 id="ul和li"><a href="#ul和li" class="headerlink" title="ul和li"></a>ul和li</h4><p><code>&lt;ul&gt;</code>（无序列表）和 <code>&lt;li&gt;</code>（列表项）是 HTML 中用于创建列表的标签，它们具有以下特点：</p>
<p><code>&lt;ul&gt;</code> 标签的特点：</p>
<ol>
<li>无序列表：<code>&lt;ul&gt;</code> 表示无序列表，其中的列表项 <code>&lt;li&gt;</code> 不会按照特定的顺序排列，而是作为一个项目列表显示。</li>
<li>项目符号：无序列表使用项目符号来表示每个列表项，默认情况下是一个实心圆点（•）。</li>
<li>嵌套列表：<code>&lt;ul&gt;</code> 元素可以嵌套在另一个 <code>&lt;ul&gt;</code> 或有序列表 <code>&lt;ol&gt;</code> 中，以创建多层级的列表。</li>
</ol>
<blockquote>
<p>ul理解为容器，像是状li的罐子</p>
</blockquote>
<p><code>&lt;li&gt;</code> 标签的特点：</p>
<ol>
<li>列表项：<code>&lt;li&gt;</code> 表示列表中的每个项目或条目。每个 <code>&lt;li&gt;</code> 标签通常包裹在 <code>&lt;ul&gt;</code> 或 <code>&lt;ol&gt;</code> 标签中。</li>
<li>顺序无关：<code>&lt;li&gt;</code> 列表项的排列顺序与其在代码中的位置无关，它们将按照显示时的顺序呈现。</li>
<li>嵌套列表项：<code>&lt;li&gt;</code> 列表项可以包含嵌套的列表，创建层级结构的子列表。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.构造一个简单无序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517222930214.png" alt="image-20230517222930214"></p>
<h4 id="ol和li"><a href="#ol和li" class="headerlink" title="ol和li"></a>ol和li</h4><p>在HTML中，<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>标签通常一起使用来创建有序列表。</p>
<p><code>&lt;ol&gt;</code>标签表示有序列表，具有以下特点：</p>
<ul>
<li>有序列表中的项目通常按照顺序进行编号，可以是数字、字母或罗马数字。</li>
<li><code>&lt;ol&gt;</code>标签创建一个包含多个列表项的块级元素。</li>
<li>有序列表项的默认样式是按照顺序编号显示。</li>
</ul>
<p><code>&lt;li&gt;</code>标签用于定义列表项，它的特点包括：</p>
<ul>
<li><code>&lt;li&gt;</code>标签包裹在<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>标签内部，表示一个列表项。</li>
<li>列表项可以包含文本、图像、链接或其他HTML元素。</li>
<li>列表项默认以项目符号或顺序编号显示，但可以通过CSS样式进行自定义。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.构造一个简单无序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.构造一个简单有序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第三项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517223129645.png" alt="image-20230517223129645"></p>
<h4 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h4><div>标签是HTML中用于定义一个文档的区域或容器的元素。它具有以下特点：

<ol>
<li><p>区域划分：div标签可以用来将HTML文档划分为不同的区域或块。通过使用<div>标签，可以将页面的不同部分进行逻辑上的分组，从而方便样式和布局的控制。</p>
</li>
<li><p>块级元素：div标签是一个块级元素，它在页面中独占一行。这意味着它会自动换行，并且可以设置宽度、高度、内边距和外边距等属性。</p>
</li>
<li><p>无语义性：div标签本身没有特定的语义含义，它只是一个通用的容器。它不会给其中的内容赋予特定的含义，而是依赖于CSS样式和嵌套的内容来定义其作用和意义。</p>
</li>
<li><p>可嵌套性：div标签可以嵌套在其他HTML元素中，也可以包含其他HTML元素，包括文本、图像、链接等。这使得它成为构建复杂页面结构和布局的重要工具。</p>
</li>
<li><p>样式控制：通过为<div>标签添加CSS类或ID，可以对其应用样式规则。这使得开发者可以通过定义相应的CSS样式，实现对<div>元素及其内容的外观和布局的定制。</p>
<blockquote>
<p>要修改<code>&lt;div&gt;</code>元素的大小，可以使用CSS样式来控制其宽度和高度。有几种常见的方法可以实现这一点：</p>
<ol>
<li>使用CSS的<code>width</code>和<code>height</code>属性：通过设置<code>width</code>属性来定义<code>&lt;div&gt;</code>元素的宽度，使用<code>height</code>属性来定义其高度。可以使用像素（px）、百分比（%）或其他支持的单位来指定具体的数值。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">cssCopy code<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.my-div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>  <img src="/2023/04/30/Web/image-20230518215731263.png" alt="image-20230518215731263"></p>
<ol start="2">
<li>使用CSS的<code>max-width</code>和<code>max-height</code>属性：这些属性允许指定元素的最大宽度和最大高度，如果内容不足以填满指定的尺寸，则元素的大小会自动调整。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">cssCopy code<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.my-div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">max-height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>  <img src="/2023/04/30/Web/image-20230518215751511.png" alt="image-20230518215751511"></p>
<ol start="3">
<li>使用CSS的<code>min-width</code>和<code>min-height</code>属性：这些属性允许指定元素的最小宽度和最小高度，确保元素不会小于指定的尺寸。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">cssCopy code<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.my-div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">min-width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2023/04/30/Web/image-20230518220351244.png" alt="image-20230518220351244"></p>
<p>怎么修改都不会小于40px</p>
</blockquote>
<p>这些是常见的方法，可以根据具体的需求和情况选择适合的方式来修改<code>&lt;div&gt;</code>元素的大小。</p>
<blockquote>
<p>注：可以在浏览器中，按f12进入调试，这样就可以调整数据来看盒子大小了。</p>
<p><img src="/2023/04/30/Web/image-20230518220007950.png" alt="image-20230518220007950"></p>
</blockquote>
</blockquote>
</li>
</ol>
<p>总之，div标签是HTML中的一个通用容器元素，用于划分页面区域和组织内容，它的特点包括块级元素、无语义性、可嵌套性和样式控制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- css样式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.my_div</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 设置我们盒子的高度 */</span></span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 修改第二个样式 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.my_div2</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 自动变形的盒子 */</span></span><br><span class="language-css">            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">max-height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.my_div3</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">min-width</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div盒子样式1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 类选择器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_div&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 1.可以装其他标签 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个结构是什么1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div盒子样式2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_div2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个结构是什么2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div盒子演示3<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_div3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个结构是什么3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="容器标签"><a href="#容器标签" class="headerlink" title="容器标签"></a>容器标签</h3><h4 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h4><p><code>&lt;span&gt;</code>标签是HTML中的一个内联元素，它用于对文本进行分组或标记，而不会对文本添加额外的语义或影响文档的结构。下面是<code>&lt;span&gt;</code>标签的几个特点：</p>
<ol>
<li><p>内联元素：<code>&lt;span&gt;</code>是内联元素，与其他内联元素（如<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>等）类似。它不会在文档中创建新的块级盒子，而是将其内容作为行内元素嵌入到文本中。</p>
<blockquote>
<p>内联元素（Inline Element）是HTML中的一种元素类型，它用于表示文档中的内联内容，这些内容通常嵌套在块级元素内部或直接位于文本流中。与块级元素不同，内联元素不会创建独立的块，并且它们在文档中水平排列，不会强制换行。</p>
<p>以下是内联元素的特点：</p>
<ol>
<li>水平排列：内联元素默认以水平方向排列，相邻的内联元素会在同一行上显示。</li>
<li>不独占一行：内联元素不会强制换行，除非遇到换行符或父元素的宽度不足以容纳内联内容。</li>
<li>无法设置宽度和高度：内联元素的宽度和高度通常由其内容决定，无法直接通过CSS属性设置固定的宽度和高度。</li>
<li>可以与其他内联元素共享水平空间：内联元素会根据其内容的大小动态分配水平空间，并且可以与其他内联元素共享同一行的空间。</li>
<li>支持部分CSS属性：内联元素支持一部分CSS属性，如颜色、字体大小、字体样式等，可以通过CSS样式对其进行样式调整。</li>
</ol>
<p>一些常见的内联元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>等。需要注意的是，并非所有元素都是内联元素，还有块级元素和行内块元素等不同类型的元素，它们具有不同的布局和行为特点。</p>
<p>使用内联元素可以方便地对文本或行内内容进行标记、样式化和操作，从而实现更灵活的页面设计和排版效果。</p>
<p><strong>可以理解为，内联标签是一个括号，可以将文本的一段括号起来，以便我们单独对这个括号执行修饰。^-^</strong></p>
</blockquote>
</li>
<li><p>无语义：<code>&lt;span&gt;</code>标签本身没有特定的语义含义。它主要用于通过CSS样式或JavaScript脚本来对文本进行分组、标记或添加样式。</p>
</li>
<li><p>文本容器：<code>&lt;span&gt;</code>可以包裹文本内容，使得可以对其中的文本进行样式或操作。它通常用于设置特定文本的样式，如颜色、字体大小、字体样式等。</p>
</li>
<li><p>嵌套使用：<code>&lt;span&gt;</code>标签可以嵌套在其他元素内部，以便于对特定部分进行样式控制。通过嵌套使用<code>&lt;span&gt;</code>，可以对文档进行更精细的标记和样式调整。</p>
<blockquote>
<p><code>&lt;span&gt;</code>标签是HTML中的一个内联元素，它没有特定的语义含义，主要用于对文本或行内内容进行分组、标记或样式化。下面是<code>&lt;span&gt;</code>标签的几个常见的用途：</p>
<p>文本标记：<code>&lt;span&gt;</code>标签可以用来标记文本的特定部分，以便后续通过CSS或JavaScript对其进行样式或操作。例如，可以给某个词语、短语或字符添加特定的样式或行为。</p>
<p><img src="/2023/04/30/Web/image-20230521194049707.png" alt="image-20230521194049707"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>高亮<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>样式控制：<code>&lt;span&gt;</code>标签可以用来包裹需要进行样式控制的文本或行内内容。通过为<code>&lt;span&gt;</code>标签添加CSS类或内联样式，可以对其内部的内容应用特定的样式属性，如颜色、字体大小、字体样式等。</p>
<p><img src="/2023/04/30/Web/image-20230521194102324.png" alt="image-20230521194102324"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-weight: bold;&quot;</span>&gt;</span>红色粗体<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>JavaScript操作：<code>&lt;span&gt;</code>标签可以用作JavaScript操作的目标元素。通过为<code>&lt;span&gt;</code>标签添加标识符或事件处理程序，可以对其进行动态操作或交互效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击这个<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clickable-text&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;你点击了文本！&#x27;)&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>可以触发一个弹窗。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230521194231941.png" alt="image-20230521194231941"></p>
<p>文本分组：<code>&lt;span&gt;</code>标签可以用于将文本或行内内容进行逻辑上的分组。通过使用<code>&lt;span&gt;</code>标签，可以在文本中划分多个区块，从而方便对这些区块进行整体样式或操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group1&quot;</span>&gt;</span>第一组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group2&quot;</span>&gt;</span>第二组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的文本。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230521194421688.png" alt="image-20230521194421688"></p>
<p>需要注意的是，<code>&lt;span&gt;</code>标签本身不会对文档结构产生显著影响，它主要用于样式和操作层面的处理。使用<code>&lt;span&gt;</code>标签需要结合CSS或JavaScript来实现相应的效果和功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 运行这个修饰style会显示字体颜色 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.highlight</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">font-weight</span>: bold;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.group1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.group2</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 运行这个函数的时候会弹出警告框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//警告提示行</span></span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>span标签的用法<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- span就是在文本中圈出一块区域，对这个区域可以用其他的例如css和js来操控这个圈出区域的文本样式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>突出显示<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的文本。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用span标签赋予文字属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>点击这里<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 段落之间会有合适间距，不用换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>高亮<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-weight: bold;&quot;</span>&gt;</span>红色粗体<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击这个<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clickable-text&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;你点击了文本！&#x27;)&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>可以触发一个弹窗。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group1&quot;</span>&gt;</span>第一组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group2&quot;</span>&gt;</span>第二组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的文本。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230521194453684.png" alt="image-20230521194453684"></p>
</blockquote>
</li>
</ol>
<p>下面是一个示例，展示了如何使用<code>&lt;span&gt;</code>标签为文本添加样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>红色文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-weight: bold;&quot;</span>&gt;</span>粗体文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>&lt;span&gt;</code>标签用于分别标记红色文本和粗体文本，并通过内联样式来指定它们的样式属性。</p>
<p>总结而言，<code>&lt;span&gt;</code>标签是一个非常通用的标签，用于对文本进行包装和样式控制。它在HTML文档中提供了灵活的文本处理能力，可用于各种定制和设计需求。</p>
<h4 id="table标签"><a href="#table标签" class="headerlink" title="table标签*"></a>table标签*</h4><p><code>&lt;table&gt;</code>标签是HTML中用于创建表格的元素。下面是<code>&lt;table&gt;</code>标签的一些特点：</p>
<ol>
<li><p>表格结构：<code>&lt;table&gt;</code>标签用于创建表格结构，它可以包含一个或多个行（<code>&lt;tr&gt;</code>标签），每行可以包含一个或多个单元格（<code>&lt;td&gt;</code>标签或<code>&lt;th&gt;</code>标签）。通过使用<code>&lt;table&gt;</code>标签及其相关标签，可以实现复杂的表格布局。</p>
<blockquote>
<p>可以将table分为三个部分，第一个部分是表头thead，另一个部分是表体tbody.最后一个是这个表的名称caption<br>在thead中，行修饰标tr是不变的，但是在内部我们要编写行的标题，也就是首行。内部标签变为th</p>
<p>在tbody中，行修饰标tr是不变的，内部标签变为td</p>
<p>在table中可以加入caption作为表的标题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用css样式设置边框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.table_1</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 边框合并 - 相邻有相同的元素就会合并在一起 */</span></span><br><span class="language-css">            <span class="hljs-attribute">border-collapse</span>: collapse;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 可以用table父类引用子类别 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.table_1</span> <span class="hljs-selector-tag">th</span>,</span><br><span class="language-css">        <span class="hljs-selector-class">.table_1</span> <span class="hljs-selector-tag">td</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 设置边框样式 */</span></span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>表修饰1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table_1&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 表标题 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>学生成绩表<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 首列标题 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 第一行 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>85<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>92<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 第二行 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>88<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>92<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>87<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230522140911732.png" alt="image-20230522140911732"></p>
</blockquote>
</li>
<li><p>行和列：表格由行和列组成。每个行使用<code>&lt;tr&gt;</code>标签表示，而每个单元格使用<code>&lt;td&gt;</code>标签表示。在表头部分，可以使用<code>&lt;th&gt;</code>标签表示表头单元格，用于标识列的标题或表格的相关信息。</p>
</li>
<li><p>单元格合并：通过使用<code>colspan</code>和<code>rowspan</code>属性，可以将单元格进行合并，从而跨越多个行或多个列。这使得可以创建具有复杂布局的表格。</p>
</li>
<li><p>表格标题和描述：可以使用<code>&lt;caption&gt;</code>标签为表格添加标题，用于描述表格的内容或目的。同时，可以使用<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>标签对表格内容进行分组，以提高可读性和语义性。</p>
</li>
<li><p>表格样式和格式：通过CSS可以对表格进行样式和格式化，如设置边框、背景色、字体样式等。使用CSS，还可以实现表格的响应式布局，以适应不同的屏幕尺寸和设备。</p>
</li>
<li><p>无障碍性支持：表格元素提供了一些属性和技术，以支持无障碍访问。例如，可以使用<code>scope</code>属性来指定表格单元格的作用范围，或者使用<code>headers</code>属性来建立单元格与表头之间的关联。</p>
</li>
</ol>
<p>需要注意的是，使用表格时应谨慎考虑其语义和结构，以确保表格的正确使用和可访问性。对于非表格数据或纯粹的布局需求，应该使用CSS布局技术而不是滥用表格元素。</p>
<p>总结而言，<code>&lt;table&gt;</code>标签是用于创建表格的HTML元素，它提供了创建、布局和样式化表格的功能。表格可以具有复杂的结构和样式，适用于展示和组织数据。</p>
<h4 id="from标签"><a href="#from标签" class="headerlink" title="from标签"></a>from标签</h4><p>表单（form）标签是HTML中用于创建用户交互表单的元素。下面是表单标签的一些特点：</p>
<ol>
<li>用户输入收集：表单标签用于创建包含用户输入字段的交互式表单，如文本输入框、复选框、单选按钮、下拉列表等。用户可以在表单中填写信息或选择选项。</li>
<li>数据提交：通过表单，用户可以将填写的数据提交到服务器或指定的处理程序进行处理。表单可以使用<code>&lt;form&gt;</code>标签指定提交方法（GET或POST）和目标URL。</li>
<li>表单字段：表单标签提供了一系列用于收集用户数据的字段标签，如<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等。这些标签可以设置不同类型的输入控件，以满足不同的数据输入需求。</li>
<li>表单控件组织：表单标签可以包含多个表单字段，通过在<code>&lt;form&gt;</code>标签内嵌套其他表单字段标签，可以组织和布局表单内容。</li>
<li>提交按钮：通过添加<code>&lt;input type=&quot;submit&quot;&gt;</code>或<code>&lt;button type=&quot;submit&quot;&gt;</code>标签，可以在表单中添加提交按钮，以便用户点击提交表单数据。</li>
<li>表单验证：HTML5提供了表单验证功能，可以通过设置表单字段的属性来进行客户端验证，如必填字段、最小长度、数据类型等。还可以使用JavaScript进行自定义的表单验证。</li>
<li>表单样式和布局：通过使用CSS，可以对表单进行样式化和布局控制，如设置字段的尺寸、背景色、边框样式等。使用CSS框架和技术，可以实现响应式表单布局。</li>
<li>安全性考虑：在处理敏感信息的表单时，应考虑使用安全传输协议（如HTTPS）以保护数据的安全性。</li>
</ol>
<p>需要注意的是，表单只是提供了前端的数据收集和提交机制，实际的数据处理和验证通常需要与后端服务器端编程语言（如PHP、Java、Python等）结合使用。</p>
<p>总结而言，表单标签用于创建用户交互表单，收集用户数据并提交到服务器进行处理。它提供了丰富的表单字段选项和验证功能，可通过CSS进行样式和布局控制。使用表单可以实现各种用户输入场景，如注册表单、登录表单、调查问卷等。</p>
<h3 id="小标签"><a href="#小标签" class="headerlink" title="小标签"></a>小标签</h3><h4 id="br标签"><a href="#br标签" class="headerlink" title="br标签"></a>br标签</h4><p><code>&lt;br&gt;</code>标签是HTML中用于创建换行的元素，它具有以下特点：</p>
<ol>
<li>换行功能：<code>&lt;br&gt;</code>标签用于在文本或行内内容中创建一个显式的换行。当浏览器遇到<code>&lt;br&gt;</code>标签时，会将文本或行内内容的换行位置断开，并在该位置插入一个换行符。</li>
<li>单标签：<code>&lt;br&gt;</code>标签是一个单标签，不需要闭合标签。它没有内容，只是一个用于表示换行的标记。</li>
<li>内联元素：<code>&lt;br&gt;</code>标签是内联元素（inline element），在默认情况下不会产生块级元素的换行效果。它可以在行内元素或块级元素内使用，用于插入换行符而不会创建新的块。</li>
<li>可嵌套性：<code>&lt;br&gt;</code>标签通常不会嵌套在其他标签内部，它在文本内容中直接使用，用于插入换行。</li>
<li>语义简单：<code>&lt;br&gt;</code>标签的语义非常简单明确，只表示一个显式的换行符，不会添加其他语义含义。</li>
</ol>
<p>需要注意的是，HTML中的换行通常由浏览器根据文本和元素的自然流进行处理。通常情况下，使用合适的HTML和CSS来实现布局和分隔效果，而不是过度依赖<code>&lt;br&gt;</code>标签进行换行。</p>
<p>使用<code>&lt;br&gt;</code>标签时应注意适度使用，避免滥用，以保持代码的可读性和语义化。在大多数情况下，最好使用合适的HTML元素和CSS样式来实现更灵活和语义化的布局效果。</p>
<h4 id="hr标签"><a href="#hr标签" class="headerlink" title="hr标签"></a>hr标签</h4><p><code>&lt;hr&gt;</code>标签是HTML中用于创建水平分隔线的元素，它具有以下特点：</p>
<ol>
<li>分隔线功能：<code>&lt;hr&gt;</code>标签用于在文档中创建一条水平的分隔线，可以用于将内容分隔为不同的段落或节。</li>
<li>单标签：<code>&lt;hr&gt;</code>标签是一个单标签，不需要闭合标签。它表示一个完整的水平分隔线，不包含任何内容。</li>
<li>默认样式：<code>&lt;hr&gt;</code>标签具有默认的样式属性，通常表现为一条水平线，具体的样式可以通过CSS进行自定义。</li>
<li>块级元素：<code>&lt;hr&gt;</code>标签在默认情况下是一个块级元素，会独占一行。它会创建一个与其他块级元素（如段落、标题等）相邻的分隔线。</li>
<li>可调整性：<code>&lt;hr&gt;</code>标签可以通过CSS进行样式调整，如设置颜色、宽度、边距等。通过调整样式属性，可以改变分隔线的外观和布局。</li>
<li>语义简单：<code>&lt;hr&gt;</code>标签的语义非常简单明确，只表示一个水平分隔线，不会添加其他语义含义。</li>
</ol>
<p>需要注意的是，<code>&lt;hr&gt;</code>标签在现代Web开发中的使用逐渐减少，因为分隔线的样式和布局通常可以通过CSS来实现，从而提供更大的灵活性和控制。因此，在实际应用中，最好使用合适的HTML元素和CSS样式来实现分隔线的效果，而不是依赖于<code>&lt;hr&gt;</code>标签。</p>
<p>使用<code>&lt;hr&gt;</code>标签时应注意适度使用，避免滥用，以保持代码的可读性和语义化。在大多数情况下，最好使用CSS样式来创建定制化的分隔线，以满足具体的设计和布局需求。</p>
<h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><p>CSS（层叠样式表，Cascading Style Sheets）是一种用于描述网页（HTML 或 XML 等文档）外观和样式的标记语言。它与 HTML 一起使用，通过为 HTML 元素应用样式规则，控制网页的布局、字体、颜色、大小和其他视觉方面的属性。</p>
<p>CSS 提供了一种将样式与内容分离的方法，使得开发人员可以单独管理网页的样式而无需修改 HTML 结构。通过使用 CSS，可以在不改变网页内容的情况下改变其外观和布局，从而实现更好的灵活性和可维护性。</p>
<p>CSS 使用选择器来选择要应用样式的 HTML 元素，然后使用属性和值来定义元素的样式。可以通过内联样式表、嵌入式样式表或外部样式表的方式将 CSS 应用到 HTML 文档中。</p>
<p>CSS 是 Web 开发中的重要技术之一，它使得网页设计变得更加灵活和美观，并提供了更好的用户体验。</p>
<blockquote>
<p>可以创建一个新的css样式文件，并将css和html链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接文件&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>相应的，我们要记住css常见的功能</p>
<blockquote>
<p>CSS具有许多功能和特性，用于控制和样式化网页的外观和布局。以下是CSS中常用的一些功能：</p>
<ol>
<li>选择器：CSS选择器用于选择要应用样式的HTML元素。常见的选择器包括类选择器（.class）、ID选择器（#id）、元素选择器（element）等，还有更高级的选择器如属性选择器、伪类选择器和伪元素选择器等。</li>
<li>盒子模型：CSS盒子模型描述了HTML元素的布局结构，包括内容区域、内边距、边框和外边距。通过控制盒子模型的属性（如width、height、padding、border、margin），可以实现元素的尺寸和间距的调整。</li>
<li>字体和文本样式：CSS提供了丰富的字体和文本样式属性，包括字体族（font-family）、字体大小（font-size）、字体粗细（font-weight）、行高（line-height）、文字颜色（color）等，可以用于设置元素的文本样式。</li>
<li>背景和边框：CSS提供了一系列的背景属性（如background-color、background-image、background-size）和边框属性（如border-color、border-style、border-width），用于设置元素的背景和边框样式。</li>
<li>定位和布局：CSS提供了多种定位和布局属性，如position（用于设置元素的定位方式）、display（用于设置元素的显示方式）、float（用于实现元素的浮动布局）、flexbox（用于弹性盒子布局）和grid（用于网格布局）等，可以实现灵活的页面布局。</li>
<li>动画和过渡：CSS动画和过渡属性（如animation、transition）允许在元素上创建平滑的过渡效果和动画效果，使页面更具交互性和生动性。</li>
<li>响应式设计：通过使用CSS媒体查询和响应式布局技术，可以根据设备的不同屏幕尺寸和特性，自适应地调整网页的布局和样式，以提供更好的用户体验。</li>
</ol>
<p>这只是CSS的一小部分功能，还有许多其他功能和属性可用于创建丰富的网页样式和布局。CSS的灵活性使得开发人员能够自定义和控制网页的外观和行为。</p>
</blockquote>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>CSS选择器用于选择网页中的特定元素，从而将样式应用于这些元素。它们允许您根据元素的标签名、类名、ID、属性等特征来选择元素。</p>
<p>使用CSS选择器，您可以针对不同的元素应用不同的样式，或者根据需要对一组元素进行样式化。通过选择器，您可以精确地控制网页中的元素，并根据需要调整其外观和布局。</p>
<blockquote>
<p>在选择器中，有一些常见的属性是我们要记住的。</p>
<ol>
<li><code>color</code>：用于设置文本颜色，可以使用颜色名称、十六进制值或RGB值。</li>
<li><code>background-color</code>：用于设置元素的背景颜色，同样可以使用颜色名称、十六进制值或RGB值。</li>
<li><code>font-size</code>：用于设置字体大小，可以使用像素、百分比、em等单位。</li>
<li><code>font-family</code>：用于设置字体家族，可以指定多个字体备选项。</li>
<li><code>font-weight</code>：用于设置字体粗细，可以使用关键词如<code>normal</code>、<code>bold</code>，或使用数值如<code>400</code>、<code>700</code>。</li>
<li><code>text-align</code>：用于设置文本对齐方式，可以是<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code>等。</li>
<li><code>width</code>、<code>height</code>：用于设置元素的宽度和高度，可以使用像素、百分比、em等单位。</li>
<li><code>margin</code>、<code>padding</code>：用于设置元素的外边距和内边距，可以使用像素、百分比、em等单位。</li>
<li><code>border</code>：用于设置元素的边框样式，可以指定边框宽度、边框颜色和边框样式。</li>
<li><code>display</code>：用于设置元素的显示方式，如<code>block</code>、<code>inline</code>、<code>inline-block</code>等。</li>
</ol>
</blockquote>
<p>class选择器</p>
<p>类选择器是CSS中一种常用的选择器，用于选择具有相同类名的元素并应用相应的样式。以下是类选择器的一些特点：</p>
<ol>
<li><p>选择多个元素：类选择器可以选择HTML文档中具有相同类名的多个元素，并为它们应用相同的样式。</p>
</li>
<li><p>重复使用：可以在同一个HTML文档中多次使用相同的类名，从而在不同位置和元素上应用相同的样式。</p>
</li>
<li><p>独立于元素类型：类选择器与元素类型无关，可以应用于任意HTML元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code> 等等。</p>
</li>
<li><p>可组合：可以将类选择器与其他选择器组合使用，以更精确地选择和样式化元素。例如，结合标签选择器和类选择器可以选择特定类型的元素中具有特定类名的元素。</p>
</li>
<li><p>优先级较低：类选择器的优先级相对较低，如果与其他选择器具有相同的特定性（specificity），其他选择器的样式可能会覆盖类选择器的样式。</p>
</li>
<li><p>可重复使用性和可维护性：通过使用类选择器，可以在多个元素上应用相同的样式，并且可以在整个网站上重复使用相同的类名，从而实现样式的重用和维护性。</p>
<blockquote>
<p> 类选择器的使用十分简单，在标签内部加入类名称，就可以对这个标签进行操作了。如果想要使用css，就在style样式中，用**.**操作符操作对应标签的类名就行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css_1.css&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置了类选择器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heading&quot;</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;paragraph&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 标签样式 */</span><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>    <span class="hljs-attribute">font-family</span>: Arial, sans-serif;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-comment">/* 容器的样式 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heading</span> &#123;<br>    <span class="hljs-comment">/* 标题的样式 */</span><br>    <span class="hljs-attribute">color</span>: aqua;<br>&#125;<br><br><span class="hljs-selector-class">.paragraph</span> &#123;<br>    <span class="hljs-comment">/* 段落的样式 */</span><br>    <span class="hljs-attribute">color</span>: wheat;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>id选择器</p>
<p>ID选择器在Web开发中具有以下特点：</p>
<ol>
<li><p>唯一性：每个HTML文档中的ID应该是唯一的。一个元素只能有一个ID，不能重复使用。这使得ID选择器非常适合选择具有特定标识符的单个元素。</p>
<blockquote>
<p>如果在HTML文档中违反了ID选择器的唯一性原则，即多个元素具有相同的ID，可能会导致以下问题：</p>
<ol>
<li>不可预测的行为：当多个元素具有相同的ID时，根据HTML规范，浏览器只会选择第一个具有该ID的元素作为目标元素。其他具有相同ID的元素将被忽略。这可能导致无法预测的行为，例如样式应用于错误的元素或JavaScript操作作用于错误的元素。</li>
<li>样式冲突：如果多个元素具有相同的ID并且应用了不同的样式规则，那么由于ID选择器的高优先级，只有第一个具有该ID的元素将应用正确的样式规则。其他具有相同ID的元素将无法正确显示所期望的样式。</li>
<li>JavaScript操作错误：如果在JavaScript中使用了重复的ID，并且依赖于通过ID选择器获取元素或处理元素的特定行为，将会出现问题。JavaScript操作可能应用于错误的元素或无法正常工作。</li>
</ol>
<p>总之，违反ID选择器的唯一性原则会引发不可预测的行为、样式冲突和JavaScript操作错误。为了避免这些问题，应确保在HTML文档中每个ID都是唯一的，并合理使用其他选择器来选择多个元素。</p>
</blockquote>
</li>
<li><p>高优先级：ID选择器的优先级非常高，比其他选择器（如类选择器、元素选择器）更具特权。当使用ID选择器选择一个元素时，它的权重比其他选择器更高，这意味着它的样式规则将覆盖其他选择器的样式规则。</p>
</li>
<li><p>快速查找：由于ID在文档中应该是唯一的，浏览器可以通过ID快速准确定位到对应的元素。因此，使用ID选择器可以提高选择元素的效率和性能。</p>
</li>
<li><p>用途广泛：ID选择器常用于为特定的元素应用唯一的样式规则或添加特定的JavaScript交互行为。通过给元素添加ID，可以方便地针对该元素进行样式设置或JavaScript操作。</p>
</li>
<li><p>不易复用：由于ID选择器的唯一性，通常不建议将ID选择器用于多个元素。如果多个元素具有相同的样式或行为，应该使用类选择器或其他更适合的选择器。</p>
</li>
</ol>
<p>需要注意的是，在编写CSS样式时，应合理使用ID选择器，并避免过度依赖ID选择器的高优先级。合理选择合适的选择器可以使代码更具灵活性、可维护性和可复用性。</p>
<blockquote>
<p>使用方法和类选择器是一样的（基本上所有的都是一样的），只是在css中，不再使用.而是改为#</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hlf&quot;</span>&gt;</span>djaslkhflkas<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#hlf</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>CSS中有多个用于设置元素背景的属性，包括以下常用属性：</p>
<ol>
<li><p>background-color：设置元素的背景颜色。可以使用颜色名称、十六进制值、RGB值或RGBA值来指定颜色。例如：<code>background-color: blue;</code></p>
<blockquote>
<p><img src="/2023/04/30/Web/image-20230523121833418.png" alt="image-20230523121833418"></p>
</blockquote>
</li>
<li><p>background-image：设置元素的背景图像。可以指定图像的URL路径或使用<code>url()</code>函数。例如：<code>background-image: url(&#39;image.jpg&#39;);</code></p>
</li>
<li><p>background-repeat：指定背景图像的重复方式。常见的取值有：<code>repeat</code>（默认，图像在水平和垂直方向上平铺）、<code>repeat-x</code>（只在水平方向上平铺）、<code>repeat-y</code>（只在垂直方向上平铺）、<code>no-repeat</code>（不重复）等。</p>
</li>
<li><p>background-position：指定背景图像的位置。可以使用关键字（如<code>left</code>、<code>center</code>、<code>right</code>、<code>top</code>、<code>bottom</code>）或百分比值、像素值来定位。例如：<code>background-position: center top;</code></p>
</li>
<li><p>background-size：设置背景图像的大小。可以使用关键字（如<code>auto</code>、<code>cover</code>、<code>contain</code>）或像素值、百分比值来指定大小。例如：<code>background-size: cover;</code></p>
</li>
<li><p>background-attachment：指定背景图像的滚动行为。常见的取值有：<code>scroll</code>（默认，背景图像会随着元素内容的滚动而滚动）、<code>fixed</code>（背景图像固定在视口中，不随滚动而移动）等。</p>
</li>
<li><p>background-origin：指定背景图像的定位起点。常见的取值有：<code>padding-box</code>（背景图像相对于内边距框定位）、<code>border-box</code>（背景图像相对于边框框定位）、<code>content-box</code>（背景图像相对于内容框定位）等。</p>
</li>
<li><p>background-clip：指定背景图像的裁剪区域。常见的取值有：<code>border-box</code>（默认，背景图像延伸到边框外沿）、<code>padding-box</code>（背景图像延伸到内边距外沿）、<code>content-box</code>（背景图像裁剪为内容框内部）等。</p>
</li>
</ol>
<p>这些属性可以单独使用或组合使用，通过设置不同的值来创建各种背景效果。</p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>在CSS中，可以使用边框属性来定义元素的边框样式、宽度和颜色。以下是常用的边框属性：</p>
<ol>
<li>border-width：设置边框的宽度。可以使用像素值、百分比值或预定义的关键字（如<code>thin</code>、<code>medium</code>、<code>thick</code>）来指定。例如：<code>border-width: 2px;</code></li>
<li>border-style：设置边框的样式。常见的取值有：<code>none</code>（无边框）、<code>solid</code>（实线边框）、<code>dotted</code>（点状边框）、<code>dashed</code>（虚线边框）等。例如：<code>border-style: solid;</code></li>
<li>border-color：设置边框的颜色。可以使用颜色名称、十六进制值、RGB值或RGBA值来指定颜色。例如：<code>border-color: red;</code></li>
<li>border：可以同时设置边框的宽度、样式和颜色。属性值的顺序可以是宽度、样式和颜色，也可以是样式、宽度和颜色。例如：<code>border: 2px solid red;</code></li>
<li>border-radius：设置边框的圆角半径，使边框呈现圆角效果。可以指定一个值来应用相同的圆角半径，或使用四个值分别指定每个角的圆角半径。例如：<code>border-radius: 5px;</code> 或 <code>border-radius: 5px 10px 15px 20px;</code></li>
</ol>
<p>这些边框属性可以在单独的样式规则中使用，也可以组合在一起来创建自定义的边框样式。同时，还可以使用<code>border-top</code>、<code>border-right</code>、<code>border-bottom</code>和<code>border-left</code>属性分别设置上、右、下和左边框的样式、宽度和颜色。</p>
<h3 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h3><p>在CSS中，盒子（Box）是用于布局和定位元素的基本单位。每个元素都被看作一个矩形盒子，具有四个边框、内边距和内容区域。以下是与CSS盒子相关的常见属性：</p>
<ol>
<li>width：设置盒子的宽度。可以使用像素值、百分比值或其他长度单位来指定。例如：<code>width: 200px;</code></li>
<li>height：设置盒子的高度。与<code>width</code>属性类似，可以使用不同的单位来指定高度。</li>
<li>padding：设置盒子的内边距。内边距是指元素内容与边框之间的空间。可以使用像素值或百分比值来指定内边距。例如：<code>padding: 10px;</code> 或 <code>padding: 10px 20px;</code>（分别表示上下内边距为10像素，左右内边距为20像素）。</li>
<li>border：设置盒子的边框样式、宽度和颜色。可以使用<code>border-width</code>、<code>border-style</code>和<code>border-color</code>属性分别指定边框的宽度、样式和颜色。例如：<code>border: 1px solid black;</code></li>
<li>margin：设置盒子的外边距。外边距是指元素与相邻元素之间的间隔。可以使用像素值或百分比值来指定外边距。例如：<code>margin: 10px;</code> 或 <code>margin: 10px 20px;</code>（分别表示上下外边距为10像素，左右外边距为20像素）。</li>
<li>box-sizing：定义元素的盒模型计算方式。常见的取值有：<code>content-box</code>（默认，宽度和高度只包括内容区域）、<code>border-box</code>（宽度和高度包括内容区域、内边距和边框）等。</li>
</ol>
<p>这些属性用于控制盒子的尺寸、内外边距和边框样式。通过合理地使用这些属性，可以实现灵活的布局和设计效果。</p>
]]></content>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>md标注方法</title>
    <url>/2023/04/21/%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="md的书写样式练习"><a href="#md的书写样式练习" class="headerlink" title="md的书写样式练习"></a><strong>md的书写样式练习</strong></h2><h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a><strong>书写格式</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">代码框书写格式<br>     <span class="hljs-string">&quot;``` bash(这里是代码的样式 - 看你输入的是什么语言)&quot;</span> <br>        中间这里输入你的代码<br>     <span class="hljs-string">&quot;```&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="Front-matter修改"><a href="#Front-matter修改" class="headerlink" title="Front-matter修改"></a><strong>Front-matter修改</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">Page Front-matter 用于页面配置<br>Post Front-matter 用于文章页配置<br>    这两个就是你md文档的最顶部的两个 --- ---之间,用来配置hexo的网页功能<br><br><span class="hljs-comment"># 功能样式</span><br><span class="hljs-comment"># 当前文章题目</span><br>title:  <br><span class="hljs-comment"># 当前文章创建日期</span><br><span class="hljs-built_in">date</span>:<br><span class="hljs-comment"># 当前文章更新日期</span><br>updated:<br><span class="hljs-comment"># 标签、分类和友情链接三个页面需要配置 - 这个是啥暂时不知道</span><br><span class="hljs-built_in">type</span>:<br><span class="hljs-comment"># 显示评论模块(默认 true)</span><br>comments:<br><span class="hljs-comment"># 页面描述</span><br>description:<br><span class="hljs-comment"># 页面关键字</span><br>keywords:<br><span class="hljs-comment"># 顶部图片 - 这里修改优先级最高</span><br>top_img:<br><span class="hljs-comment"># 显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false) - 不清楚</span><br>mathjax:<br><span class="hljs-comment"># 【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false) - 不清楚</span><br>katex:<br><span class="hljs-comment"># 显示侧边栏 (默认 true)</span><br>aside:<br><span class="hljs-comment"># 在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br>aplayer:<br><span class="hljs-comment"># 配置代码框是否展开 (true/false) (默认为设置中highlight_shrink的配置)</span><br>highlight_shrink:<br></code></pre></td></tr></table></figure>

<h3 id="md-表格创建"><a href="#md-表格创建" class="headerlink" title="md_表格创建"></a><strong>md_表格创建</strong></h3><p>要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列.您可以选择在表的任一端添加管道</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++">| Syntax    | Description |<br>| --------- | ----------- |<br>| Header    | Title       |<br>| Paragraph | Text        |<br></code></pre></td></tr></table></figure>

<p>实现效果</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody></table>
<p>创建表格可以使用：<a href="https://www.tablesgenerator.com/markdown_tables"><strong>label</strong></a>是一个创建md格式表格的好工具</p>
<h3 id="md基础语法"><a href="#md基础语法" class="headerlink" title="md基础语法"></a><strong>md基础语法</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>标题：<br>    在头部用<span class="hljs-string">&quot;#&quot;</span>修饰即可，<span class="hljs-string">&quot;#&quot;</span>数量代表着标题的序数。还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。<br><span class="hljs-number">2.</span>段落：<br>    在需要分段的文字尾部，两个空格以上就是独立的段落了。（有个问题就是，上下空格数是否要相同）。注意的是，md语法中没有缩进段落的选项，所以说不能用缩进来操作段落。<br><span class="hljs-number">3.</span>换行：<br>    建议用&lt;br&gt; - html中的语法。<br><span class="hljs-number">4.</span>强调<br>    在两边加入两个*,就可以加粗我们选中的字体了。<br><span class="hljs-number">5.</span>斜体<br>    添加一个*就可以实现斜体。<br><span class="hljs-number">6.</span>强调斜体<br>    加三个***就可以了<br><span class="hljs-number">7.</span>引用<br>    &gt;添加一个这个符号就可以实现引用框框了，如果多加一个&gt;就是嵌套环境,<br>&gt; <br>&gt; <span class="hljs-comment">//上面就是初级引用</span><br>&gt;&gt; <span class="hljs-comment">//这样子就算是嵌套了</span><br><span class="hljs-number">8.</span>无序列表<br>    - 空格 加入输入的文字，这就算是一个无序列表了<br><span class="hljs-number">9.</span>列表<br>    可以用html中的创建列表的语法，&lt;ol&gt; &gt; &lt;li&gt; *。或者直接在前面加上标题就可以<br></code></pre></td></tr></table></figure>

<h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a><strong>嵌套规则</strong></h3><h4 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a><strong>在列表中嵌套其他元素</strong></h4><p>我们简单创建一个无序列表：</p>
<ul>
<li>三天打鱼两天晒网</li>
<li>六天打鱼四天晒网</li>
</ul>
<p>我们在其中插入一个引用数据，只需要用到&gt;即可</p>
<ul>
<li>三天打鱼两天晒网<blockquote>
<p>不能打鱼，我们要摆烂 ૮꒰ ˶• ༝ •˶꒱ა</p>
</blockquote>
</li>
<li>六天打鱼四天晒网<blockquote>
<p>不能打鱼，我们要摆烂 ૮꒰ ˶• ༝ •˶꒱ა</p>
</blockquote>
</li>
</ul>
<p>要是想要在列表中输入代码框,就直接用代码行格式就行（没必要用几个制表符或者空格来说明）。</p>
<ul>
<li>写一个简单代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>写两个简单代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    cin&gt;&gt;a;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。</p>
<hr>
<p>如果出现了其他内容，就会变成这样</p>
<p>——-你好,所以说不要在分割线上加东西</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">[]() - 中括号中写入的是你要实现的超链接的名称<br>     - 小括号中写入的是你要跳转的链接<br></code></pre></td></tr></table></figure>

<p>超链接格式和我们的图片格式是相似的 <a href="https://markdown.com.cn/basic-syntax/links.html"><strong>md语法</strong></a></p>
<hr>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">图片格式限定，![]()，[] - 是照片的名字，()是照片的文件地址<br>和超链接比较就多了一个！<br>存储文件的时候记得，新开一个文件夹，以防图片数据互相影响<br></code></pre></td></tr></table></figure>

<p>图片演示</p>
<p><img src="/../picture/format/Different%20from%20the%20usual%20of%20you.jpg" alt="与平常的你不同"></p>
<h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;&gt; - (这里面放的是网址信息，出现的链接这样就可以点击了)<br></code></pre></td></tr></table></figure>

<p><a href="https://markdown.com.cn/">https://markdown.com.cn</a></p>
<h4 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h4><p>强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">就是在链接处加入我们的强调修饰符号：**[]()**<br></code></pre></td></tr></table></figure>

<p>渲染效果如下（还有其他链接方式暂时不学）：</p>
<!-- 这里是强调链接 链接不一定存在 -->
<p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em></p>
<hr>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><h4 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h4><p><img src="/../picture/format/turn.png" alt="转义字符"></p>
]]></content>
  </entry>
  <entry>
    <title>c#</title>
    <url>/2023/05/29/c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C#基础"></a>C#基础</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>简单介绍一下c#“简单操作”，基本上学过其他语言的都是通用的，简单看看就行。如果在序号之前看到了*，说明这个知识点比较抽象（或者没啥用），建议多查👋</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> _001_第一个程序<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这段代码是一个简单的C#程序框架示例，它包含了一些常见的命名空间和一个包含<code>Main</code>方法的类。</p>
<ol>
<li><p><code>using</code>语句：在代码的开头，使用了一系列的<code>using</code>语句来引入不同的命名空间。这些命名空间包括<code>System</code>、<code>System.Collections.Generic</code>、<code>System.Linq</code>、<code>System.Text</code>和<code>System.Threading.Tasks</code>等。通过引入这些命名空间，我们可以在代码中直接使用这些命名空间中定义的类型和成员，而无需使用完全限定名。</p>
<blockquote>
<p>命名空间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br></code></pre></td></tr></table></figure>

<p>C#中的命名空间（Namespace）用于组织和管理代码，它具有以下作用：</p>
<ol>
<li>避免命名冲突：命名空间可以防止不同代码元素（类、结构、接口、枚举等）之间的命名冲突。通过将相关的代码元素放置在同一个命名空间中，可以确保它们的名称在该命名空间内是唯一的。</li>
<li>提供代码组织结构：命名空间提供了一种逻辑上组织和划分代码的方式。你可以根据功能、模块或其他逻辑关系将相关的类型放置在同一个命名空间中，以便更好地组织和管理代码。</li>
<li>支持代码重用和模块化：通过使用命名空间，可以将代码分割成多个逻辑模块，使得这些模块可以在不同的项目或文件中进行重用。通过引用适当的命名空间，可以在代码中访问和使用其他命名空间中定义的类型和成员。</li>
<li>提供代码可见性控制：命名空间也可以用于控制类型和成员的可见性。在C#中，命名空间可以被限定为特定的访问修饰符（例如<code>public</code>、<code>internal</code>等），从而决定其内部的类型和成员是否可以被其他代码访问。</li>
<li>与类库和命名空间的组织结构对应：C#标准类库和第三方类库通常使用命名空间来组织和命名其提供的类型和功能。通过使用相应的命名空间，你可以引用并使用这些类库中的类型和成员。</li>
</ol>
<p>总之，C#中的命名空间提供了一种组织、管理和访问代码的机制，能够避免命名冲突，提供代码重用和模块化，控制代码可见性，并与类库和模块的组织结构对应。它是代码组织和协作的重要工具。</p>
</blockquote>
</li>
<li><p>命名空间：代码中定义了一个名为<code>_001_第一个程序</code>的命名空间。命名空间用于组织和管理代码，它可以包含类、结构、接口、枚举等代码元素。在这个示例中，命名空间内部只包含一个类<code>Program</code>。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> _001_第一个程序<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在C#中，自定义命名空间时需要遵循以下规则：</p>
<ol>
<li>命名空间名称必须是有效的标识符：命名空间的名称必须符合C#中有效标识符的规则。它可以包含字母、数字和下划线，并且必须以字母或下划线开头。</li>
<li>命名空间可以使用层次结构：命名空间可以包含多个层次，使用<code>.</code>进行分隔。例如，命名空间可以是<code>MyNamespace</code>、<code>MyNamespace.SubNamespace</code>、<code>MyNamespace.SubNamespace.SubSubNamespace</code>等。</li>
<li>命名空间应具有描述性：命名空间的名称应该具有描述性，能够清楚地表达其所包含代码的目的或功能。例如，如果你正在创建一个与日志记录相关的代码，可以选择一个描述性的命名空间名称，如<code>MyCompany.Logging</code>。</li>
<li>避免与现有命名空间冲突：在自定义命名空间时，应避免与已有的系统命名空间或其他第三方库的命名空间发生冲突。可以通过选择唯一的命名空间名称、使用公司名或项目名作为前缀等方式来避免冲突。</li>
<li>命名空间与目录结构可以对应：在组织项目文件时，可以将命名空间与文件的物理目录结构相对应。这有助于在代码文件的组织和查找方面更加直观和一致。</li>
<li>命名空间的规范化：根据一般的命名约定，命名空间的首字母应大写，采用帕斯卡命名法（PascalCase）。例如，<code>MyNamespace</code>、<code>MyNamespace.SubNamespace</code>。</li>
</ol>
<p>总之，自定义命名空间时需要确保名称符合C#中有效标识符的规则，具有描述性，避免与现有命名空间冲突，可以与文件的目录结构对应，符合命名约定。这些规则有助于编写清晰、可维护的代码，并提供一致性和可读性。</p>
</blockquote>
</li>
<li><p>类：在命名空间中定义了一个名为<code>Program</code>的类。这是程序的入口点，其中包含一个静态的<code>Main</code>方法。<code>Main</code>方法是C#程序的起始执行点，它是程序开始运行的地方。在这个示例中，<code>Main</code>方法没有任何具体的代码</p>
</li>
</ol>
<h4 id="变量标识符"><a href="#变量标识符" class="headerlink" title="变量标识符"></a>变量标识符</h4><p>变量标识符是用来命名变量的名称，它具有以下特点：</p>
<ol>
<li><p>标识符必须是有效的标识符：变量标识符必须符合C#中有效标识符的规则。它可以包含字母、数字和下划线，并且必须以字母或下划线开头。标识符区分大小写，因此大小写敏感。</p>
</li>
<li><p>标识符应具有描述性：变量标识符应该具有描述性，能够清晰地表达所代表的变量的含义和用途。良好的标识符命名有助于提高代码的可读性和可维护性。</p>
</li>
<li><p>遵循命名约定：在C#中，通常采用驼峰命名法（camelCase）来命名变量。这意味着标识符的第一个单词以小写字母开头，后续的每个单词的首字母大写。例如，<code>myVariable</code>、<code>firstName</code>。</p>
<blockquote>
<p>驼峰命名法（CamelCase）是一种命名约定，用于命名标识符（如变量、函数、属性、类等）。它的命名规则如下：</p>
<ol>
<li>第一个单词以小写字母开头：首字母小写，后续单词的首字母大写。</li>
<li>单词之间没有空格或其他分隔符：所有单词连续写在一起，没有空格或其他分隔符。</li>
</ol>
<p>驼峰命名法分为两种形式：</p>
<ol>
<li>小驼峰命名法（lowerCamelCase）：第一个单词的首字母小写，后续单词的首字母大写。例如：<code>myVariable</code>、<code>firstName</code>。</li>
<li>大驼峰命名法（PascalCase）：每个单词的首字母都大写。例如：<code>MyVariable</code>、<code>FirstName</code>。</li>
</ol>
<p>驼峰命名法的目的是使标识符具有更好的可读性和一致性，并提供一种清晰的命名约定。它在C#编程中被广泛使用，并且也是许多其他编程语言中常见的命名约定之一。</p>
<p>以下是一些使用驼峰命名法的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeint myVariable = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">string</span> firstName = <span class="hljs-string">&quot;John&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-built_in">int</span> myProperty &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">myMethod</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总之，驼峰命名法是一种命名约定，根据首字母的大小写来区分单词，并且没有空格或其他分隔符。它有助于提高代码的可读性和一致性。</p>
</blockquote>
</li>
<li><p>不使用保留字：标识符不能是C#的保留字（关键字），因为保留字具有特殊的意义和用途，用于编程语言本身的语法和功能。</p>
</li>
<li><p>尽量简洁明确：标识符应该尽量简洁明确，避免过长或过于复杂的命名。一个好的标识符能够准确地表达变量的用途，同时也便于代码的编写和阅读。</p>
</li>
<li><p>语义正确：标识符应该与变量的含义和类型相符。它们应该能够清晰地表达变量所代表的数据或对象。</p>
</li>
<li><p>遵循命名约定和项目规范：在特定的项目或团队中，可能会有特定的命名约定或规范。遵循这些规范可以保持代码风格的一致性，并使不同开发者之间更容易理解和协作。</p>
</li>
</ol>
<p>总的来说，变量标识符是用于命名变量的名称，应符合C#中有效标识符的规则，具有描述性，遵循命名约定，不使用保留字，简洁明确，并与变量的含义和类型相符。良好的标识符命名有助于编写易读、易维护的代码。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 C# 中，变量具有以下规则：</p>
<ol>
<li><p>命名规则：</p>
<ul>
<li>变量名称必须以字母或下划线 <code>_</code> 开头。</li>
<li>变量名称可以包含字母、数字和下划线。</li>
<li>变量名称区分大小写。</li>
</ul>
</li>
<li><p>关键字保留：</p>
<ul>
<li>不可以使用 C# 中的关键字作为变量名称。例如，<code>int</code>、<code>string</code>、<code>if</code> 等都是关键字，不能用作变量名。</li>
</ul>
</li>
<li><p>类型声明：</p>
<ul>
<li>变量必须先声明后使用。在声明变量时，需要指定变量的类型。</li>
</ul>
</li>
<li><p>类型安全：</p>
<ul>
<li><p>C# 是一种静态类型语言，变量在声明时需要指定其类型，且变量的类型在编译时就确定了。类型安全意味着变量在使用过程中必须与其声明的类型匹配，不允许类型之间的隐式转换（除非使用显式类型转换）。</p>
<blockquote>
<p>当说到C#是一种静态类型语言时，意味着在编译时，每个变量都必须被显式地声明为某种类型。这意味着在声明变量时，必须指定变量的数据类型，例如整数 (<code>int</code>)、字符串 (<code>string</code>)、布尔值 (<code>bool</code>) 等。</p>
<p>一旦变量被声明为某种类型，它的类型就在编译时确定，无法在运行时更改。这为编译器提供了类型检查的机会，以确保变量在使用过程中与其声明的类型匹配。</p>
<p>类型安全的概念是指在使用变量时，变量的类型必须与其声明的类型相匹配，否则将产生编译时错误。这意味着在对变量进行操作、赋值或传递给函数时，需要保证类型的一致性。</p>
<p>举个例子，假设有以下代码片段：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeint num = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">string</span> text = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-built_in">int</span> result = num + text; <span class="hljs-comment">// 编译时错误：不能将 int 类型和 string 类型相加</span><br></code></pre></td></tr></table></figure>

<p>在上面的代码中，<code>num</code> 声明为整数类型 (<code>int</code>)，<code>text</code> 声明为字符串类型 (<code>string</code>)。由于整数和字符串是不兼容的类型，试图将它们相加会导致编译时错误。这是因为 C# 是类型安全的，不允许将不同类型的值混合使用。</p>
<p>然而，有时我们确实需要将一个类型的值转换为另一个类型。在这种情况下，可以使用显式类型转换来实现，例如使用 <code>(type)</code> 运算符。但是需要注意，显式类型转换可能会导致数据丢失或精度损失，所以需要谨慎使用。</p>
<p>总结起来，类型安全是指在 C# 中，变量在声明时需要指定其类型，并且在使用过程中必须与其声明的类型相匹配。这有助于在编译时捕捉类型错误，并提高代码的可靠性和可维护性。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>作用域：</p>
<ul>
<li>变量的作用域指的是其可见性和可访问性的范围。</li>
<li>变量可以在代码块内部声明，包括方法、循环、条件语句等。</li>
<li>变量的作用域通常是在声明它的代码块中，可以通过大括号 <code>&#123;&#125;</code> 来限定作用域。</li>
<li>局部变量的作用域在声明的代码块内有效，一旦超出作用域，变量就无法访问。</li>
</ul>
</li>
<li><p>生命周期：</p>
<ul>
<li>变量的生命周期是指变量存在的时间段。</li>
<li>局部变量的生命周期与其作用域一致，当超出作用域时，变量将被销毁。</li>
<li>类成员变量的生命周期与其所属的对象或类的生命周期相关。</li>
</ul>
</li>
<li><p>值赋值和修改：</p>
<ul>
<li>变量可以通过赋值运算符 <code>=</code> 来进行值的赋值。</li>
<li>变量可以在其生命周期内被修改，即可以重新赋予不同的值。</li>
</ul>
</li>
</ol>
<blockquote>
<p>变量的简单类型</p>
<p>在C#中，有许多简单的数据类型可以用来声明变量。以下是一些常见的简单类型：</p>
<ol>
<li>整数类型：<ul>
<li><code>int</code>: 表示整数，范围为约 -2,147,483,648 到 2,147,483,647。</li>
<li><code>long</code>: 表示长整数，范围更大，约 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li>
<li><code>short</code>: 表示短整数，范围约为 -32,768 到 32,767。</li>
<li><code>byte</code>: 表示无符号字节，范围为 0 到 255。</li>
</ul>
</li>
<li>浮点类型：<ul>
<li><code>float</code>: 表示单精度浮点数，范围为约 ±1.5 x 10^(-45) 到 ±3.4 x 10^(38)，精度约为 7 位小数。</li>
<li><code>double</code>: 表示双精度浮点数，范围更大，约 ±5.0 x 10^(-324) 到 ±1.7 x 10^(308)，精度约为 15 位小数。</li>
</ul>
</li>
<li>字符类型：<ul>
<li><code>char</code>: 表示单个字符，用单引号括起来，例如 ‘A’、’b’。</li>
</ul>
</li>
<li>布尔类型：<ul>
<li><code>bool</code>: 表示布尔值，只有两个可能的值：<code>true</code> 或 <code>false</code>。</li>
</ul>
</li>
<li>字符串类型：<ul>
<li><code>string</code>: 表示文本字符串，用双引号括起来，例如 “Hello”、”World”。</li>
</ul>
</li>
<li>其他简单类型：<ul>
<li><code>decimal</code>: 表示高精度小数，适用于金融和货币计算，精度约为 28-29 位小数。</li>
<li><code>DateTime</code>: 表示日期和时间值。</li>
<li><code>enum</code>: 表示枚举类型，用于定义一组具名的常量值。</li>
</ul>
</li>
</ol>
<p>这些是C#中一些常见的简单数据类型，你可以根据需要选择适当的类型来声明变量。每种类型都有其特定的用途和取值范围。</p>
</blockquote>
<h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>在C#中，块（block）是由一组语句（statements）组成的代码段。块可以用来将多个语句组合在一起，以便按照一定的逻辑顺序执行。常见的使用块的情况是在条件语句（if、else if、else）和循环语句（for、while、do while）中。</p>
<p>一个块由一对花括号（{}）括起来，其中包含了一系列的语句。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code&#123;<br>    <span class="hljs-comment">// 这是一个块</span><br>    Console.WriteLine(<span class="hljs-string">&quot;语句1&quot;</span>);<br>    Console.WriteLine(<span class="hljs-string">&quot;语句2&quot;</span>);<br>    <span class="hljs-comment">// ...</span><br>    Console.WriteLine(<span class="hljs-string">&quot;语句n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，花括号内的部分就是一个块，它包含了多个语句。当程序执行到这个块时，其中的语句将按照编写的顺序依次执行。</p>
<p>块的作用不仅仅是为了组织代码，还可以用来限制变量的作用域。在一个块内部声明的变量只在该块内有效，在块外部是不可见的。这种方式可以提供更好的代码封装和变量管理。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code&#123;<br>    <span class="hljs-built_in">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 在块内部声明变量x</span><br>    Console.WriteLine(x); <span class="hljs-comment">// 输出：10</span><br>&#125;<br><br>Console.WriteLine(x); <span class="hljs-comment">// 编译错误，x 在此处不可见</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，变量 <code>x</code> 在块内部声明，并在该块内部可见。在块外部的代码中，变量 <code>x</code> 是不可见的，因此会导致编译错误。</p>
<p>总之，块在C#中是一种用于组织语句和限制变量作用域的重要结构。</p>
<h4 id="字面值"><a href="#字面值" class="headerlink" title="*字面值"></a>*字面值</h4><p>在C#中，字面值（Literal）是指直接表示特定值的固定文本或符号。字面值可以用于声明和初始化变量，或者直接用于表达式中。</p>
<p>以下是C#中常见的字面值类型：</p>
<ol>
<li>整数字面值：<ul>
<li>十进制整数：例如 <code>123</code>。</li>
<li>二进制整数：以 <code>0b</code> 或 <code>0B</code> 开头，后跟一串二进制数字。例如 <code>0b1010</code> 表示十进制的 10。</li>
<li>八进制整数：以 <code>0</code> 开头，后跟一串八进制数字。例如 <code>0123</code> 表示十进制的 83。</li>
<li>十六进制整数：以 <code>0x</code> 或 <code>0X</code> 开头，后跟一串十六进制数字。例如 <code>0xFF</code> 表示十进制的 255。</li>
</ul>
</li>
<li>浮点数字面值：<ul>
<li>十进制浮点数：例如 <code>3.14</code>。</li>
<li>指数表示法：使用 <code>E</code> 或 <code>e</code> 表示指数部分。例如 <code>1.23e-4</code> 表示十进制的 0.000123。</li>
</ul>
</li>
<li>字符字面值：<ul>
<li>字符字面值用单引号括起来，表示单个字符。例如 <code>&#39;A&#39;</code>、<code>&#39;7&#39;</code>、<code>&#39;!&#39;</code>。</li>
</ul>
</li>
<li>字符串字面值：<ul>
<li>字符串字面值用双引号括起来，表示文本字符串。例如 <code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>。</li>
</ul>
</li>
<li>布尔字面值：<ul>
<li>布尔字面值表示逻辑值，只有两个可能的值：<code>true</code> 和 <code>false</code>。</li>
</ul>
</li>
</ol>
<p>除了上述基本类型的字面值，C#还支持其他类型的字面值，如日期时间字面值、空值字面值等。</p>
<p>以下是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeint num = <span class="hljs-number">42</span>;           <span class="hljs-comment">// 整数字面值</span><br><span class="hljs-built_in">double</span> pi = <span class="hljs-number">3.14159</span>;    <span class="hljs-comment">// 浮点数字面值</span><br><span class="hljs-built_in">char</span> ch = <span class="hljs-string">&#x27;A&#x27;</span>;          <span class="hljs-comment">// 字符字面值</span><br><span class="hljs-built_in">string</span> message = <span class="hljs-string">&quot;Hello, World!&quot;</span>;   <span class="hljs-comment">// 字符串字面值</span><br><span class="hljs-built_in">bool</span> isTrue = <span class="hljs-literal">true</span>;     <span class="hljs-comment">// 布尔字面值</span><br>DateTime now = DateTime.Now;   <span class="hljs-comment">// 日期时间字面值</span><br></code></pre></td></tr></table></figure>

<p>这些字面值在代码中直接表示相应的值，无需其他转换或操作。</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>C#中有多种运算符，用于执行各种算术、逻辑和位运算。以下是C#中常用的运算符的分类和示例：</p>
<ol>
<li><p>算术运算符：</p>
<ul>
<li><code>+</code>：加法</li>
<li><code>-</code>：减法</li>
<li><code>*</code>：乘法</li>
<li><code>/</code>：除法</li>
<li><code>%</code>：取模（取余数）</li>
</ul>
</li>
<li><p>关系运算符：</p>
<ul>
<li><code>==</code>：等于</li>
<li><code>!=</code>：不等于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;=</code>：大于等于</li>
<li><code>&lt;=</code>：小于等于</li>
</ul>
</li>
<li><p>逻辑运算符：</p>
<ul>
<li><code>&amp;&amp;</code>：逻辑与（and）</li>
<li><code>||</code>：逻辑或（or）</li>
<li><code>!</code>：逻辑非（not）</li>
</ul>
</li>
<li><p>赋值运算符：</p>
<ul>
<li><code>=</code>：简单赋值</li>
<li><code>+=</code>：加法赋值</li>
<li><code>-=</code>：减法赋值</li>
<li><code>*=</code>：乘法赋值</li>
<li><code>/=</code>：除法赋值</li>
<li><code>%=</code>：取模赋值</li>
</ul>
</li>
<li><p>位运算符：</p>
<ul>
<li><code>&amp;</code>：按位与</li>
<li><code>|</code>：按位或</li>
<li><code>^</code>：按位异或</li>
<li><code>&lt;&lt;</code>：左移</li>
<li><code>&gt;&gt;</code>：右移</li>
<li><code>~</code>：按位取反</li>
</ul>
</li>
<li><p>条件运算符：</p>
<ul>
<li><p><code>? :</code>：条件运算符（三元运算符），用于简化条件语句</p>
<blockquote>
<p>在C#中，三元运算符（Conditional Operator）是一种简洁的条件表达式，它允许根据条件的真假选择不同的值。三元运算符的语法形式为 <code>condition ? trueValue : falseValue</code>，其中 <code>condition</code> 是一个条件表达式，<code>trueValue</code> 是在条件为真时返回的值，<code>falseValue</code> 是在条件为假时返回的值。</p>
<p>以下是一个使用三元运算符的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">int</span> num = (x &gt; y) ? x : y;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，根据条件 <code>(x &gt; y)</code> 的真假，如果条件为真，则将 <code>x</code> 的值赋给 <code>num</code>；如果条件为假，则将 <code>y</code> 的值赋给 <code>num</code>。这样就可以根据条件动态地选择不同的值进行赋值。</p>
<p>三元运算符的优点是简洁、易读，并且可以在单行中完成条件判断和赋值操作。但是，需要注意避免过度使用，以免降低代码的可读性和可维护性。在某些情况下，使用 <code>if-else</code> 语句可能更易于理解和维护，特别是当需要执行更复杂的逻辑时。因此，在选择使用三元运算符还是 <code>if-else</code> 语句时，可以根据具体情况和代码的可读性来进行判断。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>其他运算符：</p>
<ul>
<li><code>()</code>：括号，用于分组和优先级控制</li>
<li><code>[]</code>：方括号，用于访问数组元素和索引器</li>
<li><code>.</code>：点运算符，用于访问成员和方法</li>
</ul>
</li>
</ol>
<blockquote>
<p>布尔运算符:</p>
<p>C# 中的布尔运算符用于执行逻辑运算，操作布尔类型的值（true 或 false）。以下是常用的布尔运算符：</p>
<p>逻辑与运算符（&amp;&amp;）：当且仅当两个操作数都为 true 时，结果才为 true。否则，结果为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">bool</span> result = condition1 &amp;&amp; condition2;<br></code></pre></td></tr></table></figure>

<p>逻辑或运算符（||）：当至少一个操作数为 true 时，结果为 true。只有两个操作数都为 false 时，结果才为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">bool</span> result = condition1 || condition2;<br></code></pre></td></tr></table></figure>

<p>逻辑非运算符（!）：对单个操作数进行取反操作，如果操作数为 true，则结果为 false；如果操作数为 false，则结果为 true。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">bool</span> result = !condition;<br></code></pre></td></tr></table></figure>

<p>除了上述三个基本的布尔运算符，C# 还提供了其他一些用于布尔运算的运算符，如：</p>
<p>相等运算符（&#x3D;&#x3D;）：用于比较两个操作数是否相等，如果相等则结果为 true，否则为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">bool</span> result = value1 == value2;<br></code></pre></td></tr></table></figure>

<p>不等运算符（!&#x3D;）：用于比较两个操作数是否不相等，如果不相等则结果为 true，否则为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">bool</span> result = value1 != value2;<br></code></pre></td></tr></table></figure>

<p>大于运算符（&gt;）、小于运算符（&lt;）、大于等于运算符（&gt;&#x3D;）、小于等于运算符（&lt;&#x3D;）：用于比较两个操作数的大小关系，返回结果为 true 或 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codebool result = value1 &gt; value2;<br><span class="hljs-built_in">bool</span> result = value1 &lt; value2;<br><span class="hljs-built_in">bool</span> result = value1 &gt;= value2;<br><span class="hljs-built_in">bool</span> result = value1 &lt;= value2;<br></code></pre></td></tr></table></figure>

<p>这些布尔运算符可用于控制流程、条件判断、循环控制等情况下，以便根据条件的真假进行相应的操作。</p>
</blockquote>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>在C#中，转义字符（Escape Character）是用于表示一些特殊字符的特殊序列。转义字符以反斜杠 <code>\</code> 开头，后面跟着一个或多个字符，用于表示特定的含义。</p>
<p>以下是C#中常见的转义字符及其含义：</p>
<ul>
<li><code>\&#39;</code>：表示单引号字符。</li>
<li><code>\&quot;</code>：表示双引号字符。</li>
<li><code>\\</code>：表示反斜杠字符。</li>
<li><code>\n</code>：表示换行符（ASCII 值为 10）。</li>
<li><code>\r</code>：表示回车符（ASCII 值为 13）。</li>
<li><code>\t</code>：表示制表符。</li>
<li><code>\b</code>：表示退格符。</li>
<li><code>\f</code>：表示换页符。</li>
<li><code>\uXXXX</code>：表示一个 Unicode 字符，其中 <code>XXXX</code> 是四个十六进制数字。</li>
</ul>
<p>以下是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codestring singleQuote = <span class="hljs-string">&#x27;\&#x27;&#x27;</span>;     <span class="hljs-comment">// 单引号字符</span><br><span class="hljs-built_in">string</span> doubleQuote = <span class="hljs-string">&#x27;\&quot;&#x27;</span>;     <span class="hljs-comment">// 双引号字符</span><br><span class="hljs-built_in">string</span> backslash = <span class="hljs-string">&#x27;\\&#x27;</span>;       <span class="hljs-comment">// 反斜杠字符</span><br><span class="hljs-built_in">string</span> newLine = <span class="hljs-string">&quot;\n&quot;</span>;         <span class="hljs-comment">// 换行符</span><br><span class="hljs-built_in">string</span> tab = <span class="hljs-string">&quot;\t&quot;</span>;             <span class="hljs-comment">// 制表符</span><br><span class="hljs-built_in">string</span> unicodeChar = <span class="hljs-string">&quot;\u03A9&quot;</span>; <span class="hljs-comment">// 表示希腊字母大写Omega（Ω）</span><br></code></pre></td></tr></table></figure>

<p>在字符串中使用转义字符时，反斜杠后的字符将被解释为其特殊含义，而不是字面字符。</p>
<p>需要注意的是，如果你希望在字符串中显示实际的反斜杠字符而非转义字符，你可以使用两个连续的反斜杠 <code>\\</code> 来表示。</p>
<blockquote>
<p>在C#中，转义字符是一种特殊字符序列，用于表示一些特殊的字符或控制字符。如果你想禁用转义字符，你可以使用字符串前缀 <code>@</code> 来创建一个原始字符串（raw string），这样其中的转义字符就会被当作普通字符对待。</p>
<p>下面是一个示例，展示如何在C#中禁用转义字符：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codestring normalString = <span class="hljs-string">&quot;Hello\tWorld&quot;</span>; <span class="hljs-comment">// 使用转义字符的普通字符串</span><br><span class="hljs-built_in">string</span> rawString = <span class="hljs-string">@&quot;Hello\tWorld&quot;</span>; <span class="hljs-comment">// 使用原始字符串禁用转义字符</span><br><br>Console.WriteLine(normalString); <span class="hljs-comment">// 输出：Hello   World</span><br>Console.WriteLine(rawString); <span class="hljs-comment">// 输出：Hello\tWorld</span><br></code></pre></td></tr></table></figure>

<p>在 <code>rawString</code> 中，<code>\t</code> 不再表示制表符，而是被当作普通的两个字符：反斜杠和字母 ‘t’。</p>
</blockquote>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>在C#中，条件语句用于根据条件的真假来执行不同的代码块。C#提供了几种条件语句的形式，包括以下常见的：</p>
<ol>
<li><p><code>if</code> 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codeif</span> (<span class="hljs-params">condition</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 当条件为真时执行的代码</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// 当条件为假时执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>else if</code> 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codeif</span> (<span class="hljs-params">condition1</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 当条件1为真时执行的代码</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition2)<br>&#123;<br>    <span class="hljs-comment">// 当条件1为假而条件2为真时执行的代码</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// 当前面条件都为假时执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>switch</code> 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codeswitch</span> (<span class="hljs-params">variable</span>)</span><br>&#123;<br>    <span class="hljs-keyword">case</span> value1:<br>        <span class="hljs-comment">// 当变量等于value1时执行的代码</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> value2:<br>        <span class="hljs-comment">// 当变量等于value2时执行的代码</span><br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-literal">default</span>:<br>        <span class="hljs-comment">// 当变量不匹配任何case时执行的代码</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>这些条件语句根据条件的真假来选择执行不同的代码块。<code>if</code> 语句根据单个条件的真假执行不同的代码块，而 <code>else if</code> 语句可以用于检查多个条件并选择执行对应的代码块。<code>switch</code> 语句根据变量的值进行匹配，并执行与值匹配的代码块。</p>
<p>这些条件语句使程序能够根据不同的情况采取不同的行动，从而实现灵活的控制流程和逻辑。您可以根据具体的需求选择适当的条件语句来控制程序的行为。</p>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>在C#中，循环语句用于重复执行一段代码块，直到满足指定的条件。C#提供了几种常用的循环语句，包括以下：</p>
<ol>
<li><p><code>for</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codefor</span> (<span class="hljs-params">initialization; condition; iteration</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 循环执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>while</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codewhile</span> (<span class="hljs-params">condition</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 循环执行的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>do-while</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codedo<br>&#123;<br>    <span class="hljs-comment">// 循环执行的代码</span><br>&#125; <span class="hljs-keyword">while</span> (condition);<br></code></pre></td></tr></table></figure>
</li>
<li><p><code>foreach</code> 循环（用于遍历集合）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codeforeach</span> (<span class="hljs-params"><span class="hljs-keyword">var</span> item <span class="hljs-keyword">in</span> collection</span>)</span><br>&#123;<br>    <span class="hljs-comment">// 循环执行的代码，item 代表集合中的每个元素</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>这些循环语句允许您根据需要重复执行一段代码块，直到满足指定的条件。<code>for</code> 循环在执行循环之前进行初始化，并在每次迭代后进行迭代操作。<code>while</code> 循环在每次循环开始之前检查条件。<code>do-while</code> 循环首先执行一次循环体，然后在每次循环结束后检查条件。</p>
<p><code>foreach</code> 循环用于遍历集合中的元素，无需手动追踪索引或迭代器。它适用于数组、列表、字典等集合类型。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>在C#中，枚举（Enum）是一种特殊的数据类型，用于定义一组具名的常量值。枚举类型允许我们为特定概念创建有意义的命名常量，使代码更加可读和可维护。</p>
<p>以下是一个枚举的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeenum DayOfWeek<br>&#123;<br>    Monday,<br>    Tuesday,<br>    Wednesday,<br>    Thursday,<br>    Friday,<br>    Saturday,<br>    Sunday<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 <code>DayOfWeek</code> 的枚举类型，它包含了一周中的每一天。枚举中的每个值都是一个常量，并用逗号分隔。默认情况下，第一个枚举成员的值为0，然后依次递增。</p>
<p>我们可以使用枚举类型来声明变量，并将其限制为枚举中的某个特定值，例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br>DayOfWeek today = DayOfWeek.Monday;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们将 <code>today</code> 声明为 <code>DayOfWeek</code> 枚举类型的变量，并将其赋值为 <code>DayOfWeek.Monday</code>。这样，我们可以使用 <code>today</code> 变量来表示今天是星期几。</p>
<p>枚举还可以使用 <code>switch</code> 语句进行处理，方便地处理不同枚举值的情况：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy <span class="hljs-title">codeswitch</span> (<span class="hljs-params">today</span>)</span><br>&#123;<br>    <span class="hljs-keyword">case</span> DayOfWeek.Monday:<br>        Console.WriteLine(<span class="hljs-string">&quot;今天是星期一&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DayOfWeek.Tuesday:<br>        Console.WriteLine(<span class="hljs-string">&quot;今天是星期二&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-literal">default</span>:<br>        Console.WriteLine(<span class="hljs-string">&quot;未知的星期&quot;</span>);<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们根据 <code>today</code> 变量的值，通过 <code>switch</code> 语句判断今天是星期几，并输出相应的信息。</p>
<p>枚举提供了一种方便的方式来定义和使用一组相关的常量值，以增加代码的可读性和可维护性。它在许多情况下都是非常有用的，例如表示日期、状态、选项等。</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>在C#中，结构体（Struct）是一种用户定义的值类型，用于封装一组相关的数据字段。结构体是值类型，意味着它们在赋值或传递给方法时会被复制，而不是引用。</p>
<p>以下是一个结构体的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codestruct Point<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> X;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Y;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 <code>Point</code> 的结构体，它包含两个整型字段 <code>X</code> 和 <code>Y</code>。这个结构体表示二维平面上的一个点。</p>
<p>我们可以创建结构体的实例，并访问其字段，例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codePoint p;<br>p.X = <span class="hljs-number">10</span>;<br>p.Y = <span class="hljs-number">5</span>;<br>Console.WriteLine(<span class="hljs-string">$&quot;X: <span class="hljs-subst">&#123;p.X&#125;</span>, Y: <span class="hljs-subst">&#123;p.Y&#125;</span>&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为 <code>p</code> 的 <code>Point</code> 结构体的实例，并设置了其 <code>X</code> 和 <code>Y</code> 字段的值。然后，我们使用插值字符串将字段的值输出到控制台。</p>
<p>结构体可以具有构造函数、方法和属性，以提供更丰富的功能。此外，结构体还可以实现接口，从而使其具备更多的行为和特性。</p>
<p>与类相比，结构体通常更适合用于简单的数据封装，特别是对于小型、轻量级的对象。由于结构体是值类型，它们在内存上的存储方式和复制行为也与类不同，这些特性使得结构体在某些场景下具有性能优势。</p>
<p>需要注意的是，结构体是值类型，因此在将结构体实例传递给方法时，传递的是结构体的副本而不是引用。这可能会导致性能开销，尤其在结构体较大或复杂时。在这种情况下，可以考虑使用类来代替结构体。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在C#中，数组（Array）是一种用于存储相同类型的元素的数据结构。数组提供了一个连续的内存块来存储多个元素，并使用索引来访问和操作这些元素。</p>
<p>以下是一个数组的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们声明了一个名为 <code>numbers</code> 的整型数组，它可以存储5个整数。使用 <code>new int[5]</code> 创建了一个长度为5的整型数组，并将其赋值给 <code>numbers</code> 变量。</p>
<p>我们可以使用索引来访问数组中的元素。数组的索引从0开始，因此可以使用 <code>[index]</code> 访问特定位置的元素，例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codenumbers[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>;<br>numbers[<span class="hljs-number">1</span>] = <span class="hljs-number">20</span>;<br>numbers[<span class="hljs-number">2</span>] = <span class="hljs-number">30</span>;<br><br>Console.WriteLine(numbers[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 输出: 20</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用索引操作符 <code>[index]</code> 将值分配给数组的特定位置，并使用索引访问特定位置的元素。</p>
<p>除了使用固定大小的数组，C#还提供了动态数组，称为 <code>List&lt;T&gt;</code>，它具有更灵活的大小调整和功能。使用 <code>List&lt;T&gt;</code> 类型可以动态添加、删除和修改元素。</p>
<p>以下是一个使用 <code>List&lt;int&gt;</code> 的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeList&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br>numbers.Add(<span class="hljs-number">10</span>);<br>numbers.Add(<span class="hljs-number">20</span>);<br>numbers.Add(<span class="hljs-number">30</span>);<br><br>Console.WriteLine(numbers[<span class="hljs-number">1</span>]);  <span class="hljs-comment">// 输出: 20</span><br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个 <code>List&lt;int&gt;</code> 类型的对象，并使用 <code>Add</code> 方法向列表中添加整数。然后，使用索引访问特定位置的元素。</p>
<p>数组在许多编程场景中都是非常有用的，可以用于存储和处理大量数据，以及实现诸如集合、矩阵、图像等数据结构和算法。</p>
<blockquote>
<p>在C#中，<code>new</code> 操作符用于创建一个对象的实例或初始化一个数组。它在内存中分配了足够的空间来存储对象或数组，并调用适当的构造函数来初始化对象的状态。</p>
<p><code>new</code> 操作符的用法有以下几个常见的情况：</p>
<ol>
<li><p>创建对象实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br>ClassName obj = <span class="hljs-keyword">new</span> ClassName();<br></code></pre></td></tr></table></figure>

<p>这种用法创建了一个类的实例，并调用了该类的默认构造函数来初始化对象的初始状态。可以通过 <code>obj</code> 变量来访问和操作该对象的成员。</p>
</li>
<li><p>创建对象实例并传递参数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br>ClassName obj = <span class="hljs-keyword">new</span> ClassName(arg1, arg2, ...);<br></code></pre></td></tr></table></figure>

<p>这种用法创建了一个类的实例，并调用了带有指定参数的构造函数来初始化对象的状态。构造函数根据参数的类型和顺序来确定调用哪个构造函数重载。</p>
</li>
<li><p>初始化数组：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure>

<p>这种用法创建了一个指定长度的数组，并使用默认值对数组的元素进行初始化。在上面的示例中，数组的长度为5，所有元素都被初始化为 <code>int</code> 类型的默认值 0。</p>
</li>
</ol>
<p>在C#中，<code>new</code> 操作符是用于动态创建对象和数组的关键操作符之一。它使我们能够在运行时创建和初始化新的实例，以满足程序的需求。同时，<code>new</code> 操作符也触发了相应类型的构造函数，允许我们在对象创建的过程中执行必要的初始化操作。</p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在C#中，函数具有以下特点：</p>
<ol>
<li>封装性（Encapsulation）：函数允许将相关代码块封装成一个独立的单元，使代码更加模块化和可复用。函数可以隐藏内部实现细节，并提供一个公共接口供其他部分使用。</li>
<li>参数传递（Parameter Passing）：函数可以接受零个或多个参数，这些参数用于向函数传递数据。在C#中，参数可以是值类型、引用类型或输出参数，允许函数对传入的参数进行读取和修改。</li>
<li>返回值（Return Value）：函数可以返回一个值，用于向调用方提供计算结果或其他需要的信息。返回值可以是任何有效的数据类型，包括基本类型、自定义类型和引用类型。</li>
<li>可访问性（Accessibility）：函数可以具有不同的访问修饰符，如<code>public</code>、<code>private</code>、<code>protected</code>等，用于控制函数的可见性和访问权限。这决定了哪些部分可以调用函数和访问函数内部。</li>
<li>方法重载（Method Overloading）：在C#中，可以定义具有相同名称但参数列表不同的多个函数，称为方法重载。通过方法重载，可以根据不同的参数类型和数量来选择调用合适的函数。</li>
<li>递归（Recursion）：函数可以调用自身，这称为递归。递归在解决某些问题时非常有用，可以简化代码逻辑，但需要注意递归终止条件，以避免无限递归。</li>
<li>异常处理（Exception Handling）：函数可以抛出异常（<code>throw</code>语句），并在调用方处于适当的位置进行异常处理（<code>try-catch</code>语句）。异常处理可以捕获和处理在函数执行过程中可能发生的错误或异常情况。</li>
<li>匿名函数和Lambda表达式（Anonymous Functions and Lambda Expressions）：C#支持定义匿名函数和使用Lambda表达式，这使得在需要时可以更方便地编写简单的函数代码块。</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><p>在C#中，可以使用标准输入和输出流进行输入和输出操作。下面是一些常用的输入和输出方法：</p>
<p>Console.ReadLine()：从标准输入流读取一行用户输入，并以字符串的形式返回。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br><span class="hljs-built_in">string</span> input = Console.ReadLine();<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529202723287.png" alt="image-20230529202723287"></p>
<p>Console.Read()：从标准输入流读取下一个字符的 ASCII 值，并以整数形式返回。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<br>    <span class="hljs-comment">//只能读一个是吗？</span><br><span class="hljs-built_in">int</span> input = Console.Read();<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529203000925.png" alt="image-20230529203000925"></p>
<p>*Console.ReadKey()：从标准输入流读取下一个键入的字符，并返回一个表示该键入的 ConsoleKeyInfo 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeConsoleKeyInfo keyInfo = Console.ReadKey();<br><span class="hljs-built_in">char</span> input = keyInfo.KeyChar;<br></code></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> _001_第一个程序<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//结构体：接受输入的值</span><br>            ConsoleKeyInfo keyInfo = Console.ReadKey();<br><br>            <span class="hljs-built_in">char</span> inputChar = keyInfo.KeyChar;         <span class="hljs-comment">// 获取按下的字符值</span><br>            ConsoleKey key = keyInfo.Key;             <span class="hljs-comment">// 获取按下的键的枚举值</span><br>            ConsoleModifiers modifiers = keyInfo.Modifiers;  <span class="hljs-comment">// 获取修饰键的状态</span><br><br>            Console.WriteLine(<span class="hljs-string">&quot;输入的字符值: &quot;</span> + inputChar);<br>            Console.WriteLine(<span class="hljs-string">&quot;输入的键: &quot;</span> + key);<br>            Console.WriteLine(<span class="hljs-string">&quot;修饰键的状态: &quot;</span> + modifiers);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ConsoleKeyInfo</code> 是在 <code>System</code> 命名空间下定义的结构，用于表示从标准输入流读取的键入信息。该结构包含了按下的键、键的字符值和修饰键的状态。</p>
<p>以下是一些 <code>ConsoleKeyInfo</code> 结构的属性：</p>
<ul>
<li><code>KeyChar</code>：按下的键对应的字符值。如果按下的是特殊键或无法映射到字符的键，则该属性的值为 <code>\0</code>。</li>
<li><code>Key</code>：按下的键的枚举值，类型为 <code>ConsoleKey</code>。可以使用 <code>Key</code> 属性来判断按下的是哪个特殊键，如方向键、功能键等。</li>
<li><code>Modifiers</code>：按下键时同时按下的修饰键（如 Shift、Ctrl 等）。该属性的类型为 <code>ConsoleModifiers</code> 枚举，可以使用按位运算符来判断是否同时按下了某个修饰键。</li>
</ul>
<p>以下是一个示例，演示如何使用 <code>ConsoleKeyInfo</code> 结构：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeConsoleKeyInfo keyInfo = Console.ReadKey();<br><br><span class="hljs-built_in">char</span> inputChar = keyInfo.KeyChar;         <span class="hljs-comment">// 获取按下的字符值</span><br>ConsoleKey key = keyInfo.Key;             <span class="hljs-comment">// 获取按下的键的枚举值</span><br>ConsoleModifiers modifiers = keyInfo.Modifiers;  <span class="hljs-comment">// 获取修饰键的状态</span><br><br>Console.WriteLine(<span class="hljs-string">&quot;输入的字符值: &quot;</span> + inputChar);<br>Console.WriteLine(<span class="hljs-string">&quot;输入的键: &quot;</span> + key);<br>Console.WriteLine(<span class="hljs-string">&quot;修饰键的状态: &quot;</span> + modifiers);<br></code></pre></td></tr></table></figure>

<p>通过上述代码，你可以获取按下的字符值、键和修饰键的状态，并根据需要进行进一步的处理和判断。</p>
</blockquote>
<p>Console.Write()：将指定的数据写入标准输出流，不附加换行符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">Console.Write(<span class="hljs-string">&quot;The number is: &quot;</span>);<br>Console.Write(number);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529210259411.png" alt="image-20230529210259411"></p>
<p>Console.WriteLine()：将指定的数据写入标准输出流，并附加换行符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;John&quot;</span>;<br>Console.WriteLine(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529210347145.png" alt="image-20230529210347145"></p>
<p>Console.WriteFormat()：将格式化的字符串写入标准输出流。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>;<br>Console.WriteFormat(<span class="hljs-string">&quot;My name is &#123;0&#125; and I am &#123;1&#125; years old.&quot;</span>, name, age);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529210603766.png" alt="image-20230529210603766"></p>
<blockquote>
<p>这里用到了占位符，就简单的讲一下：</p>
<p>占位符的使用特点如下：</p>
<ol>
<li>顺序替换：占位符按照在格式化字符串中的顺序进行替换。第一个占位符 <code>&#123;0&#125;</code> 对应第一个参数，第二个占位符 <code>&#123;1&#125;</code> 对应第二个参数，依此类推。确保提供的参数数量与占位符的数量匹配，否则会引发异常。</li>
<li>参数类型灵活：占位符可以接受任意类型的参数。在替换过程中，会自动将参数转换为字符串形式。这允许你在格式化字符串中插入各种类型的数据，包括字符串、数字、日期等。</li>
<li>重复使用：占位符可以在格式化字符串中多次重复使用。这意味着你可以多次插入同一个参数值，或者在不同位置插入相同或不同的参数值。</li>
<li>格式化选项：占位符还可以使用格式化选项来指定参数的显示格式。格式化选项可以用于数字、日期、时间等类型的参数，以控制其显示方式。例如：<code>&#123;0:C&#125;</code> 表示将第一个参数作为货币值进行格式化显示。</li>
</ol>
<p>下面是一个示例，展示了占位符的使用特点：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codestring name = <span class="hljs-string">&quot;Alice&quot;</span>;<br><span class="hljs-built_in">int</span> age = <span class="hljs-number">25</span>;<br><span class="hljs-built_in">double</span> salary = <span class="hljs-number">2500.50</span>;<br><br><span class="hljs-built_in">string</span> result = String.Format(<span class="hljs-string">&quot;My name is &#123;0&#125;, I am &#123;1&#125; years old, and my salary is &#123;2:C&#125;.&quot;</span>, name, age, salary);<br>Console.WriteLine(result);<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">swiftCopy code<br>My name <span class="hljs-keyword">is</span> Alice, I am <span class="hljs-number">25</span> years old, <span class="hljs-keyword">and</span> my salary <span class="hljs-keyword">is</span> $<span class="hljs-number">2</span>,<span class="hljs-number">500.50</span>.<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>&#123;0&#125;</code> 对应变量 <code>name</code>，<code>&#123;1&#125;</code> 对应变量 <code>age</code>，<code>&#123;2:C&#125;</code> 对应变量 <code>salary</code>。参数按照顺序替换占位符，并使用相应的格式化选项。</p>
<p>通过占位符的使用特点，你可以方便地构建格式化的字符串，插入适当的参数，并根据需要进行格式化控制。</p>
</blockquote>
<p>这些方法可以用于控制台应用程序中的输入和输出操作。你可以根据需要使用适当的方法来读取用户输入或向控制台输出数据。</p>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>在 C# 中，有多种方法可以进行字符串拼接。下面是一些常见的字符串拼接规则和方法：</p>
<p>使用 <code>+</code> 运算符：可以使用 <code>+</code> 运算符将多个字符串连接在一起。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-built_in">string</span> lastName = <span class="hljs-string">&quot;Doe&quot;</span>;<br><span class="hljs-built_in">string</span> fullName = firstName + <span class="hljs-string">&quot; &quot;</span> + lastName;<br>Consolo.Write(fullName);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212308991.png" alt="image-20230529212308991"></p>
<p>*使用字符串插值（String Interpolation）：可以使用 <code>$</code> 符号和花括号 <code>&#123;&#125;</code> 来将变量插入到字符串中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> firstName = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-built_in">string</span> lastName = <span class="hljs-string">&quot;Doe&quot;</span>;<br><span class="hljs-built_in">string</span> fullName = <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;firstName&#125;</span> <span class="hljs-subst">&#123;lastName&#125;</span>&quot;</span>;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212411765.png" alt="image-20230529212411765"></p>
<p>使用 <code>String.Format</code> 方法：可以使用 <code>String.Format</code> 方法来格式化字符串，并将参数插入到占位符中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">string</span> firstName = <span class="hljs-string">&quot;John&quot;</span>;<br><span class="hljs-built_in">string</span> lastName = <span class="hljs-string">&quot;Doe&quot;</span>;<br><span class="hljs-built_in">string</span> fullName = String.Format(<span class="hljs-string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, firstName, lastName);<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212513492.png" alt="image-20230529212513492"></p>
<p><strong>使用 <code>StringBuilder</code> 类：如果需要高效地拼接大量字符串或在循环中进行拼接操作，可以使用 <code>StringBuilder</code> 类。</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>sb.Append(<span class="hljs-string">&quot;Hello&quot;</span>);<br>sb.Append(<span class="hljs-string">&quot; &quot;</span>);<br>sb.Append(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-built_in">string</span> result = sb.ToString();<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212821511.png" alt="image-20230529212821511"></p>
<p>需要注意的是，字符串是不可变的（immutable），这意味着每次对字符串进行修改时，实际上会创建一个新的字符串对象。因此，在需要进行大量字符串拼接的情况下，使用 <code>StringBuilder</code> 类可以避免不必要的内存分配和性能损失。</p>
<blockquote>
<p>在C#中，有许多常用的字符串操作方法可用于处理和操作字符串。以下是一些常见的字符串操作示例：</p>
<ol>
<li><p>字符串连接：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">cCopy codestring str1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-built_in">string</span> str2 = <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-built_in">string</span> result = str1 + <span class="hljs-string">&quot; &quot;</span> + str2;  <span class="hljs-comment">// 结果为 &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串长度：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">cCopy codestring str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">int</span> length = str.Length;  <span class="hljs-comment">// 结果为 11</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串截取：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">cCopy codestring str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">string</span> substring = str.Substring(<span class="hljs-number">6</span>);  <span class="hljs-comment">// 结果为 &quot;World&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串分割：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">luaCopy codestring str = <span class="hljs-string">&quot;apple,banana,orange&quot;</span>;<br><span class="hljs-built_in">string</span>[] fruits = str.Split(<span class="hljs-string">&#x27;,&#x27;</span>);  <span class="hljs-comment">// 结果为 [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串替换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">cCopy codestring str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">string</span> replaced = str.Replace(<span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;Universe&quot;</span>);  <span class="hljs-comment">// 结果为 &quot;Hello Universe&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串大小写转换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">cCopy codestring str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">string</span> uppercase = str.ToUpper();  <span class="hljs-comment">// 结果为 &quot;HELLO WORLD&quot;</span><br><span class="hljs-built_in">string</span> lowercase = str.ToLower();  <span class="hljs-comment">// 结果为 &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串去除空格：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">cCopy codestring str = <span class="hljs-string">&quot;  Hello World  &quot;</span>;<br><span class="hljs-built_in">string</span> trimmed = str.Trim();  <span class="hljs-comment">// 结果为 &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>字符串查找：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">rustCopy codestring str = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">bool</span> containsHello = str.Contains(<span class="hljs-string">&quot;Hello&quot;</span>);  <span class="hljs-comment">// 结果为 true</span><br><span class="hljs-built_in">int</span> index = str.IndexOf(<span class="hljs-string">&quot;World&quot;</span>);  <span class="hljs-comment">// 结果为 6</span><br></code></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h4><p>在C#中，可以使用类型转换操作符或转换方法来进行变量类型转换。以下是几种常见的类型转换方法：</p>
<ol>
<li><p>显式类型转换（Explicit Casting）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<span class="hljs-comment">// 使用类型转换操作符</span><br><span class="hljs-built_in">int</span> intValue = (<span class="hljs-built_in">int</span>)doubleValue;<br><br><span class="hljs-comment">// 使用Convert类的转换方法</span><br><span class="hljs-built_in">int</span> intValue = Convert.ToInt32(doubleValue);<br></code></pre></td></tr></table></figure>
</li>
<li><p>隐式类型转换（Implicit Casting）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<span class="hljs-comment">// 隐式类型转换只适用于可安全地转换的情况</span><br><span class="hljs-built_in">int</span> intValue = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">double</span> doubleValue = intValue;<br></code></pre></td></tr></table></figure>
</li>
<li><p>Parse方法和TryParse方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<span class="hljs-comment">// Parse方法将字符串转换为特定类型的值</span><br><span class="hljs-built_in">int</span> intValue = <span class="hljs-built_in">int</span>.Parse(<span class="hljs-string">&quot;10&quot;</span>);<br><br><span class="hljs-comment">// TryParse方法尝试将字符串转换为特定类型的值，并返回转换是否成功的布尔值</span><br><span class="hljs-built_in">bool</span> success = <span class="hljs-built_in">int</span>.TryParse(<span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-keyword">out</span> <span class="hljs-built_in">int</span> intValue);<br></code></pre></td></tr></table></figure>
</li>
<li><p>Convert类的转换方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<span class="hljs-comment">// 使用Convert类的转换方法进行类型转换</span><br><span class="hljs-built_in">int</span> intValue = Convert.ToInt32(doubleValue);<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h2><p>用几个简单的实例，来让我们熟系c#代码的功能吧。</p>
<h3 id="交换两个数据的值"><a href="#交换两个数据的值" class="headerlink" title="交换两个数据的值"></a>交换两个数据的值</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> _002_练习<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//声明两个变量交换他们的值</span><br>            <span class="hljs-built_in">int</span> a = <span class="hljs-number">100</span>;<br>            <span class="hljs-built_in">int</span> b = <span class="hljs-number">10</span>;<br>            <span class="hljs-built_in">int</span> temp = <span class="hljs-number">0</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;打印交换之前的数据&quot;</span>);<br>            Console.WriteLine(a);<br>            Console.WriteLine(b);<br><br>            <span class="hljs-comment">// 等待用户按下一个键</span><br>            Console.ReadKey(); <br><br>            temp = a;<br>            a = b;<br>            b = temp;<br>            <span class="hljs-comment">//打印</span><br>            Console.WriteLine(a);<br>            Console.WriteLine(b);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="计算梯形和圆形的值"><a href="#计算梯形和圆形的值" class="headerlink" title="计算梯形和圆形的值"></a>计算梯形和圆形的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> _002_练习<br>&#123;<br>    internal <span class="hljs-keyword">class</span> <span class="hljs-title class_">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">m</span><span class="hljs-params">(<span class="hljs-type">double</span> up, <span class="hljs-type">double</span> down, <span class="hljs-type">double</span> h)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> (up + down) * h / <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(string[] args)</span></span><br><span class="hljs-function">        </span>&#123;<br>            Console.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;计算梯形的面积&quot;</span>);<br>            Console.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;请输入上底：&quot;</span>);<br>            <span class="hljs-type">double</span> up = Convert.<span class="hljs-built_in">ToDouble</span>(Console.<span class="hljs-built_in">ReadLine</span>());<br><br>            Console.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;请输入下底：&quot;</span>);<br>            <span class="hljs-type">double</span> down = Convert.<span class="hljs-built_in">ToDouble</span>(Console.<span class="hljs-built_in">ReadLine</span>());<br><br>            Console.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;请输入高度：&quot;</span>);<br>            <span class="hljs-type">double</span> h = Convert.<span class="hljs-built_in">ToDouble</span>(Console.<span class="hljs-built_in">ReadLine</span>());<br><br>            <span class="hljs-type">double</span> result = <span class="hljs-built_in">m</span>(up, down, h);<br><br>            Console.<span class="hljs-built_in">WriteLine</span>(<span class="hljs-string">&quot;计算结果为：&quot;</span> + result);<br>            Console.<span class="hljs-built_in">ReadKey</span>();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>ToDouble</code> 是一个用于将其他数据类型转换为 <code>double</code> 类型的方法。它是.NET Framework 中的一个内置方法，可用于在C#中进行数据类型转换。</p>
<p>在C#中，数据类型转换是将一个数据类型的值转换为另一个数据类型的过程。当您需要在不同的数据类型之间进行转换时，可以使用适当的类型转换方法。</p>
<p><code>ToDouble</code> 方法用于将其他数据类型的值转换为 <code>double</code> 类型的值。它是静态方法，可以通过调用相应数据类型的实例来使用。</p>
<p>例如，如果要将一个字符串转换为 <code>double</code> 类型，可以使用以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codestring numberString = <span class="hljs-string">&quot;3.14&quot;</span>;<br><span class="hljs-built_in">double</span> number = Convert.ToDouble(numberString);<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们将字符串变量 <code>numberString</code> 的值转换为 <code>double</code> 类型，并将结果存储在 <code>number</code> 变量中。<code>Convert.ToDouble()</code> 方法根据字符串的内容将其转换为相应的 <code>double</code> 类型值。</p>
<p>请注意，如果无法成功进行转换（例如，字符串不是有效的数字表示），则会抛出 <code>FormatException</code> 异常。因此，在进行数据类型转换时，需要确保输入的数据与目标数据类型兼容，否则可能会导致运行时错误。</p>
<blockquote>
<p><code>Convert</code> 是一个在 .NET Framework 中提供的类，用于执行数据类型之间的转换操作。它包含了各种静态方法，用于在不同的数据类型之间进行转换。</p>
<p><code>Convert</code> 类提供了一系列的静态方法，用于将一个数据类型的值转换为另一个数据类型。它支持各种常见的数据类型，例如整数、浮点数、字符串、日期等。通过调用相应的 <code>Convert</code> 方法，您可以将一个数据类型的值转换为另一个数据类型，前提是转换是合法和有效的。</p>
<p>以下是一些常用的 <code>Convert</code> 方法的示例：</p>
<ol>
<li><code>Convert.ToInt32()</code>：将其他数据类型的值转换为 32 位整数类型（<code>int</code>）。</li>
<li><code>Convert.ToDouble()</code>：将其他数据类型的值转换为双精度浮点数类型（<code>double</code>）。</li>
<li><code>Convert.ToString()</code>：将其他数据类型的值转换为字符串类型（<code>string</code>）。</li>
<li><code>Convert.ToDateTime()</code>：将其他数据类型的值转换为日期和时间类型（<code>DateTime</code>）。</li>
</ol>
<p>这些方法使用方法类似于 <code>Convert.ToDouble(value)</code>，其中 <code>value</code> 是要转换的值。方法将返回转换后的值，并根据需要进行合理的舍入、截断或格式化操作。</p>
<p>需要注意的是，在进行转换之前，需要确保源数据类型可以被转换为目标数据类型，否则可能会引发异常。例如，如果尝试将一个非数字字符串转换为整数类型，则会引发 <code>FormatException</code> 异常。</p>
<p><code>Convert</code> 类提供了一种方便且安全的方法来执行数据类型转换，使开发人员能够轻松地在不同的数据类型之间进行转换操作。</p>
</blockquote>
</blockquote>
<p>为什么要在函数体前加static？</p>
<blockquote>
<p>在C#中，<code>static</code> 关键字用于声明静态成员（方法、字段、属性等）。当在函数体前加上 <code>static</code> 关键字时，表示该方法是一个静态方法。</p>
<p>静态方法与实例方法有一些不同之处：</p>
<ol>
<li>静态方法属于类本身，而不是类的实例。可以通过类名直接调用静态方法，而无需创建类的实例。</li>
<li>静态方法可以在不创建类的实例的情况下访问和操作类的静态成员（静态字段、静态属性等）。</li>
<li>静态方法不能直接访问实例成员（实例字段、实例属性等），因为它们没有与特定实例关联。</li>
</ol>
<p>在将方法声明为静态时，有几个常见的原因和用途：</p>
<ol>
<li>共享性：静态方法是类的共享成员，所有类的实例都可以共享相同的静态方法。这使得静态方法可以用于实现与类相关的功能，而无需每次创建实例。</li>
<li>实用性：某些方法不需要访问实例状态或实例成员，只需要执行一些独立于实例的操作。将这些方法声明为静态方法可以更清晰地表达其意图和用途。</li>
<li>工具类方法：静态方法经常用于实现工具类或辅助类中的通用功能。这些方法不需要访问实例状态，可以通过类名直接调用。</li>
</ol>
<p>需要注意的是，静态方法只能访问静态成员，无法直接访问实例成员。如果在静态方法中需要访问实例成员，可以通过传递实例参数或创建实例对象来间接访问。</p>
<p>总而言之，将函数体前加上 <code>static</code> 关键字表示该方法是一个静态方法，具有与实例方法不同的特性和用途。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> _002_练习<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">o</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> r</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-number">3.14</span> * r * r);  <br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;请输入圆的半径&quot;</span>);<br>            <span class="hljs-built_in">double</span> r = Convert.ToDouble(Console.ReadLine());<br>           Console.WriteLine(o(r));<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="条件语句练习"><a href="#条件语句练习" class="headerlink" title="条件语句练习"></a>条件语句练习</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ConditionalStatementExercise</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>);<br>            <span class="hljs-built_in">int</span> number = Convert.ToInt32(Console.ReadLine());<br><br>            <span class="hljs-comment">// 判断输入的数值是否为正数、负数或零，并输出相应的消息</span><br>            <span class="hljs-keyword">if</span> (number &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;输入的数值是正数&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (number &lt; <span class="hljs-number">0</span>)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;输入的数值是负数&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;输入的数值是零&quot;</span>);<br>            &#125;<br>  <span class="hljs-comment">//暂停</span><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="兔子增速问题"><a href="#兔子增速问题" class="headerlink" title="兔子增速问题"></a>兔子增速问题</h3><p>兔子繁育问题。设有一对新生的兔子，从第三个月开始他们每个月都生一对兔子，新生的兔子从第三个月开始又每个月生一对兔子。技此规律，并假定象子没有死亡，20个月后共有多少个兔子? 要求编编写为控制台程序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">RabbitReproduction</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> totalMonths = <span class="hljs-number">20</span>; <span class="hljs-comment">// 总月数</span><br>            <span class="hljs-built_in">int</span> adultPairs = <span class="hljs-number">1</span>; <span class="hljs-comment">// 成年兔对数（初始为1对）</span><br>            <span class="hljs-built_in">int</span> childPairs = <span class="hljs-number">0</span>; <span class="hljs-comment">// 幼兔对数（初始为0对）</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= totalMonths; i++)<br>            &#123;<br>                <span class="hljs-built_in">int</span> newPairs = adultPairs; <span class="hljs-comment">// 新生的兔对数等于成年兔对数</span><br>                adultPairs += childPairs; <span class="hljs-comment">// 成年兔对数增加幼兔对数</span><br>                childPairs = newPairs; <span class="hljs-comment">// 幼兔对数更新为新生的兔对数</span><br>                <br>   <span class="hljs-comment">//$符号是C#语言中的字符串插值符号。它允许你在字符串中嵌入表达式</span><br>                Console.WriteLine(<span class="hljs-string">$&quot;第<span class="hljs-subst">&#123;i&#125;</span>个月：成年兔对数：<span class="hljs-subst">&#123;adultPairs&#125;</span>，幼兔对数：<span class="hljs-subst">&#123;childPairs&#125;</span>&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-built_in">int</span> totalPairs = adultPairs + childPairs; <span class="hljs-comment">// 总兔对数</span><br>            Console.WriteLine(<span class="hljs-string">$&quot;总共有<span class="hljs-subst">&#123;totalMonths&#125;</span>个月后，共有<span class="hljs-subst">&#123;totalPairs&#125;</span>对兔子。&quot;</span>);<br><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//随机数版本</span><br><span class="hljs-keyword">namespace</span> _02_兔子增速<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//开始兔子数量给他一个随机数</span><br>            <span class="hljs-built_in">int</span> starting_number = <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>);<br><br>            <span class="hljs-comment">//一共生二十个月</span><br>            <span class="hljs-built_in">int</span> totalMouths = <span class="hljs-number">20</span>;<br>            <span class="hljs-built_in">int</span> adultPairs = starting_number;<br>            <span class="hljs-comment">//生下来幼小的兔子开始为0对</span><br>            <span class="hljs-built_in">int</span> childPairs = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; totalMouths; i++)<br>            &#123;<br>                <span class="hljs-built_in">int</span> newPair = adultPairs; <span class="hljs-comment">//新生的兔子对数等于成年兔对数</span><br>                adultPairs += childPairs; <span class="hljs-comment">//成年兔对数增加幼兔对数</span><br>                childPairs = newPair; <span class="hljs-comment">//幼兔出现</span><br><br>                Console.WriteLine(<span class="hljs-string">$&quot;第<span class="hljs-subst">&#123;i&#125;</span>个月：成年兔对数：<span class="hljs-subst">&#123;adultPairs&#125;</span>，幼兔对数：<span class="hljs-subst">&#123;childPairs&#125;</span>&quot;</span>);<br>            &#125;<br>            <span class="hljs-comment">//总数 ： 幼+成</span><br>            <span class="hljs-built_in">int</span> totalPairs = adultPairs+childPairs;<br>            Console.WriteLine(<span class="hljs-string">$&quot;总共有<span class="hljs-subst">&#123;totalMouths&#125;</span>个月后，共有<span class="hljs-subst">&#123;totalPairs&#125;</span>对兔子。&quot;</span>);<br><br>            Console.ReadKey();<br><br><br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="控制输出"><a href="#控制输出" class="headerlink" title="控制输出"></a>控制输出</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">NumberList</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;请输入一个整数：&quot;</span>);<br>                <span class="hljs-built_in">int</span> n = Convert.ToInt32(Console.ReadLine());<br><br>                <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>                    &#123;<br>                        Console.Write(i);<br>                    &#125;<br>                    <span class="hljs-comment">//打印个空格 换行</span><br>                    Console.WriteLine();<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">0</span>)<br>                &#123;<br>                    <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 退出程序</span><br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 转到下一次循环，接收下一个整数</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="求解1000以内的所有完数"><a href="#求解1000以内的所有完数" class="headerlink" title="求解1000以内的所有完数"></a>求解1000以内的所有完数</h3><p>完数（Perfect Number）是指一个正整数，它恰好等于它的所有因子（除了自身）之和。换句话说，一个完数的所有真因子之和等于它本身。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">PerfectNumbers</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> number = <span class="hljs-number">1</span>; number &lt;= <span class="hljs-number">1000</span>; number++)<br>            &#123;<br>                <span class="hljs-built_in">int</span> sum = <span class="hljs-number">0</span>;<br><br>                <span class="hljs-comment">// 寻找因子并求和</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; number; i++)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (number % i == <span class="hljs-number">0</span>)<br>                    &#123;<br>                        sum += i;<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">// 判断是否为完数</span><br>                <span class="hljs-keyword">if</span> (sum == number)<br>                &#123;<br>                    Console.WriteLine(number);<br>                &#125;<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="投掷骰子"><a href="#投掷骰子" class="headerlink" title="投掷骰子"></a>投掷骰子</h3><p>编写一个掷筛子100次的程序，并打印出各种点数的出现次数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DiceRoll</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//随机数</span><br>            Random random = <span class="hljs-keyword">new</span> Random();<br>            <span class="hljs-built_in">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[<span class="hljs-number">6</span>]; <span class="hljs-comment">// 用于记录每个点数的出现次数</span><br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>            &#123;<br>                <span class="hljs-built_in">int</span> diceValue = random.Next(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>); <span class="hljs-comment">// 随机生成1到6的整数，模拟筛子的点数</span><br>                count[diceValue - <span class="hljs-number">1</span>]++; <span class="hljs-comment">// 对应点数的出现次数加1</span><br>            &#125;<br><br>            <span class="hljs-comment">// 打印各种点数的出现次数</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++)<br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">$&quot;点数 <span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span> 出现的次数：<span class="hljs-subst">&#123;count[i]&#125;</span>&quot;</span>);<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>生成随机数：</p>
<p>在 C# 中，可以使用 <code>Random</code> 类来生成随机数。<code>Random</code> 类提供了一些方法来生成不同范围和类型的随机数。</p>
<p>下面是一些常见的随机数生成示例：</p>
<p>生成一个介于0和最大整数之间的随机整数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeRandom random = <span class="hljs-keyword">new</span> Random();<br><span class="hljs-built_in">int</span> randomNumber = random.Next();<br></code></pre></td></tr></table></figure>

<p>生成一个指定范围内的随机整数（包括最小值但不包括最大值）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeRandom random = <span class="hljs-keyword">new</span> Random();<br><span class="hljs-built_in">int</span> randomNumber = random.Next(minValue, maxValue);<br></code></pre></td></tr></table></figure>

<p>生成一个随机双精度浮点数（介于0.0和1.0之间）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeRandom random = <span class="hljs-keyword">new</span> Random();<br><span class="hljs-built_in">double</span> randomDouble = random.NextDouble();<br></code></pre></td></tr></table></figure>

<p>生成一个指定范围内的随机双精度浮点数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeRandom random = <span class="hljs-keyword">new</span> Random();<br><span class="hljs-built_in">double</span> randomDouble = minValue + (random.NextDouble() * (maxValue - minValue));<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>Random</code> 类的实例被创建，并使用 <code>Next()</code> 或 <code>NextDouble()</code> 方法来生成随机数。对于整数，<code>Next()</code> 方法生成一个非负整数；对于浮点数，<code>NextDouble()</code> 方法生成一个介于0.0和1.0之间的浮点数。</p>
<p>需要注意的是，在某些情况下，如果在循环中连续创建 <code>Random</code> 对象并立即使用 <code>Next()</code> 方法，可能会得到相同的随机数序列。为了避免这种情况，建议将 <code>Random</code> 对象的创建移到循环外部，以便重复使用同一个对象。</p>
</blockquote>
<h3 id="99乘法表"><a href="#99乘法表" class="headerlink" title="99乘法表"></a>99乘法表</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultiplicationTable</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++)<br>            &#123;<br>                <span class="hljs-comment">//j&lt;=i是个细节</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>                &#123;<br>                    Console.Write(<span class="hljs-string">$&quot;<span class="hljs-subst">&#123;j&#125;</span> × <span class="hljs-subst">&#123;i&#125;</span> = <span class="hljs-subst">&#123;i * j&#125;</span>\t&quot;</span>);<br>                &#125;<br>                Console.WriteLine();<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>Console.Write($&quot;&#123;j&#125; × &#123;i&#125; = &#123;i * j&#125;\t&quot;);</code></p>
<p>字符串插值（String interpolation）的语法。<code>$&#123;j&#125; × &#123;i&#125; = &#123;i * j&#125;\t</code> 是一个包含格式占位符的字符串，其中 <code>&#123;&#125;</code> 用于包含表达式，而 <code>$</code> 前缀表示字符串是一个插值字符串。在这个字符串中，<code>&#123;j&#125;</code> 表示将变量 <code>j</code> 的值插入到字符串中，<code>&#123;i&#125;</code> 表示将变量 <code>i</code> 的值插入到字符串中，<code>&#123;i * j&#125;</code> 表示将变量 <code>i * j</code> 的结果插入到字符串中。<code>\t</code> 是一个制表符，用于在输出中创建水平制表。</p>
<p>综上所述，<code>Console.Write($&quot;&#123;j&#125; × &#123;i&#125; = &#123;i * j&#125;\t&quot;)</code> 的作用是将一条形如 “j × i &#x3D; (i * j)” 的带有制表符的字符串输出到控制台。</p>
</blockquote>
<h3 id="计算素数个数"><a href="#计算素数个数" class="headerlink" title="计算素数个数"></a>计算素数个数</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Prime numbers up to 1000:&quot;</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-number">1000</span>; i++)<br>        &#123;<br>            <span class="hljs-built_in">bool</span> isPrime = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">2</span>; j &lt;= Math.Sqrt(i); j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (i % j == <span class="hljs-number">0</span>)<br>                &#123;<br>                    isPrime = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (isPrime)<br>            &#123;<br>                Console.WriteLine(i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="要求用户输入5个大写字母"><a href="#要求用户输入5个大写字母" class="headerlink" title="要求用户输入5个大写字母"></a>要求用户输入5个大写字母</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> input;<br>        <span class="hljs-built_in">bool</span> isValid = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-keyword">while</span> (!isValid)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;请输入5个大写字母：&quot;</span>);<br>            input = Console.ReadLine();<br><br>            <span class="hljs-keyword">if</span> (input.Length == <span class="hljs-number">5</span> &amp;&amp; IsAllUpperCaseLetters(input))<br>            &#123;<br>                isValid = <span class="hljs-literal">true</span>;<br>                Console.WriteLine(<span class="hljs-string">&quot;输入有效！&quot;</span>);<br><br>                <span class="hljs-comment">// 在这里可以继续处理输入的逻辑</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                Console.WriteLine(<span class="hljs-string">&quot;输入无效，请确保输入5个大写字母。&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsAllUpperCaseLetters</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> input</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">char</span> c <span class="hljs-keyword">in</span> input)<br>        &#123;<br>            <span class="hljs-comment">//检查c是否为大写字母</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">char</span>.IsUpper(c))<br>            &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p><code>char.IsUpper(c)</code> 是一个方法调用，用于判断给定的字符是否为大写字母。<code>char.IsUpper</code> 方法返回一个布尔值，如果字符是大写字母，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</blockquote>
<h2 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h2><h3 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h3><p>猜数字游戏，我有一个数请您猜猜是多少?请忽输入一个0-50之问的数:20( 用户输入数字)您猜小了，这个数字比20大:30.您猜大了，这个数字比30小:25.恭喜您猜对了，这个数字为:25</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultiplicationTable</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            <br>            <span class="hljs-built_in">bool</span> is_read = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">int</span> counter = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (!is_read)<br>            &#123;<br>                <span class="hljs-comment">//让这个语句只执行一次</span><br>                <span class="hljs-keyword">if</span>(counter == <span class="hljs-number">0</span>)<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;请你猜猜我这个数据是多少涅？&quot;</span>);<br>                    counter++;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;不对捏，再猜&quot;</span>);<br>                &#125;<br>               <br>                <span class="hljs-comment">//读入一个int类型数据</span><br>                <span class="hljs-built_in">int</span> readS = Convert.ToInt32(Console.ReadLine());<br>                <span class="hljs-comment">//猜的数据</span><br>                <span class="hljs-built_in">int</span> guess = <span class="hljs-number">61</span>;<br><br>                <span class="hljs-keyword">if</span> (readS == guess)<br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;你猜对了&quot;</span>);<br>                    is_read = <span class="hljs-literal">true</span>;<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(readS &gt; guess) &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;输入的数据比目标数据大&#123;0&#125;&quot;</span>, Math.Abs(guess - readS));<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;输入的数据比目标数据小&#123;0&#125;&quot;</span>, Math.Abs(guess - readS));<br>                &#125;<br><br>            &#125;<br>            Console.ReadKey();<br>           <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">//随机数版本</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MultiplicationTable</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>        &#123;<br>            <span class="hljs-built_in">bool</span> isGuessed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-built_in">int</span> guess = <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>); <span class="hljs-comment">// 生成1到100之间的随机数作为目标数据</span><br><br>            <span class="hljs-keyword">while</span> (!isGuessed)<br>            &#123;<br>                <span class="hljs-built_in">int</span> readS;<br>                Console.WriteLine(<span class="hljs-string">&quot;请你猜猜我这个数据是多少涅？&quot;</span>);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">int</span>.TryParse(Console.ReadLine(), <span class="hljs-keyword">out</span> readS)) <span class="hljs-comment">// 输入验证</span><br>                &#123;<br>                    <span class="hljs-keyword">if</span> (readS == guess)<br>                    &#123;<br>                        Console.WriteLine(<span class="hljs-string">&quot;你猜对了&quot;</span>);<br>                        isGuessed = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readS &gt; guess)<br>                    &#123;<br>                        Console.WriteLine(<span class="hljs-string">&quot;输入的数据比目标数据大&#123;0&#125;&quot;</span>, readS - guess);<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        Console.WriteLine(<span class="hljs-string">&quot;输入的数据比目标数据小&#123;0&#125;&quot;</span>, guess - readS);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    Console.WriteLine(<span class="hljs-string">&quot;输入的不是有效的整数，请重新输入&quot;</span>);<br>                &#125;<br>            &#125;<br><br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>编写一个控制台程序，要求用户输入一组数字，对用户输入的数字从小到大输出。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;请输入一组数字（以逗号分隔）：&quot;</span>);<br>        <span class="hljs-built_in">string</span> input = Console.ReadLine();<br><br>        <span class="hljs-built_in">string</span>[] numbers = input.Split(<span class="hljs-string">&#x27;,&#x27;</span>);<br>        <span class="hljs-built_in">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[numbers.Length];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.Length; i++)<br>        &#123;<br>            <span class="hljs-built_in">int</span>.TryParse(numbers[i], <span class="hljs-keyword">out</span> arr[i]);<br>        &#125;<br><br>        Array.Sort(arr);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;从小到大排序后的数字为：&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> arr)<br>        &#123;<br>            Console.Write(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br><br>        Console.ReadKey();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="猴子吃桃"><a href="#猴子吃桃" class="headerlink" title="猴子吃桃"></a>猴子吃桃</h3><p>每天的桃子数量是前一天桃子数量加1后乘以2的结果。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;请输入天数 n 的值：&quot;</span>);<br>        <span class="hljs-built_in">int</span> n = Convert.ToInt32(Console.ReadLine());<br><br>        <span class="hljs-built_in">int</span> peachCount = CalculatePeaches(n);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;悟空第一天吃桃子的数量为：&quot;</span> + peachCount);<br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CalculatePeaches</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> peachCount = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--)<br>        &#123;<br>            peachCount = (peachCount + <span class="hljs-number">1</span>) * <span class="hljs-number">2</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> peachCount;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="找最小"><a href="#找最小" class="headerlink" title="找最小"></a>找最小</h3><p>输入n(n&lt;100)个数，找出其中最小的数，将它与最前面的数交换后输出这些数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;请输入要输入的数字个数 n（n &lt; 100）：&quot;</span>);<br>        <span class="hljs-built_in">int</span> n = Convert.ToInt32(Console.ReadLine());<br><br>        <span class="hljs-built_in">int</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[n];<br><br>        Console.WriteLine(<span class="hljs-string">&quot;请输入这 &quot;</span> + n + <span class="hljs-string">&quot; 个数字：&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            numbers[i] = Convert.ToInt32(Console.ReadLine());<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> minIndex = FindMinimumIndex(numbers);<br><br>        <span class="hljs-keyword">if</span> (minIndex != <span class="hljs-number">0</span>)<br>        &#123;<br>            Swap(numbers, <span class="hljs-number">0</span>, minIndex);<br>        &#125;<br><br>        Console.WriteLine(<span class="hljs-string">&quot;交换后的数字为：&quot;</span>);<br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> num <span class="hljs-keyword">in</span> numbers)<br>        &#123;<br>            Console.Write(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br><br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">FindMinimumIndex</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> minIndex = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">int</span> minValue = arr[<span class="hljs-number">0</span>];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.Length; i++)<br>        &#123;<br>    <span class="hljs-keyword">if</span> (arr[i] &lt; minValue)<br>            &#123;<br>                minIndex = i;<br>                minValue = arr[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> minIndex;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Swap</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] arr, <span class="hljs-built_in">int</span> index1, <span class="hljs-built_in">int</span> index2</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span> temp = arr[index1];<br>        arr[index1] = arr[index2];<br>        arr[index2] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="发工资"><a href="#发工资" class="headerlink" title="发工资"></a>发工资</h3><p>作为泰课的老师，最盼望的日子就是每月的8号了，因为这一天是发工资的日子，养家糊口就它了，呵呵但是对子素则务处的工作人员来说，这一天是很忙品的天,对务处的小云最近就在考海一个同题:如果每个老所的工资额都和道，最少需要备多少张人民币，才能在治年位老师发工路的时候都不用老师战零呢这里假设老师的工资都是正整数，单位元，人民币一共有100元、50元、10元，5元、2元和1元六种</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;请输入老师的人数：&quot;</span>);<br>        <span class="hljs-built_in">int</span> teacherCount = Convert.ToInt32(Console.ReadLine());<br><br>        Console.WriteLine(<span class="hljs-string">&quot;请输入每位老师的工资额（以空格分隔）：&quot;</span>);<br>        <span class="hljs-built_in">string</span> input = Console.ReadLine();<br>        <span class="hljs-built_in">string</span>[] salaryStrArray = input.Split(<span class="hljs-string">&#x27; &#x27;</span>);<br>        <span class="hljs-built_in">int</span>[] salaries = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[teacherCount];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; teacherCount; i++)<br>        &#123;<br>            salaries[i] = Convert.ToInt32(salaryStrArray[i]);<br>        &#125;<br><br>        <span class="hljs-built_in">int</span> minimumBills = CalculateMinimumBills(salaries);<br><br>        Console.WriteLine(<span class="hljs-string">&quot;最少需要备 &quot;</span> + minimumBills + <span class="hljs-string">&quot; 张人民币。&quot;</span>);<br>        Console.ReadKey();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">CalculateMinimumBills</span>(<span class="hljs-params"><span class="hljs-built_in">int</span>[] salaries</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">int</span>[] denominations = &#123; <span class="hljs-number">100</span>, <span class="hljs-number">50</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span> &#125;;<br>        <span class="hljs-built_in">int</span> minimumBills = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">int</span> salary <span class="hljs-keyword">in</span> salaries)<br>        &#123;<br>            <span class="hljs-built_in">int</span> remainingSalary = salary;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; denominations.Length; i++)<br>            &#123;<br>                minimumBills += remainingSalary / denominations[i];<br>                remainingSalary %= denominations[i];<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> minimumBills;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="判断是否合法"><a href="#判断是否合法" class="headerlink" title="判断是否合法"></a>判断是否合法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Text.RegularExpressions;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 从用户输入中获取标识符</span><br>        Console.WriteLine(<span class="hljs-string">&quot;请输入一个标识符:&quot;</span>);<br>        <span class="hljs-built_in">string</span> input = Console.ReadLine();<br><br>        <span class="hljs-comment">// 使用正则表达式检查标识符的合法性</span><br>        <span class="hljs-built_in">bool</span> isValidIdentifier = Regex.IsMatch(input, <span class="hljs-string">@&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;</span>);<br><br>        <span class="hljs-comment">// 输出结果</span><br>        <span class="hljs-keyword">if</span> (isValidIdentifier)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;输入的字符串是一个合法的C#标识符&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;输入的字符串不是一个合法的C#标识符&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>正则表达式：</p>
</blockquote>
<h2 id="c-面向对象"><a href="#c-面向对象" class="headerlink" title="c#面向对象"></a>c#面向对象</h2><p>面向对象编程（Object-Oriented Programming，简称OOP）是一种编程范式，它将程序设计问题划分为对象的集合，这些对象通过相互之间的交互来解决问题。在面向对象编程中，程序被组织成一组对象，每个对象都是类的实例，类定义了对象的属性（数据）和行为（方法）。</p>
<p>面向对象编程的核心思想是将真实世界中的事物抽象成为程序中的对象，每个对象都具有自己的状态和行为。对象可以通过发送消息（调用方法）来与其他对象进行交互，从而实现数据的封装、继承和多态性等特性。</p>
<p>面向对象编程具有以下特点：</p>
<ol>
<li>封装（Encapsulation）：将数据和操作封装在对象中，对象对外部提供有限的接口来访问和修改其内部状态，隐藏了实现细节，增强了安全性和模块化。</li>
<li>继承（Inheritance）：通过继承机制，一个类可以派生出子类，子类继承了父类的属性和方法，并可以在此基础上进行扩展或修改，实现代码的重用和扩展。</li>
<li>多态（Polymorphism）：多态性允许对象根据上下文的不同呈现不同的行为。通过多态，可以通过父类类型引用来引用子类对象，并根据实际对象类型来调用相应的方法。</li>
</ol>
<p>面向对象编程能够提供更加模块化、可扩展和可维护的代码，通过将问题分解成对象的方式来组织代码结构，使得代码更易于理解和重用。它被广泛应用于许多编程语言和软件开发领域。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在C#中，命名空间（Namespace）用于组织和管理代码，提供了一种避免命名冲突和代码组织的机制。命名空间可以包含类、结构、枚举、接口和其他命名空间等元素。</p>
<p>以下是一些命名空间的作用：</p>
<ol>
<li><strong>避免命名冲突</strong>：命名空间提供了一种将相关的类、结构和其他元素组织在一起的方式。不同命名空间中的同名类或成员不会发生冲突，可以在代码中使用完全限定名（包含命名空间）来区分它们。</li>
<li><strong>代码组织和模块化</strong>：命名空间可以按照逻辑关系将代码组织成模块，提高代码的可读性和可维护性。通过使用命名空间，可以将相关的类和功能放在一起，使代码更加结构化。</li>
<li><strong>访问控制和可见性</strong>：命名空间可以定义公共（public）和非公共（internal、private）的元素，从而控制代码的可见性和访问级别。通过将类和成员放置在适当的命名空间中，并使用适当的访问修饰符，可以限制对代码的访问。</li>
<li><strong>代码重用和组件化</strong>：命名空间可以用于组织和管理代码库中的各个组件。可以通过引用相应的命名空间来重用其他代码库中的类和功能，提高代码的重用性和可维护性。</li>
<li><strong>名称空间别名</strong>：命名空间还可以使用别名来简化代码中的引用。通过使用<code>using</code>关键字并提供一个别名，可以在代码中使用简短的名称来引用长命名空间，减少代码的冗余性和书写工作。</li>
</ol>
<p>例如，以下是一个使用命名空间的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeusing System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MyApplication</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>using System</code>语句引入了名为<code>System</code>的命名空间，其中包含了<code>Console</code>类。这样就可以直接使用<code>Console.WriteLine</code>方法而不需要使用完全限定名。</p>
<p>总而言之，命名空间在C#中提供了一种组织、管理和控制代码的机制，可以提高代码的可读性、可维护性和可重用性，并帮助避免命名冲突。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装（Encapsulation）是面向对象编程中的一个重要概念，它指的是将数据和操作封装在一个单元（如类）中，以实现信息隐藏和安全性。</p>
<p>封装通过将相关的数据和操作组合在一起形成一个单元，将其视为一个独立的实体，并对外部隐藏其内部实现细节。这意味着外部代码无法直接访问和修改封装单元的数据，而是通过定义的公共接口来与其进行交互。</p>
<p>类是实现封装的主要方式之一。在面向对象编程中，类是一个封装数据和方法的模板。它将数据（成员变量）和操作（成员方法）组合在一起，形成一个独立的实体。</p>
<p>通过使用访问修饰符（如<code>public</code>、<code>private</code>、<code>protected</code>等），类可以控制成员的可访问性。私有成员只能在类的内部访问，而公共成员可以被外部代码访问。这种访问控制机制实现了封装的一部分，通过隐藏内部实现细节，提高了代码的安全性和可维护性。</p>
<p>封装的优点包括：</p>
<ol>
<li>数据隐藏：封装可以隐藏类的内部数据，防止外部直接访问和修改，从而确保数据的一致性和完整性。</li>
<li>安全性：通过限制对类的访问权限，可以控制外部代码对类的操作，提高安全性。</li>
<li>简化接口：封装通过定义公共接口，隐藏内部实现细节，使外部代码只需要关注如何使用接口而不需要了解内部实现。</li>
<li>代码重用：封装可以将相关的数据和方法组合在一起，形成可重用的类，提高代码的可维护性和可重用性。</li>
<li>隔离变化：封装可以隔离类的内部实现细节，当需要修改内部实现时，只需修改类的内部，而不影响外部代码。</li>
</ol>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在C#中，类（Class）是一种用户自定义的数据类型，它定义了对象的属性（数据成员）和行为（成员方法）。类是面向对象编程的核心概念之一，它允许开发人员将相关的数据和功能封装在一个单独的实体中。</p>
<p>类可以看作是对象的蓝图或模板，用于创建具体的对象实例。每个对象实例都基于类的定义，并拥有自己的一组属性和行为。</p>
<p>类的定义通常包含以下组成部分：</p>
<ol>
<li>类名：类的名称，用于标识和引用该类。</li>
<li>数据成员：用于存储对象的状态或属性的变量。这些成员可以是各种数据类型，如整数、浮点数、字符串等。</li>
<li>成员方法：用于定义对象的行为和功能的函数。成员方法可以访问和操作数据成员，并执行其他操作。</li>
</ol>
<p>以下是一个简单的C#类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-comment">// 数据成员</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age;<br><br>    <span class="hljs-comment">// 成员方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SayHello</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Hello, my name is &quot;</span> + Name + <span class="hljs-string">&quot; and I am &quot;</span> + Age + <span class="hljs-string">&quot; years old.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，定义了一个名为”Person”的类，它具有两个数据成员：Name（姓名）和Age（年龄），以及一个成员方法SayHello（打招呼），用于输出一个简单的问候语。使用该类，可以创建多个Person对象的实例，并访问它们的属性和方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codePerson person1 = <span class="hljs-keyword">new</span> Person();<br>person1.Name = <span class="hljs-string">&quot;John&quot;</span>;<br>person1.Age = <span class="hljs-number">25</span>;<br>person1.SayHello();<br><br>Person person2 = <span class="hljs-keyword">new</span> Person();<br>person2.Name = <span class="hljs-string">&quot;Alice&quot;</span>;<br>person2.Age = <span class="hljs-number">30</span>;<br>person2.SayHello();<br></code></pre></td></tr></table></figure>

<p>上述代码创建了两个Person对象的实例，分别设置它们的姓名和年龄，并调用它们的SayHello方法输出问候语。</p>
<blockquote>
<p>类访问修饰符号：</p>
<p>在C#中，类的访问修饰符用于控制类的可见性和访问级别。C#提供了以下几种类的访问修饰符：</p>
<ol>
<li><strong>public</strong>：公共访问修饰符，表示该类对于所有代码都是可见的。可以从任何位置访问该类。</li>
<li><strong>private</strong>：私有访问修饰符，表示该类仅对于当前类内部可见。其他类无法直接访问私有类。</li>
<li><strong>protected</strong>：受保护访问修饰符，表示该类对于当前类及其派生类可见。其他类无法直接访问受保护类。</li>
<li><strong>internal</strong>：内部访问修饰符，表示该类对于当前程序集内的其他类可见。跨程序集时无法访问内部类。</li>
<li><strong>protected internal</strong>：受保护内部访问修饰符，表示该类对于当前程序集内的其他类及其派生类可见。跨程序集时无法访问受保护内部类。</li>
</ol>
<p>这些访问修饰符可以应用于类的定义，以控制类的可见性和访问级别。默认情况下，如果没有显式指定访问修饰符，类的访问级别为<code>internal</code>（内部）。</p>
<p>以下是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title">PublicClass</span><br>&#123;<br>    <span class="hljs-comment">// 可以从任何位置访问PublicClass</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PrivateClass</span><br>&#123;<br>    <span class="hljs-comment">// 仅对当前类内部可见</span><br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProtectedClass</span><br>&#123;<br>    <span class="hljs-comment">// 仅对当前类及其派生类可见</span><br>&#125;<br><br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InternalClass</span><br>&#123;<br>    <span class="hljs-comment">// 仅对当前程序集内的其他类可见</span><br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProtectedInternalClass</span><br>&#123;<br>    <span class="hljs-comment">// 对当前程序集内的其他类及其派生类可见</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>请注意，类的访问修饰符还可以与其他修饰符（如静态修饰符<code>static</code>、抽象修饰符<code>abstract</code>等）一起使用，以提供更多的控制和灵活性。</p>
<p><strong>tip: 在类中如果声明的时候没有加访问修饰符，一般默认为private</strong></p>
</blockquote>
<h5 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h5><p>当提及C#语言时，类的构造函数是通过使用特定的构造函数语法来定义的。在C#中，构造函数与类的名称相同，并且可以包含参数。以下是一个简单的C#类和构造函数的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment">// 无参数构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 构造函数的代码逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">int</span> age</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 构造函数的代码逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyClass</code>类具有两个构造函数。第一个构造函数是无参数的构造函数，它不接受任何参数。第二个构造函数是带有两个参数（<code>name</code>和<code>age</code>）的构造函数。</p>
<p>你可以根据实际需要在构造函数中执行各种初始化任务，例如设置对象的初始状态、分配内存、初始化成员变量等。</p>
<p>在使用C#时，你可以根据需要选择使用适当的构造函数，并在创建类的实例时自动调用相应的构造函数。</p>
<blockquote>
<p><strong>在C#中，有参构造函数不会直接代替无参构造函数。当一个类定义了有参构造函数时，如果没有显式定义无参构造函数，编译器将不会为类自动生成默认的无参构造函数。</strong></p>
<p>无参构造函数（也称为默认构造函数）是一个没有参数的构造函数，它在创建类的新实例时使用。如果没有显式定义无参构造函数，编译器会自动为类生成一个默认的无参构造函数。无参构造函数通常用于执行类的基本初始化操作，例如将成员变量设置为默认值。</p>
<p>有参构造函数是一个带有一个或多个参数的构造函数，它允许在创建对象时提供初始化所需的值。有参构造函数可以接受参数，并用这些参数对类的成员进行初始化。</p>
<p>如果一个类定义了有参构造函数，而没有显式定义无参构造函数，那么在创建类的实例时，必须使用有参构造函数并提供必要的参数。如果尝试使用无参构造函数创建对象，编译器将报错。</p>
<p>然而，如果需要在类中同时支持有参构造函数和无参构造函数，可以通过<strong>重载构造函数的方式实现。重载构造函数允许在一个类中定义多个构造函数，每个构造函数有不同的参数列表。在重载构造函数中，可以在参数列表不同的构造函数中实现不同的初始化逻辑。</strong></p>
<p>以下是一个示例，演示了有参构造函数和无参构造函数的使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeclass MyClass<br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> myVariable;<br><br>    <span class="hljs-comment">// 有参构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        myVariable = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 无参构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        myVariable = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayVariable</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;变量的值为：&quot;</span> + myVariable);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyClass myObject1 = <span class="hljs-keyword">new</span> MyClass(<span class="hljs-number">10</span>);<br>        myObject1.DisplayVariable(); <span class="hljs-comment">// 输出：变量的值为：10</span><br><br>        MyClass myObject2 = <span class="hljs-keyword">new</span> MyClass();<br>        myObject2.DisplayVariable(); <span class="hljs-comment">// 输出：变量的值为：0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，**<code>MyClass</code> 类定义了一个有参构造函数和一个无参构造函数。有参构造函数接受一个整数参数，并将其用于初始化私有变量 <code>myVariable</code>。无参构造函数将 <code>myVariable</code> 设置为默认值 0。**</p>
<p>通过在创建对象时选择适当的构造函数，我们可以使用有参构造函数或无参构造函数来初始化类的实例，并执行相应的初始化操作。这样，无参构造函数和有参构造函数可以在不同的情况下使用。</p>
</blockquote>
<h5 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h5><p>在C#中，析构函数（Destructor）是一种特殊的方法，用于在对象被销毁之前执行清理操作。析构函数通常用于释放对象占用的资源，例如关闭文件、释放内存、关闭数据库连接等。</p>
<p>在C#中，析构函数使用特殊的语法进行定义，其名称与类的名称相同，但前面加上一个波浪线（~）。析构函数不能有参数，也不能被显式地调用，而是由垃圾回收器自动在对象被销毁时调用。</p>
<p>以下是一个简单的C#类和析构函数的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 构造函数的代码逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~MyClass()<br>    &#123;<br>        <span class="hljs-comment">// 析构函数的代码逻辑，执行清理操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyClass</code>类具有一个构造函数和一个析构函数。当对象被销毁时，垃圾回收器会自动调用析构函数，以执行清理操作。</p>
<p>需要注意的是，<strong>C#的垃圾回收器会自动管理对象的内存，因此在大多数情况下，你不需要显式地定义和使用析构函数。析构函数通常用于释放非托管资源（如文件句柄或数据库连接），在使用这些资源时可能需要手动清理。</strong>对于托管资源，垃圾回收器会自动进行垃圾回收和内存释放。</p>
<p>但是，如果确实有需要使用析构函数进行清理操作的情况，可以通过析构函数来实现。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在C#中，属性（Property）是一种特殊的成员，用于封装类的字段（Field）并提供对其读取和写入的访问方法。属性允许你定义类的外部代码如何访问和操作类的数据。</p>
<p>属性通过使用<code>get</code>和<code>set</code>访问器来定义读取和写入操作。<code>get</code>访问器用于获取属性的值，而<code>set</code>访问器用于设置属性的值。属性可以具有不同的访问修饰符，例如<code>public</code>、<code>private</code>、<code>protected</code>等，用于控制属性的可见性。</p>
<p>以下是一个简单的C#类和属性的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> name; &#125;<br>        <span class="hljs-keyword">set</span> &#123; name = <span class="hljs-keyword">value</span>; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>Person</code>类有一个名为<code>Name</code>的属性。属性的类型是<code>string</code>，并且使用了默认的访问修饰符<code>public</code>。属性对应的字段是<code>name</code>，它被<code>private</code>修饰，只能在类的内部访问。</p>
<p><strong>通过定义属性，可以通过以下方式读取和写入属性的值：</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">Person person = <span class="hljs-keyword">new</span> Person();<br>person.Name = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// 设置属性的值</span><br><span class="hljs-built_in">string</span> name = person.Name; <span class="hljs-comment">// 获取属性的值</span><br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们使用属性来设置和获取<code>Person</code>对象的<code>Name</code>属性的值。</p>
<p>属性提供了一种更加直观和易于使用的方式来访问类的字段，并且可以对字段的读取和写入进行额外的逻辑处理，例如数据验证、计算等。属性使得代码更具可读性、可维护性和安全性。</p>
<blockquote>
<p>get访问器：</p>
<p>当定义属性时，<code>get</code> 访问器用于获取属性的值。它指定了在访问属性时应该执行的代码逻辑。<code>get</code> 访问器没有参数，并且返回与属性类型相匹配的值。</p>
<p>以下是 <code>get</code> 访问器的基本语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> &lt;type&gt; PropertyName<br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-comment">// 返回属性的值的代码逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>&lt;type&gt;</code> 中，你需要指定属性的类型。代码逻辑部分位于 <code>get</code> 访问器的花括号中，用于返回属性的值。</p>
<p>让我们看一个示例，假设我们有一个 <code>Person</code> 类，其中包含 <code>name</code> 字段和 <code>Name</code> 属性，我们使用 <code>get</code> 访问器获取 <code>Name</code> 属性的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>Name</code> 属性的 <code>get</code> 访问器简单地返回 <code>name</code> 字段的值。</p>
<p>当我们创建 <code>Person</code> 对象时，我们可以通过调用 <code>Name</code> 属性来获取 <code>name</code> 字段的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">Person person = <span class="hljs-keyword">new</span> Person();<br>person.Name = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// 这里是错误的，因为 Name 属性只定义了 get 访问器</span><br><span class="hljs-built_in">string</span> name = person.Name; <span class="hljs-comment">// 获取属性的值</span><br>Console.WriteLine(name); <span class="hljs-comment">// 输出 &quot;John&quot;</span><br></code></pre></td></tr></table></figure>

<p>请注意，由于属性只定义了 <code>get</code> 访问器，我们不能使用 <code>person.Name = &quot;John&quot;</code> 这样的语法为属性赋值，这将导致编译错误。只有当属性同时定义了 <code>get</code> 和 <code>set</code> 访问器时，我们才可以读取和写入属性的值。</p>
<p>通过使用 <code>get</code> 访问器，我们可以实现对属性的封装，并在需要时提供定制的获取逻辑，例如对属性进行计算、验证或其他处理。<br><code>set</code> 访问器:</p>
<p>当定义属性时，<code>set</code> 访问器用于设置属性的值。它指定了在给属性赋值时应该执行的代码逻辑。<code>set</code> 访问器接受一个参数，用于传递要设置的值。</p>
<p>以下是 <code>set</code> 访问器的基本语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> &lt;type&gt; PropertyName<br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-comment">// 返回属性的值的代码逻辑</span><br>    &#125;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        <span class="hljs-comment">// 设置属性的值的代码逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 <code>&lt;type&gt;</code> 中，你需要指定属性的类型。<code>set</code> 访问器包含一个名为 <code>value</code> 的特殊参数，用于传递要设置的值。你可以在 <code>set</code> 访问器的代码逻辑中使用 <code>value</code> 参数来设置属性的值。</p>
<p>让我们看一个示例，假设我们有一个 <code>Person</code> 类，其中包含 <code>name</code> 字段和 <code>Name</code> 属性，我们使用 <code>get</code> 和 <code>set</code> 访问器来获取和设置 <code>Name</code> 属性的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> name;<br>        &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            name = <span class="hljs-keyword">value</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>Name</code> 属性定义了 <code>get</code> 和 <code>set</code> 访问器。<code>get</code> 访问器返回 <code>name</code> 字段的值，而 <code>set</code> 访问器将传递的值赋给 <code>name</code> 字段。</p>
<p>当我们创建 <code>Person</code> 对象时，我们可以通过调用 <code>Name</code> 属性来获取和设置 <code>name</code> 字段的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">Person person = <span class="hljs-keyword">new</span> Person();<br>person.Name = <span class="hljs-string">&quot;John&quot;</span>; <span class="hljs-comment">// 设置属性的值</span><br><span class="hljs-built_in">string</span> name = person.Name; <span class="hljs-comment">// 获取属性的值</span><br>Console.WriteLine(name); <span class="hljs-comment">// 输出 &quot;John&quot;</span><br></code></pre></td></tr></table></figure>

<p>通过使用 <code>set</code> 访问器，我们可以在为属性赋值时执行验证、计算或其他逻辑。我们可以根据需要自定义 <code>set</code> 访问器的行为，例如检查传递的值是否满足某些条件，然后再决定是否设置属性的值。</p>
</blockquote>
<blockquote>
<p>属性（Property）和变量（Variable）在 C# 中有几个重要的区别：</p>
<ol>
<li>访问方式：属性提供了对类的字段的封装访问方式，通过使用 get 和 set 访问器来读取和修改属性的值。而变量可以直接读取和修改其存储的值。</li>
<li>封装性和控制：属性允许你在访问器中添加额外的逻辑，以对数据进行验证、处理或实施封装策略。这使得属性更加灵活和可控。而变量没有这种封装和控制的额外层面。</li>
<li>语法：属性使用特定的语法来定义，包含 get 和 set 访问器。变量则是通过简单的声明来定义。</li>
<li>外部可见性：属性可以具有不同的可见性修饰符，可以控制属性的访问级别。变量的可见性取决于其所在的作用域。</li>
<li>命名约定：属性通常使用 PascalCase 命名约定，以强调它们的行为和封装性。变量通常使用 camelCase 命名约定。</li>
</ol>
<p>总的来说，属性提供了更好的封装性、控制和灵活性，使得对类中的字段的访问和操作更加可控和一致。变量则是简单的数据存储容器，可以直接访问和修改其值。你可以根据具体的需求和设计目标选择使用属性或变量。</p>
</blockquote>
<h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p>匿名类型是使用 <code>var</code> 关键字声明的一种特殊类型，它在编译时期由编译器自动推断出来。匿名类型是具有只读属性的类，它的属性名称和类型是根据初始化时提供的属性和值自动生成的。</p>
<p>匿名类型的语法如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codevar anonymousObject = <span class="hljs-keyword">new</span><br>&#123;<br>    Property1 = value1,<br>    Property2 = value2,<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>anonymousObject</code> 是使用 <code>var</code> 声明的匿名类型变量。通过使用 <code>new</code> 关键字和对象初始化器的方式，我们可以创建一个匿名类型对象，并指定一组属性和对应的值。</p>
<p>匿名类型的属性是只读的，即不能在运行时修改其值。编译器为匿名类型生成一个类，并自动为每个属性创建一个只读的公共属性。匿名类型的属性名称和类型在编译时期确定，而不是在运行时。</p>
<p>匿名类型主要用于临时存储和传递一组相关的数据，通常与LINQ查询一起使用，以方便地处理查询结果。由于匿名类型没有显式的类定义，它们在编译时期是未知的，因此不能将匿名类型直接转换为其他类型。如果需要将匿名类型的数据转换为其他类型，可以使用显式类型转换或将其属性值逐个提取到新的对象中。</p>
<p>请注意，匿名类型的作用域通常被限制在定义它们的方法或代码块内部。超出作用域后，匿名类型将不再可用。</p>
<blockquote>
<p>匿名类型在C#中是通过 <code>new</code> 关键字创建的，它可以是结构体（struct）或类（class）的实例。实际上，编译器会根据匿名类型的属性数量和类型来决定生成结构体还是类。</p>
<p>当匿名类型的属性都是值类型（如整数、字符串等）时，编译器会生成一个结构体作为匿名类型的实例。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codevar anonymousObject = <span class="hljs-keyword">new</span><br>&#123;<br>    Property1 = <span class="hljs-number">42</span>,<br>    Property2 = <span class="hljs-string">&quot;Hello&quot;</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，由于 <code>Property1</code> 是整数类型，<code>Property2</code> 是字符串类型，编译器会生成一个结构体作为匿名类型的实例。</p>
<p>当匿名类型的属性包含引用类型（如自定义类、数组等）时，编译器会生成一个类作为匿名类型的实例。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codevar anonymousObject = <span class="hljs-keyword">new</span><br>&#123;<br>    Property1 = <span class="hljs-keyword">new</span> MyClass(),<br>    Property2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>Property1</code> 是一个自定义类的实例，<code>Property2</code> 是一个整数数组，因此编译器会生成一个类作为匿名类型的实例。</p>
<p>无论是结构体还是类，匿名类型都是只读的，不能在运行时修改其属性的值。匿名类型的属性名称和类型是在编译时期确定的。</p>
<p>需要注意的是，由于匿名类型是在编译时期生成的，所以它们的具体类型名称是不可知的，并且不能将匿名类型直接转换为其他类型。如果需要将匿名类型的数据转换为其他类型，可以使用显式类型转换或将其属性值逐个提取到新的对象中。</p>
</blockquote>
<h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>在C#中，堆（Heap）和栈（Stack）是两种用于存储和管理内存的重要概念。</p>
<p>栈（Stack）：</p>
<ul>
<li>栈是一种用于存储局部变量和方法调用的内存区域。</li>
<li>栈中的数据以“后进先出”（LIFO）的方式进行操作。</li>
<li>栈的操作非常高效，因为它使用简单的指针操作来管理内存。</li>
<li>当你调用一个方法时，该方法的局部变量和参数将被分配到栈上。当方法执行完毕，栈上的数据将被释放。</li>
</ul>
<p>堆（Heap）：</p>
<ul>
<li>堆是一种用于存储动态分配的对象的内存区域。</li>
<li>堆中的数据可以以任意顺序进行操作，没有特定的顺序要求。</li>
<li>堆的操作相对较慢，因为它需要进行内存分配和垃圾回收。</li>
<li>当你使用 <code>new</code> 关键字创建一个对象时，该对象将被分配到堆上。堆上的对象可以长时间存在，直到垃圾回收器将其标记为不再使用。</li>
</ul>
<p>在C#中，基本数据类型（如整数、浮点数、布尔值等）和引用类型（如类、接口、数组等）的存储位置有所不同：</p>
<ul>
<li>基本数据类型通常存储在栈上。当你声明一个基本数据类型的变量并为其赋值时，数据将直接存储在栈上。这些变量的生命周期在其作用域结束时就会结束。</li>
<li>引用类型的变量本身存储在栈上，但实际的对象存储在堆上。当你声明一个引用类型的变量并为其赋值时，变量本身存储在栈上，而对象存储在堆上。对象的生命周期由垃圾回收器来管理，垃圾回收器会自动检测不再使用的对象并进行回收。</li>
</ul>
<p>需要注意的是，通过传递引用类型变量作为参数或在方法中创建对象时，引用类型的对象可能存储在堆上或栈上。这取决于具体的情况和编译器的优化策略。</p>
<p>总结起来，栈用于存储局部变量和方法调用，它的操作效率高；堆用于存储动态分配的对象，它的操作相对较慢。在C#中，栈和堆都是用于管理内存的重要部分，理解它们的运行逻辑有助于编写高效和可靠的代码。</p>
<h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h4><p>在C#中，变量可以是值类型（Value Types）或引用类型（Reference Types）。这两种类型在内存中的存储方式和行为有所不同。</p>
<p>值类型（Value Types）：</p>
<ul>
<li>值类型的变量直接包含其数据的实际值。</li>
<li>值类型的变量在栈上分配内存。</li>
<li>值类型的赋值是通过将一个变量的值复制到另一个变量来完成的。</li>
<li>值类型的变量通常具有固定的大小，由编译时确定。</li>
<li>值类型包括整数类型（如int、float、double等）、布尔类型（bool）、字符类型（char）、结构体（struct）等。</li>
</ul>
<p>下面是一个值类型的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeint x = <span class="hljs-number">10</span>; <span class="hljs-comment">// 值类型变量 x，存储在栈上</span><br><span class="hljs-built_in">int</span> y = x; <span class="hljs-comment">// 将 x 的值复制给 y</span><br>y = <span class="hljs-number">20</span>; <span class="hljs-comment">// 修改 y 不会影响 x 的值</span><br>Console.WriteLine(x); <span class="hljs-comment">// 输出 10</span><br>Console.WriteLine(y); <span class="hljs-comment">// 输出 20</span><br></code></pre></td></tr></table></figure>

<p>引用类型（Reference Types）：</p>
<ul>
<li>引用类型的变量存储的是对象的引用，而不是对象的实际数据。</li>
<li>引用类型的变量在栈上分配内存，但对象本身存储在堆上。</li>
<li>引用类型的赋值是通过将一个变量的引用复制到另一个变量来完成的，这样两个变量将引用同一个对象。</li>
<li>引用类型的大小是固定的，不受对象数据大小的影响，因为变量本身只是引用。</li>
<li>引用类型包括类（class）、接口（interface）、委托（delegate）、字符串（string）等。</li>
</ul>
<p>下面是一个引用类型的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">int</span>[] array1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;; <span class="hljs-comment">// 引用类型变量 array1，存储在栈上，对象存储在堆上</span><br><span class="hljs-built_in">int</span>[] array2 = array1; <span class="hljs-comment">// 将 array1 的引用复制给 array2</span><br>array2[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>; <span class="hljs-comment">// 修改 array2 也会影响 array1 中的值</span><br>Console.WriteLine(array1[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 10</span><br>Console.WriteLine(array2[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出 10</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，值类型的赋值是将值复制给另一个变量，而引用类型的赋值是复制引用。这意味着修改引用类型变量的值会影响到其他引用同一对象的变量，因为它们引用的是同一个对象。</p>
<p>在实际编程中，理解值类型和引用类型的区别很重要，因为它们的存储和传递方式不同，可能会对程序的行为产生影响。</p>
<blockquote>
<p><strong>值类型和引用类型在内存中的存储原理有所不同。</strong></p>
<p>值类型是指基本数据类型（如整数、浮点数、布尔值等）以及结构体（struct）等，它们的值直接存储在栈（stack）内存中。栈是一种后进先出（LIFO）的数据结构，用于存储局部变量和方法调用的上下文。当一个值类型的变量被声明时，系统会为其分配一块栈内存，并将值直接存储在这块内存中。当变量超出其作用域时，栈内存会被自动释放。</p>
<p>引用类型是指类（class）、接口（interface）、数组（array）以及字符串（string）等，它们的值存储在堆（heap）内存中。堆是一种动态分配的内存区域，用于存储对象和数据结构。当一个引用类型的变量被声明时，系统会为其分配一块堆内存，并将变量的引用（即指向该对象或数据结构的内存地址）存储在栈内存中。引用类型的变量实际上存储的是对象或数据结构在堆内存中的地址，通过这个地址可以找到实际存储的值。当变量超出其作用域时，只有栈内存中的引用被释放，而堆内存中的实际对象或数据结构需要等待垃圾回收器（garbage collector）进行回收。</p>
<p>这种区别在于内存的管理方式。值类型的存储是直接的，而引用类型的存储则是通过引用来访问实际的数据。这也意味着对于值类型的操作是在栈上进行的，而对于引用类型的操作需要通过引用来查找并操作堆内存中的数据。</p>
<p><strong>在C#中，值类型和引用类型在内存中的存储原理与前面描述的概念基本相同。</strong></p>
<p>对于值类型，在C#中包括基本数据类型（如整数、浮点数、布尔值等）以及结构体（struct）。这些值类型的实例直接存储在栈内存中，而不是堆内存。当值类型的变量被声明时，内存会分配在栈上，并将值直接存储在该栈内存中。当变量超出其作用域时，栈内存会自动释放。</p>
<p>引用类型在C#中包括类（class）、接口（interface）、数组（array）以及字符串（string）。这些引用类型的实例存储在堆内存中。当引用类型的变量被声明时，内存会分配在栈上，并将引用（即指向堆内存中对象的地址）存储在栈内存中。实际的对象或数据结构则存储在堆内存中。当变量超出其作用域时，栈内存中的引用会被释放，但堆内存中的对象或数据结构会等待垃圾回收器进行回收。</p>
<p>需要注意的是，<strong>C#中的引用类型还涉及到垃圾回收的机制</strong>。垃圾回收器会定期检查堆内存中的对象，释放不再被引用的对象，并回收其所占用的内存。这可以减轻开发者的内存管理负担，但也意味着无法精确控制对象的生命周期和内存释放的时机，因此在某些情况下可能会出现性能问题。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在C#中，类可以通过继承来扩展和重用现有的类。继承是面向对象编程中的一个重要概念，它允许你创建一个新类，从一个或多个现有的类中派生，继承其属性和方法。</p>
<p><strong>要在C#中实现类的继承，你可以使用冒号（:）符号来指定一个类派生自另一个类。派生类（子类）继承基类（父类）的成员，并可以添加自己的成员或覆盖基类的成员。</strong></p>
<p>下面是一个简单的示例，演示了如何在C#中实现类的继承：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-comment">// 基类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Eat</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal is eating.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Bark</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog is barking.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用继承的示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        dog.Eat();  <span class="hljs-comment">// 继承自基类 Animal</span><br>        dog.Bark(); <span class="hljs-comment">// 派生类 Dog 自己的方法</span><br><br>        Console.ReadLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code>类是基类，<code>Dog</code>类是派生类。<code>Dog</code>类继承了<code>Animal</code>类的<code>Eat()</code>方法，并添加了自己的<code>Bark()</code>方法。在<code>Main</code>方法中，我们创建了<code>Dog</code>的实例，并可以调用继承的方法和自己的方法。</p>
<p>继承的优点是可以实现代码的重用和层次化设计。派生类可以访问基类的非私有成员（公有、受保护或受内部可见性约束的成员），并且可以通过方法覆盖来修改或扩展基类的行为。</p>
<p>注意：在C#中，一个类只能直接继承自一个基类，即C#不支持多重继承。但是，你可以通过接口来实现类似多重继承的效果。</p>
<blockquote>
<p>在使用继承时，有一些需要注意的事项：</p>
<ol>
<li>类之间的逻辑关系：继承应该基于”是一个”的关系，即派生类是基类的一种特化或扩展。确保在建立继承关系时，派生类能够满足基类的行为和属性，遵循类之间的逻辑关系。</li>
<li>单一继承原则：C#中只支持单一继承，一个类只能直接继承自一个基类。这意味着你需要谨慎选择基类，以确保派生类能够获取所需的功能。</li>
<li>虚方法和方法重写：当使用继承时，如果你希望在派生类中重写基类的方法，可以将基类中的方法声明为<code>virtual</code>，然后在派生类中使用<code>override</code>来进行重写。这样可以实现多态性，确保在运行时根据对象的实际类型调用正确的方法。</li>
<li>访问修饰符的考虑：继承关系中，派生类对于基类的成员的访问权限取决于成员的访问修饰符。如果基类的成员是私有的（private），则派生类无法直接访问。如果基类的成员是受保护的（protected），则派生类可以直接访问。如果基类的成员是公共的（public），则派生类可以直接访问。</li>
<li>构造函数的继承：派生类默认会调用基类的无参构造函数，如果基类没有无参构造函数，则需要在派生类中显式调用基类的有参构造函数。</li>
<li>基类和派生类的生命周期管理：在继承关系中，需要注意基类和派生类对象的创建、销毁和生命周期管理。确保在适当的时候释放资源，避免内存泄漏等问题。</li>
<li>避免过度继承：过度的继承可能导致类之间的耦合性增加，难以维护和扩展。在设计类继承关系时，尽量遵循单一责任原则，保持继承关系的简洁和清晰。</li>
</ol>
</blockquote>
<h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><p>虚方法是C#中用于实现多态性的一种特殊类型的方法。通过将方法声明为虚方法，可以在派生类中重写该方法，实现基于对象的实际类型来调用相应的方法。</p>
<p>在C#中，使用<code>virtual</code>关键字来声明一个方法为虚方法。以下是一个示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The animal makes a sound.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The cat meows.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Animal animal = <span class="hljs-keyword">new</span> Animal();<br>        animal.MakeSound();  <span class="hljs-comment">// 输出：&quot;The animal makes a sound.&quot;</span><br><br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        dog.MakeSound();     <span class="hljs-comment">// 输出：&quot;The dog barks.&quot;</span><br><br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br>        cat.MakeSound();     <span class="hljs-comment">// 输出：&quot;The cat meows.&quot;</span><br><br>        Animal polymorphicAnimal = <span class="hljs-keyword">new</span> Dog();<br>        polymorphicAnimal.MakeSound();  <span class="hljs-comment">// 输出：&quot;The dog barks.&quot;</span><br><br>        Console.ReadLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code>类中的<code>MakeSound()</code>方法被声明为虚方法，允许派生类进行方法的重写。<code>Dog</code>和<code>Cat</code>类分别重写了基类中的<code>MakeSound()</code>方法，提供了它们自己的实现。</p>
<p>在<code>Main</code>方法中，我们创建了<code>Animal</code>、<code>Dog</code>和<code>Cat</code>的实例，并分别调用它们的<code>MakeSound()</code>方法。此外，我们还创建了一个<code>Animal</code>类型的变量，但将其实际引用为<code>Dog</code>类的实例。这体现了多态性，当我们调用<code>MakeSound()</code>方法时，实际执行的是<code>Dog</code>类中重写的方法。</p>
<p>通过使用虚方法和方法重写，我们可以根据具体对象的类型来决定调用哪个方法，实现了运行时多态性的特性。这样的设计模式能够提高代码的灵活性和可扩展性，使得程序能够适应不同类型的对象，并根据对象的实际行为进行相应的处理。</p>
<h4 id="隐藏方法"><a href="#隐藏方法" class="headerlink" title="隐藏方法"></a>隐藏方法</h4><p>隐藏方法是继承中的一个相关概念，但它与方法重写（覆盖）有所不同。</p>
<p>在C#中，通过在派生类中使用<code>new</code>关键字，可以隐藏基类中的同名方法。这被称为方法隐藏（method hiding）。</p>
<p>方法隐藏是在派生类中定义一个与基类中同名的方法，而不是重写基类方法。当使用派生类的实例调用这个方法时，会调用派生类中定义的方法，而不是基类中的方法。</p>
<p>以下是一个示例，演示了方法隐藏的使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a sound.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Animal animal = <span class="hljs-keyword">new</span> Animal();<br>        animal.MakeSound();  <span class="hljs-comment">// 输出：&quot;Animal makes a sound.&quot;</span><br><br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        dog.MakeSound();     <span class="hljs-comment">// 输出：&quot;Dog barks.&quot;</span><br><br>        Animal dogAnimal = <span class="hljs-keyword">new</span> Dog();<br>        dogAnimal.MakeSound();   <span class="hljs-comment">// 输出：&quot;Animal makes a sound.&quot;</span><br><br>        Console.ReadLine();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code>类中有一个<code>MakeSound()</code>方法，而<code>Dog</code>类中也定义了一个同名的方法。<code>Dog</code>类中的<code>MakeSound()</code>方法使用<code>new</code>关键字隐藏了基类中的方法。</p>
<p>当我们使用<code>Animal</code>类的实例调用<code>MakeSound()</code>方法时，执行的是基类中的方法。当我们使用<code>Dog</code>类的实例调用<code>MakeSound()</code>方法时，执行的是派生类中隐藏的方法。</p>
<p>注意，当将派生类的实例赋值给基类的变量时（如<code>Animal dogAnimal = new Dog()</code>），如果使用该变量调用<code>MakeSound()</code>方法，仍会执行基类中的方法。这是因为隐藏方法是通过编译时的静态类型来确定调用的方法，而不是基于运行时的实际对象类型。</p>
<h4 id="get和set关键字"><a href="#get和set关键字" class="headerlink" title="get和set关键字"></a>get和set关键字</h4><p><code>get</code> 和 <code>set</code> 是访问器标识符，用于定义属性的读取器和写入器。它们具有以下特点：</p>
<p><code>get</code> 标识符：用于定义属性的读取器。它指定了在访问属性时返回属性值的逻辑。<code>get</code> 方法必须返回与属性类型兼容的值。例如，对于一个名为 <code>MyProperty</code> 的属性，可以使用以下方式定义 <code>get</code> 访问器：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-comment">// 返回属性值的逻辑</span><br>        <span class="hljs-keyword">return</span> someValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>set</code> 标识符：用于定义属性的写入器。它指定了在给属性赋值时设置属性值的逻辑。<code>set</code> 方法使用一个隐含的参数 <code>value</code>，表示将要分配给属性的值。例如，对于一个名为 <code>MyProperty</code> 的属性，可以使用以下方式定义 <code>set</code> 访问器：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>&#123;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        <span class="hljs-comment">// 设置属性值的逻辑</span><br>        someValue = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>get</code> 和 <code>set</code> 访问器可以一起使用，用于定义可读写的属性。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> myField;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty<br>&#123;<br>    <span class="hljs-keyword">get</span><br>    &#123;<br>        <span class="hljs-comment">// 返回属性值的逻辑</span><br>        <span class="hljs-keyword">return</span> myField;<br>    &#125;<br>    <span class="hljs-keyword">set</span><br>    &#123;<br>        <span class="hljs-comment">// 设置属性值的逻辑</span><br>        myField = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>get</code> 和 <code>set</code> 访问器可以具有不同的访问修饰符，例如 <code>public</code>、<code>private</code> 等，用于控制属性的访问级别。</p>
<p>在 C# 6.0 之后，可以使用自动属性来简化属性的定义。自动属性使用简化的语法，编译器会自动生成私有字段和访问器的实现。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br></code></pre></td></tr></table></figure>

<p>通过使用 <code>get</code> 和 <code>set</code> 标识符，可以实现属性的读取和写入逻辑，并提供对属性的访问和修改。这种封装属性的方式使得代码更具可读性和可维护性，并提供了对属性访问的控制和验证。</p>
<h4 id="this和base关键字"><a href="#this和base关键字" class="headerlink" title="this和base关键字"></a>this和base关键字</h4><p>在C#中，<code>this</code>和<code>base</code>是两个关键字，用于引用当前对象和基类对象。它们在以下情况下使用：</p>
<p><code>this</code>关键字：</p>
<ul>
<li><p><code>this</code>关键字用于引用当前对象的成员（字段、属性、方法等）。它可以解决成员与局部变量之间的命名冲突。例如，如果一个方法的参数名与成员名相同，可以使用<code>this</code>关键字来指明要访问的是成员而不是参数。</p>
</li>
<li><p><code>this</code>关键字还可以在构造函数中调用其他构造函数，以实现构造函数的重载。通过使用<code>this</code>关键字，可以在一个构造函数中调用同一类的其他构造函数。</p>
</li>
<li><p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClass</span>() : <span class="hljs-title">this</span>(<span class="hljs-params"><span class="hljs-number">0</span></span>) <span class="hljs-comment">// 调用另一个构造函数</span></span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p><code>base</code>关键字：</p>
<ul>
<li><p><code>base</code>关键字用于引用基类对象的成员（字段、属性、方法等）。当派生类中定义了与基类同名的成员时，可以使用<code>base</code>关键字来访问基类的成员。</p>
</li>
<li><p><code>base</code>关键字还可以在派生类的构造函数中调用基类的构造函数。通过使用<code>base</code>关键字，可以在派生类的构造函数中调用基类的特定构造函数。</p>
</li>
<li><p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title">MyBaseClass</span><br>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBaseClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyDerivedClass</span> : <span class="hljs-title">MyBaseClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyDerivedClass</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span></span>) : <span class="hljs-title">base</span>(<span class="hljs-params"><span class="hljs-keyword">value</span></span>) <span class="hljs-comment">// 调用基类的构造函数</span></span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>总而言之，<code>this</code>关键字用于引用当前对象的成员，而<code>base</code>关键字用于引用基类对象的成员。它们在构造函数重载和解决成员命名冲突时非常有用。</p>
<h4 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h4><p>基类（Base Class）是面向对象编程中的一个概念，它是其他类的父类或超类。基类定义了一组通用的属性、方法和行为，可以被其他类继承和重用。</p>
<p>在继承关系中，子类可以从基类中继承（或派生）属性和方法。子类继承基类的成员后，可以直接使用这些成员，无需重新编写相同的代码。基类通过提供通用的结构和行为，可以为子类提供共享的功能和特征。</p>
<p>在C#中，使用关键字<code>class</code>定义一个类时，可以指定该类的基类。例如，如果要创建一个名为<code>Car</code>的子类，并使其继承一个名为<code>Vehicle</code>的基类，可以使用冒号（:）指定继承关系：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> <span class="hljs-comment">// 基类</span><br>&#123;<br>    <span class="hljs-comment">// 基类的成员</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> <span class="hljs-comment">// 子类，继承自基类</span><br>&#123;<br>    <span class="hljs-comment">// 子类的成员</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，<code>Vehicle</code>是<code>Car</code>的基类。<code>Car</code>类继承了<code>Vehicle</code>类的成员，并可以使用基类中定义的属性和方法。</p>
<p>基类可以包含构造函数、字段、属性、方法和事件等成员。子类可以直接访问基类的公共和受保护成员（根据访问修饰符的限制），并可以通过关键字<code>base</code>引用基类的成员。</p>
<p>基类的主要目的是促进代码的重用性和扩展性。通过继承基类，可以避免在每个子类中重复编写相同的代码，而是共享和继承基类的通用功能。基类也可以作为抽象基类或接口来定义规范和约束，以确保子类满足特定的行为要求。</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>在C#中，抽象类（Abstract Class）是一种特殊的类，用于提供其他类的基类（父类）。抽象类本身不能被实例化，<strong>它主要用作其他类的蓝图或模板。</strong></p>
<p>抽象类通过在类的定义中使用 <code>abstract</code> 关键字来声明。它可以包含抽象方法、虚方法、实例字段和属性等成员。抽象方法是没有实现的方法，而是在派生类中被重写和实现。</p>
<p>下面是一个抽象类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>; <span class="hljs-comment">// 抽象方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Print</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;This is a shape.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Shape</code> 类是一个抽象类，其中包含一个抽象方法 <code>CalculateArea()</code> 和一个非抽象方法 <code>Print()</code>。派生类必须实现抽象方法，但可以选择性地重写非抽象方法。</p>
<p>当你想要定义一个基类，提供一些通用行为，但又不希望直接实例化该基类时，抽象类非常有用。它允许你定义一些通用的方法和属性，并要求派生类提供实现细节。</p>
<p>需要注意的是，抽象类不能直接实例化，但可以被用作引用类型。你可以创建派生类的实例，然后将其赋值给抽象类类型的变量。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">Shape shape = <span class="hljs-keyword">new</span> Circle();<br></code></pre></td></tr></table></figure>

<p>总而言之，抽象类是一种用于定义其他类的基类，并且它可以包含抽象方法和非抽象方法。派生类必须实现抽象方法，而非抽象方法可以选择性地被重写。</p>
<blockquote>
<p>抽象基类（Abstract Base Class）是面向对象编程中的一个概念，它是一种特殊的类，不能被直接实例化，而是被用作其他类的基类。</p>
<p>抽象基类本身是抽象的，它定义了一组抽象方法、虚方法或具体方法，这些方法可以在子类中进行重写或实现。抽象基类通常用于定义一组共享的特征、行为或接口，而不关心具体实现细节。</p>
<p>在C#中，可以使用<code>abstract</code>关键字将一个类声明为抽象基类。抽象基类可以包含以下类型的成员：</p>
<ol>
<li>抽象方法（Abstract Method）：这是一个没有实现体的方法，只有方法的声明，没有方法体。抽象方法必须在子类中进行实现（重写），用以提供具体的实现逻辑。</li>
<li>虚方法（Virtual Method）：这是一个具有默认实现的方法，但可以在子类中进行重写。子类可以选择重写虚方法以提供自定义的实现，也可以使用默认实现。</li>
<li>具体方法（Concrete Method）：这是一个具有完整实现的方法，没有关键字修饰。具体方法在抽象基类中提供默认实现，子类可以选择性地进行重写。</li>
</ol>
<p>抽象基类的主要目的是作为其他类的模板，通过继承它来共享通用行为和结构。它可以提供一种约束，要求子类必须实现某些方法或遵循特定的接口。抽象基类在设计和组织大型项目时非常有用，可以提高代码的可重用性、可扩展性和可维护性。</p>
</blockquote>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>在C#中，密封类（Sealed Class）是一种特殊类型的类，它阻止其他类继承或派生自该密封类。使用 <code>sealed</code> 关键字可以将类声明为密封类。</p>
<p>当你声明一个类为密封类时，它将被标记为最终类，不允许其他类继承它或派生自它。换句话说，密封类不能作为基类用于其他类的继承。</p>
<p>下面是一个密封类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MySealedClass</span><br>&#123;<br>    <span class="hljs-comment">// 类的定义</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>密封类的主要目的是限制类的继承，以确保其行为和状态不会被修改或扩展。密封类常用于具有固定功能的类，它们通常被设计为不可修改和不可继承的。</p>
<p>需要注意的是，密封类本身可以继承自其他类，但不能被其他类继承。例如，一个密封类可以继承自非密封的基类。</p>
<p>总结一下，密封类是通过使用 <code>sealed</code> 关键字声明的一种特殊类。它阻止其他类继承或派生自该类，主要用于限制类的继承，确保类的行为和状态不被修改或扩展。</p>
<blockquote>
<p>密封类不能被用作基类。在 C# 中，使用 <code>sealed</code> 关键字可以将一个类声明为密封类。密封类是为了防止其他类继承它。</p>
<p>当你将一个类声明为密封类时，它将不能被其他类继承。这意味着密封类不能作为其他类的基类，因为它不允许其他类派生自它。</p>
<p>以下是一个示例，展示了如何声明和使用密封类：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SealedClass</span><br>&#123;<br>    <span class="hljs-comment">// Class implementation</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DerivedClass</span> : <span class="hljs-title">SealedClass</span>  <span class="hljs-comment">// 错误！密封类不能作为基类</span><br>&#123;<br>    <span class="hljs-comment">// Class implementation</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>SealedClass</code> 被声明为密封类，使用 <code>sealed</code> 关键字进行标识。然后，我们尝试从 <code>SealedClass</code> 派生一个名为 <code>DerivedClass</code> 的类，但这是错误的，因为密封类不能作为基类。</p>
<p>密封类的主要目的是为了限制继承，以确保某个类的特定实现不会被子类修改或扩展。密封类通常用于不希望被继承或修改的情况，例如某些框架类或工具类。</p>
<p>需要注意的是，密封类本身可以继承自其他类。只是它不能作为基类供其他类继承。</p>
</blockquote>
<h4 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h4><p>派生类（Derived Class）是指在面向对象编程中，通过继承从一个基类（父类）派生出新的类。派生类可以继承基类的成员（字段、属性、方法等），并且可以添加新的成员或修改继承的成员的行为。</p>
<p>在C#中，可以使用关键字 <code>class</code> 和冒号 <code>:</code> 来定义派生类，并指定基类。派生类在定义时可以扩展基类的功能，重写基类的虚方法，并可以添加自己的成员。</p>
<p>下面是一个派生类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> <span class="hljs-comment">// 基类</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Brand &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Year &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The vehicle starts.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> : <span class="hljs-title">Vehicle</span> <span class="hljs-comment">// 派生类</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Accelerate</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The car accelerates.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Start</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;The car starts.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Vehicle</code> 是一个基类，<code>Car</code> 是派生类。<code>Car</code> 类继承了基类 <code>Vehicle</code> 的属性和方法，并添加了自己的方法 <code>Accelerate()</code>。此外，派生类还可以重写基类中的虚方法，例如在 <code>Car</code> 类中重写了 <code>Start()</code> 方法。</p>
<p>使用派生类的好处是可以通过继承和扩展现有的类来创建新的类，从而实现代码的重用和组织。派生类可以使用基类的成员，并且可以根据需要修改或添加功能。</p>
<p>需要注意的是，C#不支持多重继承，即一个类不能直接继承自多个基类。但是，C#支持通过接口实现多重继承的特性。</p>
<p>总结一下，派生类是通过继承基类创建的新类。它可以继承基类的成员，可以添加新的成员或重写继承的成员的行为。通过派生类，可以实现代码的重用、组织和扩展。</p>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>在C#中，有多种访问修饰符（Access Modifiers）用于控制类、成员（字段、属性、方法等）以及其他元素的访问级别。以下是C#中常用的访问修饰符：</p>
<ol>
<li><strong>public</strong>：公共访问修饰符，表示成员可以从任何地方都可以访问，没有访问限制。</li>
<li><strong>private</strong>：私有访问修饰符，表示成员只能在定义它的类内部被访问。私有成员对于类的外部是不可见的。</li>
<li><strong>protected</strong>：受保护访问修饰符，表示成员可以在定义它的类及其派生类中被访问，但对于类的外部是不可见的。</li>
<li><strong>internal</strong>：内部访问修饰符，表示成员可以在当前程序集内的任何类中访问，但对于程序集之外的类是不可见的。如果没有显式指定访问修饰符，默认情况下成员的访问级别就是 internal。</li>
<li><strong>protected internal</strong>：受保护内部访问修饰符，表示成员可以在当前程序集内的任何类及其派生类中访问，以及在其他程序集中通过派生类访问。</li>
</ol>
<p>这些访问修饰符可以用于类的定义、类的成员（字段、属性、方法等）的定义，以及命名空间的定义。它们用于控制对不同成员和元素的访问权限，帮助实现封装性、继承性和抽象性等面向对象编程的概念。</p>
<p>需要注意的是，访问修饰符的使用要根据具体的需求和设计决策。选择适当的访问修饰符可以确保代码的安全性和可维护性。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在C#中，多态（Polymorphism）是面向对象编程中的一个重要概念。它允许使用相同的接口来处理不同类型的对象，从而实现代码的灵活性和可重用性。</p>
<p>多态性有两种形式：静态多态性（静态绑定）和动态多态性（动态绑定）。</p>
<p>静态多态性（静态绑定）： 在编译时，通过方法的重载和运算符重载，可以根据参数的类型来决定要调用的具体方法或操作符。这称为静态多态性，因为它在编译时期已经确定了具体的方法或操作符。</p>
<p>例如，假设有一个基类<code>Shape</code>和两个派生类<code>Circle</code>和<code>Rectangle</code>。如果在基类和派生类中定义了名为<code>Draw</code>的方法，那么可以根据调用对象的类型来决定具体调用哪个类的<code>Draw</code>方法。这就是静态多态性的体现。</p>
<p>动态多态性（动态绑定）： 动态多态性是通过继承和方法重写（override）实现的。它在运行时根据对象的实际类型来确定要调用的方法。当基类引用指向派生类的对象时，可以通过基类引用调用派生类中重写的方法。</p>
<p>例如，假设有一个基类<code>Animal</code>和两个派生类<code>Dog</code>和<code>Cat</code>。如果在基类中定义了一个名为<code>MakeSound</code>的虚方法，并在派生类中重写该方法，那么可以通过基类引用指向派生类的对象，并调用<code>MakeSound</code>方法时，实际执行的是派生类中重写的方法。这就是动态多态性的体现。</p>
<p>多态性的好处在于可以编写通用的代码，能够处理不同类型的对象，而无需为每种对象编写独立的代码。它提高了代码的可维护性和可扩展性，并促进了面向对象编程的核心概念之一：封装、继承和多态。</p>
<blockquote>
<p>多态性在面向对象编程中具有多种常用功能。以下是一些常见的多态性功能：</p>
<ol>
<li>方法重写（Method Overriding）：多态性通过方法重写实现。子类可以重写基类的方法，并在运行时根据实际对象类型调用相应的方法。这允许不同的对象以不同的方式响应相同的方法调用。</li>
<li>动态绑定（Dynamic Binding）：多态性通过动态绑定实现。在运行时，系统根据对象的实际类型决定要调用的方法。这使得代码能够在运行时适应不同的对象类型，实现灵活性和可扩展性。</li>
<li>抽象类和接口（Abstract Class and Interface）：抽象类和接口是多态性的重要概念。它们定义了一组共享的行为或功能，并允许不同的类实现这些行为或功能。通过基于抽象类或接口编程，可以编写通用的代码，处理多个具体的类对象。</li>
<li>泛型编程（Generic Programming）：多态性在泛型编程中起着关键作用。通过泛型类型参数，可以编写与具体类型无关的通用代码。这样的代码可以在不同类型的对象上进行操作，提高了代码的可重用性和类型安全性。</li>
<li>集合和容器类的多态性：在面向对象的集合和容器类中，多态性允许将不同类型的对象存储在同一个集合或容器中，并可以通过统一的接口来访问和处理这些对象。这提供了更灵活的数据结构和算法设计。</li>
<li>虚方法和抽象方法的多态性：通过在基类中定义虚方法（Virtual Method）或抽象方法（Abstract Method），子类可以重写这些方法，并根据自身的需求提供不同的实现。这种多态性允许通过基类的引用调用子类的方法。</li>
</ol>
<p>这些功能使得多态性成为面向对象编程中的重要概念之一。它提供了灵活性、可扩展性和可维护性，使得代码能够更好地适应变化和复杂性。</p>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在C#中，接口（Interface）是一种定义了一组方法、属性和事件的合同（Contract），用于描述类或结构体应具有的行为。接口定义了一组公共的成员，但没有提供具体的实现。类或结构体可以实现一个或多个接口，并通过实现接口中的成员来达到接口所描述的行为。</p>
<p>接口在C#中使用 <code>interface</code> 关键字进行声明。下面是一个简单的接口示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>IShape</code> 接口定义了两个方法：<code>CalculateArea()</code> 和 <code>Draw()</code>。任何类实现了这个接口都必须提供这两个方法的具体实现。</p>
<p>类可以通过使用 <code>:</code> 符号来实现一个或多个接口。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> : <span class="hljs-title">IShape</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Radius &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> <span class="hljs-title">CalculateArea</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> Math.PI * Radius * Radius;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Draw</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Drawing a circle.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Circle</code> 类实现了 <code>IShape</code> 接口，并提供了 <code>CalculateArea()</code> 和 <code>Draw()</code> 方法的具体实现。</p>
<p>通过接口，可以实现多态性，即一个对象可以被视为属于多个类型。类可以实现多个接口，从而具备不同接口所定义的行为，这提供了更大的灵活性和可重用性。</p>
<p>接口还可以用于定义事件和属性的规范，类在实现接口时必须提供这些事件和属性的实现。</p>
<p>总结一下，接口是一种定义行为规范的合同，它描述了类或结构体应该具有的一组方法、属性和事件。接口本身没有提供具体的实现，而是由类或结构体实现接口并提供具体的实现。通过实现接口，类可以达到多态性，并具备不同接口所定义的行为。</p>
<blockquote>
<p><strong>接口和类的区别：</strong></p>
<p>相似之处：</p>
<ol>
<li>都可以定义抽象成员（未实现的方法、属性、事件等）。</li>
<li>都不能被直接实例化，需要其他类来实现或继承。</li>
</ol>
<p>区别之处：</p>
<ol>
<li>接口可以多重继承，而类只能单继承。一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>接口只能定义抽象成员，不包含实现，而抽象类可以包含具体实现的成员。</li>
<li>接口中的成员默认是公共的（public），而抽象类中的成员可以有不同的访问修饰符。</li>
<li>接口不能包含字段（字段是类的状态），而抽象类可以包含字段。</li>
<li>接口不能提供代码的实现，而抽象类可以提供部分实现。</li>
</ol>
<p>接口通常用于描述对象应该具备的行为，定义了一套合约，供实现接口的类来遵循。通过实现接口，类可以在不同的层次结构中共享相同的行为规范，实现了一种多态性。</p>
<p>抽象类则更多地用于定义一种通用的基类，可以包含具体的实现代码，以及一些子类通用的属性和方法。抽象类可以作为其他类的基类被继承，子类可以继承抽象类的实现代码，并覆盖其中的抽象成员。</p>
<p>总之，接口主要关注行为的规范和多态性，而抽象类则更关注代码的复用和继承。选择使用接口还是抽象类，取决于设计的目标和需求。</p>
</blockquote>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>方法重写（Method overriding）是面向对象编程中的一个概念，它允许子类重新定义并实现从父类继承的方法。</p>
<p>当一个类继承自另一个类时，子类可以继承父类的方法。但有时子类可能需要修改继承的方法的实现，以满足自己的特定需求。方法重写提供了这样的机制，允许子类提供一个新的实现来替代父类的方法。</p>
<p>要实现方法重写，需要满足以下条件：</p>
<ol>
<li><strong>子类必须继承自父类。</strong></li>
<li><strong>父类中的方法必须被标记为<code>virtual</code>，表示它可以被子类重写。</strong></li>
<li><strong>子类中需要使用<code>override</code>关键字来重写父类中的方法，并提供新的实现。</strong></li>
</ol>
<p>子类中重写的方法必须具有与父类中被重写的方法相同的名称、参数列表和返回类型。通过重写方法，子类可以改变或扩展父类方法的行为，以适应子类的需求。</p>
<p>当使用父类的引用指向子类的对象时，如果调用被重写的方法，实际上会执行子类中重写的方法，而不是父类中的原始方法。这种行为称为动态绑定，因为在运行时决定要调用的具体方法。</p>
<p>方法重写是实现多态性的一种方式，它允许以统一的方式处理不同类型的对象，并根据对象的实际类型来调用相应的方法。这提高了代码的灵活性、可维护性和可扩展性。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>动态绑定（Dynamic Binding）是多态性的一个重要概念，它是指在运行时根据对象的实际类型来决定要调用的方法或执行的操作。通过动态绑定，程序能够根据对象的实际类型选择正确的方法实现，实现灵活性和可扩展性。</p>
<p>在编译时，编译器通常根据变量的声明类型来确定要调用的方法。但是，当使用多态性的特性时，对象的实际类型可能与声明类型不同。在这种情况下，动态绑定允许在运行时根据对象的实际类型来解析方法调用。</p>
<p>具体而言，当通过基类的引用指向子类的对象时，编译器会根据基类的声明类型确定要调用的方法。但在运行时，实际执行的是子类中重写的方法，而不是基类中的原始方法。这是因为在运行时，系统会根据对象的实际类型动态选择正确的方法实现。</p>
<p>例如，考虑以下代码片段：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Animal makes a sound&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Dog barks&quot;</span>);<br>    &#125;<br>&#125;<br><br>Animal animal = <span class="hljs-keyword">new</span> Dog();<br>animal.MakeSound(); <span class="hljs-comment">// 动态绑定，实际调用的是Dog类的MakeSound方法</span><br></code></pre></td></tr></table></figure>

<p>在上述代码中，<code>animal</code>是一个基类<code>Animal</code>的引用，但它实际上指向一个子类<code>Dog</code>的对象。当调用<code>MakeSound</code>方法时，通过动态绑定，实际执行的是<code>Dog</code>类中重写的<code>MakeSound</code>方法，输出”Dog barks”。</p>
<p>通过动态绑定，程序能够根据对象的实际类型来决定要调用的方法，实现了多态性的灵活性和可扩展性。这对于处理不同类型的对象和实现运行时多态行为非常重要。</p>
<blockquote>
</blockquote>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型（Generics）是一种在编程语言中使用类型参数来创建可重用代码的机制。它允许在编写类或方法时延迟指定具体的数据类型，使代码能够适用于多种不同类型的数据。</p>
<p>泛型的主要目的是提供类型安全和代码重用。通过使用泛型，可以编写与数据类型无关的通用代码，避免重复编写相似的代码，提高代码的可维护性和可扩展性。</p>
<p>在C#中，泛型可以应用于类、结构体、接口和方法。它使用尖括号（&lt;&gt;）来指定类型参数，并在需要使用具体类型时进行替换。</p>
<p>以下是一个使用泛型的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeclass MyGenericClass&lt;T&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T genericField;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyGenericClass</span>(<span class="hljs-params">T <span class="hljs-keyword">value</span></span>)</span><br>    &#123;<br>        genericField = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">GetGenericField</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> genericField;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用泛型类</span><br>MyGenericClass&lt;<span class="hljs-built_in">int</span>&gt; myIntObject = <span class="hljs-keyword">new</span> MyGenericClass&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = myIntObject.GetGenericField(); <span class="hljs-comment">// 返回42</span><br><br>MyGenericClass&lt;<span class="hljs-built_in">string</span>&gt; myStringObject = <span class="hljs-keyword">new</span> MyGenericClass&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-string">&quot;Hello&quot;</span>);<br><span class="hljs-built_in">string</span> text = myStringObject.GetGenericField(); <span class="hljs-comment">// 返回&quot;Hello&quot;</span><br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyGenericClass&lt;T&gt;</code>是一个泛型类，其中的<code>T</code>是一个类型参数。通过在创建对象时指定具体类型，可以创建<code>MyGenericClass</code>的实例。这样，<code>genericField</code>字段和<code>GetGenericField</code>方法的类型将根据实际指定的类型进行实例化。</p>
<p>泛型提供了许多优势，包括：</p>
<ol>
<li>类型安全：泛型在编译时提供类型检查，防止类型不匹配的错误。</li>
<li>代码重用：可以编写通用的算法和数据结构，适用于多种类型的数据。</li>
<li>性能提升：泛型可以避免装箱和拆箱操作，提高性能。</li>
<li>可读性和维护性：泛型代码通常更具可读性和可维护性，因为它们是与类型无关的通用代码。</li>
</ol>
<p>总而言之，泛型是一种强大的编程机制，它允许在编写代码时推迟具体类型的指定，从而提供更灵活、类型安全和可重用的代码。</p>
<h2 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h2><p>这个练习是为了熟系所有的面向对象的内容，我们将从头开始创建一个类，用于实现所有的面向对象特性。</p>
<h3 id="练习封装"><a href="#练习封装" class="headerlink" title="练习封装"></a>练习封装</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Object_oriented_testing</span><br>&#123;<br>    <span class="hljs-comment">//创建一个类用来练习封装</span><br>    <span class="hljs-comment">//tip - 在类中，对方法和变量如果不加访问修饰符一般都是私有的（private）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">IT</span><br>    &#123;<br>        <span class="hljs-comment">//1.生成一个类中最基础的东西</span><br>        <span class="hljs-comment">// - 成员变量</span><br>        <span class="hljs-comment">//公有变量可以在类外中改变  - 用.操作符即可</span><br>        <span class="hljs-comment">//私有变量只能在类中调用 - 在类外就不能调用</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> myVariable;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> myPublic;<br><br>        <span class="hljs-comment">//2.构造函数</span><br>        <span class="hljs-comment">// - 构造函数 - 用来初始化变量</span><br>        <span class="hljs-comment">//在创建对象的时候自动运行</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IT</span>()</span> &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;我是构造函数&quot;</span>);<br>            myVariable = <span class="hljs-number">1</span>;<br>            myPublic = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//3.有参构造函数</span><br>        <span class="hljs-comment">//用于用户自己指定所需要的私有变量的值</span><br>        <span class="hljs-comment">//私有变量只能在类中改变值 - 但是我们可以通过构造函数来初始化我们想要的值</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IT</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> variable</span>)</span><br>        &#123;<br>            myVariable = variable;<br>            myPublic = variable;<br>        &#125;<br>        <span class="hljs-comment">//4.构造我们的类方法</span><br>        <span class="hljs-comment">//类方法完成某种方式 - 这里我们就简单一点</span><br>        <span class="hljs-comment">//用方法打印一些字段</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;你好我是test这个方法&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;我打印变量&#123;1&#125;和&#123;2&#125;&quot;</span>, myVariable, myPublic);<br>        &#125;<br>        <span class="hljs-comment">//5.析构函数</span><br>        <span class="hljs-comment">//在程序结束的时候自动运行</span><br>        ~IT() &#123;<br>            myPublic = <span class="hljs-number">1</span>;<br>            myVariable = <span class="hljs-number">1</span>;<br>            Console.WriteLine(<span class="hljs-string">&quot;我是析构函数&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> Object_oriented_testing;<br><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">Object_oriented_testing</span><br>&#123;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            IT a = <span class="hljs-keyword">new</span> IT();<br>            <span class="hljs-comment">//1.对公共变量赋值</span><br>            a.myPublic = <span class="hljs-number">3</span>;<br>            <span class="hljs-comment">//2.调用对象方法</span><br>            a.test();<br>            Console.ReadKey();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230604202621214.png" alt="image-20230604202621214"></p>
<h3 id="练习继承"><a href="#练习继承" class="headerlink" title="练习继承"></a>练习继承</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> 练习继承<br>&#123;<br>   <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Car</span><br>    &#123;<br>        <span class="hljs-comment">//创建Car作为基类 - 一般基类被创建为抽象类</span><br>        <span class="hljs-comment">//抽象类不能实例化——只是我们子类的蓝图</span><br>        <span class="hljs-comment">//创建两个变量 - 来传值给我们的属性</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> id = <span class="hljs-string">&quot;并没有设定默认id&quot;</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> name = <span class="hljs-string">&quot;并没有表明该车辆的名字&quot;</span>;<br>        <span class="hljs-comment">//创建Car类来模拟继承</span><br><br>        <span class="hljs-comment">//1.创建两个属性</span><br>        <span class="hljs-comment">//属性的概念其实无处不在，我们的名字和性别就是一种属性</span><br>        <span class="hljs-comment">//我们可以赋予属性功能来实现我们的目的</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Id<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> id;<br>            &#125;<br>            <span class="hljs-keyword">set</span><br>            &#123;<br>                <span class="hljs-comment">//赋值的时候由value传递值给name</span><br>                id = <span class="hljs-keyword">value</span>;<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>        &#123;<br>            <span class="hljs-keyword">get</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> name;<br>            &#125;<br>            <span class="hljs-keyword">set</span><br>            &#123;<br>                name = <span class="hljs-keyword">value</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//2.创建Car的虚方法 - 用于子类重写</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyCars</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这辆车是什么&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//这里可以用属性代替</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Price</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这辆车的价钱是多少&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Balance</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;测试一下未重写是怎么样的&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wuling_Hongguang</span> : <span class="hljs-title">Car</span><br>    &#123;<br>        <span class="hljs-comment">//3.重写父类的虚方法</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyCars</span>()</span><br>        &#123; <br>            Console.WriteLine(<span class="hljs-string">&quot;这辆车是五菱宏光&quot;</span>);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Price</span>()</span> &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;这辆车很便宜&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wuling_Hongguang</span>()</span><br>        &#123;<br>            <span class="hljs-comment">//在构造函数可用 - 用于调用父类的属性</span><br>            <span class="hljs-keyword">base</span>.Id =<span class="hljs-string">&quot;001&quot;</span>;<br>            <span class="hljs-keyword">base</span>.Name = <span class="hljs-string">&quot;五菱宏光&quot;</span>;<br>            <span class="hljs-comment">//打印一下对应的属性</span><br>            Console.WriteLine(Id);<br>            Console.WriteLine(Name);<br>        &#125;<br>        <br>    &#125;<br><br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//创建一个五菱宏光的对象</span><br>            Wuling_Hongguang a = <span class="hljs-keyword">new</span> Wuling_Hongguang();<br>            <span class="hljs-comment">//更改一下五菱宏光的属性</span><br>            a.Id = <span class="hljs-string">&quot;002&quot;</span>;<br>            a.Name = <span class="hljs-string">&quot;小绵羊&quot;</span>;<br>            a.Price();<br>            a.MyCars();<br>            a.Balance();<br>            <span class="hljs-comment">//打印自定义属性</span><br>            Console.WriteLine(<span class="hljs-string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>,a.Id,a.Name);<br>            <span class="hljs-comment">//打印对象就出现对象对应的命名空间</span><br>            Console.WriteLine(a);<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230605130627976.png" alt="image-20230605130627976"></p>
<blockquote>
<p>当你打印一个对象时，它的默认打印行为是输出对象的完全限定类型名称。这是通过调用对象的 <code>ToString()</code> 方法实现的。</p>
<p>在 C# 中，所有类都继承自 <code>System.Object</code>，而 <code>System.Object</code> 类定义了默认的 <code>ToString()</code> 方法。默认情况下，<code>ToString()</code> 方法会返回对象的完全限定类型名称。</p>
<p>例如，假设你声明了一个名为 <code>myCar</code> 的对象，类型为 <code>Car</code>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeCar myCar = <span class="hljs-keyword">new</span> Car();<br>Console.WriteLine(myCar);<br></code></pre></td></tr></table></figure>

<p>输出将会是类似以下的结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">vbnetCopy code<br>Namespace.Car<br></code></pre></td></tr></table></figure>

<p><code>Namespace</code> 是 <code>Car</code> 类所在的命名空间，而 <code>Car</code> 是类的名称。</p>
<p>如果你想在输出中显示自定义的信息，你可以重写基类 <code>System.Object</code> 中的 <code>ToString()</code> 方法，以便返回你想要的字符串表示形式。例如，你可以在 <code>Car</code> 类中重写 <code>ToString()</code> 方法，以返回车辆的特定信息：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy codepublic <span class="hljs-keyword">override</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ToString</span>()</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Car: &quot;</span> + Name + <span class="hljs-string">&quot;, ID: &quot;</span> + Id;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，当你打印 <code>myCar</code> 对象时，将会输出你自定义的字符串表示形式，而不是默认的完全限定类型名称。</p>
</blockquote>
<h3 id="练习多态"><a href="#练习多态" class="headerlink" title="练习多态"></a>练习多态</h3><figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">using</span> System.Text;<br><span class="hljs-keyword">using</span> System.Threading.Tasks;<br><br><span class="hljs-keyword">namespace</span> _03_练习多态<br>&#123;<br>    <span class="hljs-comment">//1.定义了一个接口</span><br>    <span class="hljs-comment">//接口可以实现多继承——来调用我们频繁使用的方法</span><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title">IMyInterface</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span>;<br>        <span class="hljs-built_in">int</span> MyProperty &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> &#123;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-built_in">string</span> a;<br>        <span class="hljs-comment">//创建属性对a操作</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> A<br>        &#123;<br>            <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> a; &#125;<br>            <span class="hljs-keyword">set</span> &#123; a = <span class="hljs-keyword">value</span>; &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//抽象类无法声明主题，需要继承来重写</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Call</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span>;<br>      <br>        <br>    &#125;<br><br><br><br>    <span class="hljs-comment">//2.创建一个类用来调用我们的接口方法</span><br>    <span class="hljs-comment">//顺便继承父类 - 记住继承抽象类一定要重写它的抽象方法</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> : <span class="hljs-title">Name</span>, <span class="hljs-title">IMyInterface</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyMethod</span>()</span><br>        &#123;<br>            <span class="hljs-comment">// 实现接口中定义的方法</span><br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> MyProperty &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Call</span>(<span class="hljs-params"><span class="hljs-built_in">double</span> <span class="hljs-keyword">value</span></span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 提供具体的实现</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">value</span> * <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//例子2</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The animal makes a sound.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> : <span class="hljs-title">Animal</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The dog barks.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> : <span class="hljs-title">Animal</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">override</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MakeSound</span>()</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;The cat meows.&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            Animal animal1 = <span class="hljs-keyword">new</span> Dog();<br>            Animal animal2 = <span class="hljs-keyword">new</span> Cat();<br><br>            animal1.MakeSound(); <span class="hljs-comment">// 输出：The dog barks.</span><br>            animal2.MakeSound(); <span class="hljs-comment">// 输出：The cat meows.</span><br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230605194425539.png" alt="image-20230605194425539"></p>
<h2 id="c-功能类"><a href="#c-功能类" class="headerlink" title="c#功能类*"></a>c#功能类*</h2><h3 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是一种在编程语言中实现参数化类型的机制。它允许我们编写可重用的代码，可以在不同的数据类型上进行操作，而无需为每种类型编写重复的代码。</p>
<p>使用泛型，我们可以定义类、接口、方法等具有参数化类型的实体。参数化类型允许我们在使用时指定具体的类型，从而使代码更加灵活和可重用。</p>
<p>泛型的主要好处如下：</p>
<ol>
<li>类型安全：通过使用泛型，我们可以在编译时捕获类型错误。编译器会在编译时检查泛型代码的类型，并提供类型安全保证。</li>
<li>代码重用：泛型使我们能够编写通用的代码，可以在不同类型上进行操作。这样可以避免重复编写类似的代码，提高代码的重用性和可维护性。</li>
<li>性能优化：使用泛型可以提高代码的性能。由于泛型代码在编译时生成特定类型的代码，因此避免了装箱和拆箱操作，并提供了更好的性能。</li>
</ol>
<p>以下是一个使用泛型的简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">T</span>&gt;<br>&#123;<br>    <span class="hljs-keyword">private</span> T[] items;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> top;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> capacity</span>)</span><br>    &#123;<br>        items = <span class="hljs-keyword">new</span> T[capacity];<br>        top = <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Push</span>(<span class="hljs-params">T item</span>)</span><br>    &#123;<br>        items[++top] = item;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">Pop</span>()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> items[top--];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Stack&lt;<span class="hljs-built_in">int</span>&gt; intStack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">int</span>&gt;(<span class="hljs-number">5</span>);<br>        intStack.Push(<span class="hljs-number">1</span>);<br>        intStack.Push(<span class="hljs-number">2</span>);<br>        intStack.Push(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-built_in">int</span> <span class="hljs-keyword">value</span> = intStack.Pop();<br>        Console.WriteLine(<span class="hljs-keyword">value</span>); <span class="hljs-comment">// 输出：3</span><br><br>        Stack&lt;<span class="hljs-built_in">string</span>&gt; stringStack = <span class="hljs-keyword">new</span> Stack&lt;<span class="hljs-built_in">string</span>&gt;(<span class="hljs-number">5</span>);<br>        stringStack.Push(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        stringStack.Push(<span class="hljs-string">&quot;World&quot;</span>);<br><br>        <span class="hljs-built_in">string</span> str = stringStack.Pop();<br>        Console.WriteLine(str); <span class="hljs-comment">// 输出：World</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个泛型类 <code>Stack&lt;T&gt;</code>，它表示一个栈数据结构。通过在类定义中使用泛型参数 <code>T</code>，我们可以在创建对象时指定栈中存储的元素类型。</p>
<p>在 <code>Main</code> 方法中，我们创建了一个 <code>Stack&lt;int&gt;</code> 对象 <code>intStack</code>，用于存储整数类型的元素，并进行了入栈和出栈操作。然后，我们创建了一个 <code>Stack&lt;string&gt;</code> 对象 <code>stringStack</code>，用于存储字符串类型的元素，并进行了相应的操作。</p>
<p>通过使用泛型，我们可以在不同类型上重复使用相同的栈类，并在编译时获得类型安全和性能优化的好处。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>在 C# 中，<code>List&lt;T&gt;</code> 类是泛型集合类之一，用于表示动态大小的可变数组。<code>List&lt;T&gt;</code> 提供了一组强大的方法和属性，用于操作和管理元素列表。</p>
<p><code>List&lt;T&gt;</code> 类位于 <code>System.Collections.Generic</code> 命名空间中，是 .NET Framework 中最常用的集合类型之一。它提供了类似数组的功能，但具有更大的灵活性和功能。</p>
<p>以下是 <code>List&lt;T&gt;</code> 类的一些主要特点和功能：</p>
<ol>
<li>动态大小：<code>List&lt;T&gt;</code> 允许根据需要自动调整容量，以容纳不同数量的元素。可以随时向列表中添加或删除元素。</li>
<li>泛型：<code>List&lt;T&gt;</code> 是一个泛型类，可以在创建时指定元素的类型。泛型提供了类型安全和性能优化的好处。</li>
<li>索引访问：可以通过索引访问列表中的元素。使用索引可以读取或修改列表中特定位置的元素。</li>
<li>增删改查：<code>List&lt;T&gt;</code> 提供了一系列的方法用于添加、删除、修改和搜索列表中的元素。例如，<code>Add</code> 方法用于添加元素，<code>Remove</code> 方法用于删除元素，<code>Find</code> 方法用于搜索元素等等。</li>
<li>排序和排序搜索：<code>List&lt;T&gt;</code> 提供了排序方法（<code>Sort</code>）和排序搜索方法（<code>BinarySearch</code>），方便对列表中的元素进行排序和搜索。</li>
<li>遍历：可以使用 <code>foreach</code> 循环或迭代器来遍历 <code>List&lt;T&gt;</code> 中的元素。</li>
</ol>
<p>下面是一个使用 <code>List&lt;T&gt;</code> 的简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeusing System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;<span class="hljs-built_in">string</span>&gt; fruits = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">string</span>&gt;();<br>        <br>        <span class="hljs-comment">// 添加元素</span><br>        fruits.Add(<span class="hljs-string">&quot;Apple&quot;</span>);<br>        fruits.Add(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        fruits.Add(<span class="hljs-string">&quot;Orange&quot;</span>);<br>        <br>        <span class="hljs-comment">// 访问元素</span><br>        Console.WriteLine(fruits[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 输出：Apple</span><br>        <br>        <span class="hljs-comment">// 遍历元素</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-built_in">string</span> fruit <span class="hljs-keyword">in</span> fruits)<br>        &#123;<br>            Console.WriteLine(fruit);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 删除元素</span><br>        fruits.Remove(<span class="hljs-string">&quot;Banana&quot;</span>);<br>        <br>        <span class="hljs-comment">// 判断元素是否存在</span><br>        <span class="hljs-built_in">bool</span> containsOrange = fruits.Contains(<span class="hljs-string">&quot;Orange&quot;</span>);<br>        Console.WriteLine(containsOrange); <span class="hljs-comment">// 输出：True</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个 <code>List&lt;string&gt;</code> 对象 <code>fruits</code>，并使用 <code>Add</code> 方法向其中添加了几个水果。然后，我们可以使用索引访问元素，使用 <code>foreach</code> 循环遍历元素，使用 <code>Remove</code> 方法删除元素，并使用 <code>Contains</code> 方法判断元素是否存在。</p>
<p>总之，<code>List&lt;T&gt;</code> 类是 C# 中用于表示动态大小的可变数组的泛型集合类，提供了丰富的方法和属性，方便对元素列表进行操作和管理。</p>
<h2 id="c-高级"><a href="#c-高级" class="headerlink" title="c#高级"></a>c#高级</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式（Regular Expression），简称为正则或正则表达式，是一种用于描述和匹配字符串模式的工具。它是由一系列字符和特殊字符组成的表达式，可以用来进行字符串的搜索、匹配、替换和提取等操作。</p>
<p>正则表达式由普通字符（例如字母、数字和标点符号）和特殊字符组成，特殊字符具有特定的含义和功能。通过组合和使用这些字符，可以构建出具有复杂匹配规则的模式。</p>
<p>正则表达式常用于以下场景：</p>
<ol>
<li>搜索和匹配：可以用来搜索和匹配符合特定模式的字符串。例如，可以使用正则表达式来检查一个字符串是否符合某种格式，如邮箱地址、电话号码等。</li>
<li>替换和修改：可以用来替换字符串中符合某个模式的部分。例如，可以使用正则表达式将一个文本中的所有日期格式改为另一种格式。</li>
<li>提取和分割：可以用来提取字符串中符合某个模式的部分。例如，可以使用正则表达式从一个网页的 HTML 代码中提取出所有链接。</li>
<li>格式验证：可以用来验证用户输入的数据是否符合特定的格式要求。例如，可以使用正则表达式来验证用户输入的密码是否包含特定的字符和长度。</li>
</ol>
<p>正则表达式是跨平台的，几乎所有现代编程语言都支持正则表达式的操作。在 C# 中，可以使用 <code>System.Text.RegularExpressions</code> 命名空间提供的正则表达式类来处理和操作正则表达式。</p>
<p>以下是一个简单的示例，演示了使用正则表达式来搜索和匹配字符串：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeusing System;<br><span class="hljs-keyword">using</span> System.Text.RegularExpressions;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-built_in">string</span> input = <span class="hljs-string">&quot;Hello, 12345!&quot;</span>;<br><br>        <span class="hljs-comment">// 定义匹配模式</span><br>        <span class="hljs-built_in">string</span> pattern = <span class="hljs-string">@&quot;\d+&quot;</span>;<br><br>        <span class="hljs-comment">// 创建正则表达式对象</span><br>        Regex regex = <span class="hljs-keyword">new</span> Regex(pattern);<br><br>        <span class="hljs-comment">// 搜索匹配项</span><br>        Match match = regex.Match(input);<br><br>        <span class="hljs-comment">// 判断是否找到匹配项</span><br>        <span class="hljs-keyword">if</span> (match.Success)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;找到匹配项：&#123;0&#125;&quot;</span>, match.Value);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;未找到匹配项&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个匹配模式 <code>@&quot;\d+&quot;</code>，表示一个或多个连续的数字。然后，我们使用 <code>Regex</code> 类创建一个正则表达式对象，并使用 <code>Match</code> 方法在输入字符串中搜索匹配项。</p>
<p>如果找到了匹配项，我们可以通过 <code>Match</code> 对象的属性来获取匹配结果。在此示例中，我们输出找到的匹配项。</p>
<p>总结来说，正则表达式是一种用于描述和匹配字符串模式的工具。它具有广泛使用的语法和特殊字符，可以用来进行字符串的搜索、匹配、替换和提取等操作。在不同编程语言中，正则表达式的具体语法和使用方式可能有所不同，但基本的概念和功能是相通的。</p>
<p>以下是一些常用的正则表达式特殊字符和符号的示例：</p>
<ul>
<li><code>.</code>: 匹配任意单个字符，除了换行符。</li>
<li><code>*</code>: 匹配前一个元素零次或多次。</li>
<li><code>+</code>: 匹配前一个元素一次或多次。</li>
<li><code>?</code>: 匹配前一个元素零次或一次。</li>
<li><code>[]</code>: 匹配括号内的任意一个字符。例如，<code>[abc]</code> 匹配字符 ‘a’、’b’ 或 ‘c’。</li>
<li><code>[^]</code>: 匹配不在括号内的任意一个字符。例如，<code>[^abc]</code> 匹配除了 ‘a’、’b’ 和 ‘c’ 之外的任意字符。</li>
<li><code>\d</code>: 匹配任意一个数字字符。等价于 <code>[0-9]</code>。</li>
<li><code>\w</code>: 匹配任意一个字母、数字或下划线字符。等价于 <code>[A-Za-z0-9_]</code>。</li>
<li><code>\s</code>: 匹配任意一个空白字符，包括空格、制表符、换行符等。</li>
<li><code>^</code>: 匹配字符串的开头位置。</li>
<li><code>$</code>: 匹配字符串的结尾位置。</li>
<li><code>|</code>: 在模式中使用逻辑或，匹配两个或多个模式之一。</li>
</ul>
<p>除了上述特殊字符外，正则表达式还支持使用括号进行分组、使用限定符指定匹配次数、使用转义字符来匹配特殊字符等。</p>
<p>正则表达式可以在不同的编程语言中使用，例如 C#、Java、Python、JavaScript 等。每种编程语言可能有自己的正则表达式类或函数，用于进行正则操作。在 C# 中，可以使用 <code>System.Text.RegularExpressions</code> 命名空间提供的类来处理和操作正则表达式。</p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>在 C# 中，委托（Delegate）是一种类型，用于表示对一个或多个方法的引用。委托可以将方法视为对象，并将其赋值给委托变量，以便在需要时调用这些方法。</p>
<p>委托提供了一种将方法作为参数传递、将方法存储在数据结构中和通过委托调用方法的机制。它可以帮助实现事件处理、回调函数和多播委托等功能。</p>
<p>以下是委托的主要特点和使用方法：</p>
<ol>
<li>类型安全：委托是类型安全的，它在编译时会进行类型检查，以确保委托变量与其引用的方法具有相同的签名（参数和返回类型）。</li>
<li>方法引用：委托可以引用一个或多个具有相同签名的方法。通过将方法赋值给委托变量，可以将方法作为对象来操作。</li>
<li>事件处理：委托经常用于实现事件处理机制。当事件发生时，相关的委托将被调用，并执行相应的方法。</li>
<li>回调函数：委托可以用作回调函数的机制，允许将一个方法传递给另一个方法，在需要时进行回调调用。</li>
<li>多播委托：委托可以合并多个方法，形成一个多播委托。调用多播委托时，所有合并的方法都会被依次调用。</li>
</ol>
<p>以下是一个简单的委托示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate myDelegate = DisplayMessage;<br>        myDelegate(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>        myDelegate += DisplayUpperCaseMessage;<br>        myDelegate(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Message: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayUpperCaseMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Message in uppercase: &quot;</span> + message.ToUpper());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个委托类型 <code>MyDelegate</code>，它可以引用具有 <code>void</code> 返回类型和一个 <code>string</code> 参数的方法。然后，我们创建了一个委托变量 <code>myDelegate</code>，并将其赋值为 <code>DisplayMessage</code> 方法。</p>
<p>通过调用委托变量 <code>myDelegate</code>，我们实际上调用了被委托引用的方法 <code>DisplayMessage</code>，并传递了一个字符串参数。</p>
<p>在后续操作中，我们将另一个方法 <code>DisplayUpperCaseMessage</code> 添加到委托变量 <code>myDelegate</code> 中。当调用委托变量时，两个方法都会被依次调用，从而实现多播委托的功能。</p>
<p>总而言之，委托是一个类，可以定义自己的委托类型，也可以使用.NET框架提供的预定义委托类型。预定义的委托类型包括<code>Action</code>、<code>Func</code>、<code>Predicate</code>等，它们具有不同的签名和功能，可以用于不同的场景。</p>
<p>下面是一些常用的预定义委托类型：</p>
<ul>
<li><code>Action</code>: 表示一个不返回值的委托。可以用于执行无返回值的操作。</li>
<li><code>Func</code>: 表示一个具有返回值的委托。可以用于执行带有返回值的操作。</li>
<li><code>Predicate</code>: 表示一个接受一个参数并返回布尔值的委托。通常用于进行条件判断。</li>
</ul>
<p>预定义委托类型的使用示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 使用 Action 委托执行无返回值的操作</span><br>        Action&lt;<span class="hljs-built_in">string</span>&gt; actionDelegate = DisplayMessage;<br>        actionDelegate(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br><br>        <span class="hljs-comment">// 使用 Func 委托执行带有返回值的操作</span><br>        Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; funcDelegate = AddNumbers;<br>        <span class="hljs-built_in">int</span> result = funcDelegate(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Result: &quot;</span> + result);<br><br>        <span class="hljs-comment">// 使用 Predicate 委托进行条件判断</span><br>        Predicate&lt;<span class="hljs-built_in">int</span>&gt; predicateDelegate = IsPositive;<br>        <span class="hljs-built_in">bool</span> isPositive = predicateDelegate(<span class="hljs-number">5</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;Is Positive: &quot;</span> + isPositive);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DisplayMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Message: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">AddNumbers</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">IsPositive</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> number</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> number &gt; <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了不同的预定义委托类型来执行不同的操作。通过使用泛型，我们可以指定委托的参数类型和返回类型。</p>
<p>使用 <code>Action&lt;string&gt;</code> 委托执行了一个接受一个字符串参数并且没有返回值的方法 <code>DisplayMessage</code>。使用 <code>Func&lt;int, int, int&gt;</code> 委托执行了一个接受两个整数参数并返回整数结果的方法 <code>AddNumbers</code>。使用 <code>Predicate&lt;int&gt;</code> 委托进行了一个判断，判断一个整数是否为正数。</p>
<p>预定义委托类型使得使用委托更加方便和简洁，并且减少了自定义委托类型的需要。</p>
<p>总结来说，委托是一个类，用于表示对一个或多个方法的引用。它可以定义自己的委托类型，也可以使用预定义的委托类型。委托在C#中提供了一种灵活的机制，可以将方法作为参数传递、存储和调用。它在事件处理、回调函数和多播委托等场景中非常有用。</p>
<blockquote>
<p><code>Action</code> 委托是 C# 中预定义的一个委托类型，它用于表示一个不返回值的委托。<code>Action</code> 委托可以接受最多 16 个输入参数，但不返回任何值。</p>
<p><code>Action</code> 委托的定义如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy codepublic <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">T obj</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Action</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">in</span> <span class="hljs-title">T2</span>&gt;(<span class="hljs-params">T1 arg1, T2 arg2</span>)</span>;<br><span class="hljs-comment">// ... 其他重载 ...</span><br></code></pre></td></tr></table></figure>

<p><code>Action</code> 委托的命名规范为以 “Action” 开头，后面跟着输入参数的个数，最多可以有 16 个输入参数。</p>
<p>以下是一些使用 <code>Action</code> 委托的示例：</p>
<p>不带参数的 <code>Action</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeAction greet = () =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>&#125;;<br><br>greet(); <span class="hljs-comment">// 输出: Hello, World!</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个不带参数的 <code>Action</code> 委托变量 <code>greet</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>greet()</code>，实际上会执行 Lambda 表达式中定义的方法，输出 “Hello, World!”。</p>
<p>带有一个输入参数的 <code>Action</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeAction&lt;<span class="hljs-built_in">string</span>&gt; greet = (name) =&gt;<br>&#123;<br>    Console.WriteLine(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>&#125;;<br><br>greet(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 输出: Hello, John!</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有一个输入参数的 <code>Action</code> 委托变量 <code>greet</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>greet(&quot;John&quot;)</code>，Lambda 表达式中定义的方法会接收到参数 “John”，输出 “Hello, John!”。</p>
<p>带有多个输入参数的 <code>Action</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeAction&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt;<br>&#123;<br>    <span class="hljs-built_in">int</span> result = a + b;<br>    Console.WriteLine(<span class="hljs-string">&quot;Sum: &quot;</span> + result);<br>&#125;;<br><br><span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 输出: Sum: 8</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有两个输入参数的 <code>Action</code> 委托变量 <code>add</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>add(5, 3)</code>，Lambda 表达式中定义的方法会接收到参数 5 和 3，计算它们的和并输出结果 “Sum: 8”。</p>
<p><code>Action</code> 委托提供了一种方便的方式来定义和使用不返回值的委托。通过使用不同的重载，可以接受不同数量和类型的输入参数。这使得委托的使用更加灵活和简洁。</p>
</blockquote>
<blockquote>
<p><code>Func</code> 委托是 C# 中预定义的一个委托类型，它用于表示一个具有返回值的委托。<code>Func</code> 委托可以接受最多 16 个输入参数，并返回一个指定的结果类型。</p>
<p><code>Func</code> 委托的定义如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-function">csharpCopy codepublic <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;()</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T arg</span>)</span>;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T1</span>, <span class="hljs-keyword">in</span> <span class="hljs-title">T2</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T1 arg1, T2 arg2</span>)</span>;<br><span class="hljs-comment">// ... 其他重载 ...</span><br></code></pre></td></tr></table></figure>

<p><code>Func</code> 委托的命名规范为以 “Func” 开头，后面跟着输入参数的个数，最多可以有 16 个输入参数。最后一个类型参数表示返回值的类型。</p>
<p>以下是一些使用 <code>Func</code> 委托的示例：</p>
<p>不带参数的 <code>Func</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeFunc&lt;<span class="hljs-built_in">string</span>&gt; getGreeting = () =&gt;<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>&#125;;<br><br><span class="hljs-built_in">string</span> greeting = getGreeting(); <span class="hljs-comment">// greeting = &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个不带参数的 <code>Func</code> 委托变量 <code>getGreeting</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>getGreeting()</code>，实际上会执行 Lambda 表达式中定义的方法，返回字符串 “Hello, World!”。</p>
<p>带有一个输入参数的 <code>Func</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeFunc&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; greet = (name) =&gt;<br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>;<br>&#125;;<br><br><span class="hljs-built_in">string</span> greeting = greet(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// greeting = &quot;Hello, John!&quot;</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有一个输入参数的 <code>Func</code> 委托变量 <code>greet</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>greet(&quot;John&quot;)</code>，Lambda 表达式中定义的方法会接收到参数 “John”，返回字符串 “Hello, John!”。</p>
<p>带有多个输入参数的 <code>Func</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeFunc&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt;<br>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><br><span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// result = 8</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有两个输入参数的 <code>Func</code> 委托变量 <code>add</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>add(5, 3)</code>，Lambda 表达式中定义的方法会接收到参数 5 和 3，计算它们的和并返回结果 8。</p>
<p><code>Func</code> 委托提供了一种方便的方式来定义和使用带有返回值的委托。通过使用不同的重载，可以接受不同数量和类型的输入参数，并指定返回值的类型。这使得委托的使用更加灵活和简洁。</p>
</blockquote>
<h4 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h4><p>多播委托（Multicast Delegate）是 C# 中的一种特殊委托类型，它可以持有一个或多个目标方法的引用，并且可以按顺序依次调用这些方法。</p>
<p>在 C# 中，多播委托是由 <code>System.MulticastDelegate</code> 类派生而来的委托类型。它具有以下特点：</p>
<ol>
<li>可以使用 <code>+</code> 运算符将多个委托合并为一个多播委托。</li>
<li>可以使用 <code>-</code> 运算符将一个委托从多播委托中移除。</li>
<li>调用多播委托时，会按照添加的顺序依次调用每个目标方法。</li>
</ol>
<p>下面是一个简单的示例，演示如何使用多播委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MyDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        MyDelegate myDelegate = MethodA;<br>        myDelegate += MethodB;<br>        myDelegate += MethodC;<br><br>        myDelegate(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodA</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodA: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodB</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodB: &quot;</span> + message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">MethodC</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> message</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;MethodC: &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">MethodA: Hello, World!<br>MethodB: Hello, World!<br>MethodC: Hello, World!<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 <code>MyDelegate</code> 的委托类型，它接受一个字符串参数并且没有返回值。然后，我们创建了一个多播委托 <code>myDelegate</code>，并使用 <code>+=</code> 运算符将三个方法 <code>MethodA</code>、<code>MethodB</code> 和 <code>MethodC</code> 添加到委托中。最后，我们通过调用委托 <code>myDelegate(&quot;Hello, World!&quot;)</code>，依次调用了每个方法，并传递相同的字符串参数。</p>
<p>需要注意的是，多播委托的调用顺序与添加方法的顺序有关。在示例中，我们按照添加的顺序依次调用了 <code>MethodA</code>、<code>MethodB</code> 和 <code>MethodC</code>。</p>
<p>另外，通过使用 <code>-</code> 运算符，我们可以从多播委托中移除一个方法。例如，使用 <code>myDelegate -= MethodB;</code> 可以从多播委托中移除 <code>MethodB</code> 方法。</p>
<p>多播委托在某些情况下非常有用，例如事件处理程序、回调函数等场景，它允许将多个方法组合在一起，并且能够方便地按顺序调用这些方法。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在 C# 中，事件（Event）是一种特殊的语言构造，用于实现发布-订阅模型（Publish-Subscribe Model）。事件允许一个对象（发布者）通知其他对象（订阅者）某个特定事件的发生，以便订阅者可以执行相应的操作。</p>
<p>事件由两个主要组成部分组成：事件声明和事件触发。事件声明定义了事件的名称、事件处理程序的委托类型以及可选的事件访问器。事件触发是在发布者对象中引发事件，以通知订阅者事件的发生。</p>
<p>以下是一个简单的示例，演示了如何在 C# 中声明和使用事件：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeusing System;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">// 1. 事件声明</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler MyEvent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        Program program = <span class="hljs-keyword">new</span> Program();<br><br>        <span class="hljs-comment">// 2. 事件订阅（添加事件处理程序）</span><br>        program.MyEvent += Program_MyEventHandler;<br><br>        <span class="hljs-comment">// 3. 触发事件</span><br>        program.OnMyEvent();<br>    &#125;<br><br>    <span class="hljs-comment">// 4. 事件触发的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnMyEvent</span>()</span><br>    &#123;<br>        MyEvent?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 事件处理程序</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Program_MyEventHandler</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Event handled!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们首先在 <code>Program</code> 类中声明了一个事件 <code>MyEvent</code>，它使用 <code>EventHandler</code> 委托作为事件处理程序的类型。然后，在 <code>Main</code> 方法中订阅了该事件，即将事件处理程序方法 <code>Program_MyEventHandler</code> 添加到事件的订阅列表中。最后，通过调用 <code>OnMyEvent</code> 方法触发了事件。</p>
<p>当事件触发时，订阅事件的事件处理程序方法 <code>Program_MyEventHandler</code> 将被执行，并在控制台输出 “Event handled!”。</p>
<p>需要注意的是，事件的访问器可以使用 <code>add</code> 和 <code>remove</code> 关键字进行自定义。这允许控制事件的订阅和取消订阅的行为。</p>
<p>事件是一种强大的机制，它可以实现对象间的松耦合通信，提供了一种简洁且可扩展的方式来处理对象间的交互。在 C# 中，事件被广泛用于处理用户界面的交互、异步操作的完成通知、消息传递和回调机制等各种场景。</p>
<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>匿名方法（Anonymous Methods）是 C# 中一种特殊的方法，它允许我们在代码中定义一个没有显式命名的方法。匿名方法可以作为委托的实例或事件处理程序使用。</p>
<p>匿名方法的语法形式如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-built_in">delegate</span> (parameters)<br>&#123;<br>    <span class="hljs-comment">// 方法体</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在匿名方法中，我们可以定义方法体并传递参数，就像定义普通方法一样。匿名方法的参数列表和方法体放在一个委托类型的声明中，并且可以直接使用该委托类型的实例进行调用。</p>
<p>以下是一个使用匿名方法的示例，展示了如何将匿名方法作为委托的实例使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">GreetingDelegate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name</span>)</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        GreetingDelegate greeting = <span class="hljs-built_in">delegate</span> (<span class="hljs-built_in">string</span> name)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br>        &#125;;<br><br>        greeting(<span class="hljs-string">&quot;John&quot;</span>); <span class="hljs-comment">// 输出: Hello, John!</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 <code>GreetingDelegate</code> 的委托类型，它接受一个字符串参数并且没有返回值。然后，我们创建了一个匿名方法并将其赋值给委托变量 <code>greeting</code>。匿名方法的方法体是在 <code>delegate</code> 关键字后的大括号内定义的。最后，我们通过调用委托变量 <code>greeting(&quot;John&quot;)</code> 来调用匿名方法，并传递字符串参数 “John”。</p>
<p>匿名方法通常用于简单的委托场景，当我们只需要定义一个简短的方法体并且不想为其命名时，匿名方法提供了一种方便的方式。匿名方法可以与委托类型一起使用，允许我们以一种更简洁的方式定义委托实例。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>Lambda 表达式是 C# 中的一种语法特性，它提供了一种简洁的方式来定义匿名函数。Lambda 表达式可以用于创建委托实例、LINQ 查询、事件处理程序等场景。</p>
<p>Lambda 表达式的基本语法形式如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">(parameters) =&gt; expression<br></code></pre></td></tr></table></figure>

<p>Lambda 表达式包括以下几个部分：</p>
<ul>
<li>参数列表：一对括号中包含零个或多个输入参数，可以指定参数的类型或使用隐式类型推断。</li>
<li>箭头运算符 <code>=&gt;</code>：表示从参数到表达式的映射。</li>
<li>表达式：定义 Lambda 表达式的方法体，可以是单个表达式或语句块。</li>
</ul>
<p>以下是一些使用 Lambda 表达式的示例：</p>
<p>无参数的 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">() =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这个 Lambda 表达式没有参数，表达式体是调用 <code>Console.WriteLine</code> 方法输出 “Hello, World!”。</p>
<p>带有一个参数的 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">name =&gt; Console.WriteLine(<span class="hljs-string">&quot;Hello, &quot;</span> + name + <span class="hljs-string">&quot;!&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这个 Lambda 表达式有一个参数 <code>name</code>，表达式体是调用 <code>Console.WriteLine</code> 方法输出 “Hello, “ 加上参数值。</p>
<p>带有多个参数的 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">(a, b) =&gt; a + b;<br></code></pre></td></tr></table></figure>

<p>这个 Lambda 表达式有两个参数 <code>a</code> 和 <code>b</code>，表达式体是将参数 <code>a</code> 和 <code>b</code> 相加并返回结果。</p>
<p>Lambda 表达式可以与委托类型一起使用，用于创建委托实例。例如，我们可以使用 Lambda 表达式创建 <code>Func</code> 委托的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = (a, b) =&gt; a + b;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有两个输入参数和一个返回值的 <code>Func</code> 委托实例 <code>add</code>，使用 Lambda 表达式 <code>(a, b) =&gt; a + b</code> 定义了方法体，实现了将两个参数相加并返回结果的逻辑。</p>
<p>Lambda 表达式的优势在于它的简洁性和灵活性。它可以减少编写冗余代码的需求，并且可以更直观地表达某些操作。Lambda 表达式在 LINQ 查询、集合操作、事件处理程序等场景中被广泛使用，提供了一种便捷的方式来编写简短而高效的代码。</p>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>在C#中，扩展方法（Extension Methods）是一种特殊的静态方法，允许你向已存在的类型添加新的方法，而无需修改原始类型的定义或创建子类。</p>
<p>扩展方法提供了一种在不修改已有类型的情况下，为它们添加额外的功能的方式。这使得你可以向.NET框架中的类型添加自定义的方法，或者为自己定义的类型添加更便利的操作。</p>
<p>下面是扩展方法的一般写法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ExtensionClass</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ReturnType <span class="hljs-title">MethodName</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> ExtendedType obj, parameters</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// 扩展方法的实现逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述代码展示了一个扩展方法的示例，其中：</p>
<ul>
<li><code>ExtensionClass</code> 是定义扩展方法的静态类。类必须是静态的，并且在命名空间中。</li>
<li><code>MethodName</code> 是你给扩展方法起的名字。</li>
<li><code>ExtendedType</code> 是你要扩展的类型。</li>
<li><code>ReturnType</code> 是扩展方法的返回类型。</li>
<li><code>this ExtendedType obj</code> 表示将该扩展方法应用于 <code>ExtendedType</code> 类型的对象，通过 <code>this</code> 关键字进行标识。</li>
</ul>
<p>下面是一个示例，展示如何使用扩展方法为字符串类型添加一个自定义的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">ReverseString</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> input</span>)</span><br>    &#123;<br>        <span class="hljs-built_in">char</span>[] chars = input.ToCharArray();<br>        Array.Reverse(chars);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(chars);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们为字符串类型添加了一个名为 <code>ReverseString</code> 的扩展方法，用于将字符串反转。</p>
<p>使用扩展方法时，需要注意以下几点：</p>
<ul>
<li>扩展方法必须定义在静态类中。</li>
<li>扩展方法必须是静态的。</li>
<li>扩展方法的第一个参数必须使用 <code>this</code> 关键字标识，并指定要扩展的类型。</li>
<li>调用扩展方法时，编译器会自动将调用者作为第一个参数传递给扩展方法。</li>
</ul>
<p>通过使用扩展方法，你可以在不修改已有类型的情况下，为其添加自定义的行为和功能。这对于扩展.NET框架中的类型或者自定义类型非常有用，可以使代码更加简洁、可读，并提供更便利的操作。</p>
<h3 id="Obsolete特性"><a href="#Obsolete特性" class="headerlink" title="Obsolete特性"></a>Obsolete特性</h3><p>在C#中，<code>Obsolete</code>特性用于标记已经过时（deprecated）的代码元素，例如类型、方法、属性或字段。通过将<code>Obsolete</code>特性应用于代码元素，可以向开发人员发出警告或错误，以指示该代码元素不再建议使用，并提供替代方案或建议。</p>
<p><code>Obsolete</code>特性具有以下特征：</p>
<ol>
<li>编译器警告：使用<code>Obsolete</code>特性标记的代码元素将导致编译器生成警告。这提醒开发人员在使用过时的代码元素时需要注意，并考虑替代方案。</li>
<li>自定义警告消息：<code>Obsolete</code>特性允许你提供自定义的警告消息，以解释为什么该代码元素被标记为过时，以及建议使用哪些替代方案。开发人员可以根据这些消息来了解如何迁移代码。</li>
<li>错误级别：你可以选择将<code>Obsolete</code>特性的错误级别设置为<code>Error</code>，这将导致编译器将过时的代码元素视为错误，阻止编译通过。这对于强制要求开发人员立即处理过时的代码非常有用。</li>
<li>版本控制：<code>Obsolete</code>特性还允许你指定过时的代码元素应该从哪个版本开始过时。这样，你可以明确说明从哪个版本开始推荐使用替代方案，并为使用较旧版本的代码的开发人员提供指导。</li>
</ol>
<p>使用<code>Obsolete</code>特性有助于提高代码的可维护性和可读性，确保开发人员及时了解不再建议使用的代码</p>
<h3 id="onditional特性"><a href="#onditional特性" class="headerlink" title="onditional特性"></a>onditional特性</h3><p>在C#中，<code>Conditional</code>特性用于在编译时根据条件决定是否包含或排除代码。它允许您根据条件选择性地编译和执行代码。</p>
<p><code>Conditional</code>特性有两个常见的用途：</p>
<ol>
<li><p>条件编译：通过使用条件预处理指令，您可以根据编译时定义的条件选择性地编译不同的代码块。<code>Conditional</code>特性可以与条件编译一起使用，以便在满足特定条件时才包含代码。这对于在不同的构建配置中包含或排除代码非常有用。</p>
<p>例如，考虑以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy code<span class="hljs-meta">#<span class="hljs-keyword">define</span> DEBUG</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;DEBUG&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DebugMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Debug method called.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DebugMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>DebugMethod</code>方法带有<code>[Conditional(&quot;DEBUG&quot;)]</code>特性。这表示只有在定义了<code>DEBUG</code>预处理符号时，编译器才会将<code>DebugMethod</code>方法包含在生成的代码中。因此，只有当在代码的顶部定义了<code>#define DEBUG</code>时，<code>DebugMethod</code>方法才会在<code>Main</code>方法中调用。</p>
</li>
<li><p>方法调用条件性：使用<code>Conditional</code>特性还可以根据特定条件选择性地调用方法。在这种情况下，方法本身将始终包含在生成的代码中，但方法调用可能会根据条件被排除。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codepublic <span class="hljs-keyword">class</span> <span class="hljs-title">Example</span><br>&#123;<br>    [<span class="hljs-meta">Conditional(<span class="hljs-string">&quot;DEBUG&quot;</span>)</span>]<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DebugMethod</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Debug method called.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        DebugMethod();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>DebugMethod</code>方法带有<code>[Conditional(&quot;DEBUG&quot;)]</code>特性。这意味着无论如何，<code>DebugMethod</code>方法都会被包含在生成的代码中，但是在调用<code>DebugMethod</code>方法时，它只会在定义了<code>DEBUG</code>预处理符号时执行。</p>
</li>
</ol>
<p>需要注意的是，<code>Conditional</code>特性只能应用于无返回值（<code>void</code>）的静态方法。这是因为在编译时，编译器会根据条件决定是否调用方法，而无法处理方法的返回值。</p>
<p>总结来说，<code>Conditional</code>特性允许您根据条件选择性地编译和执行代码，或选择性地调用方法。它在进行条件编译和调试期间非常有用。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射*"></a>反射*</h3><p>在C#中，反射（Reflection）是一种强大的机制，它允许你在运行时动态地探查、访问和操作程序集（assembly）、类型（type）和成员（member）的信息。通过反射，你可以在编译时不知道类型和成员的具体信息的情况下，通过名称来动态地获取并使用它们。</p>
<p>反射提供了一组类型（位于<code>System.Reflection</code>命名空间下）和方法，用于在运行时获取类型信息、创建对象实例、调用方法、获取和设置属性值等。下面是一些反射的常用用途：</p>
<ol>
<li>获取类型信息：你可以使用<code>Type</code>类来获取一个类型的信息，包括类型的名称、命名空间、基类、实现的接口、属性、方法等。你可以使用<code>typeof</code>运算符获取一个类型的<code>Type</code>对象，也可以使用<code>GetType()</code>方法获取一个对象的类型。</li>
<li>创建对象实例：通过反射，你可以使用<code>Activator</code>类来动态地创建对象实例。你可以指定类型的名称或<code>Type</code>对象，然后使用<code>Activator.CreateInstance</code>方法来创建对象。</li>
<li>调用方法和访问属性：反射允许你通过方法名称和参数信息来调用类型的方法，并获取方法的返回值。你可以使用<code>Type.InvokeMember</code>方法来实现。类似地，你也可以通过反射来获取和设置属性的值。</li>
<li>动态加载程序集：反射可以在运行时动态地加载程序集。通过<code>Assembly</code>类，你可以加载和探查程序集，获取其中的类型信息，并在需要时创建对象实例或调用方法。</li>
</ol>
<p>需要注意的是，反射是一个强大但复杂的机制，其使用可能会对性能产生一定的影响。在大多数情况下，建议优先考虑使用静态类型和编译时绑定，而将反射作为一种备选方案，用于处理那些在编译时无法确定的类型和成员。</p>
<h4 id="Assembly程序集合类"><a href="#Assembly程序集合类" class="headerlink" title="Assembly程序集合类"></a>Assembly程序集合类</h4><p>在C#中，<code>Assembly</code>类是一个用于加载、探索和操作程序集（assembly）的核心类。下面是<code>Assembly</code>类的一些主要特点和功能：</p>
<ol>
<li>加载程序集：<code>Assembly</code>类提供了多种方法来加载程序集，包括从文件、字节数组、流或已加载的程序集中加载。你可以使用<code>Assembly.Load</code>或<code>Assembly.LoadFrom</code>方法来加载程序集，并获取一个<code>Assembly</code>对象，以便后续的操作。</li>
<li>获取程序集信息：通过<code>Assembly</code>类，你可以获取程序集的各种信息，包括程序集的名称、版本号、公钥、特性、引用的程序集等。你可以使用<code>AssemblyName</code>类来访问这些信息，并通过<code>Assembly.GetCustomAttributes</code>方法获取程序集的自定义特性。</li>
<li>探索类型信息：<code>Assembly</code>类允许你在程序集中探索类型信息。你可以使用<code>Assembly.GetTypes</code>方法获取程序集中定义的所有类型，并使用<code>Type</code>类的相关方法来访问类型的成员、特性和基类信息。</li>
<li>创建对象实例：通过<code>Assembly</code>类，你可以在程序集中创建对象实例。使用<code>Assembly.CreateInstance</code>方法，你可以根据类型名称或<code>Type</code>对象创建对象实例。这对于实现插件系统或动态加载模块非常有用。</li>
<li>动态调用方法和访问属性：<code>Assembly</code>类允许你通过反射动态调用程序集中类型的方法和访问属性。你可以使用<code>Assembly.GetType</code>方法获取类型的<code>Type</code>对象，然后使用反射的方法来调用方法和访问属性。</li>
<li>扩展性和灵活性：<code>Assembly</code>类提供了一种扩展性和灵活性，使得在运行时动态加载和操作程序集成为可能。这对于实现插件系统、动态扩展功能或实现基于配置的行为非常有用。</li>
</ol>
<p>需要注意的是，<code>Assembly</code>类的使用需要谨慎考虑，并且在处理程序集时需要确保安全性和性能。反射和程序集操作可能具有一定的开销，因此在应用程序中要适度使用，并考虑使用更高效的技术来满足需求。</p>
<h2 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h2><p>在C#中，LINQ（Language Integrated Query）是一种强大的查询语言和查询操作符的集合，它被集成到语言和.NET框架中，用于对各种数据源进行统一的查询和操作。</p>
<p>LINQ提供了一种统一的语法和模型，用于查询和操作不同类型的数据，如集合、数组、数据库、XML等。使用LINQ，开发人员可以通过直观的查询表达式或方法调用的方式来执行各种数据查询和操作，而无需编写繁琐的迭代代码。</p>
<p>LINQ的核心思想是将查询看作是对数据源进行筛选、排序、分组和投影等操作的过程。它提供了一组标准的查询操作符，如Where、Select、OrderBy、GroupBy、Join等，以及强大的表达式树和延迟执行的机制。</p>
<p>以下是一个使用LINQ查询的简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">var</span> numbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>[] &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span> &#125;;<br><br><span class="hljs-keyword">var</span> evenNumbers = <span class="hljs-keyword">from</span> num <span class="hljs-keyword">in</span> numbers<br>                  <span class="hljs-keyword">where</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span><br>                  <span class="hljs-keyword">select</span> num;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> evenNumbers)<br>&#123;<br>    Console.WriteLine(number);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们使用LINQ查询从一个整数数组中筛选出所有的偶数。使用<code>from</code>关键字指定查询的数据源（<code>numbers</code>数组），然后使用<code>where</code>关键字指定筛选条件，最后使用<code>select</code>关键字选择要返回的结果。</p>
<p>LINQ不仅可以用于集合的查询，还可以用于数据库查询（LINQ to SQL）、XML文档查询（LINQ to XML）、数据集查询（LINQ to DataSet）等。它提供了一种统一的编程模型，使得对不同类型数据源的查询具有一致的语法和风格。</p>
<p>通过LINQ，开发人员可以更加简洁、直观地编写查询代码，提高开发效率和代码可读性。同时，LINQ还具有编译时类型检查和优化查询的能力，使得查询更加安全和高效。</p>
<blockquote>
<p>LINQ 可以类比为在 C#（或其他支持 LINQ 的语言）中的 SQL 语句。LINQ 提供了一种类似于 SQL 的查询语法，使开发人员可以以一种直观和声明性的方式编写查询。</p>
<p>通过使用 LINQ 查询表达式，你可以使用类似于 SQL 的关键字和操作符（如<code>select</code>、<code>from</code>、<code>where</code>、<code>join</code>、<code>group by</code>、<code>order by</code>等）来编写查询逻辑。这样，你可以以一种熟悉且易于理解的方式来表示数据的筛选、排序、投影和聚合等操作。</p>
<p>这里是一个示例，展示了使用 LINQ 查询表达式来筛选和排序一个整数集合：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codeList&lt;<span class="hljs-built_in">int</span>&gt; numbers = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span> &#125;;<br><br><span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> number <span class="hljs-keyword">in</span> numbers<br>            <span class="hljs-keyword">where</span> number &gt; <span class="hljs-number">5</span><br>            <span class="hljs-keyword">orderby</span> number <span class="hljs-keyword">descending</span><br>            <span class="hljs-keyword">select</span> number;<br><br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> result <span class="hljs-keyword">in</span> query)<br>&#123;<br>    Console.WriteLine(result);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用 LINQ 查询表达式从 <code>numbers</code> 列表中筛选出大于 5 的数，并按降序排序。然后，我们遍历查询结果并将每个结果打印到控制台。</p>
<p>虽然 LINQ 查询表达式的语法类似于 SQL，但它是在编译时进行类型检查的，因此可以提供更高的类型安全性和编译时错误检测。此外，LINQ 还提供了方法语法，可以通过使用 LINQ 扩展方法来编写查询，这种方式更接近于在代码中编写函数式操作。</p>
</blockquote>
<h4 id="LINQ集合联合查询"><a href="#LINQ集合联合查询" class="headerlink" title="LINQ集合联合查询"></a>LINQ集合联合查询</h4><p>在LINQ中，可以使用联合操作符进行集合的联合查询。联合查询允许你将多个集合合并为一个结果集，去除重复项并保持元素的顺序。</p>
<p>LINQ提供了两个常用的联合操作符：</p>
<ol>
<li><code>Union()</code>：将两个集合的元素合并为一个结果集，去除重复项。</li>
<li><code>Concat()</code>：将两个集合的元素按顺序合并为一个结果集，不去除重复项。</li>
</ol>
<p>下面是使用这两个联合操作符进行集合联合查询的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#">csharpCopy codevar numbers1 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br><span class="hljs-keyword">var</span> numbers2 = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt; &#123; <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span> &#125;;<br><br><span class="hljs-comment">// 使用 Union() 进行联合查询</span><br><span class="hljs-keyword">var</span> unionQuery = numbers1.Union(numbers2);<br><br>Console.WriteLine(<span class="hljs-string">&quot;Union Query:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> unionQuery)<br>&#123;<br>    Console.WriteLine(number);<br>&#125;<br><br><span class="hljs-comment">// 使用 Concat() 进行联合查询</span><br><span class="hljs-keyword">var</span> concatQuery = numbers1.Concat(numbers2);<br><br>Console.WriteLine(<span class="hljs-string">&quot;Concat Query:&quot;</span>);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> number <span class="hljs-keyword">in</span> concatQuery)<br>&#123;<br>    Console.WriteLine(number);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了两个整数列表 <code>numbers1</code> 和 <code>numbers2</code>，然后使用 <code>Union()</code> 方法和 <code>Concat()</code> 方法进行联合查询。</p>
<p>在使用 <code>Union()</code> 方法时，结果集中的重复项会被去除，最终输出结果为：1, 2, 3, 4, 5, 6, 7, 8。</p>
<p>在使用 <code>Concat()</code> 方法时，结果集中保留了所有的元素，并按照它们在集合中的顺序进行合并，最终输出结果为：1, 2, 3, 4, 5, 4, 5, 6, 7, 8。</p>
<p>需要注意的是，联合查询的结果集是一个延迟执行的查询，只有在访问结果集时才会执行实际的查询操作。</p>
<p>除了 <code>Union()</code> 和 <code>Concat()</code>，LINQ还提供了其他的集合操作符，如交集查询（<code>Intersect()</code>）、差集查询（<code>Except()</code>）等，可以根据具体需求选择合适的操作符进行集合联合查询。</p>
<h4 id="join-on联合查询"><a href="#join-on联合查询" class="headerlink" title="join on联合查询"></a>join on联合查询</h4><p>在 C# 中，可以使用 LINQ（Language-Integrated Query）来执行联合查询和使用 <code>join on</code> 子句。LINQ 是一种强大的查询语言，可以与各种数据源（例如集合、数据库等）进行交互。</p>
<p>下面是一个示例，展示了如何在 C# 中使用 <code>join on</code> 来执行联合查询：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><code class="hljs c#"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        <span class="hljs-comment">// 创建示例数据源</span><br>        List&lt;Order&gt; orders = <span class="hljs-keyword">new</span> List&lt;Order&gt;<br>        &#123;<br>            <span class="hljs-keyword">new</span> Order &#123; OrderId = <span class="hljs-number">1</span>, CustomerId = <span class="hljs-number">1</span>, OrderDate = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2023</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) &#125;,<br>            <span class="hljs-keyword">new</span> Order &#123; OrderId = <span class="hljs-number">2</span>, CustomerId = <span class="hljs-number">1</span>, OrderDate = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2023</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>) &#125;,<br>            <span class="hljs-keyword">new</span> Order &#123; OrderId = <span class="hljs-number">3</span>, CustomerId = <span class="hljs-number">2</span>, OrderDate = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2023</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) &#125;,<br>            <span class="hljs-keyword">new</span> Order &#123; OrderId = <span class="hljs-number">4</span>, CustomerId = <span class="hljs-number">2</span>, OrderDate = <span class="hljs-keyword">new</span> DateTime(<span class="hljs-number">2023</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>) &#125;<br>        &#125;;<br><br>        List&lt;Customer&gt; customers = <span class="hljs-keyword">new</span> List&lt;Customer&gt;<br>        &#123;<br>            <span class="hljs-keyword">new</span> Customer &#123; CustomerId = <span class="hljs-number">1</span>, Name = <span class="hljs-string">&quot;John&quot;</span> &#125;,<br>            <span class="hljs-keyword">new</span> Customer &#123; CustomerId = <span class="hljs-number">2</span>, Name = <span class="hljs-string">&quot;Jane&quot;</span> &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 执行联合查询</span><br>        <span class="hljs-keyword">var</span> query = <span class="hljs-keyword">from</span> order <span class="hljs-keyword">in</span> orders<br>                    <span class="hljs-keyword">join</span> customer <span class="hljs-keyword">in</span> customers <span class="hljs-keyword">on</span> order.CustomerId <span class="hljs-keyword">equals</span> customer.CustomerId<br>                    <span class="hljs-keyword">where</span> customer.Name == <span class="hljs-string">&quot;John&quot;</span><br>                    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span><br>                    &#123;<br>                        OrderId = order.OrderId,<br>                        CustomerName = customer.Name,<br>                        OrderDate = order.OrderDate<br>                    &#125;;<br><br>        <span class="hljs-comment">// 输出查询结果</span><br>        <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> result <span class="hljs-keyword">in</span> query)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">$&quot;OrderId: <span class="hljs-subst">&#123;result.OrderId&#125;</span>, CustomerName: <span class="hljs-subst">&#123;result.CustomerName&#125;</span>, OrderDate: <span class="hljs-subst">&#123;result.OrderDate&#125;</span>&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Order</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> OrderId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> CustomerId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> DateTime OrderDate &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Customer</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> CustomerId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了两个示例数据源：<code>orders</code>（订单）和 <code>customers</code>（客户）。然后，我们使用 LINQ 查询语法执行联合查询，使用 <code>join on</code> 将 <code>orders</code> 和 <code>customers</code> 根据 <code>CustomerId</code> 进行联接，并通过 <code>where</code> 子句筛选出 <code>Name</code> 为 “John” 的客户。最后，我们选择需要的字段，并将结果输出到控制台。</p>
<p>请注意，这只是一个简单的示例，你可以根据自己的实际需求进行调整和扩展。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是一种被广泛接受和使用的解决特定软件设计问题的经验总结。它们提供了一套被认为是最佳实践的解决方案，可以帮助开发人员设计可维护、可扩展和可重用的代码。</p>
<p>以下是一些常见的设计模式：</p>
<ol>
<li>创建型模式（Creational Patterns）：<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
</li>
<li>结构型模式（Structural Patterns）：<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰者模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
</li>
<li>行为型模式（Behavioral Patterns）：<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板方法模式（Template Method Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
</li>
<li>并发模式（Concurrency Patterns）：<ul>
<li>生产者-消费者模式（Producer-Consumer Pattern）</li>
<li>读者-写者模式（Reader-Writer Pattern）</li>
<li>同步模式（Synchronization Pattern）</li>
</ul>
</li>
</ol>
<p>每种设计模式都有其特定的应用场景和解决问题的方式。选择适当的设计模式可以提高代码的可读性、可维护性和可扩展性，同时也有助于促进团队合作和共享设计经验。然而，设计模式并非万能的，使用时需要根据具体情况进行权衡和选择。</p>
<h3 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h3><p>观察者设计模式（Observer Design Pattern）是一种行为设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生变化时，其相关依赖对象都能够自动得到通知并更新。这种模式也被称为发布-订阅（Publish-Subscribe）模式。</p>
<p>在观察者设计模式中，有两个主要的角色：</p>
<ol>
<li>Subject（主题）：也称为被观察者或发布者，它维护一组观察者对象，并且提供了添加、删除和通知观察者的方法。当主题的状态发生变化时，它会通知所有注册的观察者。</li>
<li>Observer（观察者）：也称为订阅者，它定义了一个接口，用于接收主题的通知。当观察者接收到通知时，它可以执行相应的操作以更新自己的状态。</li>
</ol>
<p>观察者设计模式的工作原理如下：</p>
<ol>
<li>观察者通过订阅主题来注册自己，以便接收主题的通知。</li>
<li>主题维护一个观察者列表，用于记录所有注册的观察者。</li>
<li>当主题的状态发生变化时，它会遍历观察者列表，并调用每个观察者的通知方法。</li>
<li>观察者接收到通知后，可以根据需要进行相应的处理。</li>
</ol>
<p>观察者设计模式的优点包括：</p>
<ol>
<li>松耦合：主题和观察者之间是松耦合的关系，它们之间通过接口进行通信，主题不需要知道观察者的具体实现。</li>
<li>可扩展性：可以方便地添加新的观察者，主题和观察者之间的关系可以动态地建立和解除。</li>
<li>一致性：主题和观察者之间的一致性得到了保证，无论有多少观察者，它们都能够接收到相同的通知。</li>
</ol>
<p>然而，观察者设计模式也有一些潜在的缺点，包括：</p>
<ol>
<li>如果观察者过多或处理逻辑过于复杂，可能会导致性能问题。</li>
<li>观察者可能会收到不必要的通知，需要谨慎设计以避免这种情况。</li>
</ol>
<p>总之，观察者设计模式是一种常用的设计模式，它在许多应用场景中都有广泛的应用，例如事件处理、GUI 编程、消息队列等。通过使用观察者模式，可以实现对象之间的解耦和增加系统的灵活性。</p>
]]></content>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
</search>
