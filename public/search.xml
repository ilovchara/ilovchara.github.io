<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>English</title>
      <link href="/2023/05/24/English/"/>
      <url>/2023/05/24/English/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h2><p>在英语语法中，有五种基本的简单句结构，它们分别是：</p><ol><li>主语 + 动词 (Subject + Verb)：这是最基本的简单句结构，主语是句子中的主要名词或代词，动词描述主语的动作或状态。例如：”She sings.”（她唱歌。）</li><li>主语 + 动词 + 宾语 (Subject + Verb + Object)：除了主语和动词，这种简单句还包括一个宾语，宾语是动作的接受者或影响者。例如：”I love you.”（我爱你。）</li><li>主语 + 动词 + 表语 (Subject + Verb + Predicative)：表语是对主语的描述或补充，通常使用形容词或名词。例如：”He is a doctor.”（他是一名医生。）</li><li>主语 + 动词 + 间接宾语 + 直接宾语 (Subject + Verb + Indirect Object + Direct Object)：这种结构中，动作的影响对象由直接宾语表示，而间接宾语表示受益人或间接对象。例如：”She gave me a book.”（她给了我一本书。）</li><li>主语 + 动词 + 宾语 + 宾补 (Subject + Verb + Object + Object Complement)：宾补是对宾语的进一步描述或补充，通常使用形容词或名词。例如：”They elected him president.”（他们选举他为总统。）</li></ol><p>所有句子都是基于以上的句子构成，至于修饰语是和主语结合形成一个新的“主语”。要单拿出来解释的有</p><h3 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h3><p>在英语中，补语通常出现在以下几种情况下：</p><ol><li><p>表语（Predicative Complement）：表语是用来描述或补充主语的成分。它可以是名词、形容词、代词或介词短语。例如：</p><ul><li><p>She is a doctor.（表语是名词）</p></li><li><p>He seems happy.（表语是形容词）</p></li><li><p>They elected her as the president.（表语是介词短语）</p><blockquote><p>作为表语的动词没有实际意义，只起到了链接主语和宾语的作用，相当于绳子一样系住，所以被称之为系动词。</p><p>同时，be动词单拿出来有一个含义是：存在的意思。</p><p><strong>To be or not to be, that is the question.</strong></p></blockquote></li></ul></li><li><p>宾语补足语（Object Complement）：宾语补足语用来补充或描述及物动词后面的宾语。它通常是名词、形容词或介词短语。例如：</p><ul><li><p>They made him the captain.（宾语补足语是名词）</p></li><li><p>She painted the walls blue.（宾语补足语是形容词）</p><blockquote><p>宾补是用来描述宾语的状态，完善句子结构的一个词类。</p><p>宾补一般是形容词，如果是名词的话，我们可以理解宾语和宾补是一种主系表的关系，相当于宾语is宾补这样（去掉的be动词）。</p></blockquote></li></ul></li><li><p>主语补足语（Subject Complement）：主语补足语出现在系动词（be动词、感官动词、变化动词等）后面，用来补充或描述主语。它通常是名词、形容词或介词短语。例如：</p><ul><li><p>He is a teacher.（主语补足语是名词）</p></li><li><p>She became angry.（主语补足语是形容词）</p><blockquote><p>就是主系表，这里描述主语被修饰的部分。</p></blockquote></li></ul></li></ol><h3 id="双宾语"><a href="#双宾语" class="headerlink" title="双宾语"></a>双宾语</h3><p>在句子中，宾语、宾语补足语和双宾语是不同的语法成分，它们在句子结构和功能上有所区别。下面是对它们的解释和区分：</p><ol><li><p>宾语（Object）：宾语是一个句子中的核心成分，它接受动作的影响或指示动作的对象。宾语通常是动词的直接接受者或受益者。在英语中，宾语通常是名词、代词或名词性短语。例如：</p><ul><li>她买了一本书。 She bought a book.</li><li>他给我一杯咖啡。 He gave me a cup of coffee.</li></ul><p>在这些例句中，”一本书”和”一杯咖啡”是宾语，它们接受动词的动作。</p></li><li><p>宾语补足语（Object Complement）：宾语补足语是用来进一步描述、补充或修改宾语的成分。它通常出现在及物动词或使役动词后面，用来提供额外的信息来描述宾语的性质、状态、身份等。宾语补足语可以是形容词、名词、介词短语等。例如：</p><ul><li>我发现他很聪明。 I found him intelligent.</li><li>她把那个男孩称为英雄。 She called that boy a hero.</li></ul><p>在这些例句中，”聪明”和”英雄”是宾语补足语，它们进一步描述了宾语的特征。</p></li><li><p>双宾语（Double Object）：双宾语结构是一种特殊的情况，其中动词可以带有两个宾语，一个直接宾语和一个间接宾语。直接宾语是接受动作的直接对象，而间接宾语是动作的受益者或间接对象。在英语中，直接宾语通常是名词或代词，而间接宾语通常是介词短语或代词。例如：</p><ul><li>我送给她一束花。 I gave her a bouquet of flowers.</li><li>他买了我一杯咖啡。 He bought me a cup of coffee.</li></ul><p>在这些例句中，”一束花”和”一杯咖啡”是直接宾语，”她”和”我”是间接宾语。直接宾语接受动作，而间接宾语是动作的受益者。</p></li></ol><h2 id="名词性成分"><a href="#名词性成分" class="headerlink" title="名词性成分"></a>名词性成分</h2><h3 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h3><p>在英语中，动名词（Gerund）可以作为动词的形式在句子中充当多种语法角色。以下是动名词可能出现的几种语法角色和用法：</p><ol><li>主语（Subject）：<ul><li>Swimming is my favorite hobby.（游泳是我最喜欢的爱好。）</li><li>Jogging helps me stay fit.（慢跑帮助我保持健康。）</li></ul></li><li>宾语（Object）：<ul><li>I enjoy swimming in the ocean.（我喜欢在海里游泳。）</li><li>She loves reading books.（她喜欢读书。）</li></ul></li><li>宾语补足语（Object Complement）：<ul><li>He made a living by teaching English.（他靠教英语谋生。）</li><li>They find joy in helping others.（他们从帮助他人中找到快乐。）</li></ul></li><li>介词宾语（Object of Preposition）：<ul><li>She is interested in painting.（她对绘画感兴趣。）</li><li>We talked about going on a trip.（我们谈论去旅行的事。）</li></ul></li><li>主格形式（Subjective Form）：<ul><li>Swimming is a great exercise.（游泳是一项很好的运动。）</li><li>Running can be tiring but rewarding.（跑步可能会令人疲劳，但是有回报。）</li></ul></li></ol><p>需要注意的是，动名词在功能上可以类似名词，但它保留了动词的性质和特点，可以带有动词的补语或修饰语。动名词以-ing 结尾，并且可以有自己的宾语、副词修饰等。</p><h3 id="名词短语"><a href="#名词短语" class="headerlink" title="名词短语"></a>名词短语</h3><p>名词短语（Noun Phrase）是由一个名词（或代词）充当核心，并且可能由其他修饰语或补语组成的短语。名词短语具有以下特点：</p><ol><li><p>名词核心：名词短语的核心是一个名词或代词，它给出短语所描述的事物、人或概念的基本标识。例如，”a book”（一本书）中的名词短语核心是”book”（书）。</p></li><li><p>修饰语：名词短语可以由多个修饰语组成，这些修饰语在语法上修饰或限定名词的含义、特征或属性。修饰语可以是形容词、限定词、副词或其他名词短语等。例如，”a beautiful old house”（一座美丽的古老房屋）中的”beautiful”（美丽的）和”old”（古老的）都是修饰语。</p></li><li><p>补语：名词短语还可以包含补语，补语是对名词的进一步补充或说明。常见的补语包括形容词短语、介词短语或从句等。例如，”the president of the company”（公司的总裁）中的”of the company”（公司的）是一个介词短语作为补语。</p></li><li><p>可拓展性：名词短语可以根据需要进行扩展，以提供更多的信息或详细描述。可以添加更多的修饰语、补语或其他成分来进一步丰富名词短语的含义。例如，”a small red leather-bound book on the shelf”（架子上一本小巧的红色皮封书）中的名词短语逐渐扩展，包含了多个修饰语和补语。</p></li><li><p>在句子中的作用：名词短语在句子中可以作为主语、宾语、表语、定语或同位语等。它们在句子中承担名词的角色，并根据语境和句子结构发挥不同的语法功能。</p><blockquote><p>名词短语包括 1.限定词 2.形容词 3.名词构成，任意一个部分都可能被省略</p></blockquote></li></ol><p>名词短语在语言中起到重要的作用，它们用来描述和指代具体的事物、人或概念，并且在句子中扮演多种语法角色。名词短语的特点包括核心名词、修饰语、补语、可拓展性和语法功能的多样性。</p><h3 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h3><p>名词性从句（Noun Clauses）是一种在句子中充当名词的从句，它可以担任名词在句子中的各种功能，例如主语、宾语、表语、补足语等。以下是名词性从句的几个特点：</p><ol><li>充当名词角色：名词性从句在句子中充当名词的角色，可以出现在与名词相同的位置。例如：<ul><li>主语：What she said is true.（她说的是真的。）</li><li>宾语：I don’t know where he went.（我不知道他去哪了。）</li><li>表语：Her dream is that she wants to travel the world.（她的梦想是她想环游世界。）</li><li>宾补：I made a promise that I would help him.（我许下承诺，我会帮助他。）</li></ul></li><li>引导词：名词性从句通常由引导词引导，常见的引导词包括：<ul><li>连接代词：who, whom, whose, which, what</li><li>连接副词：where, when, why, how</li></ul></li><li>可以包含陈述句、疑问句或感叹句的结构：名词性从句可以采用陈述句、疑问句或感叹句的结构，根据从句的具体功能和意义进行相应的语序调整。例如：<ul><li>陈述句结构：I know that he is coming.（我知道他要来。）</li><li>疑问句结构：Can you tell me where she lives?（你能告诉我她住在哪里吗？）</li><li>感叹句结构：What a beautiful day it is!（多么美好的一天啊！）</li></ul></li><li>可以包含其他从句或从句成分：名词性从句内部可以包含其他从句或从句成分，形成更复杂的句子结构。例如：<ul><li>I don’t know what he said when he left.（我不知道他离开时说了什么。）</li><li>The question is whether they will attend the party.（问题是他们是否会参加聚会。）</li></ul></li></ol><p>总之，名词性从句在句子中具有名词的功能，可以出现在与名词相同的位置，并由引导词引导。它可以采用陈述句、疑问句或感叹句的结构，还可以包含其他从句或从句成分。名词性从句在句子中起着重要的名词替代作用，丰富了句子的表达和结构。</p><h2 id="形容词成分"><a href="#形容词成分" class="headerlink" title="形容词成分"></a>形容词成分</h2><p>在英语中，以下成分可以充当形容词：</p><ol><li>形容词（Adjectives）：它们直接修饰名词或代词，描述其特征或性质。例如：beautiful（美丽的）、old（老的）。</li><li>限定词（Determiners）：这些词修饰名词并限定其范围。它们可以指示数量、所有权、特定性等。例如：a（一个）、my（我的）、this（这个）。</li><li>数词（Numerals）：它们表示数量，可以是基数词（cardinal numbers）或序数词（ordinal numbers）。例如：three（三）、first（第一）。</li><li>不定代词（Indefinite Pronouns）：这些代词在句子中充当形容词的角色，描述某种未指定的事物或人。例如：some（一些）、any（任何）。</li><li>分词（Participles）：它们是动词的非谓语形式，可以作为形容词使用。分词通常用来描述名词所具有的状态或特征。例如：broken（破碎的）、fascinating（迷人的）。</li><li>物质名词（Nouns as Adjectives）：有时，名词被用作形容词来描述其他名词。例如：water（水）可以修饰bottle（瓶子），形成water bottle（水瓶）。</li></ol><p>这些是一些常见的充当形容词的成分，它们在句子中起到描述或修饰名词的作用。</p><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>在英语中，分词（Participles）具有以下特点：</p><ol><li>非谓语形式：分词是动词的非谓语形式，不具备时态和主语一致的特征。它们可以被用作形容词或副词，描述名词或修饰动词。</li><li>形容词性质：分词在形式上类似于形容词，可以用来描述名词的特征或状态。例如，”a broken cup”（一个破碎的杯子），其中的”broken”是现在分词作为形容词修饰”cup”。</li><li>副词性质：分词也可以作为副词修饰动词，表示动作的方式、原因或时间等。例如，”He ran, breathing heavily”（他跑着，大口喘着气），其中的”breathing”是现在分词作为副词修饰”ran”。</li><li>主动或被动：根据分词的形式，可以区分主动分词（Present Participle）和过去分词（Past Participle）。主动分词以-ing结尾（例如”running”），而过去分词通常以-ed、-en、-d、-t或其他变体结尾（例如”broken”）。它们在形式上不同，但在用法上有一些共同之处。</li><li>修饰名词：分词可以直接修饰名词或代词，描述其特征或状态。例如，”a sleeping baby”（一个正在睡觉的宝宝），其中的”sleeping”是现在分词作为形容词修饰”baby”。</li><li>时间关系：分词可以表达动作发生的时间关系，例如表示同时进行的动作、先后发生的动作或完成的动作等。这取决于上下文和其他句子成分的配合使用。</li></ol><p>分词是英语中一种灵活的语法结构，可以增加句子的表达能力和丰富性。了解分词的特点和用法，有助于正确使用和理解它们在句子中的作用。</p><h2 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h2><p>在英语中，动词时态（Verb Tense）用于表示动作或状态发生的时间。英语中常见的动词时态包括以下几种（这里只讨论时态）：</p><ol><li>现在时态（Present Tense）：<ul><li>简单现在时（Simple Present）：表示经常性、习惯性的动作或普遍真理。例如：”I play tennis every Sunday.”（我每个星期天打网球。）</li><li>现在进行时（Present Continuous）：表示正在进行的动作。例如：”She is watching TV now.”（她正在看电视。）</li><li>现在完成时（Present Perfect）：表示过去发生的动作对现在的影响或状态。例如：”I have finished my homework.”（我已经完成作业。）</li></ul></li><li>过去时态（Past Tense）：<ul><li>简单过去时（Simple Past）：表示过去发生的具体动作或状态。例如：”He played football yesterday.”（他昨天踢足球。）</li><li>过去进行时（Past Continuous）：表示过去某一时刻正在进行的动作。例如：”They were watching a movie when I arrived.”（当我到达时，他们正在看电影。）</li><li>过去完成时（Past Perfect）：表示过去某一时刻之前已经发生的动作或状态。例如：”She had already left when I called her.”（我打电话给她时，她已经离开了。）</li></ul></li><li>将来时态（Future Tense）：<ul><li>简单将来时（Simple Future）：表示将来发生的动作或状态。例如：”I will go to the beach tomorrow.”（明天我会去海滩。）</li><li>将来进行时（Future Continuous）：表示将来某一时刻正在进行的动作。例如：”They will be having a party this weekend.”（他们将在这个周末举办派对。）</li><li>将来完成时（Future Perfect）：表示将来某一时刻之前已经完成的动作或状态。例如：”By the time you arrive, I will have finished cooking dinner.”（你到达时，我会已经做完晚饭了。）</li></ul></li></ol><p>此外，英语中还有其他时态形式，如进行完成时（Present Perfect Continuous、Past Perfect Continuous、Future Perfect Continuous）等，用于表示更加复杂的时间关系。正确使用动词时态可以帮助清晰地表达动作发生的时间和顺序。</p><blockquote><p>其实有更好理解的方法,时态只有两种: 1.简单式 2.完成式</p><p>将句子中的be单拿出来，作为我们的动词，剩下的“动词”作为我们be动词的形容词补语。简单式分为三个时间  1.过去时间 2.现在时间 3.未来时间</p><p>同时，在简单句中，时间范围我们可以想象为一个括号，时间我们可以想象成一个轴。简单句所表达的时态，都可以清晰的用括号圈出来。</p><p>例句（过去时间）：<strong>The movable print was introduced to England in 1485</strong></p><p>将这句话的动词，be和时间状语in 1485比对，发现动词要变状态为was。be动词变化体现了时态的变化。形容词补语（本来的动词变化，体现了语态的变化，后面会讲）。括弧时间就是，1485.</p><p>例句（现在时间）：<strong>I drink coffee every morning</strong></p><p>这句话的动词涵盖的时间范围比较大。括弧时间将now都给涵盖了。所以说用一般时就行。</p><p>例句（将来时间）：<strong>There will be a major election in March</strong></p><p>将来时态，就是在be动词前加上will。</p><p>反正不管怎么变，时态的变化只体现在be动词处。</p><p>完成句:在完成句中，时间范围就不是括弧了，就是箭头。因为完成式是会有时间结束的点的，表示持续一段时间后结束了。</p><p>具体的变形要看时间箭头结束的地方，也就是时间副词？</p><p>例句：（现在时间）<strong>I’m sure I have  seen this face somewhere</strong></p><p>例句：（过去时间）<strong>Many soldiers had died from pneumonia before the discovery of penicillin.</strong></p><p>例句：（未来时间）<strong>Next April,I will have worked here for 20 years</strong></p></blockquote><h2 id="语态"><a href="#语态" class="headerlink" title="语态"></a>语态</h2><p>在英语中，语态（Voice）是用来表示动作或状态与主语之间关系的一种语法特征。英语中有两种主要的语态：主动语态（Active Voice）和被动语态（Passive Voice）。</p><ol><li>主动语态（Active Voice）：主动语态是最常用的语态形式。在主动语态中，主语是执行动作的实施者或行为的主体。动作的执行者位于句子的主语位置，而动作的接受者或承受者通常位于动词后的宾语位置。例如：<ul><li>“John reads a book.”（约翰读一本书。）</li><li>“She ate an apple.”（她吃了一个苹果。）</li></ul></li><li>被动语态（Passive Voice）：被动语态用于强调动作的接受者或承受者，而不是动作的执行者。在被动语态中，动词由”be”（根据时态变化）和过去分词形式构成，并且动作的接受者成为句子的主语。动作的执行者通常作为介词短语（通常是”by”）或省略不表达。例如：<ul><li>“The book is read by John.”（这本书被约翰读了。）</li><li>“An apple was eaten by her.”（一个苹果被她吃了。）</li></ul></li></ol><p>被动语态常用于以下情况：</p><ul><li>强调动作的接受者或承受者，而不是执行者。</li><li>当执行者未知、不重要或明显时。</li><li>当描述一般真理或客观事实时。</li></ul><p>需要注意的是，被动语态的使用要根据上下文和需要选择，有时也可以使用主动语态来表达相同的意思。了解和正确使用语态对于准确表达和理解英语句子至关重要。</p><h3 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h3><p>被动语态（Passive Voice）在英语中具有以下特点：</p><ol><li>动作接受者为主语：在被动语态中，动作的接受者或承受者成为句子的主语，突出了接受动作的对象。主动语态中的宾语通常变为被动语态中的主语。例如，”John reads a book”（约翰读一本书）的被动语态是”The book is read by John”（这本书被约翰读了）。</li><li>动词形式变化：被动语态的动词由”be”（根据时态变化）和过去分词形式构成。”be”的形式根据时态的不同而变化，如”is”、”was”、”will be”等。过去分词形式是动词的第三态形式，通常以”-ed”或”-en”结尾。例如，”read”（读）的过去分词形式是”read”，在被动语态中变为”read”。</li><li>执行者省略或通过介词短语表示：在被动语态中，动作的执行者（主动语态中的主语）可以被省略不表达，尤其当执行者未知、不重要或明显时。但如果需要明确指出执行者，可以通过介词短语（通常是”by”）来表达。例如，”The book is read”（这本书被读）中的执行者未指定，而”The book is read by John”（这本书被约翰读）中的执行者为John。</li><li>强调动作接受者或承受者：被动语态常用于强调动作的接受者或承受者，而不是动作的执行者。通过使用被动语态，可以将注意力放在受影响的对象上，使其成为句子的焦点。例如，”The house was built by my grandfather”（这座房子是我爷爷建造的）强调的是房子被建造的事实和建造者。</li><li>用于一般真理或客观事实：被动语态常用于表达一般真理、客观事实或普遍规律。通过使用被动语态，可以使句子更加客观和中性，避免强调特定的个体或行为。例如，”Water is boiled at 100 degrees Celsius”（水在100摄氏度沸腾）表达的是一般真理。</li></ol><p>需要注意的是，被动语态并非在所有情况下都适用，而且过度使用被动语态可能会使句子显得笨拙或不自然。正确地运用被动语态需要根据上下文和意图进行</p><h2 id="读音"><a href="#读音" class="headerlink" title="读音"></a>读音</h2><h3 id="元音"><a href="#元音" class="headerlink" title="元音"></a>元音</h3><p>元音在语言中扮演着多个重要角色，它们的作用包括：</p><ol><li>声音的核心：元音是构成语言中音节的基本成分，可以说是语言的核心音素。它们通常具有较长的持续时间，起到音节的骨架作用。其他音素如辅音则常常围绕着元音而存在。</li><li>词汇和语法的区分：元音的使用可以区分不同的词汇和语法形式。在许多语言中，改变元音的音素可以改变词汇的意义，例如英语中的 “bit”（一点）和 “bat”（球拍）。元音还可以用来表示时态、人称、性别等语法上的差异。</li><li>发音的清晰度：元音对于清晰发音至关重要。它们通常具有较高的音量和音高，有助于使语音更加清晰明确。元音的正确发音可以帮助人们准确地表达和理解语言。</li><li>语音韵律和重音的形成：元音在语音韵律中起到重要作用。它们可以用来区分重音和非重音音节，进一步影响句子的语调和语气。元音的长短、音高和强度的变化也可以帮助构建句子的韵律和节奏。</li><li>语音系统的多样性：元音在不同语言中呈现出丰富多样的系统。不同语言中的元音数量、品质和分布都有所不同。通过对元音系统的研究，可以深入了解不同语言之间的差异和相似之处。</li></ol><p>总之，元音在语言中起到了连接词汇和语法、帮助发音清晰、形成韵律和重音、以及构建语音系统多样性等重要作用。它们是语言中不可或缺的一部分，对于有效的交流和理解起着至关重要的作用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web</title>
      <link href="/2023/04/30/Web/"/>
      <url>/2023/04/30/Web/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML超文本标记语言"><a href="#HTML超文本标记语言" class="headerlink" title="HTML超文本标记语言"></a>HTML超文本标记语言</h2><p>HTML（HyperText Markup Language）是一种用于创建网页结构和内容的标记语言。它使用标签（tag）来定义网页中的各种元素，如标题、段落、链接、图像等。HTML文件由一系列标签和文本内容组成，浏览器根据这些标签解析并显示网页的结构和内容。</p><p>HTML相当于我们文章的文本，内部存在一些标签，来对这些文本修饰和美化，相当于我们的大纲，通过与CSS结合使用，可以通过样式规则控制文本的外观和呈现方式。下面我们来介绍一些基础的标签。</p><h3 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><code>&lt;!DOCTYPE html&gt;</code>：声明文档类型，告诉浏览器这是一个HTML5文档。</li><li><code>&lt;html&gt;</code>：根元素，表示整个HTML文档的开始和结束。</li><li><code>&lt;head&gt;</code>：头部元素，用于定义文档的元数据和引入外部资源，如CSS和JavaScript文件等。</li><li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：指定文档的字符编码为UTF-8，确保网页中的文本可以正确地显示。</li><li><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>：定义浏览器的兼容性模式，确保在Internet Explorer浏览器中以最新的渲染模式显示。</li><li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>：设置视口的宽度和初始缩放级别，使网页在移动设备上能够适应屏幕大小。</li><li><code>&lt;title&gt;</code>：定义网页的标题，显示在浏览器的标题栏或标签页上。</li><li><code>&lt;body&gt;</code>：主体元素，包含了网页的可见内容，如文本、图像、链接等。</li></ol><h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p>在介绍完基础框架后，我们来学习一下基本构建网站的标签。它们通常都是书写在我们的body标签处</p><h4 id="h标签"><a href="#h标签" class="headerlink" title="h标签"></a><strong>h标签</strong></h4><p> h标签是文章的标题，一共有6个级别，h1…h6。每一个级别代表着一个标签头。我们书写一个这样的案例，按照6个级别分别输出我们的标题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 试试打开全部的标签 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>我是标题1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>我是标题2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>我是标题3<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>我是标题4<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h5</span>&gt;</span>我是标题5<span class="hljs-tag">&lt;/<span class="hljs-name">h5</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>我是标题6<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230517201250588.png" alt="image-20230517201250588"></p><h4 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a><strong>p标签</strong></h4><p>p标签是文章的段落，被p标签修饰的字段，会有执行文章段落的规则，浏览器通常会在段落前后添加一些默认的空间和换行，以显示段落的分隔效果。</p><p>块级元素：<code>&lt;p&gt;</code>标签是一个块级元素，它会占据一行或多行的空间。相邻的<code>&lt;p&gt;</code>标签会在页面上垂直排列，每个<code>&lt;p&gt;</code>标签之间会有一定的间距。</p><blockquote><p>块级元素：块级元素（Block-level elements）是HTML中的一个概念，用于描述元素在文档流中的布局和行为方式。以下是块级元素的特点：</p><ol><li>独占一行：块级元素通常会在页面上独占一行，即使它的内容没有填满整行。相邻的块级元素会在页面上垂直排列。</li><li>宽度默认为100%：块级元素的默认宽度会填满其父元素的可用宽度，除非通过CSS显式设置其宽度。</li><li>可以设置宽度、高度、内边距和外边距：块级元素可以通过CSS属性设置其宽度、高度、内边距和外边距，以调整布局和样式。</li><li>可以包含内联元素和其他块级元素：块级元素可以包含其他块级元素和内联元素。这使得可以构建复杂的布局结构，并且在其中放置各种内容。</li><li>默认情况下会产生一些垂直间距：块级元素通常会在其上下产生一些默认的垂直间距，例如段落之间的间距。</li></ol><p>一些常见的块级元素包括<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;form&gt;</code>等。这些元素在默认情况下都是块级元素，但也可以通过CSS进行样式上的修改。</p><p>相对于块级元素，还有另一类元素称为内联元素（Inline elements），它们通常不会独占一行，而是在同一行内水平排列。内联元素的特点包括不能设置宽度和高度，不能独占一行，只能容纳其他内联元素或者文本内容。常见的内联元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等。</p></blockquote><p>文本包裹：<code>&lt;p&gt;</code>标签用于包裹一段文本，该文本可以是普通的纯文本，也可以包含其他内联元素或标记。例如，你可以在<code>&lt;p&gt;</code>标签内使用<code>&lt;strong&gt;</code>或<code>&lt;em&gt;</code>标签来加粗或斜体显示文本。</p><p>默认样式：浏览器会对<code>&lt;p&gt;</code>标签应用一些默认样式，例如设定一定的行间距、字体样式和段落缩进。这些样式可以通过CSS进行自定义调整。</p><blockquote><p>以下是一些常见的CSS属性，可以用来修饰段落：</p><ol><li><code>color</code>：设置文本的颜色。</li><li><code>font-size</code>：设置文本的字体大小。</li><li><code>font-family</code>：设置文本的字体系列。</li><li><code>font-weight</code>：设置文本的粗细程度，例如使用值<code>bold</code>加粗文本。</li><li><code>text-align</code>：设置文本的对齐方式，例如使用值<code>center</code>使文本居中对齐。</li><li><code>line-height</code>：设置行高，控制行与行之间的垂直间距。</li><li><code>padding</code>：设置段落的内边距，即段落内容与边框之间的空间。</li><li><code>margin</code>：设置段落的外边距，即段落与相邻元素之间的空间。</li></ol></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- css样式 - 建议封装在外部 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-tag">p</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgb</span>(<span class="hljs-number">165</span>, <span class="hljs-number">42</span>, <span class="hljs-number">128</span>);</span><br><span class="language-css">            <span class="hljs-comment">/* 字体大小 */</span></span><br><span class="language-css">            <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">            <span class="hljs-comment">/* css样式居中 */</span></span><br><span class="language-css">            <span class="hljs-attribute">text-align</span>: center;</span><br><span class="language-css">            <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>试试段落的特点<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 这个段落是一个块 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落，它有什么特点<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 尝试用css来修饰这个段落 --&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230517203408632.png" alt="image-20230517203408632"></p><h4 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a><strong>a标签</strong></h4><p>a标签是HTML中用于创建超链接的标签，它具有以下特点：</p><ol><li><p>超链接功能：<code>&lt;a&gt;</code>标签用于创建链接到其他网页、文档或特定位置的超链接。通过设置<code>href</code>属性来指定链接目标的URL或文档片段标识符。</p></li><li><p>文本或图像链接：<code>&lt;a&gt;</code>标签可以包裹文本或图像，使其成为可点击的链接。例如，可以使用<code>&lt;a&gt;</code>标签将文本或图像转换为链接，使用户能够点击并导航到链接目标。</p></li><li><p>打开新窗口：使用<code>target</code>属性可以控制链接在新窗口或当前窗口中打开。例如，设置<code>target=&quot;_blank&quot;</code>可以在新的浏览器窗口或选项卡中打开链接。</p></li><li><p>可以包含其他元素：<code>&lt;a&gt;</code>标签可以包含其他内联元素或块级元素，例如文本、图像、按钮等。这样可以在链接中添加更丰富的内容和样式。</p></li><li><p>可以添加标题：使用<code>title</code>属性可以为链接添加鼠标悬停时显示的标题文本，提供额外的描述或信息。</p></li><li><p>可以与JavaScript交互：<code>&lt;a&gt;</code>标签可以与JavaScript代码结合使用，例如通过添加事件处理程序来实现自定义行为或交互效果。  </p><blockquote><p>通过添加事件处理程序，你可以为<code>&lt;a&gt;</code>标签或其它元素添加自定义的行为或交互效果。事件处理程序是一段JavaScript代码，用于响应用户与页面元素的交互，例如点击、鼠标移入、键盘按下等事件。</p><p>在HTML中，你可以通过在元素上添加事件属性来指定事件处理程序。常见的事件属性包括<code>onclick</code>（点击事件）、<code>onmouseover</code>（鼠标悬停事件）、<code>onkeydown</code>（键盘按下事件）等。</p><p>就是一些按钮啊，点击啊之类的(＾▽＾)</p></blockquote></li></ol><p>需要注意的是，<code>&lt;a&gt;</code>标签本身并没有默认的样式，它可以通过CSS进行样式上的修改，如更改颜色、添加下划线等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>超链接实验<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.创建连接指向我们的hexo --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span>&gt;</span>hexo<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.控制链接跳转，生成新的网页 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span>hexo_open<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 3.包括其他块级元素 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>你说我这个算不算链接啊<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>试一下第二行有没有用<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 4.添加标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;这是通向hexo的链接&quot;</span>&gt;</span>?????<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 5.图片链接 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://hexo.io/zh-cn/index.html&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\Different from the usual of you.jpg&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230517204933935.png" alt="image-20230517204933935"></p><h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a><strong>img标签</strong></h4><p>img标签是HTML中用于插入图像的标签，它具有以下特点：</p><ol><li><p>插入图像：<code>&lt;img&gt;</code>标签用于在网页中插入图像。通过设置<code>src</code>属性来指定要插入的图像的路径或URL。</p></li><li><p>自闭合标签：<code>&lt;img&gt;</code>标签是一个自闭合标签，不需要闭合标签。例如：<code>&lt;img src=&quot;image.jpg&quot; alt=&quot;图像&quot;&gt;</code></p></li><li><p>显示图像：<code>&lt;img&gt;</code>标签会在网页中显示指定的图像。网页加载时，图像会根据<code>src</code>属性指定的路径下载并显示在指定位置。</p></li><li><p>替代文本：通过<code>alt</code>属性可以提供替代文本（alternative text），当图像无法加载时，或用于辅助技术（如屏幕阅读器）读取图像时，会显示替代文本。</p></li><li><p>调整尺寸：通过<code>width</code>和<code>height</code>属性可以设置图像的宽度和高度。可以使用具体像素值或百分比来调整图像的大小。</p></li><li><p>添加标题：使用<code>title</code>属性可以为图像添加鼠标悬停时显示的标题文本，提供额外的描述或信息。</p></li><li><p>响应式设计：通过CSS或使用<code>width</code>属性设置百分比值，可以使图像在不同屏幕尺寸下自动调整大小，实现响应式设计。</p><blockquote><p>响应式设计（Responsive Design）是一种设计方法和技术，旨在使网页或应用程序能够根据不同设备（如桌面电脑、平板电脑、手机等）和屏幕尺寸的变化而自动调整其布局和外观。</p><p>传统的网页设计通常是为特定的屏幕尺寸和设备进行优化，这导致在不同设备上访问同一网页时可能会出现布局错乱、内容溢出等问题。而响应式设计的目标是提供一种灵活的布局和界面，使网页能够适应不同的屏幕尺寸，从而提供更好的用户体验。</p><p>在响应式设计中，通过使用CSS媒体查询（Media Queries）和流式布局（Fluid Layouts），可以根据屏幕宽度、高度、像素密度等特性，动态地调整网页元素的大小、位置和样式。这样，网页的内容和布局会根据设备的大小和方向进行自适应，以适应不同的屏幕。</p><p>就是，可以随着用户的放大和缩小图片的大小，或者设定图片的格式固定啥的。<br>(￣▽￣)ノ</p></blockquote></li><li><p>支持多种图像格式：<code>&lt;img&gt;</code>标签可以加载多种图像格式，如JPEG、PNG、GIF等。</p></li></ol><p>需要注意的是，图像的实际大小和显示效果会受到浏览器窗口大小、图像本身尺寸以及CSS样式的影响。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 默认样式 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.responsive-img</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="language-css">            <span class="hljs-comment">/* 图片宽度填满父容器 */</span></span><br><span class="language-css">            <span class="hljs-attribute">height</span>: auto;</span><br><span class="language-css">            <span class="hljs-comment">/* 根据宽度等比例调整高度 */</span></span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 在屏幕宽度小于等于600px时调整图片大小 */</span></span><br><span class="language-css">        <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;</span><br><span class="language-css">            <span class="hljs-selector-class">.responsive-img</span> &#123;</span><br><span class="language-css">                <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">                <span class="hljs-comment">/* 图片宽度为父容器宽度的50% */</span></span><br><span class="language-css">            &#125;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>插入图片试试<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.简单插入图片 由于尺寸太大了 限制一下--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\照片素材\800 (1).jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;报错了QAQ&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.alt用法 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;im\照片素材\800 (1).jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;我是故意的&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 3.加个标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\照片素材\市.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;你好&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;300&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;300&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 4.响应式设计 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;responsive-img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;img\照片素材\雪山.png&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;响应式图片&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230517213938193.png" alt="image-20230517213938193"></p><h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><h4 id="ul和li"><a href="#ul和li" class="headerlink" title="ul和li"></a>ul和li</h4><p><code>&lt;ul&gt;</code>（无序列表）和 <code>&lt;li&gt;</code>（列表项）是 HTML 中用于创建列表的标签，它们具有以下特点：</p><p><code>&lt;ul&gt;</code> 标签的特点：</p><ol><li>无序列表：<code>&lt;ul&gt;</code> 表示无序列表，其中的列表项 <code>&lt;li&gt;</code> 不会按照特定的顺序排列，而是作为一个项目列表显示。</li><li>项目符号：无序列表使用项目符号来表示每个列表项，默认情况下是一个实心圆点（•）。</li><li>嵌套列表：<code>&lt;ul&gt;</code> 元素可以嵌套在另一个 <code>&lt;ul&gt;</code> 或有序列表 <code>&lt;ol&gt;</code> 中，以创建多层级的列表。</li></ol><blockquote><p>ul理解为容器，像是状li的罐子</p></blockquote><p><code>&lt;li&gt;</code> 标签的特点：</p><ol><li>列表项：<code>&lt;li&gt;</code> 表示列表中的每个项目或条目。每个 <code>&lt;li&gt;</code> 标签通常包裹在 <code>&lt;ul&gt;</code> 或 <code>&lt;ol&gt;</code> 标签中。</li><li>顺序无关：<code>&lt;li&gt;</code> 列表项的排列顺序与其在代码中的位置无关，它们将按照显示时的顺序呈现。</li><li>嵌套列表项：<code>&lt;li&gt;</code> 列表项可以包含嵌套的列表，创建层级结构的子列表。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.构造一个简单无序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230517222930214.png" alt="image-20230517222930214"></p><h4 id="ol和li"><a href="#ol和li" class="headerlink" title="ol和li"></a>ol和li</h4><p>在HTML中，<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>标签通常一起使用来创建有序列表。</p><p><code>&lt;ol&gt;</code>标签表示有序列表，具有以下特点：</p><ul><li>有序列表中的项目通常按照顺序进行编号，可以是数字、字母或罗马数字。</li><li><code>&lt;ol&gt;</code>标签创建一个包含多个列表项的块级元素。</li><li>有序列表项的默认样式是按照顺序编号显示。</li></ul><p><code>&lt;li&gt;</code>标签用于定义列表项，它的特点包括：</p><ul><li><code>&lt;li&gt;</code>标签包裹在<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>标签内部，表示一个列表项。</li><li>列表项可以包含文本、图像、链接或其他HTML元素。</li><li>列表项默认以项目符号或顺序编号显示，但可以通过CSS样式进行自定义。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 1.构造一个简单无序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>123<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>321<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 2.构造一个简单有序列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第一项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第二项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>第三项<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230517223129645.png" alt="image-20230517223129645"></p><h4 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h4><div>标签是HTML中用于定义一个文档的区域或容器的元素。它具有以下特点：<ol><li><p>区域划分：div标签可以用来将HTML文档划分为不同的区域或块。通过使用<div>标签，可以将页面的不同部分进行逻辑上的分组，从而方便样式和布局的控制。</p></li><li><p>块级元素：div标签是一个块级元素，它在页面中独占一行。这意味着它会自动换行，并且可以设置宽度、高度、内边距和外边距等属性。</p></li><li><p>无语义性：div标签本身没有特定的语义含义，它只是一个通用的容器。它不会给其中的内容赋予特定的含义，而是依赖于CSS样式和嵌套的内容来定义其作用和意义。</p></li><li><p>可嵌套性：div标签可以嵌套在其他HTML元素中，也可以包含其他HTML元素，包括文本、图像、链接等。这使得它成为构建复杂页面结构和布局的重要工具。</p></li><li><p>样式控制：通过为<div>标签添加CSS类或ID，可以对其应用样式规则。这使得开发者可以通过定义相应的CSS样式，实现对<div>元素及其内容的外观和布局的定制。</p><blockquote><p>要修改<code>&lt;div&gt;</code>元素的大小，可以使用CSS样式来控制其宽度和高度。有几种常见的方法可以实现这一点：</p><ol><li>使用CSS的<code>width</code>和<code>height</code>属性：通过设置<code>width</code>属性来定义<code>&lt;div&gt;</code>元素的宽度，使用<code>height</code>属性来定义其高度。可以使用像素（px）、百分比（%）或其他支持的单位来指定具体的数值。</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">cssCopy code<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.my-div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  <img src="/2023/04/30/Web/image-20230518215731263.png" alt="image-20230518215731263"></p><ol start="2"><li>使用CSS的<code>max-width</code>和<code>max-height</code>属性：这些属性允许指定元素的最大宽度和最大高度，如果内容不足以填满指定的尺寸，则元素的大小会自动调整。</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">cssCopy code<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.my-div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">max-width</span>: <span class="hljs-number">500px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">max-height</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  <img src="/2023/04/30/Web/image-20230518215751511.png" alt="image-20230518215751511"></p><ol start="3"><li>使用CSS的<code>min-width</code>和<code>min-height</code>属性：这些属性允许指定元素的最小宽度和最小高度，确保元素不会小于指定的尺寸。</li></ol>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html">cssCopy code<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.my-div</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">min-width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">min-height</span>: <span class="hljs-number">150px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>元素<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/2023/04/30/Web/image-20230518220351244.png" alt="image-20230518220351244"></p><p>怎么修改都不会小于40px</p></blockquote><p>这些是常见的方法，可以根据具体的需求和情况选择适合的方式来修改<code>&lt;div&gt;</code>元素的大小。</p><blockquote><p>注：可以在浏览器中，按f12进入调试，这样就可以调整数据来看盒子大小了。</p><p><img src="/2023/04/30/Web/image-20230518220007950.png" alt="image-20230518220007950"></p></blockquote></blockquote></li></ol><p>总之，div标签是HTML中的一个通用容器元素，用于划分页面区域和组织内容，它的特点包括块级元素、无语义性、可嵌套性和样式控制。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- css样式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.my_div</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 设置我们盒子的高度 */</span></span><br><span class="language-css">            <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 修改第二个样式 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.my_div2</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 自动变形的盒子 */</span></span><br><span class="language-css">            <span class="hljs-attribute">max-width</span>: <span class="hljs-number">300px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">max-height</span>: <span class="hljs-number">400px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.my_div3</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">min-width</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">            <span class="hljs-attribute">min-height</span>: <span class="hljs-number">40px</span>;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div盒子样式1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 类选择器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_div&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 1.可以装其他标签 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个结构是什么1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div盒子样式2<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_div2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个结构是什么2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>div盒子演示3<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;my_div3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这个结构是什么3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="容器标签"><a href="#容器标签" class="headerlink" title="容器标签"></a>容器标签</h3><h4 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h4><p><code>&lt;span&gt;</code>标签是HTML中的一个内联元素，它用于对文本进行分组或标记，而不会对文本添加额外的语义或影响文档的结构。下面是<code>&lt;span&gt;</code>标签的几个特点：</p><ol><li><p>内联元素：<code>&lt;span&gt;</code>是内联元素，与其他内联元素（如<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>等）类似。它不会在文档中创建新的块级盒子，而是将其内容作为行内元素嵌入到文本中。</p><blockquote><p>内联元素（Inline Element）是HTML中的一种元素类型，它用于表示文档中的内联内容，这些内容通常嵌套在块级元素内部或直接位于文本流中。与块级元素不同，内联元素不会创建独立的块，并且它们在文档中水平排列，不会强制换行。</p><p>以下是内联元素的特点：</p><ol><li>水平排列：内联元素默认以水平方向排列，相邻的内联元素会在同一行上显示。</li><li>不独占一行：内联元素不会强制换行，除非遇到换行符或父元素的宽度不足以容纳内联内容。</li><li>无法设置宽度和高度：内联元素的宽度和高度通常由其内容决定，无法直接通过CSS属性设置固定的宽度和高度。</li><li>可以与其他内联元素共享水平空间：内联元素会根据其内容的大小动态分配水平空间，并且可以与其他内联元素共享同一行的空间。</li><li>支持部分CSS属性：内联元素支持一部分CSS属性，如颜色、字体大小、字体样式等，可以通过CSS样式对其进行样式调整。</li></ol><p>一些常见的内联元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>等。需要注意的是，并非所有元素都是内联元素，还有块级元素和行内块元素等不同类型的元素，它们具有不同的布局和行为特点。</p><p>使用内联元素可以方便地对文本或行内内容进行标记、样式化和操作，从而实现更灵活的页面设计和排版效果。</p><p><strong>可以理解为，内联标签是一个括号，可以将文本的一段括号起来，以便我们单独对这个括号执行修饰。^-^</strong></p></blockquote></li><li><p>无语义：<code>&lt;span&gt;</code>标签本身没有特定的语义含义。它主要用于通过CSS样式或JavaScript脚本来对文本进行分组、标记或添加样式。</p></li><li><p>文本容器：<code>&lt;span&gt;</code>可以包裹文本内容，使得可以对其中的文本进行样式或操作。它通常用于设置特定文本的样式，如颜色、字体大小、字体样式等。</p></li><li><p>嵌套使用：<code>&lt;span&gt;</code>标签可以嵌套在其他元素内部，以便于对特定部分进行样式控制。通过嵌套使用<code>&lt;span&gt;</code>，可以对文档进行更精细的标记和样式调整。</p><blockquote><p><code>&lt;span&gt;</code>标签是HTML中的一个内联元素，它没有特定的语义含义，主要用于对文本或行内内容进行分组、标记或样式化。下面是<code>&lt;span&gt;</code>标签的几个常见的用途：</p><p>文本标记：<code>&lt;span&gt;</code>标签可以用来标记文本的特定部分，以便后续通过CSS或JavaScript对其进行样式或操作。例如，可以给某个词语、短语或字符添加特定的样式或行为。</p><p><img src="/2023/04/30/Web/image-20230521194049707.png" alt="image-20230521194049707"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>高亮<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>样式控制：<code>&lt;span&gt;</code>标签可以用来包裹需要进行样式控制的文本或行内内容。通过为<code>&lt;span&gt;</code>标签添加CSS类或内联样式，可以对其内部的内容应用特定的样式属性，如颜色、字体大小、字体样式等。</p><p><img src="/2023/04/30/Web/image-20230521194102324.png" alt="image-20230521194102324"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-weight: bold;&quot;</span>&gt;</span>红色粗体<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JavaScript操作：<code>&lt;span&gt;</code>标签可以用作JavaScript操作的目标元素。通过为<code>&lt;span&gt;</code>标签添加标识符或事件处理程序，可以对其进行动态操作或交互效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击这个<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clickable-text&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;你点击了文本！&#x27;)&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>可以触发一个弹窗。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230521194231941.png" alt="image-20230521194231941"></p><p>文本分组：<code>&lt;span&gt;</code>标签可以用于将文本或行内内容进行逻辑上的分组。通过使用<code>&lt;span&gt;</code>标签，可以在文本中划分多个区块，从而方便对这些区块进行整体样式或操作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group1&quot;</span>&gt;</span>第一组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group2&quot;</span>&gt;</span>第二组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的文本。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230521194421688.png" alt="image-20230521194421688"></p><p>需要注意的是，<code>&lt;span&gt;</code>标签本身不会对文档结构产生显著影响，它主要用于样式和操作层面的处理。使用<code>&lt;span&gt;</code>标签需要结合CSS或JavaScript来实现相应的效果和功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 运行这个修饰style会显示字体颜色 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.highlight</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: red;</span><br><span class="language-css">            <span class="hljs-attribute">font-weight</span>: bold;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.group1</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.group2</span> &#123;</span><br><span class="language-css">            <span class="hljs-attribute">color</span>: yellow;</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 运行这个函数的时候会弹出警告框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-comment">//警告提示行</span></span><br><span class="language-javascript">            <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>span标签的用法<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- span就是在文本中圈出一块区域，对这个区域可以用其他的例如css和js来操控这个圈出区域的文本样式 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>突出显示<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的文本。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用span标签赋予文字属性 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>点击这里<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 段落之间会有合适间距，不用换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight&quot;</span>&gt;</span>高亮<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red; font-weight: bold;&quot;</span>&gt;</span>红色粗体<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>文本的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>点击这个<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;clickable-text&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;你点击了文本！&#x27;)&quot;</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>可以触发一个弹窗。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group1&quot;</span>&gt;</span>第一组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;group2&quot;</span>&gt;</span>第二组<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的文本。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230521194453684.png" alt="image-20230521194453684"></p></blockquote></li></ol><p>下面是一个示例，展示了如何使用<code>&lt;span&gt;</code>标签为文本添加样式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">htmlCopy code<br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段包含<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: red;&quot;</span>&gt;</span>红色文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>和<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-weight: bold;&quot;</span>&gt;</span>粗体文本<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>的示例。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，<code>&lt;span&gt;</code>标签用于分别标记红色文本和粗体文本，并通过内联样式来指定它们的样式属性。</p><p>总结而言，<code>&lt;span&gt;</code>标签是一个非常通用的标签，用于对文本进行包装和样式控制。它在HTML文档中提供了灵活的文本处理能力，可用于各种定制和设计需求。</p><h4 id="table标签"><a href="#table标签" class="headerlink" title="table标签*"></a>table标签*</h4><p><code>&lt;table&gt;</code>标签是HTML中用于创建表格的元素。下面是<code>&lt;table&gt;</code>标签的一些特点：</p><ol><li><p>表格结构：<code>&lt;table&gt;</code>标签用于创建表格结构，它可以包含一个或多个行（<code>&lt;tr&gt;</code>标签），每行可以包含一个或多个单元格（<code>&lt;td&gt;</code>标签或<code>&lt;th&gt;</code>标签）。通过使用<code>&lt;table&gt;</code>标签及其相关标签，可以实现复杂的表格布局。</p><blockquote><p>可以将table分为三个部分，第一个部分是表头thead，另一个部分是表体tbody.最后一个是这个表的名称caption<br>在thead中，行修饰标tr是不变的，但是在内部我们要编写行的标题，也就是首行。内部标签变为th</p><p>在tbody中，行修饰标tr是不变的，内部标签变为td</p><p>在table中可以加入caption作为表的标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用css样式设置边框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">        <span class="hljs-selector-class">.table_1</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 边框合并 - 相邻有相同的元素就会合并在一起 */</span></span><br><span class="language-css">            <span class="hljs-attribute">border-collapse</span>: collapse;</span><br><span class="language-css">        &#125;</span><br><span class="language-css"></span><br><span class="language-css">        <span class="hljs-comment">/* 可以用table父类引用子类别 */</span></span><br><span class="language-css">        <span class="hljs-selector-class">.table_1</span> <span class="hljs-selector-tag">th</span>,</span><br><span class="language-css">        <span class="hljs-selector-class">.table_1</span> <span class="hljs-selector-tag">td</span> &#123;</span><br><span class="language-css">            <span class="hljs-comment">/* 设置边框样式 */</span></span><br><span class="language-css">            <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black</span><br><span class="language-css">        &#125;</span><br><span class="language-css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>表修饰1<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;table_1&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 表标题 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">caption</span>&gt;</span>学生成绩表<span class="hljs-tag">&lt;/<span class="hljs-name">caption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-comment">&lt;!-- 首列标题 --&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>数学<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>语文<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>英语<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 第一行 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>90<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>85<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>92<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 第二行 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>88<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>92<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>87<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/30/Web/image-20230522140911732.png" alt="image-20230522140911732"></p></blockquote></li><li><p>行和列：表格由行和列组成。每个行使用<code>&lt;tr&gt;</code>标签表示，而每个单元格使用<code>&lt;td&gt;</code>标签表示。在表头部分，可以使用<code>&lt;th&gt;</code>标签表示表头单元格，用于标识列的标题或表格的相关信息。</p></li><li><p>单元格合并：通过使用<code>colspan</code>和<code>rowspan</code>属性，可以将单元格进行合并，从而跨越多个行或多个列。这使得可以创建具有复杂布局的表格。</p></li><li><p>表格标题和描述：可以使用<code>&lt;caption&gt;</code>标签为表格添加标题，用于描述表格的内容或目的。同时，可以使用<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>标签对表格内容进行分组，以提高可读性和语义性。</p></li><li><p>表格样式和格式：通过CSS可以对表格进行样式和格式化，如设置边框、背景色、字体样式等。使用CSS，还可以实现表格的响应式布局，以适应不同的屏幕尺寸和设备。</p></li><li><p>无障碍性支持：表格元素提供了一些属性和技术，以支持无障碍访问。例如，可以使用<code>scope</code>属性来指定表格单元格的作用范围，或者使用<code>headers</code>属性来建立单元格与表头之间的关联。</p></li></ol><p>需要注意的是，使用表格时应谨慎考虑其语义和结构，以确保表格的正确使用和可访问性。对于非表格数据或纯粹的布局需求，应该使用CSS布局技术而不是滥用表格元素。</p><p>总结而言，<code>&lt;table&gt;</code>标签是用于创建表格的HTML元素，它提供了创建、布局和样式化表格的功能。表格可以具有复杂的结构和样式，适用于展示和组织数据。</p><h4 id="from标签"><a href="#from标签" class="headerlink" title="from标签"></a>from标签</h4><p>表单（form）标签是HTML中用于创建用户交互表单的元素。下面是表单标签的一些特点：</p><ol><li>用户输入收集：表单标签用于创建包含用户输入字段的交互式表单，如文本输入框、复选框、单选按钮、下拉列表等。用户可以在表单中填写信息或选择选项。</li><li>数据提交：通过表单，用户可以将填写的数据提交到服务器或指定的处理程序进行处理。表单可以使用<code>&lt;form&gt;</code>标签指定提交方法（GET或POST）和目标URL。</li><li>表单字段：表单标签提供了一系列用于收集用户数据的字段标签，如<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等。这些标签可以设置不同类型的输入控件，以满足不同的数据输入需求。</li><li>表单控件组织：表单标签可以包含多个表单字段，通过在<code>&lt;form&gt;</code>标签内嵌套其他表单字段标签，可以组织和布局表单内容。</li><li>提交按钮：通过添加<code>&lt;input type=&quot;submit&quot;&gt;</code>或<code>&lt;button type=&quot;submit&quot;&gt;</code>标签，可以在表单中添加提交按钮，以便用户点击提交表单数据。</li><li>表单验证：HTML5提供了表单验证功能，可以通过设置表单字段的属性来进行客户端验证，如必填字段、最小长度、数据类型等。还可以使用JavaScript进行自定义的表单验证。</li><li>表单样式和布局：通过使用CSS，可以对表单进行样式化和布局控制，如设置字段的尺寸、背景色、边框样式等。使用CSS框架和技术，可以实现响应式表单布局。</li><li>安全性考虑：在处理敏感信息的表单时，应考虑使用安全传输协议（如HTTPS）以保护数据的安全性。</li></ol><p>需要注意的是，表单只是提供了前端的数据收集和提交机制，实际的数据处理和验证通常需要与后端服务器端编程语言（如PHP、Java、Python等）结合使用。</p><p>总结而言，表单标签用于创建用户交互表单，收集用户数据并提交到服务器进行处理。它提供了丰富的表单字段选项和验证功能，可通过CSS进行样式和布局控制。使用表单可以实现各种用户输入场景，如注册表单、登录表单、调查问卷等。</p><h3 id="小标签"><a href="#小标签" class="headerlink" title="小标签"></a>小标签</h3><h4 id="br标签"><a href="#br标签" class="headerlink" title="br标签"></a>br标签</h4><p><code>&lt;br&gt;</code>标签是HTML中用于创建换行的元素，它具有以下特点：</p><ol><li>换行功能：<code>&lt;br&gt;</code>标签用于在文本或行内内容中创建一个显式的换行。当浏览器遇到<code>&lt;br&gt;</code>标签时，会将文本或行内内容的换行位置断开，并在该位置插入一个换行符。</li><li>单标签：<code>&lt;br&gt;</code>标签是一个单标签，不需要闭合标签。它没有内容，只是一个用于表示换行的标记。</li><li>内联元素：<code>&lt;br&gt;</code>标签是内联元素（inline element），在默认情况下不会产生块级元素的换行效果。它可以在行内元素或块级元素内使用，用于插入换行符而不会创建新的块。</li><li>可嵌套性：<code>&lt;br&gt;</code>标签通常不会嵌套在其他标签内部，它在文本内容中直接使用，用于插入换行。</li><li>语义简单：<code>&lt;br&gt;</code>标签的语义非常简单明确，只表示一个显式的换行符，不会添加其他语义含义。</li></ol><p>需要注意的是，HTML中的换行通常由浏览器根据文本和元素的自然流进行处理。通常情况下，使用合适的HTML和CSS来实现布局和分隔效果，而不是过度依赖<code>&lt;br&gt;</code>标签进行换行。</p><p>使用<code>&lt;br&gt;</code>标签时应注意适度使用，避免滥用，以保持代码的可读性和语义化。在大多数情况下，最好使用合适的HTML元素和CSS样式来实现更灵活和语义化的布局效果。</p><h4 id="hr标签"><a href="#hr标签" class="headerlink" title="hr标签"></a>hr标签</h4><p><code>&lt;hr&gt;</code>标签是HTML中用于创建水平分隔线的元素，它具有以下特点：</p><ol><li>分隔线功能：<code>&lt;hr&gt;</code>标签用于在文档中创建一条水平的分隔线，可以用于将内容分隔为不同的段落或节。</li><li>单标签：<code>&lt;hr&gt;</code>标签是一个单标签，不需要闭合标签。它表示一个完整的水平分隔线，不包含任何内容。</li><li>默认样式：<code>&lt;hr&gt;</code>标签具有默认的样式属性，通常表现为一条水平线，具体的样式可以通过CSS进行自定义。</li><li>块级元素：<code>&lt;hr&gt;</code>标签在默认情况下是一个块级元素，会独占一行。它会创建一个与其他块级元素（如段落、标题等）相邻的分隔线。</li><li>可调整性：<code>&lt;hr&gt;</code>标签可以通过CSS进行样式调整，如设置颜色、宽度、边距等。通过调整样式属性，可以改变分隔线的外观和布局。</li><li>语义简单：<code>&lt;hr&gt;</code>标签的语义非常简单明确，只表示一个水平分隔线，不会添加其他语义含义。</li></ol><p>需要注意的是，<code>&lt;hr&gt;</code>标签在现代Web开发中的使用逐渐减少，因为分隔线的样式和布局通常可以通过CSS来实现，从而提供更大的灵活性和控制。因此，在实际应用中，最好使用合适的HTML元素和CSS样式来实现分隔线的效果，而不是依赖于<code>&lt;hr&gt;</code>标签。</p><p>使用<code>&lt;hr&gt;</code>标签时应注意适度使用，避免滥用，以保持代码的可读性和语义化。在大多数情况下，最好使用CSS样式来创建定制化的分隔线，以满足具体的设计和布局需求。</p><h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><p>CSS（层叠样式表，Cascading Style Sheets）是一种用于描述网页（HTML 或 XML 等文档）外观和样式的标记语言。它与 HTML 一起使用，通过为 HTML 元素应用样式规则，控制网页的布局、字体、颜色、大小和其他视觉方面的属性。</p><p>CSS 提供了一种将样式与内容分离的方法，使得开发人员可以单独管理网页的样式而无需修改 HTML 结构。通过使用 CSS，可以在不改变网页内容的情况下改变其外观和布局，从而实现更好的灵活性和可维护性。</p><p>CSS 使用选择器来选择要应用样式的 HTML 元素，然后使用属性和值来定义元素的样式。可以通过内联样式表、嵌入式样式表或外部样式表的方式将 CSS 应用到 HTML 文档中。</p><p>CSS 是 Web 开发中的重要技术之一，它使得网页设计变得更加灵活和美观，并提供了更好的用户体验。</p><blockquote><p>可以创建一个新的css样式文件，并将css和html链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;链接文件&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure></blockquote><p>相应的，我们要记住css常见的功能</p><blockquote><p>CSS具有许多功能和特性，用于控制和样式化网页的外观和布局。以下是CSS中常用的一些功能：</p><ol><li>选择器：CSS选择器用于选择要应用样式的HTML元素。常见的选择器包括类选择器（.class）、ID选择器（#id）、元素选择器（element）等，还有更高级的选择器如属性选择器、伪类选择器和伪元素选择器等。</li><li>盒子模型：CSS盒子模型描述了HTML元素的布局结构，包括内容区域、内边距、边框和外边距。通过控制盒子模型的属性（如width、height、padding、border、margin），可以实现元素的尺寸和间距的调整。</li><li>字体和文本样式：CSS提供了丰富的字体和文本样式属性，包括字体族（font-family）、字体大小（font-size）、字体粗细（font-weight）、行高（line-height）、文字颜色（color）等，可以用于设置元素的文本样式。</li><li>背景和边框：CSS提供了一系列的背景属性（如background-color、background-image、background-size）和边框属性（如border-color、border-style、border-width），用于设置元素的背景和边框样式。</li><li>定位和布局：CSS提供了多种定位和布局属性，如position（用于设置元素的定位方式）、display（用于设置元素的显示方式）、float（用于实现元素的浮动布局）、flexbox（用于弹性盒子布局）和grid（用于网格布局）等，可以实现灵活的页面布局。</li><li>动画和过渡：CSS动画和过渡属性（如animation、transition）允许在元素上创建平滑的过渡效果和动画效果，使页面更具交互性和生动性。</li><li>响应式设计：通过使用CSS媒体查询和响应式布局技术，可以根据设备的不同屏幕尺寸和特性，自适应地调整网页的布局和样式，以提供更好的用户体验。</li></ol><p>这只是CSS的一小部分功能，还有许多其他功能和属性可用于创建丰富的网页样式和布局。CSS的灵活性使得开发人员能够自定义和控制网页的外观和行为。</p></blockquote><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>CSS选择器用于选择网页中的特定元素，从而将样式应用于这些元素。它们允许您根据元素的标签名、类名、ID、属性等特征来选择元素。</p><p>使用CSS选择器，您可以针对不同的元素应用不同的样式，或者根据需要对一组元素进行样式化。通过选择器，您可以精确地控制网页中的元素，并根据需要调整其外观和布局。</p><blockquote><p>在选择器中，有一些常见的属性是我们要记住的。</p><ol><li><code>color</code>：用于设置文本颜色，可以使用颜色名称、十六进制值或RGB值。</li><li><code>background-color</code>：用于设置元素的背景颜色，同样可以使用颜色名称、十六进制值或RGB值。</li><li><code>font-size</code>：用于设置字体大小，可以使用像素、百分比、em等单位。</li><li><code>font-family</code>：用于设置字体家族，可以指定多个字体备选项。</li><li><code>font-weight</code>：用于设置字体粗细，可以使用关键词如<code>normal</code>、<code>bold</code>，或使用数值如<code>400</code>、<code>700</code>。</li><li><code>text-align</code>：用于设置文本对齐方式，可以是<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code>等。</li><li><code>width</code>、<code>height</code>：用于设置元素的宽度和高度，可以使用像素、百分比、em等单位。</li><li><code>margin</code>、<code>padding</code>：用于设置元素的外边距和内边距，可以使用像素、百分比、em等单位。</li><li><code>border</code>：用于设置元素的边框样式，可以指定边框宽度、边框颜色和边框样式。</li><li><code>display</code>：用于设置元素的显示方式，如<code>block</code>、<code>inline</code>、<code>inline-block</code>等。</li></ol></blockquote><p>class选择器</p><p>类选择器是CSS中一种常用的选择器，用于选择具有相同类名的元素并应用相应的样式。以下是类选择器的一些特点：</p><ol><li><p>选择多个元素：类选择器可以选择HTML文档中具有相同类名的多个元素，并为它们应用相同的样式。</p></li><li><p>重复使用：可以在同一个HTML文档中多次使用相同的类名，从而在不同位置和元素上应用相同的样式。</p></li><li><p>独立于元素类型：类选择器与元素类型无关，可以应用于任意HTML元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code> 等等。</p></li><li><p>可组合：可以将类选择器与其他选择器组合使用，以更精确地选择和样式化元素。例如，结合标签选择器和类选择器可以选择特定类型的元素中具有特定类名的元素。</p></li><li><p>优先级较低：类选择器的优先级相对较低，如果与其他选择器具有相同的特定性（specificity），其他选择器的样式可能会覆盖类选择器的样式。</p></li><li><p>可重复使用性和可维护性：通过使用类选择器，可以在多个元素上应用相同的样式，并且可以在整个网站上重复使用相同的类名，从而实现样式的重用和维护性。</p><blockquote><p> 类选择器的使用十分简单，在标签内部加入类名称，就可以对这个标签进行操作了。如果想要使用css，就在style样式中，用**.**操作符操作对应标签的类名就行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css_1.css&quot;</span>&gt;</span><br><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是另一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置了类选择器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;heading&quot;</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;paragraph&quot;</span>&gt;</span>This is a paragraph.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 标签样式 */</span><br><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">color</span>: blue;<br>    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;<br>    <span class="hljs-attribute">font-family</span>: Arial, sans-serif;<br>&#125;<br><br><span class="hljs-selector-class">.container</span> &#123;<br>    <span class="hljs-comment">/* 容器的样式 */</span><br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br><br><span class="hljs-selector-class">.heading</span> &#123;<br>    <span class="hljs-comment">/* 标题的样式 */</span><br>    <span class="hljs-attribute">color</span>: aqua;<br>&#125;<br><br><span class="hljs-selector-class">.paragraph</span> &#123;<br>    <span class="hljs-comment">/* 段落的样式 */</span><br>    <span class="hljs-attribute">color</span>: wheat;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ol><p>id选择器</p><p>ID选择器在Web开发中具有以下特点：</p><ol><li><p>唯一性：每个HTML文档中的ID应该是唯一的。一个元素只能有一个ID，不能重复使用。这使得ID选择器非常适合选择具有特定标识符的单个元素。</p><blockquote><p>如果在HTML文档中违反了ID选择器的唯一性原则，即多个元素具有相同的ID，可能会导致以下问题：</p><ol><li>不可预测的行为：当多个元素具有相同的ID时，根据HTML规范，浏览器只会选择第一个具有该ID的元素作为目标元素。其他具有相同ID的元素将被忽略。这可能导致无法预测的行为，例如样式应用于错误的元素或JavaScript操作作用于错误的元素。</li><li>样式冲突：如果多个元素具有相同的ID并且应用了不同的样式规则，那么由于ID选择器的高优先级，只有第一个具有该ID的元素将应用正确的样式规则。其他具有相同ID的元素将无法正确显示所期望的样式。</li><li>JavaScript操作错误：如果在JavaScript中使用了重复的ID，并且依赖于通过ID选择器获取元素或处理元素的特定行为，将会出现问题。JavaScript操作可能应用于错误的元素或无法正常工作。</li></ol><p>总之，违反ID选择器的唯一性原则会引发不可预测的行为、样式冲突和JavaScript操作错误。为了避免这些问题，应确保在HTML文档中每个ID都是唯一的，并合理使用其他选择器来选择多个元素。</p></blockquote></li><li><p>高优先级：ID选择器的优先级非常高，比其他选择器（如类选择器、元素选择器）更具特权。当使用ID选择器选择一个元素时，它的权重比其他选择器更高，这意味着它的样式规则将覆盖其他选择器的样式规则。</p></li><li><p>快速查找：由于ID在文档中应该是唯一的，浏览器可以通过ID快速准确定位到对应的元素。因此，使用ID选择器可以提高选择元素的效率和性能。</p></li><li><p>用途广泛：ID选择器常用于为特定的元素应用唯一的样式规则或添加特定的JavaScript交互行为。通过给元素添加ID，可以方便地针对该元素进行样式设置或JavaScript操作。</p></li><li><p>不易复用：由于ID选择器的唯一性，通常不建议将ID选择器用于多个元素。如果多个元素具有相同的样式或行为，应该使用类选择器或其他更适合的选择器。</p></li></ol><p>需要注意的是，在编写CSS样式时，应合理使用ID选择器，并避免过度依赖ID选择器的高优先级。合理选择合适的选择器可以使代码更具灵活性、可维护性和可复用性。</p><blockquote><p>使用方法和类选择器是一样的（基本上所有的都是一样的），只是在css中，不再使用.而是改为#</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;hlf&quot;</span>&gt;</span>djaslkhflkas<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#hlf</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>CSS中有多个用于设置元素背景的属性，包括以下常用属性：</p><ol><li><p>background-color：设置元素的背景颜色。可以使用颜色名称、十六进制值、RGB值或RGBA值来指定颜色。例如：<code>background-color: blue;</code></p><blockquote><p><img src="/2023/04/30/Web/image-20230523121833418.png" alt="image-20230523121833418"></p></blockquote></li><li><p>background-image：设置元素的背景图像。可以指定图像的URL路径或使用<code>url()</code>函数。例如：<code>background-image: url(&#39;image.jpg&#39;);</code></p></li><li><p>background-repeat：指定背景图像的重复方式。常见的取值有：<code>repeat</code>（默认，图像在水平和垂直方向上平铺）、<code>repeat-x</code>（只在水平方向上平铺）、<code>repeat-y</code>（只在垂直方向上平铺）、<code>no-repeat</code>（不重复）等。</p></li><li><p>background-position：指定背景图像的位置。可以使用关键字（如<code>left</code>、<code>center</code>、<code>right</code>、<code>top</code>、<code>bottom</code>）或百分比值、像素值来定位。例如：<code>background-position: center top;</code></p></li><li><p>background-size：设置背景图像的大小。可以使用关键字（如<code>auto</code>、<code>cover</code>、<code>contain</code>）或像素值、百分比值来指定大小。例如：<code>background-size: cover;</code></p></li><li><p>background-attachment：指定背景图像的滚动行为。常见的取值有：<code>scroll</code>（默认，背景图像会随着元素内容的滚动而滚动）、<code>fixed</code>（背景图像固定在视口中，不随滚动而移动）等。</p></li><li><p>background-origin：指定背景图像的定位起点。常见的取值有：<code>padding-box</code>（背景图像相对于内边距框定位）、<code>border-box</code>（背景图像相对于边框框定位）、<code>content-box</code>（背景图像相对于内容框定位）等。</p></li><li><p>background-clip：指定背景图像的裁剪区域。常见的取值有：<code>border-box</code>（默认，背景图像延伸到边框外沿）、<code>padding-box</code>（背景图像延伸到内边距外沿）、<code>content-box</code>（背景图像裁剪为内容框内部）等。</p></li></ol><p>这些属性可以单独使用或组合使用，通过设置不同的值来创建各种背景效果。</p><h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>在CSS中，可以使用边框属性来定义元素的边框样式、宽度和颜色。以下是常用的边框属性：</p><ol><li>border-width：设置边框的宽度。可以使用像素值、百分比值或预定义的关键字（如<code>thin</code>、<code>medium</code>、<code>thick</code>）来指定。例如：<code>border-width: 2px;</code></li><li>border-style：设置边框的样式。常见的取值有：<code>none</code>（无边框）、<code>solid</code>（实线边框）、<code>dotted</code>（点状边框）、<code>dashed</code>（虚线边框）等。例如：<code>border-style: solid;</code></li><li>border-color：设置边框的颜色。可以使用颜色名称、十六进制值、RGB值或RGBA值来指定颜色。例如：<code>border-color: red;</code></li><li>border：可以同时设置边框的宽度、样式和颜色。属性值的顺序可以是宽度、样式和颜色，也可以是样式、宽度和颜色。例如：<code>border: 2px solid red;</code></li><li>border-radius：设置边框的圆角半径，使边框呈现圆角效果。可以指定一个值来应用相同的圆角半径，或使用四个值分别指定每个角的圆角半径。例如：<code>border-radius: 5px;</code> 或 <code>border-radius: 5px 10px 15px 20px;</code></li></ol><p>这些边框属性可以在单独的样式规则中使用，也可以组合在一起来创建自定义的边框样式。同时，还可以使用<code>border-top</code>、<code>border-right</code>、<code>border-bottom</code>和<code>border-left</code>属性分别设置上、右、下和左边框的样式、宽度和颜色。</p><h3 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h3><p>在CSS中，盒子（Box）是用于布局和定位元素的基本单位。每个元素都被看作一个矩形盒子，具有四个边框、内边距和内容区域。以下是与CSS盒子相关的常见属性：</p><ol><li>width：设置盒子的宽度。可以使用像素值、百分比值或其他长度单位来指定。例如：<code>width: 200px;</code></li><li>height：设置盒子的高度。与<code>width</code>属性类似，可以使用不同的单位来指定高度。</li><li>padding：设置盒子的内边距。内边距是指元素内容与边框之间的空间。可以使用像素值或百分比值来指定内边距。例如：<code>padding: 10px;</code> 或 <code>padding: 10px 20px;</code>（分别表示上下内边距为10像素，左右内边距为20像素）。</li><li>border：设置盒子的边框样式、宽度和颜色。可以使用<code>border-width</code>、<code>border-style</code>和<code>border-color</code>属性分别指定边框的宽度、样式和颜色。例如：<code>border: 1px solid black;</code></li><li>margin：设置盒子的外边距。外边距是指元素与相邻元素之间的间隔。可以使用像素值或百分比值来指定外边距。例如：<code>margin: 10px;</code> 或 <code>margin: 10px 20px;</code>（分别表示上下外边距为10像素，左右外边距为20像素）。</li><li>box-sizing：定义元素的盒模型计算方式。常见的取值有：<code>content-box</code>（默认，宽度和高度只包括内容区域）、<code>border-box</code>（宽度和高度包括内容区域、内边距和边框）等。</li></ol><p>这些属性用于控制盒子的尺寸、内外边距和边框样式。通过合理地使用这些属性，可以实现灵活的布局和设计效果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2023/04/30/Linux/"/>
      <url>/2023/04/30/Linux/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础知识和起源"><a href="#基础知识和起源" class="headerlink" title="基础知识和起源"></a>基础知识和起源</h2><blockquote><p><a href="https://www.runoob.com/linux/linux-intro.html">https://www.runoob.com/linux/linux-intro.html</a></p></blockquote><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p><img src="/2023/04/30/Linux/%E5%8F%91%E8%A1%8C.jpg" alt="发行"></p><p><img src="/2023/04/30/Linux/linux%E5%92%8Cwindows%E5%8C%BA%E5%88%AB.png" alt="linux和windows区别"></p><blockquote><p>我们只要知道创始人很牛逼就行，然后知道Linux其实和window一样是一个操作系统。</p></blockquote><p>对于这个操作系统，并不是像我们常用的window系统一样是有图像图标的，对次系统的操作是通过命令行操作的</p><p><img src="/2023/04/30/Linux/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9B%BE%E7%89%87.png" alt="命令行演示"></p><p>当然，在对其操作之前，我们得把Linux启动,启动Linux分为5个阶段：</p><ul><li>内核的引导。</li><li>运行 init。</li><li>系统初始化。</li><li>建立终端 。</li><li>用户登录系统。</li></ul><h3 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a><strong>内核引导</strong></h3><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p><blockquote><p>BIOS，可以理解为自检，控制我们主板其他硬件的各种参数，比如可以调整CPU频率，修改内存时序。就是控制硬件的一个简单程序吧</p></blockquote><p>操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p><p><img src="/2023/04/30/Linux/%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC.png" alt="内核引导"></p><h3 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a><strong>运行init</strong></h3><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p><blockquote><p>我们在算法中，init函数通常被声明为初始化函数，用在这里也可以这样理解。理解为初始化系统的一个程序吧。</p></blockquote><p>init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p><p><img src="/2023/04/30/Linux/init%E8%BF%9B%E7%A8%8B.png" alt="init()"></p><p>运行级别</p><p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p><p>init进程的一大任务，就是去运行这些开机启动的程序。</p><p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p><p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p><p><img src="/2023/04/30/Linux/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB.png" alt="运行级别"></p><blockquote><p>可以理解为，为了适应不同的功能，才出对应的级别。让程序运行有针对性。</p></blockquote><p>Linux系统有7个运行级别(runlevel)：</p><ul><li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li><li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li><li>运行级别2：多用户状态(没有NFS)</li><li>运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式</li><li>运行级别4：系统未使用，保留</li><li>运行级别5：X11控制台，登录后进入图形GUI模式</li><li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li></ul><h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化*"></a><strong>系统初始化</strong>*</h3><blockquote><p>这里我就看不懂了，涉及到shell。&#x2F;etc&#x2F;init.d&#x2F;是一个目录，里面存放着很多系统服务的启动和停止脚本。它可以控制各种系统服务的运行状态，比如网络、防火墙、数据库等。您可以使用 &#x2F;etc&#x2F;init.d&#x2F;目录下的脚本来启动、停止或重启某个服务，比如 &#x2F;etc&#x2F;init.d&#x2F;network restart 就是重启网络服务。</p></blockquote><p>在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p><p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">l5:5:wait:/etc/rc.d/rc 5<br></code></pre></td></tr></table></figure><p>这一行表示以5为参数运行&#x2F;etc&#x2F;rc.d&#x2F;rc，&#x2F;etc&#x2F;rc.d&#x2F;rc是一个Shell脚本，它接受5作为参数，去执行&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录下的所有的rc启动脚本，&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下。</p><p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p><p>&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</p><p>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以&#x2F;var&#x2F;lock&#x2F;subsys&#x2F;下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</p><p>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p><p>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。</p><p><img src="/2023/04/30/Linux/etc-init.png" alt="etc"></p><blockquote><p>理解为系统的关键部分吧</p></blockquote><h3 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h3><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p><p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">1:2345:respawn:/sbin/mingetty tty1<br>2:2345:respawn:/sbin/mingetty tty2<br>3:2345:respawn:/sbin/mingetty tty3<br>4:2345:respawn:/sbin/mingetty tty4<br>5:2345:respawn:/sbin/mingetty tty5<br>6:2345:respawn:/sbin/mingetty tty6<br></code></pre></td></tr></table></figure><p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p><p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p><h3 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统*"></a>用户登录系统*</h3><p>一般来说，用户的登录方式有三种：</p><ul><li>（1）命令行登录</li><li>（2）ssh登录</li><li>（3）图形界面登录</li></ul><p><img src="/2023/04/30/Linux/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.png" alt="img"></p><p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p><p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p><p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p><p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 &#x2F;etc&#x2F;nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p><p>这通常用来系统维护时防止非root用户登录。只有&#x2F;etc&#x2F;securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p><p>&#x2F;etc&#x2F;usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p><h3 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式*"></a>图形模式与文字模式的切换方式*</h3><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p><p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p><p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p><p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p><p>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1<del>F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1</del>F6 切换至命令窗口。</p><p><img src="/2023/04/30/Linux/%E5%88%87%E6%8D%A2.png" alt="切换"></p><h3 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机*"></a>Linux 关机*</h3><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p><p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p><p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p><p>例如你可以运行如下命令关机：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">sync 将数据由内存同步到硬盘中。<br><br>shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：<br><br>shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。<br><br>shutdown –h now 立马关机<br><br>shutdown –h 20:25 系统会在今天20:25关机<br><br>shutdown –h +10 十分钟后关机<br><br>shutdown –r now 系统立马重启<br><br>shutdown –r +10 系统十分钟后重启<br><br>reboot 就是重启，等同于 shutdown –r now<br><br>halt 关闭系统，等同于shutdown –h now 和 poweroff<br></code></pre></td></tr></table></figure><p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p><p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p><h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><h3 id="基本文件介绍"><a href="#基本文件介绍" class="headerlink" title="基本文件介绍"></a>基本文件介绍</h3><p>登录系统后，在当前命令窗口下输入命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls / <br></code></pre></td></tr></table></figure><p>你会看到如下图所示:</p><p><img src="/2023/04/30/Linux/ls%E5%8A%9F%E8%83%BD.png" alt="ls功能"></p><p>树状目录结构：</p><p><img src="/2023/04/30/Linux/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="树状目录"></p><p>以下是对这些目录的解释：</p><ul><li><p><strong>&#x2F;bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p></li><li><p><strong>&#x2F;boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p><strong>&#x2F;dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p></li><li><p><strong>&#x2F;etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p></li><li><p><strong>&#x2F;home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p></li><li><p><strong>&#x2F;lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p><strong>&#x2F;lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p><strong>&#x2F;media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p></li><li><p><strong>&#x2F;mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p></li><li><p><strong>&#x2F;opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p></li><li><p><strong>&#x2F;proc</strong>：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all<br></code></pre></td></tr></table></figure></li><li><p><strong>&#x2F;root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p><strong>&#x2F;sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p><strong>&#x2F;selinux</strong>：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p></li><li><p><strong>&#x2F;srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p></li><li><p><strong>&#x2F;sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p><p>该文件系统是内核设备树的一个直观反映。</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p></li><li><p><strong>&#x2F;tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p></li><li><p><strong>&#x2F;usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p></li><li><p><strong>&#x2F;usr&#x2F;bin：</strong><br>系统用户使用的应用程序。</p></li><li><p><strong>&#x2F;usr&#x2F;sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p></li><li><p><strong>&#x2F;usr&#x2F;src：</strong><br>内核源代码默认的放置目录。</p></li><li><p><strong>&#x2F;var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p><strong>&#x2F;run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p></li></ul><p><strong>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</strong></p><p><strong>&#x2F;etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p><p><strong>&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin</strong>: 这是系统预设的执行文件的放置目录，比如 <strong>ls</strong> 就是在 <strong>&#x2F;bin&#x2F;ls</strong> 目录下的。</p><p>值得提出的是 <strong>&#x2F;bin</strong>、**&#x2F;usr&#x2F;bin** 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。</p><p><strong>&#x2F;var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。</p><h3 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性*"></a>文件基本属性*</h3><blockquote><p><a href="https://www.runoob.com/linux/linux-file-attr-permission.html">https://www.runoob.com/linux/linux-file-attr-permission.html</a></p></blockquote><h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 **&#x2F;**。</p><p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p><p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p><ul><li><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</li><li><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</li></ul><h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p><ul><li>ls（英文全拼：list files）: 列出目录及文件名</li><li>cd（英文全拼：change directory）：切换目录</li><li>pwd（英文全拼：print work directory）：显示目前的目录</li><li>mkdir（英文全拼：make directory）：创建一个新的目录</li><li>rmdir（英文全拼：remove directory）：删除一个空的目录</li><li>cp（英文全拼：copy file）: 复制文件或目录</li><li>rm（英文全拼：remove）: 删除文件或目录</li><li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li></ul><p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p><p><strong>操作演示：</strong></p><p><img src="/2023/04/30/Linux/image-20230503104713448.png" alt="ls演示"></p><p><img src="/2023/04/30/Linux/image-20230503104745656.png" alt="切换目录"></p><p><img src="/2023/04/30/Linux/image-20230503104833277.png" alt="显示目录"></p><h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称<br>[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称<br>[root@www ~]# ls [--full-time] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# ls -al ~<br></code></pre></td></tr></table></figure><h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"> cd [相对路径或绝对路径]<br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用 <span class="hljs-built_in">mkdir</span> 命令创建 runoob 目录</span><br>[root@www ~]# mkdir runoob<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用绝对路径切换到 runoob 目录</span><br>[root@www ~]# cd /root/runoob/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">使用相对路径切换到 runoob 目录</span><br>[root@www ~]# cd ./runoob/<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示回到自己的家目录，亦即是 /root 这个目录</span><br>[root@www runoob]# cd ~<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span><br>[root@www ~]# cd ..<br></code></pre></td></tr></table></figure><p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p><h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# pwd [-P]<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li></ul><p>实例：单纯显示出目前的工作目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# pwd<br>/root   &lt;== 显示出目录啦～<br></code></pre></td></tr></table></figure><p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个链接档<br>[root@www mail]# pwd<br>/var/mail         &lt;==列出目前的工作目录<br>[root@www mail]# pwd -P<br>/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～<br>[root@www mail]# ls -ld /var/mail<br>lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail<br><span class="hljs-meta prompt_"># </span><span class="language-bash">看到这里应该知道为啥了吧？因为 /var/mail 是链接档，链接到 /var/spool/mail</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">所以，加上 <span class="hljs-built_in">pwd</span> -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！</span><br></code></pre></td></tr></table></figure><h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir [-mp] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul><p>实例：请到&#x2F;tmp底下尝试创建数个新目录看看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# cd /tmp<br>[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录<br>[root@www tmp]# mkdir test1/test2/test3/test4<br>mkdir: cannot create directory `test1/test2/test3/test4&#x27;: <br>No such file or directory       &lt;== 没办法直接创建此目录啊！<br>[root@www tmp]# mkdir -p test1/test2/test3/test4<br></code></pre></td></tr></table></figure><p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p><p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www tmp]# mkdir -m 711 test2<br>[root@www tmp]# ls -l<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1<br>drwx--x--x  2 root  root 4096 Jul 18 12:54 test2<br></code></pre></td></tr></table></figure><p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p><p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p><h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmdir [-p] 目录名称<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-p ：</strong>从该目录起，一次删除多级空目录</li></ul><p>删除 runoob 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www tmp]# rmdir runoob/<br></code></pre></td></tr></table></figure><p>将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www tmp]# ls -l   &lt;==看看有多少目录存在？<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test<br>drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1<br>drwx--x--x  2 root  root 4096 Jul 18 12:54 test2<br>[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题<br>[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！<br>rmdir: `test1&#x27;: Directory not empty<br>[root@www tmp]# rmdir -p test1/test2/test3/test4<br>[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！<br>drwx--x--x  2 root  root 4096 Jul 18 12:54 test2<br></code></pre></td></tr></table></figure><p>利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。</p><p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p><h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p><p>语法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)<br>[root@www ~]# cp [options] source1 source2 source3 .... directory<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li><strong>-l：</strong>进行硬式链接(hard link)的链接档创建，而非复制文件本身；</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-s：</strong>复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li><li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li></ul><p>用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# cp ~/.bashrc /tmp/bashrc<br>[root@www ~]# cp -i ~/.bashrc /tmp/bashrc<br>cp: overwrite `/tmp/bashrc&#x27;? n  &lt;==n不覆盖，y为覆盖<br></code></pre></td></tr></table></figure><h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm [-fir] 文件或目录<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li><li></li></ul><p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www tmp]# rm -i bashrc<br>rm: remove regular file `bashrc&#x27;? y<br></code></pre></td></tr></table></figure><p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p><h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# mv [-fiu] source destination<br>[root@www ~]# mv [options] source1 source2 source3 .... directory<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><p>复制一文件，创建一目录，将文件移动到目录中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# cd /tmp<br>[root@www tmp]# cp ~/.bashrc bashrc<br>[root@www tmp]# mkdir mvtest<br>[root@www tmp]# mv bashrc mvtest<br></code></pre></td></tr></table></figure><p>将某个文件移动到某个目录去，就是这样做！</p><p>将刚刚的目录名称更名为 mvtest2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www tmp]# mv mvtest mvtest2<br></code></pre></td></tr></table></figure><h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat [-AbEnTv]<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><p>检看 &#x2F;etc&#x2F;issue 这个文件的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# cat /etc/issue<br>CentOS release 6.4 (Final)<br>Kernel \r on an \m<br></code></pre></td></tr></table></figure><h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# tac /etc/issue<br><br>Kernel \r on an \m<br>CentOS release 6.4 (Final)<br></code></pre></td></tr></table></figure><h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nl [-bnw] 文件<br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul><p>实例一：用 nl 列出 &#x2F;etc&#x2F;issue 的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# nl /etc/issue<br>     1  CentOS release 6.4 (Final)<br>     2  Kernel \r on an \m<br></code></pre></td></tr></table></figure><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# more /etc/man_db.config <br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Generated automatically from man.conf.in by the</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">configure script.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># man.conf from man-1.6d</span></span><br>....(中间省略)....<br><span class="hljs-meta prompt_">--More--(28%</span><span class="language-bash">)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</span><br></code></pre></td></tr></table></figure><p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p><ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter     ：代表向下翻『一行』；</li><li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f      ：立刻显示出档名以及目前显示的行数；</li><li>q       ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# less /etc/man.config<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># Generated automatically from man.conf.in by the</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">configure script.</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash"><span class="hljs-comment"># man.conf from man-1.6d</span></span><br>....(中间省略)....<br>:   &lt;== 这里可以等待你输入命令！<br></code></pre></td></tr></table></figure><p>less运行时可以输入的命令有：</p><ul><li>空白键  ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>&#x2F;字串   ：向下搜寻『字串』的功能；</li><li>?字串   ：向上搜寻『字串』的功能；</li><li>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li><li>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li><li>q     ：离开 less 这个程序；</li></ul><h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p><p>语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">head [-n number] 文件 <br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# head /etc/man.config<br></code></pre></td></tr></table></figure><p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# head -n 20 /etc/man.config<br></code></pre></td></tr></table></figure><h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p><p>语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">tail [-n number] 文件 <br></code></pre></td></tr></table></figure><p>选项与参数：</p><ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">[root@www ~]<span class="hljs-meta"># tail /etc/man.config</span><br># 默认的情况中，显示最后的十行！若要显示最后的 <span class="hljs-number">20</span> 行，就得要这样：<br>[root@www ~]<span class="hljs-meta"># tail -n 20 /etc/man.config</span><br></code></pre></td></tr></table></figure><h2 id="调用代码演示"><a href="#调用代码演示" class="headerlink" title="调用代码演示"></a>调用代码演示</h2><p>常用命令介绍：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">(1) ctrl c: 取消命令，并且换行<br>(2) ctrl u: 清空本行命令<br>(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项<br>(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件<br>(5) pwd: 显示当前路径<br>(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录<br>(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt<br>(8) mkdir XXX: 创建目录XXX<br>(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹<br>(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令<br>(11) touch XXX: 创建一个文件<br>(12) cat XXX: 展示文件XXX中的内容<br>(13) 复制文本<br>    windows/Linux下：Ctrl + insert，Mac下：command + c<br>(14) 粘贴文本<br>    windows/Linux下：Shift + insert，Mac下：command + v<br></code></pre></td></tr></table></figure><p>作业：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：<br>(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c<br>(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak<br>(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt<br>(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下<br>(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除<br>(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除<br>(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作<br>(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，<br>    将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;<br>    将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;<br>    将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;<br>(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作<br>(9) 进入homework_9文件夹，将其中所有txt类型的文件删除<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>six</title>
      <link href="/2023/04/28/Six/"/>
      <url>/2023/04/28/Six/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>背包问题<br><span class="hljs-number">2.</span>线性dp<br><span class="hljs-number">3.</span>各种dp<br></code></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202209832.png" alt="image-20230319202209832"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319214127252.png" alt="image-20230319214127252"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-comment">//动态规划重点的是状态转移方程</span><br><span class="hljs-comment">//01背包，代表着物品只有两种可能性 - 放和不放</span><br> f[i][j] 中的前i件物品放入容量为j的背包中。我们很容易可以看出，第一个维度我们存储的是物品的不同种类，第二个维度存储的是我们的背包容量。<br> 更新容量我们就使用：<span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j-w[i]]+c[i],f[i<span class="hljs-number">-1</span>][j])<br><span class="hljs-comment">//两种情况，我们分别判断一下</span><br>     第一种：我们放入我们的i物品，那么f[i][j] = f[i<span class="hljs-number">-1</span>][j-w[i]]+c[i],就是这样子，我们从两个维度解释一下： 第一个维度f[i<span class="hljs-number">-1</span>]:很简单就是我们已经选择了i物品了，那么从全部物品中，就少了我们的i，因此就是i<span class="hljs-number">-1.</span> 第二个维度就是f[j-w[i]],就是我们既然选择了i，那么就把我们的背包中直接塞入我们的物品，这个物品就会占据位置嗯。<br>     第二种：不放我们的i物品，就是f[i][j] = f[i<span class="hljs-number">-1</span>][j],不放物品我们的j这容量肯定就不会变化，同时，我们不放这个物品的话，就只能从别的物品选择，那就是只剩下i<span class="hljs-number">-1</span>种物品了。<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202536339.png" alt="image-20230319202536339"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版思想研究</span><br><span class="hljs-comment">//用二维数组来理解</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i]) <span class="hljs-comment">//先决条件：这个位置放不了i这个物品了</span><br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j];<br>   <span class="hljs-keyword">else</span><br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i<span class="hljs-number">-1</span>][j-w[i]]+c[i]); <br> cout&lt;&lt;f[n][m];<br><span class="hljs-comment">//用滚动数组来理解</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>           <span class="hljs-keyword">if</span>(j&lt;w[i])<br>               f[j] = f[j]; <span class="hljs-comment">//容量没变化 - 就是没放入我们的i</span><br>     <span class="hljs-keyword">else</span><br>               f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]); <span class="hljs-comment">//c[i]存储的是我们装入这个物品带来的价值收入</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202555236.png" alt="image-20230319202555236"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用j逆序排序</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=<span class="hljs-number">1</span>;j--)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i])<br>                f[j] = f[j];<br>   <span class="hljs-keyword">else</span> f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319202608455.png" alt="image-20230319202608455"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>;<br><br><span class="hljs-type">int</span> N, V; <span class="hljs-comment">// N表示物品个数，V表示背包容量</span><br><span class="hljs-type">int</span> w[MAXN], v[MAXN]; <span class="hljs-comment">// w[i]表示第i个物品的重量，v[i]表示第i个物品的价值</span><br><span class="hljs-type">int</span> dp[MAXN]; <span class="hljs-comment">// dp[i]表示容量为i的背包所能装下的最大价值</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; N &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        cin &gt;&gt; w[i] &gt;&gt; v[i];<br>    &#125;<br><br>    <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(dp)); <span class="hljs-comment">// 初始化dp数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= w[i]; j--) &#123; <span class="hljs-comment">// 从后往前遍历，避免重复选择物品</span><br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - w[i]] + v[i]); <span class="hljs-comment">// 状态转移方程</span><br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; dp[V] &lt;&lt; endl; <span class="hljs-comment">// 输出结果</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320144822881.png" alt="image-20230320144822881"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320144830870.png" alt="image-20230320144830870"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320144922085.png" alt="image-20230320144922085"></p><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175854308.png" alt="image-20230320175854308"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175908237.png" alt="image-20230320175908237"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//完全背包问题  - 就是01背包的变形，物品可以无限次放入</span><br> f[i][j]依然和<span class="hljs-number">01</span>背包问题相同的，i表示的是我们物品的种类，j表示的是我们背包的容量。<br>    放入物品的时候，我们需要选择放入这个物品我们的价值是否会增加<br><span class="hljs-comment">//过程</span><br>     <span class="hljs-number">1.</span>背包容量放不下我们当前这个物品 条件就是j&lt;w[i] 所以说我们的容量还是不变<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j]; <span class="hljs-comment">//这也就解释了我们可以使用一维数组来维护我们的背包 - 这里的i-1表示的是前一个物品，就是我们不会改变当前的背包状态</span><br> <span class="hljs-number">2.</span>背包可以放入我们当前这个物品 条件也就是j&gt;=w[i]<br>        我们有两种选择 - 放入和不放入  <br>        <span class="hljs-comment">//放入的话就是</span><br>        f[i][j] = f[i][j-w[i]]+c[i] <span class="hljs-comment">//c[i]是我们的价值(这里的i的意思就是我们物品是无穷的，每一个i表示的意思就是取出当前i这个物品的其中一个)</span><br>        <span class="hljs-comment">//不放入就是</span><br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] <span class="hljs-comment">//j就不会变化</span><br>     <span class="hljs-number">3.</span>我们最终的转移方程就是 上面两个合并的结果<br>        f[i][j] = f[i<span class="hljs-number">-1</span>][j] (j&lt;w[i])<br>        f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-w[i]]+c[i])<br>        <span class="hljs-comment">//重点就是理解，变量其实是我们选不选择这个物品！！！！ </span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175946146.png" alt="image-20230320175946146"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320175955400.png" alt="image-20230320175955400"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180004395.png" alt="image-20230320180004395"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180015757.png" alt="image-20230320180015757"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180027068.png" alt="image-20230320180027068"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//遍历是怎么遍历的</span><br><span class="hljs-number">1.</span>我们每次遍历的是当前背包塞满了物品i最终的结果<br> 看上面的图都是这样子的。 <br><span class="hljs-comment">//代码</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i])<br>                f[i][j] = f[i<span class="hljs-number">-1</span>][j]<span class="hljs-comment">//原状</span><br>            <span class="hljs-keyword">else</span><br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j],f[i][j-w[i]]+c[i]);<span class="hljs-comment">//新状态</span><br>    &#125;<br> cout&lt;&lt;f[n][m];<br><span class="hljs-number">2.</span>为什么一维数组适合<br>    <span class="hljs-comment">//使用动态规划算法解决完全背包问题时，可以采用一维数组进行实现。这是因为完全背包问题具有“无后效性”和“最优子结构”这两个特点。</span><br>    <span class="hljs-comment">//无后效性指的是，当我们决定选择一个物品放入背包时，我们不需要再考虑该物品是否被选择过或未来是否还会选择该物品。也就是说，每个阶段的最优状态可以通过之前阶段的某个状态推导得到，而不受后续状态的影响。</span><br>    <span class="hljs-comment">//最优子结构指的是，每个阶段的最优状态可以由前一个阶段的最优状态推导得到，并且每个阶段的最优状态之间没有相互制约的关系，即它们是相互独立的。</span><br><br><span class="hljs-number">3.</span>一维数组实现 <span class="hljs-comment">// 不太理解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">if</span>(j&lt;w[i]) f[j] = f[j];<br>     <span class="hljs-keyword">else</span> f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-w[i]]+c[i]);<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180039797.png" alt="image-20230320180039797"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320180103129.png" alt="image-20230320180103129"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 完全背包问题的动态规划解法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">knapsack</span><span class="hljs-params">(<span class="hljs-type">int</span> W, vector&lt;<span class="hljs-type">int</span>&gt;&amp; wt, vector&lt;<span class="hljs-type">int</span>&gt;&amp; val)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = wt.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(W + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = wt[i<span class="hljs-number">-1</span>]; j &lt;= W; j++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - wt[i<span class="hljs-number">-1</span>]] + val[i<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[W];<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; wt = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br>    vector&lt;<span class="hljs-type">int</span>&gt; val = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;;<br>    <span class="hljs-type">int</span> W = <span class="hljs-number">8</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;最大价值为：&quot;</span> &lt;&lt; <span class="hljs-built_in">knapsack</span>(W, wt, val) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320182532855.png" alt="image-20230320182532855"></p><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145257361.png" alt="image-20230320145257361"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145415756.png" alt="image-20230320145415756"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//在01背包的基础上，让每一件物品都有他们的数量</span><br> <span class="hljs-number">1.</span><span class="hljs-comment">//v[i],w[i] 体积和价值</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-comment">//物品种类</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m; j&gt;=v[i];j--) <span class="hljs-comment">//背包容量</span><br>            f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-v[i]]+w[i]);<br>    <span class="hljs-number">2.</span><span class="hljs-comment">//v[i],w[i],s[i]; 体积 价值 数量</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = m;j&gt;=v[i];j--)<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++) <br>                    <span class="hljs-comment">//这里的k表示的是选择物品的数量 - s[i]表示的是当前位置的i物品的数量</span><br>                    f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> v[N],w[N],s[N]; <span class="hljs-comment">//体积 价值 数量</span><br><span class="hljs-type">int</span> f[N][N]; <span class="hljs-comment">//这个是我们的状态转移数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <br>    <span class="hljs-keyword">for</span>( <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; <span class="hljs-comment">//这里就是输入对应的价值，由i下标规定数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=m;j++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i]*k]+w[i]*k); <span class="hljs-comment">//这里i-1是把这个i物品选择了（选够了就剔除） - 只要找到一个符合的k就行（我们不管怎么实现的就行）</span><br>    cout&lt;&lt;f[n][m]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145513754.png" alt="image-20230320145513754"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145617888.png" alt="image-20230320145617888"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二进制的转化就是 - 我们不再是一个一个数了，我们现在是两个两个数的</span><br><span class="hljs-type">int</span> num = <span class="hljs-number">1</span>;<span class="hljs-comment">//拆分计数</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-comment">//v,w,s; 体积，价值，数量</span><br>    cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=s;j&lt;&lt;=<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//&lt;&lt;=是左移位赋值运算符，它将左操作数向左移动右操作数指定的位数，并将结果赋值给左操作数</span><br>        vv[num] = j*v; <span class="hljs-comment">//存体积</span><br>        ww[num++] = j*w; <span class="hljs-comment">//存价值</span><br>        s-=j;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(s)&#123;<br>        vv[num] = s*v;<br>        ww[num++] = s*w;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//01背包问题 - 基础</span><br> <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i&lt;num;i++)<br>        <span class="hljs-keyword">for</span>(j = m;j&gt;=vv[i];j--)<br>            f[j] = <span class="hljs-built_in">max</span>(f[j],f[j-vv[i]]+ww[i]);<br>cout&lt;&lt;f[m];<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">1005</span>; <span class="hljs-comment">// 物品的最大数量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXV = <span class="hljs-number">100005</span>; <span class="hljs-comment">// 背包的最大容量</span><br><span class="hljs-type">int</span> n, V; <span class="hljs-comment">// 物品的数量和背包的容量</span><br><span class="hljs-type">int</span> w[MAXN], v[MAXN], s[MAXN]; <span class="hljs-comment">// 分别表示物品的重量、价值和数量</span><br><span class="hljs-type">int</span> dp[MAXV]; <span class="hljs-comment">// dp[i]表示容量为i的情况下，可以获得的最大价值</span><br><br><span class="hljs-comment">// 二进制优化</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">binary_optimization</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = V; j &gt;= x; j--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= s[y] &amp;&amp; k * x &lt;= j; k++) &#123;<br>            dp[j] = <span class="hljs-built_in">max</span>(dp[j], dp[j - k * x] + k * y);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; V;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= s[i]; j *= <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">binary_optimization</span>(w[i] * j, v[i] * j); <span class="hljs-comment">// 调用二进制优化函数</span><br>            s[i] -= j;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">binary_optimization</span>(w[i] * s[i], v[i] * s[i]);<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; dp[V] &lt;&lt; endl; <span class="hljs-comment">// 输出答案</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二进制优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12010</span>, M = <span class="hljs-number">2010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt ++ ;<br>            <span class="hljs-comment">//这里是二进制优化的核心 - 就是将s拆成2进制</span><br>            <span class="hljs-comment">//核心是将物品拆分为2的幂次方个物品</span><br>            <span class="hljs-comment">//每次都拿s拆开二进制的数量</span><br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br><br>    n = cnt;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321174757054.png" alt="image-20230321174757054"></p><h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181451351.png" alt="image-20230321181451351"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181510913.png" alt="image-20230321181510913"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//朴素做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<span class="hljs-comment">//物品 - 组？ 我还是不理解</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=V;j++)<span class="hljs-comment">//体积</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i];k++) &#123; <span class="hljs-comment">//决策</span><br>            <span class="hljs-keyword">if</span>(j&gt;=v[i][k])<br>                f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i][k]]+w[i][k]);<br>                <span class="hljs-comment">//不选取i  选取i</span><br>        &#125;<br>cout&lt;&lt;f[n][V];<br><span class="hljs-comment">//为什么w[i][j] - 这里 i是组号 j是组内编号（组这个概念是啥）</span><br><span class="hljs-comment">//V这个是背包体积吗 - 啥意思</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181526186.png" alt="image-20230321181526186"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181540822.png" alt="image-20230321181540822"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//分组朴素做法</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=V;j++)<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>;k&lt;=s[i];k++)<br>  &#123;<br>   <span class="hljs-keyword">if</span>(j&gt;=v[i][k])<br>    f[i][j] = <span class="hljs-built_in">max</span>(f[i][j],f[i<span class="hljs-number">-1</span>][j-v[i][k]]+w[i][k]);<br>  &#125;<br>cout&lt;&lt;f[n][V];<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230321181555557.png" alt="image-20230321181555557"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12010</span>, M = <span class="hljs-number">2010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> v[N], w[N];<br><span class="hljs-type">int</span> f[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m;<br><br>    <span class="hljs-comment">//1.这段程序是将一个数量为n的物品分成若干组，每组物品有一个共同的体积上限，要求选出的物品不能超过各自的体积上限，且所有选出的物品的总体积不能超过背包容量。每组物品中的物品可以有不同的体积和价值。在这段程序中，将每个物品的数量s分成二进制，然后将每个物品拆分成若干个体积和价值相同的物品，这样就构造了一个二进制数组。最后将物品的数量n更新为拆分后的物品数量cnt。</span><br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> a, b, s;<br>        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;<br>        <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里是将s数量分二进制</span><br>        <span class="hljs-keyword">while</span> (k &lt;= s)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * k;<br>            w[cnt] = b * k;<br>            s -= k;<br>            k *= <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里就构造二进制数组</span><br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            cnt ++ ;<br>            v[cnt] = a * s;<br>            w[cnt] = b * s;<br>        &#125;<br>    &#125;<br><br>    n = cnt;<br><br>    <span class="hljs-comment">//2.这里就是选择最大</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = m; j &gt;= v[i]; j -- )<br>            f[j] = <span class="hljs-built_in">max</span>(f[j], f[j - v[i]] + w[i]);<br><br>    cout &lt;&lt; f[m] &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145732542.png" alt="image-20230320145732542"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145752872.png" alt="image-20230320145752872"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145806496.png" alt="image-20230320145806496"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//三个背包综合考虑</span><br></code></pre></td></tr></table></figure><h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a>线性dp</h2><h3 id="大盗阿福"><a href="#大盗阿福" class="headerlink" title="大盗阿福"></a>大盗阿福</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151317664.png" alt="image-20230320151317664"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151339739.png" alt="image-20230320151339739"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性dp</span><br> 在这个题目中，f数组存储的是我们偷取的物品价值是吧，然后我们要选择偷取价值最大化，每一个下标都代表着一个店铺是这个样子？<br><span class="hljs-comment">//写</span><br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br> <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<br>        <br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        f[<span class="hljs-number">1</span>] = w[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-comment">//用下标代表选择 - 是这个样子的</span><br>        <span class="hljs-comment">//用数组存储价值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            f[i] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-2</span>]+w[i]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,f[n]);<br>    &#125;<br> <br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151353844.png" alt="image-20230320151353844"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用二维数组构造</span><br> <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;t);<br> <span class="hljs-keyword">while</span>(t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;w[i]);<br>        <span class="hljs-comment">//用第二维的数据表示选择 0不选 1选择</span><br>        f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = w[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>            <span class="hljs-comment">//不选择i</span><br>            f[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>],f[i<span class="hljs-number">-1</span>][<span class="hljs-number">1</span>]);<br>            <span class="hljs-comment">//选择了i这个物品</span><br>            f[i][<span class="hljs-number">1</span>] = f[i<span class="hljs-number">-1</span>][<span class="hljs-number">0</span>]+w[i];<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,<span class="hljs-built_in">max</span>(f[n][<span class="hljs-number">0</span>],f[n][<span class="hljs-number">1</span>]));<br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151402877.png" alt="image-20230320151402877"></p><h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//数字三角形</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>,INF = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-type">int</span> g[N][N],f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;j++)<br>        cin&gt;&gt;g[i][j];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=i+<span class="hljs-number">1</span>;j++)<br>        f[i][j] = -INF;<span class="hljs-comment">//j从0开始是为了确定子树的选择</span><br>    <br>    f[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = g[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=i;j++)<br>        f[i][j] = g[i][j] + <span class="hljs-built_in">max</span>(f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>],f[i<span class="hljs-number">-1</span>][j]);<br>    <br>    <span class="hljs-type">int</span> res = -INF;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) res = <span class="hljs-built_in">max</span>(res,f[n][i]);<span class="hljs-comment">//第n行 选择i的结果</span><br>    cout&lt;&lt;res&lt;&lt;endl;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长上升子序列-or-二分优化"><a href="#最长上升子序列-or-二分优化" class="headerlink" title="最长上升子序列 or 二分优化"></a>最长上升子序列 or 二分优化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//最长上升子序列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], f[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>    &#123;<br>        f[i] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 只有a[i]一个数</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; i; j ++ )<br>        <span class="hljs-comment">//前小于后 严格单调</span><br>            <span class="hljs-keyword">if</span> (a[j] &lt; a[i])<br>                f[i] = <span class="hljs-built_in">max</span>(f[i], f[j] + <span class="hljs-number">1</span>);<span class="hljs-comment">//连续走 or 跳着走</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ ) res = <span class="hljs-built_in">max</span>(res, f[i]);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, res);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二分优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><br>    <span class="hljs-type">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>    &#123;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = len;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &lt; a[i]) l = mid;<br>            <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//二分找目标值 更新len</span><br>        len = <span class="hljs-built_in">max</span>(len, l + <span class="hljs-number">1</span>);<br>        q[r + <span class="hljs-number">1</span>] = a[i];<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, len);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="求公共子序列"><a href="#求公共子序列" class="headerlink" title="求公共子序列"></a>求公共子序列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> f[N][N];<span class="hljs-comment">//一维指的是a前n个数据 - 二位指的是b前n个数据？</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, a + <span class="hljs-number">1</span>, b + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            <span class="hljs-comment">//f[i-1][j] 表示删除a的第i个字符后与b的前j个字符的最长公共子序列长度；</span><br>     <span class="hljs-comment">//f[i][j-1] 表示删除b的第j个字符后与a的前i个字符的最长公共子序列长度；</span><br>            f[i][j] = <span class="hljs-built_in">max</span>(f[i - <span class="hljs-number">1</span>][j], f[i][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">max</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<span class="hljs-comment">//符合就选择两者变化的最大值</span><br>        &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326134216185.png" alt="image-20230326134216185"></p><h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230326135739598.png" alt="image-20230326135739598"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1010</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">char</span> a[N], b[N];<br><span class="hljs-type">int</span> f[N][N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">//初始化竖和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= m; i ++ ) f[<span class="hljs-number">0</span>][i] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n; i ++ ) f[i][<span class="hljs-number">0</span>] = i;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++ )<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; j ++ )<br>        &#123;<br>            f[i][j] = <span class="hljs-built_in">min</span>(f[i - <span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>, f[i][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]);<br>            <span class="hljs-keyword">else</span> f[i][j] = <span class="hljs-built_in">min</span>(f[i][j], f[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>        &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, f[n][m]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="区间dp"><a href="#区间dp" class="headerlink" title="区间dp"></a>区间dp</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151438854.png" alt="image-20230320151438854"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151457211.png" alt="image-20230320151457211"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151516636.png" alt="image-20230320151516636"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">/<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151549135.png" alt="image-20230320151549135"></p><h2 id="数位统计dp"><a href="#数位统计dp" class="headerlink" title="数位统计dp"></a>数位统计dp</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153227900.png" alt="image-20230320153227900"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153241076.png" alt="image-20230320153241076"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153256785.png" alt="image-20230320153256785"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153310081.png" alt="image-20230320153310081"></p><h2 id="状态dp"><a href="#状态dp" class="headerlink" title="状态dp"></a>状态dp</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//状态压缩</span><br> 通过将每一种状态映射成一个整数 - 二进制数据。这样每一个数据都是一种状态，然后我们对状态处理出我们想要的结果即可<br><span class="hljs-comment">//具体</span><br>     一般一个<span class="hljs-type">int</span>整形是<span class="hljs-number">4</span>个字节，也就是<span class="hljs-number">32</span>位bit，我们通过这<span class="hljs-number">32</span>位bit上<span class="hljs-number">0</span>和<span class="hljs-number">1</span>的组合可以表示多大<span class="hljs-number">21</span>亿个不同的数。如果我们把这<span class="hljs-number">32</span>位bit看成是一个集合，那么每一个数都应该对应集合的一种状态，并且每个数的状态都是不同的。(组合个数大)<br><span class="hljs-comment">//细节</span><br>     整数的二进制表示可以代表一个二元集合的状态，既然是状态就可以转移。在此基础上，我们可以得出另一个非常重要的结论——我们可以用整数的加减表示状态之间的转移。   <br>     总结一下，我们用二进制的<span class="hljs-number">0</span>和<span class="hljs-number">1</span>表示一个二元集合的状态。可以简单认为某个物品存在或者不存在的状态。由于二进制的<span class="hljs-number">0</span>和<span class="hljs-number">1</span>可以转化成一个<span class="hljs-type">int</span>整数，也就是说我们用整数代表了一个集合的状态。这样一来，我们可以用整数的加减计算来代表集合状态的变化。   <br></code></pre></td></tr></table></figure><h3 id="蒙德里安的幻想"><a href="#蒙德里安的幻想" class="headerlink" title="蒙德里安的幻想"></a>蒙德里安的幻想</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164339347.png" alt="image-20230327164339347"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164353684.png" alt="image-20230327164353684"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164407998.png" alt="image-20230327164407998"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用二进制表示不同的状态</span><br>  <span class="hljs-comment">//预处理：判断合并列的状态i是否合法（这里的i应该用二进制表示是吧）</span><br>  <span class="hljs-comment">//如果合并列的某行是1表示横放，是0表示竖放(用二进制表示块摆放状态)</span><br>  <span class="hljs-comment">//如果合并列不存在连续的奇数个0，就是合法状态</span><br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span>&lt;&lt;n;i++)&#123;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录合并列的连续0个数</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=n;j++)<br>                <span class="hljs-keyword">if</span>(i&gt;&gt;j &amp; <span class="hljs-number">1</span>)<span class="hljs-comment">//判断二进制i中1的个数</span><br>                 <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>)<span class="hljs-comment">//如果连续的0的个数是奇数</span><br>                    &#123;<br>                        st[i] = <span class="hljs-literal">false</span>; <span class="hljs-comment">//记录i不合法</span><br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<span class="hljs-keyword">else</span> cnt++; <span class="hljs-comment">//记录0的个数</span><br>            <br>            <span class="hljs-keyword">if</span>(cnt&amp;<span class="hljs-number">1</span>) st[i] = <span class="hljs-literal">false</span>;<span class="hljs-comment">//处理高位0的个数            </span><br>        &#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164424745.png" alt="image-20230327164424745"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164500795.png" alt="image-20230327164500795"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230327164516348.png" alt="image-20230327164516348"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版</span><br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">12</span>, M = <span class="hljs-number">1</span> &lt;&lt; N;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N][M];<br><span class="hljs-type">bool</span> st[M];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; m, n || m)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1</span> &lt;&lt; n; i ++ )<br>        &#123;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            st[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j ++ )<br>                <span class="hljs-keyword">if</span> (i &gt;&gt; j &amp; <span class="hljs-number">1</span>)<br>                &#123;<br>                    <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) st[i] = <span class="hljs-literal">false</span>;<br>                    cnt = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> cnt ++ ;<br>            <span class="hljs-keyword">if</span> (cnt &amp; <span class="hljs-number">1</span>) st[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">memset</span>(f, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span> f);<br>        f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i ++ )<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1</span> &lt;&lt; n; j ++ )<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">1</span> &lt;&lt; n; k ++ )<br>                    <span class="hljs-keyword">if</span> ((j &amp; k) == <span class="hljs-number">0</span> &amp;&amp; st[j | k])<br>                        f[i][j] += f[i - <span class="hljs-number">1</span>][k];<br><br>        cout &lt;&lt; f[m][<span class="hljs-number">0</span>] &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="树型dp"><a href="#树型dp" class="headerlink" title="树型dp"></a>树型dp</h2><h3 id="树的中心"><a href="#树的中心" class="headerlink" title="树的中心"></a>树的中心</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153539710.png" alt="image-20230320153539710"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153602922.png" alt="image-20230320153602922"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153621674.png" alt="image-20230320153621674"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153639330.png" alt="image-20230320153639330"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153645886.png" alt="image-20230320153645886"></p><h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h2><h3 id="树塔"><a href="#树塔" class="headerlink" title="树塔"></a>树塔</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153726163.png" alt="image-20230320153726163"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153741418.png" alt="image-20230320153741418"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153805063.png" alt="image-20230320153805063"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Five</title>
      <link href="/2023/04/28/Five/"/>
      <url>/2023/04/28/Five/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第五章-数论"><a href="#第五章-数论" class="headerlink" title="第五章 - 数论"></a>第五章 - 数论</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>质数的作用<br><span class="hljs-number">2.</span>各种知识<br></code></pre></td></tr></table></figure><h2 id="1-费马小定理"><a href="#1-费马小定理" class="headerlink" title="1.费马小定理"></a>1.费马小定理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前置消息</span><br>辗转相除法 <span class="hljs-built_in">gcd</span>(a,b); <span class="hljs-comment">//求取最小公倍数</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br>  <br><span class="hljs-comment">// Function to compute gcd of two numbers </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span> a; <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b); <br>&#125; <br>  <br><span class="hljs-comment">//main function</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-type">int</span> a = <span class="hljs-number">98</span>, b = <span class="hljs-number">56</span>; <br>    cout &lt;&lt; <span class="hljs-string">&quot;GCD of &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; and &quot;</span> &lt;&lt; b &lt;&lt; <span class="hljs-string">&quot; is &quot;</span> &lt;&lt; <span class="hljs-built_in">gcd</span>(a, b); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//费马小定理</span><br><br><span class="hljs-comment">//它指出，如果一个自然数p是一个素数，并且a是一个不能被p整除的任意一个正整数，那么a的p次方一定模p等于a。</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> a, b, c;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Enter two different numbers: &quot;</span>;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    c = a*a + b*b;<br>    <br>    <span class="hljs-keyword">if</span>(c % (a+b) == <span class="hljs-number">0</span>)<br>        cout &lt;&lt; <span class="hljs-string">&quot;弗尔马尔的小定理得到验证。&quot;</span>;<br>    <span class="hljs-keyword">else</span> <br>        cout &lt;&lt; <span class="hljs-string">&quot;Felmar的小定理尚未得到验证&quot;</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-欧拉函数-有啥用？"><a href="#2-欧拉函数-有啥用？" class="headerlink" title="2.欧拉函数(有啥用？)*"></a>2.欧拉函数(有啥用？)*</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//欧拉函数的理论</span><br> 欧拉函数是被称为有限欧拉定理的函数，它在数论中广泛使用。欧拉函数的定义是：<br>   Φ(N) = (p1^k1)*(p2^k2)…*(pr^kr)，<br>   其中p1、p2…pr是大于<span class="hljs-number">1</span>的所有不相等的质数，而k1、k2…kr是正整数。<br>   Φ(N)表示小于等于N的正整数中，与N互质的数之积。欧拉函数的意义就是计算满足特定限制条件的正整数值<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//欧拉函数的代码生成</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;iostream&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//定义欧拉函数</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-title">euler</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> ans=n,i,j;<br>    <span class="hljs-keyword">for</span> ( i=<span class="hljs-number">2</span>;i*i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(n%i==<span class="hljs-number">0</span>)<br>        &#123;<br>            ans=ans-ans/i;<br>            <span class="hljs-keyword">while</span>(n%i==<span class="hljs-number">0</span>) <br>            &#123;<br>                n/=i;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n&gt;<span class="hljs-number">1</span>) <br>    &#123;<br>        ans=ans-ans/n;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> n;<br> <br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入一个正整数：&quot;</span>;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;此数的欧拉函数值为：&quot;</span>&lt;&lt; <span class="hljs-built_in">euler</span>(n) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-扩展欧几里得算法"><a href="#3-扩展欧几里得算法" class="headerlink" title="3.扩展欧几里得算法"></a>3.扩展欧几里得算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前置知识 线性同余方程</span><br> 线性同余方程是一种数学模型，可以用来求解根据已知条件计算未知变量的问题。它是一个形如ax≡<span class="hljs-built_in">b</span> (modn) 的方程，其中a、b和n是已知常数，x是待求解的未知变量。<br>  线性同余方程是用来解决模运算的一种数学方法，它可以解决大多数的组合数学问题，包括数论和计算机科学等，在特定情况下甚至可以用来分析给定的数学问题。线性同余方程在破解加密算法以及模数运算中也有所应用。<br>              ax ≡ <span class="hljs-built_in">b</span> (mod n)<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法作用</span><br>扩展欧几里得算法是一个整数线性规划算法，用于通过有限的整数操作来求解ax + by = <span class="hljs-built_in">gcd</span> (a, b)的问题，其中a和b是两个正整数。它也可以用于计算多元最大公因子(gcd)，即求出多个整数的最大公约数。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-comment">//扩展欧几里得算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!b) &#123; x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>; <span class="hljs-keyword">return</span> a; &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(b, a%b, x, y);<br>    <span class="hljs-type">int</span> t = x; y = x - a/b*y; x = t;<br>    <span class="hljs-keyword">return</span> d;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a, b, x, y, ans;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    ans = <span class="hljs-built_in">exgcd</span>(a, b, x, y);<br>    cout&lt;&lt;<span class="hljs-string">&quot;ax+by=d=&quot;</span>&lt;&lt;ans&lt;&lt;endl;<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂问题</span><br>  方法<span class="hljs-number">1</span>：最朴素的想法，<span class="hljs-number">7</span>*<span class="hljs-number">7</span>=<span class="hljs-number">49</span>，<span class="hljs-number">49</span>*<span class="hljs-number">7</span>=<span class="hljs-number">343</span>，... 一步一步算，共进行了<span class="hljs-number">9</span>次乘法。<br>  这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。<br>  方法<span class="hljs-number">2</span>：先算<span class="hljs-number">7</span>的<span class="hljs-number">5</span>次方，即<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">7</span>，再算它的平方，共进行了<span class="hljs-number">5</span>次乘法。但这并不是最优解，因为对于“<span class="hljs-number">7</span>的<span class="hljs-number">5</span>次方”，我们仍然可以拆分问题。<br>  方法<span class="hljs-number">3</span>：先算<span class="hljs-number">7</span>*<span class="hljs-number">7</span>得<span class="hljs-number">49</span>，则<span class="hljs-number">7</span>的<span class="hljs-number">5</span>次方为<span class="hljs-number">49</span>*<span class="hljs-number">49</span>*<span class="hljs-number">7</span>，再算它的平方，共进行了<span class="hljs-number">4</span>次乘法。模仿这样的过程，我们得到一个在 <span class="hljs-built_in">o</span>(log n)时间内计算出幂的算法，也就是快速幂。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法实现快速幂</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">quick_mod</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> a,<span class="hljs-type">long</span> <span class="hljs-type">long</span> b,<span class="hljs-type">long</span> <span class="hljs-type">long</span> c)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans=<span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(b) <br>    &#123; <br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) <br>            ans=(ans*a)%c; <br>        b=b&gt;&gt;<span class="hljs-number">1</span>; <br>        a=(a*a)%c; <br>    &#125; <br>    <span class="hljs-keyword">return</span> ans; <br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a,b,c; <br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; <br>    cout&lt;&lt;<span class="hljs-built_in">quick_mod</span>(a,b,c); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-乘法逆元"><a href="#4-乘法逆元" class="headerlink" title="4.乘法逆元"></a>4.乘法逆元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//乘法逆元</span><br>乘法逆元是乘法运算在模意义下的一个概念，即存在一个数a，使得a*b≡<span class="hljs-number">1</span>（mod n），其中a就叫做b的乘法逆元，记为b^(<span class="hljs-number">-1</span>) (mod n)。它的用处是在模意义下实现除法的目的，可以用来求模意义下的乘法对角线，解方程组等。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//扩展欧几里得算法实现逆元</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;x, <span class="hljs-type">int</span> &amp;y)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <br>    &#123;<br>        x = <span class="hljs-number">1</span>;<br>        y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> r = <span class="hljs-built_in">exgcd</span>(b, a % b, x, y);<br>    <span class="hljs-type">int</span> t = x;<br>    x = y;<br>    y = t - a / b * y;<br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inverse</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> m)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x, y;<br>    <span class="hljs-type">int</span> gcd = <span class="hljs-built_in">exgcd</span>(a, m, x, y);<br>    <span class="hljs-keyword">return</span> x &gt;= <span class="hljs-number">0</span> ? x : x + m;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-贝祖定理"><a href="#5-贝祖定理" class="headerlink" title="5.贝祖定理"></a>5.贝祖定理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//贝祖定理 </span><br>  贝祖定理是一个重要的概率论原理，用于求解含有多个独立随机变量的复合分布概率。它可以用来解决一些关于概率分布的问题，比如计算多个独立事件的概率之和，计算某个事件出现的概率，计算两个事件概率的乘积以及计算某个条件发生的概率等问题。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Please input two integers (n, k): &quot;</span>;<br>    cin&gt;&gt;n&gt;&gt;k;<br> <br>    <span class="hljs-comment">// Compute C(n, k) using the formula</span><br>    <span class="hljs-type">long</span> c = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>        c = c * (n - i + <span class="hljs-number">1</span>) / i;<br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;C(&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;, &quot;</span>&lt;&lt;k&lt;&lt;<span class="hljs-string">&quot;) = &quot;</span>&lt;&lt;c&lt;&lt;endl;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-中国剩余定理"><a href="#6-中国剩余定理" class="headerlink" title="6.中国剩余定理"></a>6.中国剩余定理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">中国剩余定理的用途有： <br>      <span class="hljs-number">1</span>、在数论中，它可用于解决同余方程； <br>      <span class="hljs-number">2</span>、在密码学中，它可用于将私钥分成多份存放，并能通过合并多份共享私钥来解密信息；       <span class="hljs-number">3</span>、在密码学中，它还可以用于生成曲线密码，能够抗攻击； <br>    <span class="hljs-number">4</span>、在数值分析中，它可用于解决系统方程组； <br>    <span class="hljs-number">5</span>、在计算机科学中，它可用于解决复杂图形计算问题； <br>    <span class="hljs-number">6</span>、它还可以用于解决一系列复杂的模式识别问题； <br>    <span class="hljs-number">7</span>、在数据库领域，它可用于解决复杂的查询优化问题<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 中国剩余定理：求解一组数的方程组 x = ai (mod ni) 所有a_i, n_i都是正整数 </span><br><span class="hljs-comment">* 并且互质，即gcd(n_i, n_j) = 1 (1 ≤ i ≤ k, 1 ≤ j ≤ k, i ≠j)则存在这样一个整数x，</span><br><span class="hljs-comment">* 使得x≡ai(modni)成立，且0≤x&lt;n1 * n2 *...nk。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">chinese_remainder</span><span class="hljs-params">(<span class="hljs-type">int</span> *n, <span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> len)</span> </span>&#123;  <span class="hljs-comment">// 传入ni和ai的数组，len表示数组的长度</span><br> <span class="hljs-type">int</span> p, i, j, m, n_i, x; <span class="hljs-comment">//定义变量</span><br> x = <span class="hljs-number">0</span>;<br> p = <span class="hljs-number">1</span>;<br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123; <span class="hljs-comment">// 求出n1 x n2 x ... nk</span><br>  p *= n[i];<br> &#125;<br><br> <span class="hljs-comment">// 中国剩余定理算法 </span><br> <span class="hljs-comment">// 之所以不影响x的值，是因为m == (p / n[i]) * ai mod n[i]</span><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>  n_i = p / n[i];<br>  m = <span class="hljs-built_in">extended_Euclid</span>(n_i, n[i]);  <span class="hljs-comment">//  扩展欧几里得算法计算出逆元</span><br>  x += a[i] * m * n_i;<br> &#125;<br><br> <span class="hljs-keyword">return</span> x % p;<br>&#125;<br><br><span class="hljs-comment">// 扩展欧几里得算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">extended_Euclid</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br> <span class="hljs-type">int</span> x, y, d;<br> <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>  x = <span class="hljs-number">1</span>;<br>  y = <span class="hljs-number">0</span>;<br>  d = a;<br>  <span class="hljs-keyword">return</span> d;<br> &#125;<br> <span class="hljs-type">int</span> x1, y1, d1;<br> d1 = <span class="hljs-built_in">extended_Euclid</span>(b, a % b);<br> x1 = y1;  <span class="hljs-comment">// 记录上一次的结果 </span><br> y1 = x1 - (a / b)* y1;<br> d = d1;<br> x = x1;<br> y = y1;<br><br> <span class="hljs-comment">// 由模线性方程性质可知 </span><br> <span class="hljs-comment">// 如果a, b互质， 那么对于模线性方程 ax + by = c 有唯一解， </span><br> <span class="hljs-comment">// 而该解恰好为 d = gcd(a, b) 的一组特解</span><br> <span class="hljs-keyword">if</span> (d == <span class="hljs-number">1</span>) <br>  <span class="hljs-keyword">return</span> (x + b) % b; <span class="hljs-comment">// 返回模逆元 </span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-高斯消元（不理解）"><a href="#7-高斯消元（不理解）" class="headerlink" title="7.高斯消元（不理解）"></a>7.高斯消元（不理解）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高斯消元是一种数学计算方法，用于快速求解系数表示的线性方程组的解，它也被称为高斯-赛洛加算法，以著名的普林斯顿大学数学家高斯命名。该方法把方程组分为上三角形组和下三角形组，通过变换方程中的系数值，最终获得方程的解。</span><br><span class="hljs-comment">//高斯消元法用于解决线性方程组的系数矩阵形式，即通过将系数矩阵通过合并和分解，从而求解出给定线性方程组的参数值解</span><br><span class="hljs-comment">//解决多项式方程的算法 - 是线性代数的知识</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//高斯消元的证明</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iomanip&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">gauss_jordan</span><span class="hljs-params">(<span class="hljs-type">double</span> a[][],<span class="hljs-type">double</span> b[],<span class="hljs-type">int</span> n)</span><span class="hljs-comment">//a为系数矩阵，b为常数项，n为未知数个数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,j,k,r;<br>    <span class="hljs-type">double</span> m,s;<br><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        r = i;<br>        <span class="hljs-keyword">for</span>(j = i+<span class="hljs-number">1</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">fabs</span>(a[j][i]) &gt; <span class="hljs-built_in">fabs</span>(a[r][i])) <br>                r=j;<br>        <span class="hljs-comment">//将第r行与第i行交换</span><br>        <span class="hljs-keyword">if</span>(r != i) <br>        &#123;<br>            <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; n; k++) <br>            &#123;<br>                m = a[i][k];<br>                a[i][k] = a[r][k];<br>                a[r][k] = m;<br>            &#125;<br>            s = b[i];<br>            b[i] = b[r];<br>            b[r] = s;<br>        &#125;<br>        <span class="hljs-comment">//用第i行的元素除以第i列第一个元素</span><br>        m = a[i][i];<br>        b[i] = b[i]/m;<br>        <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; n; k++)<br>            a[i][k] = a[i][k]/m;<br>        <span class="hljs-comment">//化为型</span><br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;n;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(j == i) <span class="hljs-keyword">continue</span>;<br>            s = a[j][i];<br>            <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>;k&lt;n;k++)<br>                a[j][k] = a[j][k] - a[i][k]*s;<br>            b[j] = b[j] - b[i]*s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//输出解</span><br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;x%d = %f\n&quot;</span>,i,b[i]);<br>    &#125;<br><span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="筛质数"><a href="#筛质数" class="headerlink" title="筛质数"></a>筛质数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计算质数的代码(暴力根源)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span>  </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;  <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-type">int</span> i, j, count;  <br>    cout &lt;&lt; <span class="hljs-string">&quot; 它的2到100间的质数有: \n&quot;</span>;  <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">2</span>;i&lt;<span class="hljs-number">100</span>;i++)  <br>    &#123;  <br>        count = <span class="hljs-number">0</span>;  <br>        <span class="hljs-keyword">for</span>(j=<span class="hljs-number">2</span>;j&lt;i;j++)<span class="hljs-comment">//判断i是否为质数，若count==0则为质数  </span><br>        &#123;  <br>            <span class="hljs-keyword">if</span>(i%j == <span class="hljs-number">0</span>)  <br>            &#123;  <br>                count++;  <br>                <span class="hljs-keyword">break</span>;  <br>            &#125;  <br>        &#125;  <br>        <span class="hljs-keyword">if</span>(count==<span class="hljs-number">0</span>)  <br>        &#123;  <br>            cout&lt;&lt;i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;  <br>        &#125;  <br>    &#125;  <br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//加上合数优化</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">i_p</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//如果一个数是合数（不是素数），那么它的最小因数一定不会超过它的平方根</span><br>    <span class="hljs-comment">//这个属性可以用反陈述来证明。设 a 和 b 是 n 的两个因子，使得 a*b = n。如果两者都大于 √n，则 a.b &gt; √n， * √n，这与表达式 “a * b = n” 相矛盾。（可以理解为 a 和 b 最大就 √n）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>        <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;   <br>    <br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">i_p</span>(x)) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码模版</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">trial_division</span>(<span class="hljs-type">int</span> n) &#123;<br>    <span class="hljs-comment">// n是要分解的整数</span><br>    <span class="hljs-comment">// 返回一个向量，包含n的所有质因数和它们的次数</span><br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; factors; <span class="hljs-comment">// 存储质因数和次数的向量</span><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; <span class="hljs-comment">// 从2开始试除</span><br>    <span class="hljs-keyword">while</span> ( i &lt;= n/i) &#123; <span class="hljs-comment">// 只需要试到根号n就可以了</span><br>        <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录i出现的次数</span><br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果n能被i整除，就更新n和s</span><br>            n /= i; <span class="hljs-comment">// 用i约分n</span><br>            s++; <span class="hljs-comment">// 增加i的次数（当前质数的指数）</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果s大于0，说明i是n的一个质因数，把它加入factors向量</span><br>            factors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(i, s));<br>        &#125;<br>        i++; <span class="hljs-comment">// 增加i，继续试除下一个数</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 如果n最后大于1，说明它本身是一个质数，也要加入factors向量(理解)</span><br>        factors.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">make_pair</span>(n, <span class="hljs-number">1</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> factors; <span class="hljs-comment">// 返回factors向量</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">get_divisors</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; res;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=x/i;i++)<br>    <span class="hljs-comment">//整除流入</span><br>        <span class="hljs-keyword">if</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">//如果i是质因数 - 塞入res数组中</span><br>            res.<span class="hljs-built_in">push_back</span>(i); <br>            <span class="hljs-comment">//除数相等的情况 就只有i了嘛</span><br>            <span class="hljs-keyword">if</span>(i!=x/i) res.<span class="hljs-built_in">push_back</span>(x/i);<br>        &#125;<br>        <span class="hljs-comment">//排个序 (可不可以用 set存储啊)</span><br>        <span class="hljs-built_in">sort</span>(res.<span class="hljs-built_in">begin</span>(),res.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <br>    <span class="hljs-keyword">while</span> (n -- )&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">auto</span> res = <span class="hljs-built_in">get_divisors</span>(x);<br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">auto</span> x:res) cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">110</span>, mod = <span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<span class="hljs-comment">//题目的意思就是和mod取模的得数</span><br><br><span class="hljs-comment">//这个代码求约数是用约数个数定理12的方法。约数个数定理是：</span><br><span class="hljs-comment">//如果一个数可以分解为质因数的形式，如M = x^a * y^b * z^c * …，则M的约数个数 = (a+1) (b+1) (c+1)…。</span><br><span class="hljs-comment">//这个代码就是先把每个输入的数分解成质因数，然后用哈希表记录每个质因数的指数，最后用公式计算出所有输入的数的最小公倍数的约数个数。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-comment">//哈希表的键是质数，值是质数对应的指数</span><br>    <span class="hljs-comment">//primes[i], i是键，primes[i]是值</span><br>    unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; primes; <br>    <span class="hljs-comment">//unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。它的键值分别是迭代器的first和second属性12。</span><br>    <span class="hljs-comment">//例如，it-&gt;first就是键，it-&gt;second就是值。</span><br>    <span class="hljs-comment">//当然也不一定存储键值对 - 也可以存储二者</span><br>    <span class="hljs-keyword">while</span> (n -- )&#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=x/i;i++)<br>            <span class="hljs-keyword">while</span>(x%i == <span class="hljs-number">0</span>)&#123;<br>                x/=i;<br>                primes[i]++; <span class="hljs-comment">//对应位置的质数记录 （算是记录指数）</span><br>            &#125;<br>        <span class="hljs-keyword">if</span>(x&gt;<span class="hljs-number">1</span>) primes[x]++; <span class="hljs-comment">//只剩下一个数据 这个数据必然是质数</span><br>    &#125;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> p:primes) res = res*(p.second+<span class="hljs-number">1</span>)%mod;<br>    cout&lt;&lt;res&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="定义"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.埃拉托色尼筛</span><br>埃拉托色尼筛的原理是这样的：<br>    首先，把所有小于等于n的自然数都列出来，从<span class="hljs-number">2</span>开始，把<span class="hljs-number">1</span>排除掉。<br>    然后，从<span class="hljs-number">2</span>开始，把它的所有倍数都标记为合数，也就是不是素数的数。<br>    接着，找到下一个没有被标记的数，它一定是素数，然后把它的所有倍数都标记为合数。<br>    重复这个过程，直到没有更多的没有被标记的数为止。<br>    最后，所有没有被标记的数就是素数<br><br> <span class="hljs-comment">/*质数筛法是一种经典的求解质数的方法，它利用筛过程来获得所有质数。这个算法强调效率，通常使用比较基本的操作，来求解比较大的质数。 筛法的原理是：从2开始，把2的倍数筛掉，然后3，4，5，把3的倍数筛掉，以此类推。最后剩下的就是质数。 如何实现质数筛法：  1. 首先设置一个长度为n的数组，并将数组初始化，其数字依次为2, 3, …, n。   </span><br><span class="hljs-comment">2. 从2开始遍历数组中的元素，依次筛除其2、3、4、… 倍数的数，即将数组中对应元素置0。  3. 筛完后，把数组中非0元素存入一个新数组中，这些非0元素即为质数。 </span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> primes[N],cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(st[i]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//1.primes[cnt++] = i;的作用是把i这个素数存入primes数组中</span><br>        <span class="hljs-comment">//  并且把cnt加一，表示素数的个数增加了一个。</span><br>        primes[cnt++] = i;<br>        <span class="hljs-comment">//2.;这个循环的作用是把i的所有倍数都标记为合数，也就是非素数。</span><br>        <span class="hljs-comment">//  这样，当i增加时，就可以跳过已经被标记为合数的数字，只考虑没有被标记的数字，因为它们可能是素数。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i+i;j&lt;=n;j+=i) st[j] = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-built_in">get_primes</span>(n);<br>    cout&lt;&lt;cnt&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//2.线性筛法（埃拉托色尼筛优化版）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">//如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-comment">//primes[j] * i这个数标记为合数</span><br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">get_primes</span>(n);<br><br>    cout &lt;&lt; cnt &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="约数"><a href="#约数" class="headerlink" title="约数"></a>约数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//约数</span><br>约数是一个数据的因子，可以用这个约数凑成我们的这个数据<br><span class="hljs-comment">//试除法</span><br>  测试除法是一种数学操作，用来衡量和检查两个数字的除法运算结果是否正确。它通常包括算术问题、实数求余以及其他形式的除法运算。<br><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//试除法，求约数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FindDivisor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(n); i++)<br>    &#123;<br>        <span class="hljs-keyword">while</span> (n % i == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;  &quot;</span>;<br>            n /= i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>) <br>    &#123;<br>        cout &lt;&lt; n;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;Please enter an integer:&quot;</span>;<br>    cin &gt;&gt; n;<br><br>    cout &lt;&lt; n &lt;&lt; <span class="hljs-string">&quot;的约数有：&quot;</span> ;<br>    <span class="hljs-built_in">FindDivisor</span>(n);<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合数-不完整"><a href="#组合数-不完整" class="headerlink" title="组合数(不完整)"></a>组合数(不完整)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> f[<span class="hljs-number">20</span>][<span class="hljs-number">20</span>];<span class="hljs-comment">//定义二维数组，用来中间存储计算结果 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">cmn</span><span class="hljs-params">(<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> n)</span>  </span><br><span class="hljs-function"></span>&#123;     <br>    <span class="hljs-type">int</span> i,j;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;=m;++i)  <span class="hljs-comment">//循环m步，从0开始 </span><br>       <span class="hljs-keyword">for</span>(j=<span class="hljs-number">0</span>;j&lt;=n;++j)  <span class="hljs-comment">//循环n步，也是从0开始  </span><br>        <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span>||i==j)    <span class="hljs-comment">//当i等于0或者i等于j时，直接赋值为1 </span><br>           f[i][j]=<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <br>           f[i][j]=f[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+f[i<span class="hljs-number">-1</span>][j];<span class="hljs-comment">//其他的都是在上一步的计算结果上加+1，依次类推</span><br>     <span class="hljs-keyword">return</span> f[m][n];  <span class="hljs-comment">//返回结果 </span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m,n;<br>    cout&lt;&lt;<span class="hljs-string">&quot;请输入任意m.n来得到组合数：&quot;</span>;<br>    cin&gt;&gt;m&gt;&gt;n;<br>    <span class="hljs-type">int</span> result=<span class="hljs-built_in">cmn</span>(m,n);<br>    cout&lt;&lt;m&lt;&lt;<span class="hljs-string">&quot;C&quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot;=&quot;</span>&lt;&lt;result&lt;&lt;endl; <span class="hljs-comment">//输出结果</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="欧几里得算法（求最大公约数）"><a href="#欧几里得算法（求最大公约数）" class="headerlink" title="欧几里得算法（求最大公约数）"></a>欧几里得算法（求最大公约数）</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230316143057971.png" alt="image-20230316143057971"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*辗转相除法，又称欧几里得算法，是一种求两个非负整数的最大公约数的算法1。最大公约数是能够同时整除两个整数的最大的正整数2。辗转相除法的基本思想是：如果a和b都能被c整除，那么a和b的余数也能被c整除。因此，可以用a和b的余数代替b，重复这个过程，直到余数为0为止。此时，a就是最大公约数3。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">例如，要求18和30的最大公约数，可以这样做：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">18 = 0 × 30 + 18</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">30 = 1 × 18 + 12</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">18 = 1 × 12 + 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">12 = 2 × 6 + 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">此时，余数为0，所以最大公约数是6。*/</span><br><br><span class="hljs-comment">//大除小，小除大除小的余数，这样反复直到一方变为0是这样吗</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> b?<span class="hljs-built_in">gcd</span>(b,a%b):a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        cout&lt;&lt;<span class="hljs-built_in">gcd</span>(a,b)&lt;&lt;endl;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拓展：裴蜀定理"><a href="#拓展：裴蜀定理" class="headerlink" title="拓展：裴蜀定理"></a>拓展：裴蜀定理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>裴蜀定理（Bézout’s identity）又称裴蜀引理，是数论中的一个重要定理。它指出，对于任意整数 a 和 b，如果它们的最大公约数为 d，那么一定存在整数 x 和 y，使得不定方程 ax + by = d 有解。<br><br><span class="hljs-number">2.</span>换句话说，对于任意整数 a 和 b，它们的线性组合（即形如 ax + by 的整数）一定包含它们的最大公约数。此外，根据裴蜀定理还可以推出：如果不定方程 ax + by = c 有整数解，则当且仅当 c 是 a 和 b 的最大公约数的倍数时成立。<br><br>裴蜀定理在求解不定方程、计算模逆元等问题中都有重要应用。<br><br><span class="hljs-comment">//简单来说：就是构造一个这样的 ax + by = gcd(a,b); 只要gcd(a,b)能被我们题目的数据整除，就说明有整数解</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">假设我们要求解不定方程 <span class="hljs-number">3</span>x + <span class="hljs-number">5</span>y = <span class="hljs-number">11</span>。首先，我们可以使用扩展欧几里得算法求出 <span class="hljs-number">3</span> 和 <span class="hljs-number">5</span> 的最大公约数以及不定方程 <span class="hljs-number">3</span>x + <span class="hljs-number">5</span>y = <span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) 的一组整数解。运算结果显示，<span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) = <span class="hljs-number">1</span>，且不定方程 <span class="hljs-number">3</span>x + <span class="hljs-number">5</span>y = <span class="hljs-number">1</span> 的一组整数解为 (x0,y0) = (<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>)。<span class="hljs-comment">//就是只要 3x + 5y = 1 的解也就是1 -  能够被原来的 11 整除 那么就有整数解</span><br><br>由于 <span class="hljs-number">11</span> 是 <span class="hljs-built_in">gcd</span>(<span class="hljs-number">3</span>,<span class="hljs-number">5</span>) 的倍数，因此原不定方程有整数解。它的一组特殊解为 (x0 * c/d, y0 * c/d) = (<span class="hljs-number">2</span> * <span class="hljs-number">11</span>/<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> * <span class="hljs-number">11</span>/<span class="hljs-number">1</span>) = (<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>)。此外，根据裴蜀定理，原不定方程的通解为 (<span class="hljs-number">22</span> + k * b/d,<span class="hljs-number">-11</span> - k * a/d) = (<span class="hljs-number">22</span> + k * <span class="hljs-number">5</span>,<span class="hljs-number">-11</span> - k * <span class="hljs-number">3</span>)（其中 k 为任意整数）。<br><br>因此，当 k=<span class="hljs-number">0</span> 时，(x,y)=(<span class="hljs-number">22</span>,<span class="hljs-number">-11</span>) 是原不定方程的一组整数解；当 k=<span class="hljs-number">-1</span> 时，(x,y)=(<span class="hljs-number">17</span>,<span class="hljs-number">-8</span>) 是原不定方程的另一组整数解；当 k=<span class="hljs-number">1</span>时，(x,y)=(<span class="hljs-number">27</span>,<span class="hljs-number">-14</span>) 是原不定方程的第三组整数解。<br>   <br></code></pre></td></tr></table></figure><h3 id="扩展欧几里得算法-求不定方程"><a href="#扩展欧几里得算法-求不定方程" class="headerlink" title="扩展欧几里得算法(求不定方程)"></a>扩展欧几里得算法(求不定方程)</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230316150108768.png" alt="image-20230316150108768"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//求不定方程 - 判断有无整数解是这个样子吗</span><br><span class="hljs-comment">//根据裴蜀定理，当且仅当 c 是 a 和 b 的最大公约数的倍数时，不定方程才有整数解。</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;x,<span class="hljs-type">int</span> &amp;y)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(b==<span class="hljs-number">0</span>)&#123;<br>        x = <span class="hljs-number">1</span>,y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-type">int</span> x1,y1,d;<br>    d = <span class="hljs-built_in">exgcd</span>(b,a%b,x1,y1);<br>    x = y1,y = x1-a/b*y1; <span class="hljs-comment">//用欧几里得构造</span><br>    <span class="hljs-keyword">return</span> d; <span class="hljs-comment">//这个就是被除的</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b,c,x,y;<br>    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">exgcd</span>(a,b,x,y);<br>    <span class="hljs-keyword">if</span>(c%d == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,c/d*x,c/d*y); <span class="hljs-comment">//能整除就是有整数解 - 无就是无</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;none&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="快速幂算法"><a href="#快速幂算法" class="headerlink" title="快速幂算法"></a>快速幂算法</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191357823.png" alt="image-20230317191357823"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*快速幂：</span><br><span class="hljs-comment">可以这样理解，将指数转化为二进制，有1就乘，没1就不乘。 是通过二进制 一次执行多次乘法来缩减算法复杂度的</span><br><span class="hljs-comment">快速幂算法就是通过二进制来判断哪些位需要乘，哪些位不需要乘，从而减少乘法的次数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">例如，如果要计算 7 的 13 次方，可以将 13 写成二进制的 1101，然后有：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">7^13 = 7(23 + 2^2 + 2^0) = 7(23) * 7(22) * 7(20)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">= (7 * 7)^4 * (7 * 7)^2 * (7 * 7)^1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">= (49)^4 * (49)^2 * (49)^1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">这样就只需要做三次乘法，而不是十二次。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    LL res = <span class="hljs-number">1</span>%p;<br>    <span class="hljs-comment">//把次数转化成二进制 - 有1就代表有一次</span><br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%p;<br>        a = a*(LL)a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        cout&lt;&lt;<span class="hljs-built_in">qmi</span>(a,b,c)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂求逆元"><a href="#快速幂求逆元" class="headerlink" title="快速幂求逆元"></a>快速幂求逆元</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//根据费马小定理</span><br>a^(p<span class="hljs-number">-1</span>) ≡ <span class="hljs-number">1</span> (mod p)，所以a * a^(p<span class="hljs-number">-2</span>) ≡ <span class="hljs-number">1</span> (mod p)，也就是说x = a^(p<span class="hljs-number">-2</span>)就是a的逆元。<br><span class="hljs-comment">//就是要构造 a^(p-1) ≡ 1 (mod p) 那么有 a* a^(p-2) ≡ 1 (mod p)  a^(p-2)这个就是我们的目标值（用逆元是为了减少运算次数）</span><br><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> p)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b)<br>    &#123;<br>        <span class="hljs-comment">//mod质数 这里就是快速幂啦</span><br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % p;<br>        a = a * (LL)a % p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-keyword">while</span> (n -- )<br>    &#123;<br>        <br>        <span class="hljs-type">int</span> a, p;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;a, &amp;p);<br>        <span class="hljs-keyword">if</span> (a % p == <span class="hljs-number">0</span>) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;impossible&quot;</span>);<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, <span class="hljs-built_in">qmi</span>(a, p - <span class="hljs-number">2</span>, p));<br>        <span class="hljs-comment">//如果p是一个质数，那么根据费马小定理，我们有a^(p-1) ≡ 1 (mod p)</span><br>        <span class="hljs-comment">//所以a * a^(p-2) ≡ 1 (mod p)，也就是说x = a^(p-2)就是a的逆元。</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数*"></a>组合计数*</h2><p>​  本质上，求组合数就是按照公式就可以求出来的。</p><h3 id="线性筛法-求组合数"><a href="#线性筛法-求组合数" class="headerlink" title="线性筛法 - 求组合数"></a>线性筛法 - 求组合数</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317103427722.png" alt="image-20230317103427722"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性筛法板子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N= <span class="hljs-number">1000010</span>;<br><br><span class="hljs-type">int</span> primes[N], cnt;<br><span class="hljs-type">bool</span> st[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_primes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i ++ )<br>    &#123;<br>        <span class="hljs-comment">//如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。</span><br>        <span class="hljs-keyword">if</span> (!st[i]) primes[cnt ++ ] = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; primes[j] &lt;= n / i; j ++ )<br>        &#123;<br>            <span class="hljs-comment">//primes[j] * i这个数标记为合数</span><br>            st[primes[j] * i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-comment">//如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。</span><br>            <span class="hljs-keyword">if</span> (i % primes[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br><br>    <span class="hljs-built_in">get_primes</span>(n);<br><br>    cout &lt;&lt; cnt &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用这个方法 - 就是减少阶层的计算次数</span><br><span class="hljs-comment">//同时，组合数太大了只能用高精度的数据存储</span><br><span class="hljs-comment">//n！（阶层）中的p的个数 ，p是质数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-comment">//n容纳p的个数有上限的</span><br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n) s+=n/p,n/=p;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-comment">//c中的p的个数(算质数的个数) - 算组合数中的质数个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getC</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> m,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(n,p) - <span class="hljs-built_in">get</span>(m,p) - <span class="hljs-built_in">get</span>(n-m,p);<br>&#125;<br><br><span class="hljs-comment">//组合数公式 就是 - get/(get(n,p) - get(m,p) - get(n-m,p))</span><br><br><span class="hljs-comment">//数组乘质数？</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mul</span><span class="hljs-params">(<span class="hljs-type">int</span> C[],<span class="hljs-type">int</span> p,<span class="hljs-type">int</span> &amp;len)</span></span>&#123;<br>    <span class="hljs-comment">//高精度</span><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        t+=C[i]*p;<br>        C[i] = t%<span class="hljs-number">10</span>;<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(t)&#123;<br>        C[len++] = t%<span class="hljs-number">10</span>;<br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> C[N],len = <span class="hljs-number">1</span>,C[<span class="hljs-number">0</span>]= <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;cnt;i++)&#123;<br>        <span class="hljs-type">int</span> p = prim[i];<br>        <span class="hljs-type">int</span> s = <span class="hljs-built_in">getC</span>(n,m,p);<br>        <span class="hljs-keyword">while</span>(s--) <span class="hljs-built_in">mul</span>(C,p,len); <span class="hljs-comment">//这里算的结果是吗</span><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速幂-求组合数-乘法逆元-不太会"><a href="#快速幂-求组合数-乘法逆元-不太会" class="headerlink" title="快速幂 - 求组合数  - 乘法逆元(不太会)"></a>快速幂 - 求组合数  - 乘法逆元(不太会)</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317190202981.png" alt="image-20230317190202981"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂板子</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> LL;<br><br><span class="hljs-function">LL <span class="hljs-title">qmi</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> p)</span></span>&#123;<br>    LL res = <span class="hljs-number">1</span>%p;<br>    <span class="hljs-comment">//把次数转化成二进制 - 有1就代表有一次</span><br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%p;<br>        a = a*(LL)a%p;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)<br>    &#123;<br>        <span class="hljs-type">int</span> a,b,c;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        cout&lt;&lt;<span class="hljs-built_in">qmi</span>(a,b,c)&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速幂求组合数</span><br><span class="hljs-function">LL <span class="hljs-title">qpow</span><span class="hljs-params">(LL a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    LL res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)&#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) res = res*a%p;<br>        a = a*a%p;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    f[<span class="hljs-number">0</span>] = g[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;N;i++)&#123;<br>        f[i] = f[i<span class="hljs-number">-1</span>]*i%P;<br>        g[i] = g[i<span class="hljs-number">-1</span>]*<span class="hljs-built_in">qpow</span>(i,P<span class="hljs-number">-2</span>)%P;<br>    &#125;<br>    <span class="hljs-function">LL <span class="hljs-title">getC</span><span class="hljs-params">(LL n,LL m)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> f[n]*g[m]%P*g[n-m]%P;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//求出对应的次方 也就是a^b - 也可以用来求乘法逆元 a^(p-2)</span><br><span class="hljs-comment">//乘法逆元原理： a*a^(p-2) = 1(modp) 这样就行 我们要求a的乘法逆元就是a^(p-2)</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qpow</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(b)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(b&amp;<span class="hljs-number">1</span>) ans=<span class="hljs-number">1ll</span>*ans*a%mod;<br>        a=<span class="hljs-number">1ll</span>*a*a%mod;<br>        b&gt;&gt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">qpow</span>(x,mod<span class="hljs-number">-2</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        ans=<span class="hljs-number">1ll</span>*ans*(n-i+<span class="hljs-number">1</span>)%mod;<br>        ans=<span class="hljs-number">1ll</span>*ans*<span class="hljs-built_in">inv</span>(i)%mod;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="递推法-求组合数-杨辉三角形"><a href="#递推法-求组合数-杨辉三角形" class="headerlink" title="递推法 - 求组合数 - 杨辉三角形"></a>递推法 - 求组合数 - 杨辉三角形</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191900241.png" alt="image-20230317191900241"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191910081.png" alt="image-20230317191910081"></p><p><img src="C:\Users\Administrator\Pictures\杨辉三角形.jpg" alt="杨辉三角形"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//杨辉三角形求解组合数</span><br><span class="hljs-comment">//就是 当前这个数据 等于上面的左右数据的加和 - 那么就用动态规划解决这个问题就ok了</span><br><span class="hljs-comment">//但是怎么构造杨辉三角形呢 - 初始化三角形的两条边把</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;N;i++) <span class="hljs-comment">//N是上限 - 底的吗</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j&lt;=i;j++)<br>            <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>) C[i][j] = <span class="hljs-number">1</span>;<span class="hljs-comment">//j是尽头(把三角形当成是二分之一的正方形)</span><br>      <span class="hljs-keyword">else</span> C[i][j] = (C[i<span class="hljs-number">-1</span>][j]+C[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])%mod;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        a[i][<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>        a[i][i]=<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">2</span>;j&lt;=i<span class="hljs-number">-1</span>;j++)<br>        &#123;<br>            a[i][j]=a[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]+a[i<span class="hljs-number">-1</span>][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)<br>        &#123;<br>            cout&lt;&lt;a[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192018240.png" alt="image-20230317192018240"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192035378.png" alt="image-20230317192035378"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h2 id="容斥原理"><a href="#容斥原理" class="headerlink" title="容斥原理"></a>容斥原理</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192341534.png" alt="image-20230317192341534"></p><h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a>高斯消元</h2><h3 id="求解线性方程组"><a href="#求解线性方程组" class="headerlink" title="求解线性方程组"></a>求解线性方程组</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192423405.png" alt="image-20230317192423405"></p><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193339194.png" alt="image-20230317193339194"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193528005.png" alt="image-20230317193528005"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193536881.png" alt="image-20230317193536881"></p><h3 id="中国剩余定理拓展"><a href="#中国剩余定理拓展" class="headerlink" title="中国剩余定理拓展"></a>中国剩余定理拓展</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193608034.png" alt="image-20230317193608034"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193627036.png" alt="image-20230317193627036"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193636294.png" alt="image-20230317193636294"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Four</title>
      <link href="/2023/04/28/Four/"/>
      <url>/2023/04/28/Four/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第四章-图论的拓展"><a href="#第四章-图论的拓展" class="headerlink" title="第四章 - 图论的拓展"></a>第四章 - 图论的拓展</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>基础图论模型<br><span class="hljs-number">2.</span>图论算法<br></code></pre></td></tr></table></figure><p>​  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学习。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>​  要了解上述两个遍历模型，就要了解二叉树。二叉树是图的一种特殊造型，二叉树有两种主要形式：满二叉树和完全二叉树.满二叉树的深度和结点是有关系的，一个深度为k的满二叉树，它的节点数是2^k - 1（每一层是两个，减去我们的头结点就ok了）</p><h4 id="1-完全二叉树"><a href="#1-完全二叉树" class="headerlink" title="1.完全二叉树"></a>1.完全二叉树</h4><p>​  完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数 都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h层，则该层包含 1~ 2^h -1 个节点。（就是叶子结点左边可以不满，其他必须满是这个意思是吗）。</p><p>​        <img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216131827500.png" alt="image-20230216131827500"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉搜索树（建立在完全二叉树的基础之上吗）</span><br>有如下的规则（简单来说，左边的都是小于根节点，右边的都是大于根节点）<br> -若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； <br> -若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；<br> -它的左、右⼦树也分别为⼆叉排序树<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216133015856.png" alt="image-20230216133015856"></p><h4 id="2-平衡二叉搜索树"><a href="#2-平衡二叉搜索树" class="headerlink" title="2.平衡二叉搜索树"></a>2.平衡二叉搜索树</h4><p>平衡⼆叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是 ⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。（高度差 注意是高度差！！！！！）</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216133247245.png" alt="image-20230216133247245"></p><h4 id="3-用数组实现二叉树"><a href="#3-用数组实现二叉树" class="headerlink" title="3.用数组实现二叉树"></a>3.用数组实现二叉树</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216134441813.png" alt="image-20230216134441813"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">⽤数组来存储⼆叉树如何遍历的呢？ 如果⽗节点的数组下表是i，那么它的左孩⼦就是i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>，右孩⼦就是 i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>。 <br>但是⽤链式表⽰的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。<br>所以⼤家要了解，⽤数组依然可以表⽰⼆叉树<br></code></pre></td></tr></table></figure><h4 id="4-二叉树的链式实现"><a href="#4-二叉树的链式实现" class="headerlink" title="4.二叉树的链式实现"></a>4.二叉树的链式实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>  <span class="hljs-type">int</span> val;<br>  TreeNode *left;<span class="hljs-comment">//定义left指针 指向左子树</span><br>  TreeNode *right;<span class="hljs-comment">//right指针 指向右子树</span><br>  <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<span class="hljs-comment">//构造函数  </span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="5-二叉树的遍历步骤"><a href="#5-二叉树的遍历步骤" class="headerlink" title="5.二叉树的遍历步骤"></a>5.二叉树的遍历步骤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//实现递归的三要素</span><br><span class="hljs-number">1.</span> 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。<br><span class="hljs-number">2.</span> 确定终⽌条件： 写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者 终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果 递归没有终⽌，操作系统的内存栈必然就会溢出。<br><span class="hljs-number">3.</span> 确定单层递归的逻辑：<br>确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程<br><span class="hljs-comment">//前序遍历（就是前中后）</span><br><span class="hljs-number">1.</span> 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，<span class="hljs-string">&#x27;所以参数⾥需 要传⼊vector在放节点的数值，除了这⼀点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</span><br><span class="hljs-string">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) //（一个存放的是结构体的指针，一个存放的是存储数据的容器）</span><br><span class="hljs-string">2.确定终⽌条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点 是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</span><br><span class="hljs-string">if (cur == NULL) return;</span><br><span class="hljs-string">3.确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先 取中节点的数值，代码如下：</span><br><span class="hljs-string">vec.push_back(cur-&gt;val); // 中</span><br><span class="hljs-string">traversal(cur-&gt;left, vec); // 左</span><br><span class="hljs-string">traversal(cur-&gt;right, vec); // 右</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123; <br>  <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <br>   vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中</span><br>   <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>   <span class="hljs-comment">// 左 </span><br>   <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <br>   <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <br>   vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-built_in">traversal</span>(root, result); <span class="hljs-keyword">return</span> result;<br> &#125;<br>&#125;;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <br>  <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>  <span class="hljs-comment">// 左 </span><br>  vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中 </span><br>  <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec);<br>  <span class="hljs-comment">// 右</span><br>&#125;<br><br><span class="hljs-comment">//后续遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>  <span class="hljs-comment">// 左 </span><br>  <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <br>  <span class="hljs-comment">// 右</span><br>  vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216135315873.png" alt="image-20230216135315873"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216135326265.png" alt="image-20230216135326265"></p><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="0-前置知识-图的存储"><a href="#0-前置知识-图的存储" class="headerlink" title="0.前置知识 图的存储"></a>0.前置知识 图的存储</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230305080127311.png" alt="image-20230305080127311"></p><h5 id="领接矩阵"><a href="#领接矩阵" class="headerlink" title="领接矩阵"></a>领接矩阵</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.领接矩阵</span><br> 领接矩阵声明，开一个二维数组； <span class="hljs-number">1.</span>二维数组w[u][v],存储u - v的边权（就是这个连线多长）<span class="hljs-number">2.</span>只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）<br>        <span class="hljs-comment">//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系</span><br><br><span class="hljs-type">int</span> w[N][N]; <span class="hljs-comment">//声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c</span><br><span class="hljs-type">int</span> vis[N];<span class="hljs-comment">//点集</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;v&lt;=n;v++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w[u][v]);<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        w[a][b] = c; <span class="hljs-comment">//赋予权值（a点 和 b点）（算是连线）</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230305080154969.png" alt="image-20230305080154969"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//边集数组</span><br><span class="hljs-comment">//结构体下标联系三者</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>()&#123;<br>    <span class="hljs-type">int</span> u,v,w; <span class="hljs-comment">//两点 和 权</span><br>&#125;e[M]; <span class="hljs-comment">//边集合</span><br><span class="hljs-type">int</span> vis[N]; <span class="hljs-comment">//点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> v = e[i].v,w = e[i].w; <span class="hljs-comment">//用结构体中对应的值</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d&quot;</span>,u,v,w); <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//这个点到过了</span><br>        <span class="hljs-built_in">dfs</span>(e[i].v);<span class="hljs-comment">//下一个点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        e[i] = &#123;a,b,c&#125;;<br>        <span class="hljs-comment">//e[i] = &#123;b,a,c&#125;; //无向图就要加上</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="领接表（重点）"><a href="#领接表（重点）" class="headerlink" title="领接表（重点）"></a>领接表（重点）</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302110544398.png" alt="image-20230302110544398"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//领接表（将图用dfs序输出）</span><br>出边数组e[u][i] 存储u点的所有出边&#123;终点 v ， 边权 w&#125;。<br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edga</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//声明结构体（代表每个点有的属性）</span><br>vector&lt;edga&gt; e[N];<span class="hljs-comment">//存储的是每一个起点（有n个）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span>  <span class="hljs-comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u]) <span class="hljs-comment">//遍历当前层的元素</span><br>    &#123;<br>        <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>        <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重（父节点记录父节点是否走过）（u和fa是交替使用的）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d，%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);<span class="hljs-comment">// （u,fa,v,u,v,u.......） //fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）</span><br>    &#125;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//无向图 两边都要连接</span><br>        e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>        e[b].<span class="hljs-built_in">push_back</span>(&#123;c,b&#125;);<br>    &#125;<br>    <span class="hljs-comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>    <br>&#125;<br><span class="hljs-comment">//父节点是相互的，我们用领接表存储的时候，只要连接就是父和子的叠加态（这也解释了为什么可以回溯）</span><br><br></code></pre></td></tr></table></figure><h5 id="链式领接表"><a href="#链式领接表" class="headerlink" title="链式领接表"></a>链式领接表</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302111110291.png" alt="image-20230302111110291"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式领接表</span><br>两个变量：<span class="hljs-number">1.</span>边集数组 <span class="hljs-number">2.</span>表头数组<br><span class="hljs-number">1.</span>边集数组存储的是第几条边的属性：e[j]存储第j条边的&#123;起点u，终点v，边权w&#125;<br><span class="hljs-number">2.</span>表头数组存储的是u点的所有出边的编号：h[u][j](u表示的是当前的点)（j表示的是当前点连接的出边）<br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> u,v,w&#125;;<br>vector&lt;edge&gt; e; <span class="hljs-comment">//边集合（边的属性）</span><br>vector&lt;<span class="hljs-type">int</span>&gt; h[N]; <span class="hljs-comment">//点的所有出边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e.<span class="hljs-built_in">push_back</span>(&#123;a,b,c&#125;); <span class="hljs-comment">// 对应边的属性压入</span><br>    h[a].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">szie</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">//当前边权数组的大小-1（这里的应该是桶数组）    </span><br>&#125;<br><span class="hljs-comment">//u当前节点 fa-父节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;h[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> j = h[u][j];<span class="hljs-comment">//表示的是当前的点？</span><br>        <span class="hljs-type">int</span> v = e[j].v,w = e[j].w;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//邻接表存储数据</span><br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="链式前向星（重点）"><a href="#链式前向星（重点）" class="headerlink" title="链式前向星（重点）"></a>链式前向星（重点）</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302112003101.png" alt="image-20230302112003101"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星 - 用边集数组和领接表结合成的 - （还是不理解）</span><br>数组<span class="hljs-number">1</span>：边集数组 - e[i]存储第i条出边的&#123;终点v,边权w，下一条边ne&#125;<br>数组<span class="hljs-number">2</span>：表头数组 - h[u]存储的是u点的第一条出边的编号（理解为第一条边就可以了）<br>边的编号：由idx分配<br><br><span class="hljs-comment">//输入 变量 1.点的个数 2.边的个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w,ne;&#125;;<span class="hljs-comment">//ne是下一条边</span><br>edge e[M]; <span class="hljs-comment">// 存储的是所有的边</span><br><span class="hljs-type">int</span> idx,h[N]; <span class="hljs-comment">//点的第一条出边（每个点都有）</span><br><span class="hljs-comment">//表头数组相当于给我们一个起点，让我们访问到别的边</span><br><br><span class="hljs-comment">//获取第一个出边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = &#123;b,c,h[a]&#125;; <span class="hljs-comment">// e结构体存储的是这个边的信息</span><br>    <span class="hljs-comment">//这样理解吗 b就是a的出边 - 每次进来的a都会标记 而且idx会变化 不用担心重复</span><br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">//每次添加一条边，都会把这条边的ne指针指向上一次添加的边的编号，这样就形成了一个链表。例如，如果先添加了a到b的边，再添加了a到c的边，那么h[a]就会指向a到c的边的编号，而a到c的边的ne指针就会指向a到b的边的编号，这样就可以通过h[a]和e[i].ne访问到a点的所有出边。</span><br><span class="hljs-comment">//这个函数的最后一个参数是e[idx].ne，表示这条边的下一条边的编号。赋值的是h[a]，表示a点的第一条出边的编号。这样就把这条边和a点的原来的第一条出边连接起来了，形成了一个链表。表头数组只存储了每个点的第一条出边的编号，而不是所有的边。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//横向遍历是为了回溯</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];~i;i=e[i].ne)&#123; <span class="hljs-comment">//~i表示i不等于-1</span><br>        <span class="hljs-type">int</span> v = e[i].v,w = e[i].w;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重 回溯</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);/深入<br>    &#125;    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化表头</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//无向图构图</span><br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <br>&#125;<br><br><span class="hljs-comment">//说人话就是，输入一组数据 a b c。 可以将a点作为出边点 那么b就是出边。重复构建图就是这样</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ai给的例子</span><br>好的，我可以给你举一个例子。假设有一个无向图，有三个点，分别是<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，有三条边，分别是<span class="hljs-number">1</span>到<span class="hljs-number">2</span>，<span class="hljs-number">2</span>到<span class="hljs-number">3</span>，<span class="hljs-number">1</span>到<span class="hljs-number">3</span>。那么输入数据的过程如下：<br><br>输入第一条边<span class="hljs-number">1</span>到<span class="hljs-number">2</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)来添加这条边。<br>此时e[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">1</span>到<span class="hljs-number">2</span>的边的信息，其中v=<span class="hljs-number">2</span>表示终点是<span class="hljs-number">2</span>，w=<span class="hljs-number">0</span>表示权值是<span class="hljs-number">0</span>（这里没有用到），ne=<span class="hljs-number">-1</span>表示没有下一条边。<br>同时h[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>，表示<span class="hljs-number">1</span>点的第一条出边的编号是<span class="hljs-number">0</span>。<br>e[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">2</span>到<span class="hljs-number">1</span>的边的信息。<br>h[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>，表示<span class="hljs-number">2</span>点的第一条出边的编号是<span class="hljs-number">1</span>。<br>输入第二条边<span class="hljs-number">2</span>到<span class="hljs-number">3</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)来添加这条边。<br>此时e[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;，表示从<span class="hljs-number">2</span>到<span class="hljs-number">3</span>的边的信息，其中ne=<span class="hljs-number">1</span>表示下一条边的编号是<span class="hljs-number">1</span>（即从<span class="hljs-number">2</span>到<span class="hljs-number">1</span>的边）。<br>同时h[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>，表示<span class="hljs-number">2</span>点的第一条出边的编号是<span class="hljs-number">2</span>（即从<span class="hljs-number">2</span>到<span class="hljs-number">3</span>的边）。<br>e[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">3</span>到<span class="hljs-number">2</span>的边的信息。<br>h[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>，表示<span class="hljs-number">3</span>点的第一条出边的编号是<span class="hljs-number">3</span>。<br>输入第三条边<span class="hljs-number">1</span>到<span class="hljs-number">3</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)来添加这条边。<br>此时e[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;，表示从<span class="hljs-number">1</span>到<span class="hljs-number">3</span>的边的信息，其中ne=<span class="hljs-number">0</span>表示下一条边的编号是<span class="hljs-number">0</span>（即从<span class="hljs-number">1</span>到<span class="hljs-number">2</span>的边）。<br>同时h[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>，表示<span class="hljs-number">1</span>点的第一条出边的编号是<span class="hljs-number">4</span>（即从<span class="hljs-number">1</span>到<span class="hljs-number">3</span>的边）。<br>e[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>&#125;，表示从<span class="hljs-number">3</span>到<span class="hljs-number">1</span>的边的信息，其中ne=<span class="hljs-number">3</span>表示下一条边的编号是<span class="hljs-number">3</span>（即从<span class="hljs-number">3</span>到<span class="hljs-number">2</span>的边）。<br>同时h[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>，表示<span class="hljs-number">3</span>点的第一条出边的编号是<span class="hljs-number">5</span>（即从<span class="hljs-number">3</span>到<span class="hljs-number">1</span>的边）。<br>这样就完成了输入数据和构建链式前向星存储结构。你明白了吗？<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302112236202.png" alt="image-20230302112236202"></p><h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>dfs算法是一种深度优先搜索算法，它的特点是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。它可以用来解决许多不同类型的问题，如寻找最短路径、搜索树、图等。dfs又被称之为递归，算是一种用暴力方法求解全部点的连通性。这种方法使用于树（树是图的一种，它具有没有环的性质），下面我们用一种简单的二叉树的图进行讨论。</p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216151302883.png" alt="image-20230216151302883"></p><h5 id="1-dfs过程的实现"><a href="#1-dfs过程的实现" class="headerlink" title="1.dfs过程的实现"></a>1.dfs过程的实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>深搜的过程<br>   从根进入，向下走 - 走到底。 无路可走，回溯向上走，绕树根兜圈子，最后从根退出。<br><span class="hljs-number">2.</span>深搜的实现<br>   用系统栈实现的。递归调用的过程，系统自动通过栈去维护函数的状态空间。系统栈记录函数的返回地址，局部变量，参数传递。 向下走 压栈； 向上走，弹栈。 <span class="hljs-comment">// 可以看做 用栈维护不同的序列 - 弹出栈作为新的栈</span><br><span class="hljs-number">3.</span>代码（模板）<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N]; <span class="hljs-comment">// 表示一颗树（或者是图）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:e[N])&#123; <span class="hljs-comment">// v遍历我们的e数组（v变量维护我们的栈）</span><br>    <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 就相当于 在数组中构造树（有标记的数据我们不走?） - 这里才是回溯的重点 - 问ai</span><br>    <span class="hljs-built_in">dfs</span>(v,u);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;n&gt;&gt;m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  i = <span class="hljs-number">1</span>;i&lt;=m;i++)<br>  cin&gt;&gt;a&gt;&gt;b, e[a].<span class="hljs-built_in">push_back</span>(b),e[b] = <span class="hljs-built_in">push_back</span>(a); <span class="hljs-comment">//这个是啥意思</span><br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-number">4.</span>深搜的计算（暂时不想看）<br></code></pre></td></tr></table></figure><h5 id="2-dfs序列"><a href="#2-dfs序列" class="headerlink" title="2.dfs序列"></a>2.dfs序列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>dfs模板（感觉是遍历 这个树hhh）<br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">//这个就是 表示树（宽度 和 深度）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span><span class="hljs-comment">//fa表示树的根结点（醍醐灌顶）</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 整个树的节点个数</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++) <span class="hljs-comment">// 遍历每一个节点</span><br>    &#123;<br>       <span class="hljs-keyword">if</span>(g[u][i]!=fa) <span class="hljs-comment">// u（代表当前层的一个数据）的i(表示下一层的数据)没用过</span><br>        &#123;<br>           <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//加一个辅助数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>  dfs_[++len] = u; <span class="hljs-comment">//遍历的就是当前的父节点 记录一下 （每次走过的就当是根 - 父节点的就可以了）</span><br>  <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>  &#123;<br>     <span class="hljs-keyword">if</span>(g[u][i]!=fa)&#123;<br>        <span class="hljs-built_in">dfs</span>(g[u][i],u);<span class="hljs-comment">//根节点替换</span><br>      &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//实例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//一维数组 可以用作二维数组吗</span><br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dfs_[<span class="hljs-number">200020</span>],len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfs_[++len]=u;  <br>    <span class="hljs-type">int</span> sz=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(g[u][i]!=fa)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>      <span class="hljs-comment">//两个点 不同方向都有一条边</span><br>        <span class="hljs-type">int</span> from,to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);<br>        g[from].<span class="hljs-built_in">push_back</span>(to);<br>        g[to].<span class="hljs-built_in">push_back</span>(from);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dfs_[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs序列作用</span><br><span class="hljs-number">1.</span>子树加权<br>   在dfs序列中，一个结点的子树序列是连续的。 - 看下面的树： abdegcfh 我们关注 b结点 发现b - deg 这一段是连续的，就可以利用差分的操作就行加权。然后我们可以发现B字树B-D-E-G，C子树C-F-H都在一段连续的区间中。那么这有什么好处呢？比如说现在有一道题：给你一颗树，给出m个x和w，意为将x子树中的所有点加上一个权值w，最后询问所有点的权值 - 既然dfs序中x和他的所有子节点都在连续的区间上，那么我们就可以将它简化成差分的问题。比如说给b节点加<span class="hljs-number">2</span>，就可以简化为给b的差分数组+<span class="hljs-number">2</span>，c的差分数组<span class="hljs-number">-2</span> 。（又涉及到了差分数组了）<br>   - 怎么找第一个不在B子树中的点 引入时间戳<br><span class="hljs-number">2.</span>时间戳<br>   作用：记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。（用数组记录时间）<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> x = len+<span class="hljs-number">1</span>;<span class="hljs-comment">//数组拓展</span><br>    s[++len] = ++time; <br>   dfs_[len] = u;<span class="hljs-comment">//存储dfs序列</span><br>   <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>       <span class="hljs-keyword">if</span>(g[u][i] == fa)&#123;<br>          <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>   e[x] = time;<span class="hljs-comment">//存储对应 根节点到子节点的时间区间</span><br>&#125;<br><span class="hljs-comment">//如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。（算导里称之为括号化定理）</span><br></code></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/1188068/201710/1188068-20171027104122883-1380446385.png" alt="img"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230301212454581.png" alt="image-20230301212454581"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dfs_[<span class="hljs-number">200020</span>],len,time,s[<span class="hljs-number">200020</span>],e[<span class="hljs-number">200020</span>],pos[<span class="hljs-number">200020</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=len+<span class="hljs-number">1</span>;<br>    s[++len]=++time;<span class="hljs-comment">//当前点 时间起点</span><br>    dfs_[len]=u;<br>    pos[u]=len;<br>    <span class="hljs-type">int</span> sz=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(g[u][i]!=fa)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>    e[x]=time;<span class="hljs-comment">//时间终点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>  <span class="hljs-comment">//输入我们的树</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>   <span class="hljs-comment">//这段代码读入树中的边并将它们存储在邻接表 g 中。对于每条边，它都读入两个整数 from 和 to，表示边的两个端点。然后，它将 to 添加到 g[from] 的末尾，并将 from 添加到 g[to] 的末尾。这样，对于每个节点，其邻接表中都存储了与其相连的所有节点。</span><br>    &#123;<br>      <span class="hljs-comment">//用邻接表表示树</span><br>        <span class="hljs-type">int</span> from,to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);<br>        g[from].<span class="hljs-built_in">push_back</span>(to);<br>        g[to].<span class="hljs-built_in">push_back</span>(from);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        x=pos[x];<br>        y=pos[y];<br>        <span class="hljs-keyword">if</span>(s[x]&lt;=s[y]&amp;&amp;e[y]&lt;=e[x])<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//邻接表是一种常用的表示图的数据结构，它在存储稀疏图（即边数远小于节点数平方的图）时非常高效。邻接表通过为每个节点维护一个列表来存储与其相连的所有边，因此它只需要存储 2m 个整数（其中 m 是边数），空间复杂度为 O(m)。此外，使用邻接表可以快速访问与给定节点相连的所有边，时间复杂度为 O(度数)。当然，邻接表也有一些缺点。例如，它不适用于存储稠密图（即边数接近节点数平方的图），因为这样会浪费大量空间。此外，使用邻接表判断两个节点之间是否存在边需要遍历其中一个节点的邻接表，时间复杂度为 O(度数)，不如使用邻接矩阵来得快。</span><br></code></pre></td></tr></table></figure><h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><h5 id="0-前置知识：队列"><a href="#0-前置知识：队列" class="headerlink" title="0.前置知识：队列"></a>0.前置知识：队列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//队列是一种先进先出的线性表，它只允许在一端插入元素，另一端删除元素1。队列可以用数组或者链表来实现23。队列的常见操作有入队（enqueue），出队（dequeue），获取队首元素（peek），判断队列是否为空（isEmpty）等</span><br><br><span class="hljs-comment">//在bfs中： 队列的作用是存储待访问的顶点，保证按照图的宽度优先的顺序进行遍历。队列可以帮助我们记录当前层的顶点和下一层的顶点，从而找到最短路径或者最优解。队列也可以避免重复访问已经遍历过的顶点，提高搜索效率。</span><br><br><span class="hljs-comment">//1.用数组模拟队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> hh,tt; <span class="hljs-comment">//定义队头和队尾的下标 初始化 hh = 0,tt = -1;</span><br><br><span class="hljs-comment">//向队尾插入一个元素 x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    q[++tt] = x; <span class="hljs-comment">//理解tt是向右边延伸的</span><br>&#125;<br><br><span class="hljs-comment">//从队头弹出一个数（） - 队列先进先出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    hh++;<br>&#125;<br><br><span class="hljs-comment">//查询队头元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> q[hh];<br>&#125;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> hh &gt; tt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//输入操作次数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        string op; <span class="hljs-comment">//输入操作类型</span><br>        cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">//输入操作参数</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;push&quot;</span>) &#123; <span class="hljs-comment">//如果是入队操作</span><br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;pop&quot;</span>) &#123; <span class="hljs-comment">//如果是出队操作</span><br>            <span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;empty&quot;</span>) &#123; <span class="hljs-comment">//如果是判断空操作</span><br>            cout &lt;&lt; (<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果是查询对头操作</span><br>            cout &lt;&lt; <span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br><span class="hljs-comment">//2.用stl实现队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">//引入STL中的queue头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//定义一个int类型的队列q</span><br><br><span class="hljs-comment">//向队尾插入一个元素x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//调用STL中的push函数</span><br>&#125;<br><br><span class="hljs-comment">//从对头弹出一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//调用STL中的pop函数</span><br>&#125;<br><br><span class="hljs-comment">//查询对头元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//调用STL中的front函数</span><br>&#125;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//调用STL中的empty函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//输入操作次数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        string op; <span class="hljs-comment">//输入操作类型</span><br>        cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">//输入操作参数</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;push&quot;</span>) &#123; <span class="hljs-comment">//如果是入队操作</span><br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;pop&quot;</span>) &#123; <span class="hljs-comment">//如果是出队操作</span><br>            <span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;empty&quot;</span>) &#123; <span class="hljs-comment">//如果是判断空操作</span><br>            cout &lt;&lt; (<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果是查询对头操作</span><br>            cout &lt;&lt; <span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="1-bfs算法模版"><a href="#1-bfs算法模版" class="headerlink" title="1.bfs算法模版"></a>1.bfs算法模版</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230216163555284.png" alt="image-20230216163555284"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230310225256235.png" alt="image-20230310225256235"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230310225331114.png" alt="image-20230310225331114"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码模版</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<span class="hljs-comment">//存储的领接表 - 输入的时候的数据</span><br><span class="hljs-type">int</span> vis[N];<span class="hljs-comment">//标记该点是否遍历过</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//起点标记 和 起点入队</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 这里可以打印 bfs 序列</span><br>        <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;endl;</span><br>        <br>        <span class="hljs-comment">//这一段是遍历e[x]中的所有相邻点y，如果y已经被访问过，就跳过，否则就标记为已访问，并把y入队，表示下一次要访问y的相邻点。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y: e[x])&#123;<br>            <span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;<br>            vis[y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//入队 - 起点连接的下一层出队</span><br>            <span class="hljs-comment">//cout&lt;&lt;y&lt;&lt;endl;</span><br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-bfs序列（树与图的遍历）"><a href="#2-bfs序列（树与图的遍历）" class="headerlink" title="2. bfs序列（树与图的遍历）"></a>2. bfs序列（树与图的遍历）</h5><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230310225353381.png" alt="image-20230310225353381"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bfs搜索树</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> vis[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//出队的元素 （这里输出就是bfs树）</span><br>        <span class="hljs-comment">//printf(&quot;%d\n&quot;,x);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:e[x])&#123;<br>            <span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;<br>            vis[y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 入队 &quot;</span>，y); <span class="hljs-comment">//伪代码</span><br>            q.<span class="hljs-built_in">push</span>(y); <span class="hljs-comment">//搜索同层序的 入队吗</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230310225411526.png" alt="image-20230310225411526"></p><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302193314874.png" alt="image-20230302193314874"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302195721755.png" alt="image-20230302195721755"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302195739338.png" alt="image-20230302195739338"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302195757415.png" alt="image-20230302195757415"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说就是 按照 前面点最少的顺序排序（也就是入度从小到大）</span><br><span class="hljs-number">1.</span>Kahn算法<br>   起点是从入度为<span class="hljs-number">0</span>的点开始的（这样才能入度从小到大），使用队列来维护我们的点；<span class="hljs-number">1.</span>初始化：将所有入度为<span class="hljs-number">0</span>的点压入我们的队列（顺序不重要）；<span class="hljs-number">2.</span>每次从q中取出一个点x放入数组tp（存储最终序列）；<span class="hljs-number">3.</span>将x的所有出边删除：这个时候的x是队头，边被删除那么对应的连接点的入度就变成<span class="hljs-number">0</span>，就可以压入队列；<span class="hljs-number">4.</span>重复<span class="hljs-number">23</span>步骤。<span class="hljs-number">5.</span>如果tp中的数据和我们的点的数量一样，那么就有拓扑序列，如果不一样，那就没有。（有向 无环图才有拓扑序列）<br><span class="hljs-comment">//***</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N],tp;<span class="hljs-comment">//tp是我们最终输出的拓扑序列</span><br><span class="hljs-type">int</span> din[N]<span class="hljs-comment">//存储着点的入度（画图是不是要用领接表）</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//让入度0的进入队伍</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(din[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// din数组记录的是入度</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//让队头出栈 并且删除对应的边</span><br>        tp.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:e[N])&#123;<br>            <span class="hljs-keyword">if</span>(--din[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<span class="hljs-comment">//删除对应的边 并且让对应的数据入队</span><br>        &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> tp.<span class="hljs-built_in">size</span>() = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        e[a].<span class="hljs-built_in">push_back</span>(b);<br>        din[b]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">toposort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>) ; <span class="hljs-comment">//如果数量不满足 则说明这个不是拓扑序列</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:tp) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,x); <span class="hljs-comment">//将拓扑序列输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs求拓扑序列(变色法)</span><br><span class="hljs-comment">//不懂翻转序列</span><br><span class="hljs-number">1.</span>染色法（yxc用的）<br>    每个点的颜色都会变化，从<span class="hljs-number">0</span> - <span class="hljs-number">-1</span> - <span class="hljs-number">1</span>，经历三次变色；<span class="hljs-number">1.</span>初始状态，所有点染色为<span class="hljs-number">0</span>；<span class="hljs-number">2.</span>枚举每一个点，进入x点（是我们的指针），把x染色为<span class="hljs-number">-1</span>，枚举x的儿子y，如果y的颜色为<span class="hljs-number">0</span>，那么说明没碰过该点，进入y继续走（这里应该是检测有无环 - 会不会回到x）；<span class="hljs-number">3.</span>如果枚举完x（当前数据 - 也算是队头）的儿子，将x压入tp数组；<span class="hljs-number">4.</span>如果发现，有<span class="hljs-number">-1</span>的出现（那么就是有环出现了），返回<span class="hljs-literal">false</span>，退出。<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N],tp;<span class="hljs-comment">//e[N] 应该是树，，或者是领接表画的图</span><br><span class="hljs-type">int</span> c[N]; <span class="hljs-comment">//染色数组</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    c[x] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:e[x])&#123;<br>        <span class="hljs-keyword">if</span>(c[y]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//有环</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    c[x] = <span class="hljs-number">1</span>;<br>    tp.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//当前这个数据遍历完成 压入我们的tp数组</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c)); <span class="hljs-comment">// 初始化 - 刚开始全部点的颜色为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;x&lt;=n;x++)<br>        <span class="hljs-keyword">if</span>(!c[x])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(x)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">reverse</span>(tp.<span class="hljs-built_in">begin</span>(),tp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//翻转序列 为啥？</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Dijkstra-最短路算法"><a href="#Dijkstra-最短路算法" class="headerlink" title="Dijkstra - 最短路算法"></a>Dijkstra - 最短路算法</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302202401928.png" alt="image-20230302202401928"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302204100958.png" alt="image-20230302204100958"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说：就是每次选择最短路线进行前进（画最小生成树）</span><br>三个数组： <span class="hljs-number">1.</span>e[u] 存储节点u的所有出边的终点和边权 <span class="hljs-number">2.</span>d[u] 存储u到源点的最小距离（源点就是当前连边的点）（d[u]需要遍历）<span class="hljs-number">3.</span>vis[u] 标记是否出圈<br>    <span class="hljs-number">1.</span>初始的时候，所有点都在圈中，vis = <span class="hljs-number">0</span>,d[s] = <span class="hljs-number">0</span>,d[其他点] = 正无穷<br>    <span class="hljs-number">2.</span>从圈中选择一个距离最小的点，u，打标记出圈（贪心）<br>    <span class="hljs-number">3.</span>对u的所有出边执行松弛操作 - 尝试更新邻点v的最小距离<br>    <span class="hljs-number">4.</span>重复<span class="hljs-number">2</span>,<span class="hljs-number">3</span>操作，直到圈内为空<br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">struct</span> edge&#123;<span class="hljs-type">int</span> v,w;&#125;;<span class="hljs-comment">//点 和 权</span><br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//边</span><br><span class="hljs-type">int</span> d[N],vis[N];<span class="hljs-comment">//d数组是存储当前点的最小距离 - vis标记当前集合中的点（有没有调用这个点）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<span class="hljs-comment">//初始化 全部点的距离都为无穷大</span><br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//枚举每个点 内部枚举全部的点比较他们的距离大小（选最小的边权） - 就是每个点都要比较它自身和其它点的距离关系  （图遍历就是两层 for的）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//枚举全部点（包括自身）</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="hljs-comment">//如果这个点没被测过 并且 当前边权小</span><br>        <br>        vis[u] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记u点（下次就选不到了）</span><br>        <span class="hljs-comment">//遍历全部的点 v点的距离更新为最短的点 ed是迭代器：用处是迭代全部的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<span class="hljs-comment">//无穷大 &gt; 其他（这样来筛数据）</span><br>                d[v] = d[u]+w;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//领接表插入图</span><br>        e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<span class="hljs-comment">//点 连接点 边权</span><br>    &#125;    <br>    <span class="hljs-built_in">dijkstra</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302204110774.png" alt="image-20230302204110774"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302205328621.png" alt="image-20230302205328621"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆优化 - 用优先队列维护别更新点的集合。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N];<br><span class="hljs-comment">//优先队列</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-comment">//大根堆（把距离取负值） - 距离最小的元素最大 - 一定在堆顶（懂了 距离从小到大优化）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.全部点的距离都是无穷大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>; q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-comment">//自己和自己距离为0</span><br>    <span class="hljs-comment">//2.枚举进入队列中的数据</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//u是点吗</span><br>        <span class="hljs-type">int</span> u = t.second;<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重</span><br>        vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//之前忘记标记出队了</span><br>        <span class="hljs-comment">//当前点 遍历全部点 出来的边权最小的数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                d[v] = d[u]+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v],v&#125;); <span class="hljs-comment">//大根堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302205410861.png" alt="image-20230302205410861"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//就是两个模板 优化的地方就是枚举的时候用队列维护</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N]; <span class="hljs-comment">//边 和 点</span><br><span class="hljs-comment">//s是起点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//无穷大的值</span><br>    d[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">//对于自己和自己的距离当然是0了</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//枚举次数</span><br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//优化 就是把这里优化了 取消了枚举全部点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++) <span class="hljs-comment">//枚举点</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j;<br>        vis[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123; <span class="hljs-comment">//ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）</span><br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w) &#123;<br>                d[v] = d[u]+w;<br>                q.<span class="hljs-built_in">push_back</span>(&#123;-d[v],v&#125;);<span class="hljs-comment">//插入到 大根堆上</span><br>            &#125;<br>        &#125;            <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230302205417632.png" alt="image-20230302205417632"></p><h3 id="Bellman-Ford-处理负权边的最短路算法"><a href="#Bellman-Ford-处理负权边的最短路算法" class="headerlink" title="Bellman-Ford  - 处理负权边的最短路算法"></a>Bellman-Ford  - 处理负权边的最短路算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//llman-Ford 算法是一种用于求解带权图中单源最短路径的算法，可以处理负权边，但不能处理负权环。</span><br> 它的时间复杂度为 $<span class="hljs-built_in">O</span>(VE)$，其中 $V$ 是顶点数，$E$ 是边数。Bellman-Ford 算法的基本思想是对所有的边进行 $V<span class="hljs-number">-1</span>$ 轮松弛操作，以求出所有可能的最短路径。如果在第 $V$ 轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。<br>    <br><span class="hljs-comment">//Bellman-Ford算法是一种用于计算带权有向图中单源最短路径的算法。</span><br>    它由Richard Bellman和Lester Ford分别在<span class="hljs-number">1958</span>年和<span class="hljs-number">1956</span>年发表，而实际上Edward F. Moore也在<span class="hljs-number">1957</span>年发布了相同的算法，因此，此算法也常被称为Bellman-Ford-Moore算法<span class="hljs-number">1</span>。它比Dijkstra的算法慢，但更通用，因为它能够处理边权值为负数的图<span class="hljs-number">2</span>。<br><br><span class="hljs-comment">//单源最短路</span><br>    单源最短路问题是图论中的一个基本问题，它指的是给定一张有权图，如何求某两点之间的最短路径<span class="hljs-number">1</span>。解决这个问题的算法有很多，比如Dijkstra算法和Bellman-Ford算法等。<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230304212846831.png" alt="image-20230304212846831"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230304210834724.png" alt="image-20230304210834724"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230304212028882.png" alt="image-20230304212028882"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//目的是算出图中的最短路（单源最短路：是指在一个图中，给你一个起点（起点固定），然后终点不是固定的，求起点到任意终点的最短路径）</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//这里是 点 和 权</span><br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-comment">//内部变量是起点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellmanford</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化边集</span><br>    <span class="hljs-built_in">memset</span>(d,inf,<span class="hljs-keyword">sizeof</span> d);<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//标记</span><br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//n轮更新</span><br>        flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">//标记（看有无更新）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>;u&lt;=n;u++)&#123; <span class="hljs-comment">//每个点枚举出边</span><br>            <span class="hljs-keyword">if</span>(d[u] == inf) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//枚举u的领点 就行松弛操作</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123; <span class="hljs-comment">//u的出边</span><br>                <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>                <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                    d[v] = d[u] + w;<br>                    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//更新完成 就变true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//没有更新就退出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> flag; <span class="hljs-comment">//第n轮 = true 那么说明就有环    </span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spfa-算法-用bf就好了"><a href="#spfa-算法-用bf就好了" class="headerlink" title="spfa 算法 - 用bf就好了"></a>spfa 算法 - 用bf就好了</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">SPFA 算法是Bellman-Ford算法的队列优化算法的别称，通常用于求含负权边的单源最短路径，以及判负权环。SPFA 最坏情况下复杂度和朴素Bellman-Ford相同，为<span class="hljs-built_in">o</span>(VE).<br><span class="hljs-comment">//其实还不如直接用Bellman-ford</span><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230304212218685.png" alt="image-20230304212218685"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230304212529352.png" alt="image-20230304212529352"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230304212738052.png" alt="image-20230304212738052"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆优化 bellman 算法 - spfa算法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//点集合</span><br><span class="hljs-type">int</span> d[N],cnt[N],vis[N]; <span class="hljs-comment">//边 边数 开关</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//队列</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,inf,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集</span><br>    d[s] = <span class="hljs-number">0</span>; vis[s] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(s); <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//这里是将前面初始化的点操作的地方，每次都只操作一个点</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>(); vis[u] = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v , w = ed.w;<br>            <span class="hljs-comment">//比较枚举点和当前点 的长度 更新最短值</span><br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                d[v] = d[u]+w;<br>                cnt[v] = cnt[u]+<span class="hljs-number">1</span>; <span class="hljs-comment">//记录边数</span><br>                <span class="hljs-keyword">if</span>(cnt[v]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!vis[v]) q.<span class="hljs-built_in">push</span>(v),vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Floyd算法-点到点的最短路"><a href="#Floyd算法-点到点的最短路" class="headerlink" title="Floyd算法 - 点到点的最短路"></a>Floyd算法 - 点到点的最短路</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230307160057133.png" alt="image-20230307160057133"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230307160205801.png" alt="image-20230307160205801"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230307160839691.png" alt="image-20230307160839691"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）</span><br><span class="hljs-comment">// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）</span><br><br><span class="hljs-comment">//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k;k&lt;=n;k++) <span class="hljs-comment">//以k为桥(k枚举的是所有点)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span> ;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>                d[i][j] = <span class="hljs-built_in">mid</span>(d[i][j],d[i][k]+d[k][j]); <span class="hljs-comment">//二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230307161152125.png" alt="image-20230307161152125"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//路径记录原理不了解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">fill</span>(d[<span class="hljs-number">0</span>],d[<span class="hljs-number">0</span>]+N*N,<span class="hljs-number">0x3f3f3f3f</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) d[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b],c);<br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> a,b; cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(d[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230307161434260.png" alt="image-20230307161434260"></p><h3 id="最小生成树-prim算法"><a href="#最小生成树-prim算法" class="headerlink" title="最小生成树 - prim算法"></a>最小生成树 - prim算法</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230308192754299.png" alt="image-20230308192754299"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有优化版本 - 基于贪心算法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N];<span class="hljs-comment">//d是边的长度 </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="hljs-comment">//排除选过的点 - 这里是选领点的（懂了）</span><br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans+=d[u];<span class="hljs-comment">//边权和（最小生成树的边权和）</span><br>        <span class="hljs-keyword">if</span>(d[u]!=inf) cnt++; <span class="hljs-comment">//判断是否联通</span><br>        <span class="hljs-comment">//遍历到u这个点（u之前的也是一起的，算是连续的）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;w)&#123;<br>                d[v] = w;   <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n; <span class="hljs-comment">//返回true就是有最小生成树的 返回false</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230308110618789.png" alt="image-20230308110618789"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。</span><br><span class="hljs-type">int</span> n,m,s,a,b,c,ans,cnt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//构造一个结构体 内部有点和边的属性</span><br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//领点（也算是所有点？）</span><br><span class="hljs-type">int</span> d[N],vis[N];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">//这里创一个优先队列（就是堆）</span><br><span class="hljs-comment">//s是起点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf; <span class="hljs-comment">//先初始化全部的边 - 每个边都是无穷大</span><br>    <span class="hljs-comment">//起点</span><br>    d[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//取出q队列的点？ - 后面有进入点？</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>; <br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans+=d[u]; cnt++;<br>        <span class="hljs-comment">//这里应该就是插入 领点的步骤</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;w)&#123;<br>                d[v] = w; <span class="hljs-comment">//对应点v边权最小的边</span><br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v],v&#125;);<span class="hljs-comment">//大根堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n; <span class="hljs-comment">//这里判断的是啥？</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230308110724388.png" alt="image-20230308110724388"></p><h3 id="最小生成树-克鲁斯卡尔算法-并查集"><a href="#最小生成树-克鲁斯卡尔算法-并查集" class="headerlink" title="最小生成树 - 克鲁斯卡尔算法 - 并查集"></a>最小生成树 - 克鲁斯卡尔算法 - 并查集</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230308125205044.png" alt="image-20230308125205044"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230308125225033.png" alt="image-20230308125225033"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">克鲁斯卡尔算法（Kruskal）是一种使用贪婪方法的最小生成树算法。该算法初始将图视为森林，图中的每一个顶点视为一棵单独的树。一棵树只与它的邻接顶点中权值最小且不违反最小生成树属性（不构成环）的树之间建立连边。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>,M=<span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//结构体存储边的信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;e[M];<br><span class="hljs-comment">//比较函数 （用来作为排序算法的参数）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge x,edge y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.w&lt;y.w;<br>&#125;<br><span class="hljs-comment">//并查集</span><br><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);<br>    <span class="hljs-comment">//排序边权（我们是用贪心来筛选的）</span><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-comment">//每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）</span><br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a),b=<span class="hljs-built_in">find</span>(e[i].b),w=e[i].w;<br>        <span class="hljs-comment">//查一下是否是连通块</span><br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            <span class="hljs-comment">//纳入后宫</span><br>            p[a]=b;<br>            res+=w;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//成树</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<span class="hljs-comment">//输出边权</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230308100226384.png" alt="image-20230308100226384"></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图*"></a>染色法判断二分图*</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314143817025.png" alt="image-20230314143817025"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//染色法判断二分图</span><br>首先随机选择一个未染色的顶点，将其染成红色或蓝色（或其他任意两种不同颜色）。<br>然后将与该顶点相邻的所有顶点染成与其不同的颜色。<br>重复上述过程，直到所有顶点都被染色或者发现某个顶点和它相邻的顶点已经被染成了相同的颜色。<br>如果所有顶点都被染色，那么这个图就是二分图；如果发现有冲突，那么这个图就不是二分图。<br><br><span class="hljs-comment">//二分图</span><br>二分图是图论中的一种特殊模型，它的定义是<span class="hljs-number">1234</span>：如果一个无向图的顶点集可以分成两个互不相交的子集，使得每条边的两个端点分别属于这两个子集，那么这个无向图就是二分图。例如，下图就是一个二分图：<br>    A   B   C<br>    | / | / |<br>    D   E   F<br>就是映射是吧，两个不同的集合中有连边，相同集合的不连边<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断此图是否是二分图</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,M = <span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],e[N],ne[M],idx; <span class="hljs-comment">//e是点集 ne是边集</span><br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">//存储每一个点的状态 一共有三种 起始0 染色 1 - 2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b, ne[idx] = h[a],h[a] = idx++; <span class="hljs-comment">//把h[a]理解为前面的桶形数组就好了</span><br>&#125;<br><span class="hljs-comment">//每次访问一个顶点u，就会先递归地访问它的所有邻接点，直到没有未访问的邻接点为止，</span><br><span class="hljs-comment">//然后再回溯到上一层。这样可以保证每个连通分量内的顶点都被染色。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c; <span class="hljs-comment">//c是什么意思 - 是当前点的染色状态 （只有三种 0 1 2 用3减去就前后不一样了）</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i;i = ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">//邻点</span><br>        <span class="hljs-keyword">if</span>(!color[j])&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(j,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//这个是递归地调用dfs函数，给顶点j和它的邻接点染色，并判断是否有冲突。</span><br>        <span class="hljs-comment">//如果返回false，就说明发现了不符合二分图的情况，就返回false。</span><br>        <span class="hljs-comment">//冲突是指同一个子集内的顶点颜色相同，或者不同子集内的顶点颜色不同。</span><br>        <span class="hljs-comment">//这些情况都不满足二分图的定义，所以要返回false。</span><br>            &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果顶点j已经被染色，并且与u的颜色相同，就说明同一个子集内有边相连，不符合二分图的定义，就返回false。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a); <span class="hljs-comment">//无向图</span><br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!color[i])<br>        &#123;<br>           <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))<br>           &#123;<br>               flag = <span class="hljs-literal">false</span>;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>        &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314144148781.png" alt="image-20230314144148781"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314144232392.png" alt="image-20230314144232392"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>; <span class="hljs-comment">// 顶点数的最大值</span><br><span class="hljs-type">int</span> n1, n2; <span class="hljs-comment">// 二分图左右两边的顶点数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; g[N]; <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-type">int</span> match[N]; <span class="hljs-comment">// match[i]表示右边第i个点当前匹配的左边的点</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// st[i]表示右边第i个点是否已经被遍历过</span><br><br><span class="hljs-comment">// 在二分图中寻找增广路</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g[x].<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> j = g[x][i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求二分图最大匹配数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n1 &gt;&gt; n2;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">// 边数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大匹配数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res++;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法*"></a>匈牙利算法*</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314205307317.png" alt="image-20230314205307317"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>匈牙利算法 - 二分图的最大匹配<br> 二分图，简单来说就是不同集合有联系；同一集合不可以有联系； - 边数最多的一组匹配被称之为最大匹配<br> 在二分图的前提下： <span class="hljs-number">1.</span>交替路 <span class="hljs-number">2.</span>增广路  - 交替路就是匹配和不匹配边交替出现 - 增光路就是匹配和不匹配交换身份，看有没有多路径，多了就是增广路<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m,k,a,b,ans,idx;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,ne;&#125;e[M]; <span class="hljs-comment">//点（对应位置的妹子） ne 另一集合的点是吗</span><br><span class="hljs-type">int</span> h[N],idx;<br><span class="hljs-type">int</span> vis[N],match[M]; <span class="hljs-comment">//标记 和 匹配</span><br><br><span class="hljs-comment">//链式前向星</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++idx] = &#123;b,h[a]&#125;;<br>    h[a] = idx++; <span class="hljs-comment">//横置数组向右移动</span><br>&#125;<br><span class="hljs-comment">//男女匹配问题 (boy and girl）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">//每一个都要匹配看看</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i;i = e[i].ne)&#123;<br>        <span class="hljs-type">int</span> v = e[i].v; <span class="hljs-comment">//妹子</span><br>        <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记</span><br>        <span class="hljs-keyword">if</span>(!match[v]||<span class="hljs-built_in">dfs</span>(match[v]))&#123; <span class="hljs-comment">//没有匹配 || 能不能换（dfs的功能就是判断能不能换）</span><br>            match[v] = u;<span class="hljs-comment">//成对</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++) cin&gt;&gt;a&gt;&gt;b,<span class="hljs-built_in">add</span>(a,b); <span class="hljs-comment">//建图</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) ans++;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="染色法判断二分图-1"><a href="#染色法判断二分图-1" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315104701595.png" alt="image-20230315104701595"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315123714291.png" alt="image-20230315123714291"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.二分图的定义</span><br> 两个不同的集合，互相联通 - 相同集合不可能联通<br><span class="hljs-comment">//2.染色法</span><br>    可以用dfs和bfs来实现染色法，重点是怎么实现前后颜色不同。 我们运用两个标记来判断对应节点的状态： <span class="hljs-number">1</span> 表示这个节点是红 <span class="hljs-number">2</span>表示是黑 <span class="hljs-number">0</span>表示没选这个（加上个判重）<br>   <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,ne;&#125;e[M];<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">//颜色有三种 0 1 2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++idx] = &#123;b,h[a]&#125;; <span class="hljs-comment">//用链式前向星存储的</span><br>    h[a] = idx++;<br>&#125;<br><span class="hljs-comment">//u点的颜色c </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-comment">//枚举u的领边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];i;e[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span>(!color[v])&#123; <span class="hljs-comment">//还没有被访问</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(v,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//改变不同层的颜色</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[v] == c) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;   <br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        <span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!color[i])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))&#123;<br>                flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//有奇环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314142804998.png" alt="image-20230314142804998"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314143439093.png" alt="image-20230314143439093"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314143503237.png" alt="image-20230314143503237"></p><h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a><a href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">最近公共祖先</a></h3><h4 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230319121246852.png" alt="image-20230319121246852"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; tree[MAXN]; <span class="hljs-comment">// 邻接表存储树</span><br><span class="hljs-type">int</span> depth[MAXN], parent[MAXN]; <span class="hljs-comment">// 深度和父亲节点</span><br><br><span class="hljs-comment">// 深度优先搜索遍历计算深度和父亲节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    depth[u] = depth[p] + <span class="hljs-number">1</span>;<br>    parent[u] = p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : tree[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v != p) <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算两个节点的最近公共祖先</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (depth[u] &gt; depth[v]) u = parent[u];<br>    <span class="hljs-keyword">while</span> (depth[v] &gt; depth[u]) v = parent[v];<br>    <span class="hljs-keyword">while</span> (u != v) &#123;<br>        u = parent[u];<br>        v = parent[v];<br>    &#125;<br>    <span class="hljs-keyword">return</span> u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 读入节点数和查询数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 读入边</span><br>        tree[u].<span class="hljs-built_in">push_back</span>(v);<br>        tree[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 计算深度和父亲节点</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 读入查询</span><br>        cout &lt;&lt; <span class="hljs-built_in">lca</span>(u, v) &lt;&lt; endl; <span class="hljs-comment">// 输出结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>这个模板中，n 是树的节点数，m 是查询数量。对于每组查询，它读入两个节点编号 u 和 v，然后调用函数 <span class="hljs-built_in">lca</span>(u,v) 来获取它们的最近公共祖先。<br></code></pre></td></tr></table></figure><h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230314144355261.png" alt="image-20230314144355261"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Tarjan算法是由Robert Tarjan发明的一种图算法。它可以用于解决许多不同类型的问题，包括寻找强连通分量、双连通分量、割点和割边等。其中一种应用是在树中查找节点对的最近公共祖先（LCA）。Tarjan算法通过深度优先搜索和并查集数据结构来高效地解决这个问题。</span><br><br><span class="hljs-comment">//tarjan算法 ： 利用并查集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; query[N];<br><span class="hljs-type">int</span> fa[N],vis[N],ans[M];<br><span class="hljs-comment">//并查集</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == fa[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">return</span> fa[u] = <span class="hljs-built_in">find</span>(fa[u]);    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    fa[u] = u; <span class="hljs-comment">// 初始化父亲为自己</span><br>    vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[v])&#123;<br>            tarjan[v];<br>            fa[v] = u;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q:query[u])&#123;<br>        <span class="hljs-type">int</span> v = q.first,i = q.second;<br>        <span class="hljs-keyword">if</span>(vis[v]) ans[i] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树链剖分-不理解"><a href="#树链剖分-不理解" class="headerlink" title="树链剖分(不理解)"></a>树链剖分(不理解)</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315210121556.png" alt="image-20230315210121556"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315210610462.png" alt="image-20230315210610462"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> fa[N],dep[N],son[N],sz[N];<br><span class="hljs-type">int</span> top[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> father)</span></span>&#123;<br>    fa[u] = father, dep[u] = dep[father]+<span class="hljs-number">1</span>,sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v==father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(v,u);<br>        sz[u] += sz[v];<br>        <span class="hljs-keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u] = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    top[u] = t;<br>    <span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[u],t);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v,v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<br>        <span class="hljs-keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="hljs-built_in">swap</span>(u,v);<br>        u = fa[top[u]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dep[u]&lt;dep[v]?u:v;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="倍增算法（不理解）"><a href="#倍增算法（不理解）" class="headerlink" title="倍增算法（不理解）"></a>倍增算法（不理解）</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315210919875.png" alt="image-20230315210919875"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315210938761.png" alt="image-20230315210938761"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315210958755.png" alt="image-20230315210958755"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure><h4 id="总"><a href="#总" class="headerlink" title="总"></a>总</h4><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230315210622550.png" alt="image-20230315210622550"></p><h2 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树*"></a>线段树*</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230401100823894.png" alt="image-20230401100823894"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230401100840271.png" alt="image-20230401100840271"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230401100850209.png" alt="image-20230401100850209"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230401100859800.png" alt="image-20230401100859800"></p><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230401100913730.png" alt="image-20230401100913730"></p><h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组*"></a>树状数组*</h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Question</title>
      <link href="/2023/04/28/Question/"/>
      <url>/2023/04/28/Question/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      
      
      
        <tags>
            
            <tag> 每日一题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Three 基本数据结构</title>
      <link href="/2023/04/27/Three/"/>
      <url>/2023/04/27/Three/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第三章-数据结构"><a href="#第三章-数据结构" class="headerlink" title="第三章 - 数据结构"></a>第三章 - 数据结构</h2><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230420172340030.png" alt="image-20230420172340030"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>基本数据结构<br>    链表 - 栈和堆 - 队列 - 哈希表的使用 - 并查集 - 字典树 - kmp - <br><span class="hljs-number">2.</span>离散数学基本知识<br><span class="hljs-number">3.</span>线段树<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote><p><a href="https://blog.51cto.com/u_15018701/2616916">链表看这一篇就够了</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//个人学习的时候并不是很了解，就是，将一些没有联系的数据串起来。这样可以用当前的数据访问到下一个数据或者上一个数据。可以理解成为，数存储在一个数组中，然后我们再声明一个数组，存储着这些数据的位置。</span><br>就像火车一样，每一节车厢中装载的货物，和每一节车厢的编号两者互相独立，但是又互相联系；关系就仅仅是位置上的对应关系而已。<br>       <br>   <span class="hljs-comment">//链表是一种递归的数据结构，他或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</span><br>链表是一种常见且基础的数据结构，是一种线性表，但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址。我们也可以这样理解，链表是通过指针串联在一起的线性结构，每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向null。也就是我们所说的空指针。<br></code></pre></td></tr></table></figure><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><img src="/2023/04/27/Three/format.webp" alt="单链表图解"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.单链表</span><br> 一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。我们通过上面说到的可视化表示方法，将单链表可视化，如上图所示。<br><span class="hljs-comment">//2.实现</span><br> 知道了单链表的特性，我们使用数组来实现一下这个单链表，下面是代码。       <br><span class="hljs-comment">//实现细究</span><br>首先，我们要实现一个链表，应该有几个准备工作;<br><span class="hljs-number">1.</span>声明一个数组 用于存入我们的数据<br><span class="hljs-number">2.</span>声明位置数组，用来存储我们的数据下标（对应的车厢）<br><span class="hljs-number">3.</span>声明一个变量，用于插入操作 一般用我们的idx<br><span class="hljs-number">4.</span>声明开头的数据下标 head 和 尾坐标 nell<br><br><span class="hljs-comment">//链表使用的时候要初始化 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   head = <span class="hljs-number">-1</span>;<br>   idx = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//声明我们所需要的数据类型</span><br><span class="hljs-type">int</span> e[N],  ne[N],   idx ,   head;<br> 存储值  存储下标 操作变量  头指针<br> <span class="hljs-comment">//e[N] 和 ne[N] 这两个看着是错开的 实际上是因为我们的头指针占了一个位置（叫做指针 是因为它很像一个标尺一样）</span><br><br>实现的一些功能<br><span class="hljs-comment">//将x插入头指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_to_head</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">  </span>&#123;<br>    ne[idx] = head;<br>    e[idx] = x;<br>    head = idx++;<br>    idx++;  <span class="hljs-comment">//指针移动位置 </span><br>  &#125;<br><span class="hljs-comment">//插入k位置 把x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-comment">//把head 换成 ne[k] 就好了</span><br>   ne[idx] = ne[k];<br>   e[idx] = x;<br>   ne[k] = idx++;<br>   idx++;  <br>&#125;<br><span class="hljs-comment">//将下标k后面的点删除</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span><br><span class="hljs-function"></span>&#123; <br>  <span class="hljs-comment">//ne[k]表示的是k数据的下一个数据的位置</span><br>  <span class="hljs-comment">//那么 ne[ne[k]] 就是跳过了下一个数据 到第三个数据上了</span><br>  <span class="hljs-comment">//也就是当前数据的下一个位置 变成了第三个数据的位置了</span><br>  ne[k] = ne[ne[k]]; <span class="hljs-comment">//这里用递归来理解</span><br>  <span class="hljs-comment">//理解ne是下一个位置就行 实际上是用idx来构建序列的</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><a href="http://c.biancheng.net/view/1570.html">C++链表及其创建</a></p></blockquote><p><img src="/2023/04/27/Three/2-1Q20316324S20.gif" alt="结构"></p><p><img src="/2023/04/27/Three/2-1Q203163321H2.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链表的结构</span><br> 链表中的每个结点都包含一个或多个保存数据的成员。例如，存储在结点中的数据可以是库存记录；或者它可以是由客户的姓名、地址和电话号码等组成的客户信息记录。<br> 非空链表的第一个结点称为链表的头。要访问链表中的结点，需要有一个指向链表头的指针。从链表头开始，可以按照存储在每个结点中的后继指针访问链表中的其余结点。最后一个结点中的后继指针被设置为 <span class="hljs-literal">nullptr</span> 以指示链表的结束。<br><span class="hljs-comment">//个人理解</span><br>     链表就是用线串起来的数据块，每一个节点的两个值都有其特定的作用：next指针负责穿起来节点，数据块负责存储数据。数据的起点就是链表头head，数据的终点指向null。<br><br><span class="hljs-comment">//c++表示</span><br>     虽然说我们可以用数组实现我们的链表，但是这样实现的链表不够简洁，我们可以使用结构体来实现（本质上是一样的）<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span><br>        &#123;<br>            <span class="hljs-type">double</span> value;<span class="hljs-comment">//数据</span><br>            ListNode *next;<span class="hljs-comment">//下一个数据的位置</span><br>        &#125;;<br> 在以上代码中，ListNode 就是要存储在链表中的结点的类型，结构成员 value 是结点的数据部分，而另一个结构成员 next 则被声明为 ListNode 的指针，它是指向下一个结点的后继指针。<br> 在已经声明了一个数据类型来表示结点之后，即可定义一个初始为空的链表，方法是定义一个用作链表头的指针并将其初始化为 <span class="hljs-literal">nullptr</span>，示例如下<br>        ListNode *head = <span class="hljs-literal">nullptr</span>;   <br></code></pre></td></tr></table></figure><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><blockquote><p><a href="https://blog.csdn.net/slandarer/article/details/91863177">https://blog.csdn.net/slandarer/article/details/91863177</a></p><p><a href="http://c.biancheng.net/view/1570.html">http://c.biancheng.net/view/1570.html</a></p></blockquote><p><img src="/2023/04/27/Three/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//2.双向链表</span><br> 比起单链表，多了一个指向前的指针，双向链表有三个整数值: 数值、向后的节点链接、向前的节点链接，所以双链表既能向前查询也可以向后查询。<br> 还有一个常用的链表则为循环单链表，则单链表尾部的指针指向头节点。<br><span class="hljs-comment">//用数组构造双链表</span><br> 比起单链表中，多了一个指向前面的指针<br><span class="hljs-comment">//那就多声明一个前继路线</span><br><span class="hljs-type">int</span> l[N],r[N],idx,e[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  l[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>  idx = <span class="hljs-number">0</span>;  <br>&#125;<br><br><span class="hljs-comment">//往k的右边 插入数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  e[idx] = x;<br>  r[idx] = r[k];<br>  l[idx] = l[k];<br>  l[r[k]] = idx;<br>  r[k] = idx;<br>  <br>&#125;<br><span class="hljs-comment">//往k的左边插入数据</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> k,<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>  e[idx] = k;<br>  l[idx] = l[k];<br>  r[idx] = r[k];<br><span class="hljs-comment">//理解 l[k] 是k左边的位置 那么r[l[k]] 就是 k这个位置</span><br>  r[l[k]] = idx;<br>  l[k] = idx;<br>  <br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//上述使用多个数组来构造我们的链表，但实际使用的时候我们并不会这样子做（有时候会），我们可以学习一种新的构造方法（其实是一样的），利用结构体和指针关系来构造我们的链表</span><br><br><span class="hljs-comment">//用这样的思路来构造：就是说你现在有一个小纸条，上面写着一个抽屉的地址，那个抽屉里有一些你需要的东西，和一个新的写着地址的小纸条，这个小纸条又指向了一个新的抽屉，大体可以这么理解</span><br><br><span class="hljs-comment">//第一部分—构建抽屉 </span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listpoint</span> <span class="hljs-comment">//这里是抽屉的结构体</span><br>&#123;<br>    <span class="hljs-type">int</span> data;<span class="hljs-comment">//我们存储的数据</span><br>    listpoint *next;<span class="hljs-comment">//指向下一个抽屉的指针</span><br>&#125;listpoint;<br><br><span class="hljs-comment">//我们在抽屉里不仅仅可以放一个数，我们可以往里面放一个收纳盒，例如，在下面的结构体中包含了另一个结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span><br>&#123;<br>    <span class="hljs-type">int</span> number;<br>    string name;<br>    string sex;<br>&#125;data;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">listpoint</span><br>&#123;<br>    data *information;<span class="hljs-comment">//收纳盒</span><br>    listpoint *next;<span class="hljs-comment">//下一个箱子（的地址）</span><br>    listpoint *last;<span class="hljs-comment">//上一个箱子（的地址）</span><br>&#125;listpoint;<br><br><span class="hljs-comment">//第二部分—创建一个链表</span><br><span class="hljs-comment">/*链表每一个节点都是指向  listpoint结构的指针，所以返回值是listpoint *,n是指创建的链表的节点数目*/</span><br><span class="hljs-function">listpoint *<span class="hljs-title">create_normal_list</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>     </span><br><span class="hljs-function"></span>&#123;<br>    listpoint *head,*normal,*end;<span class="hljs-comment">/*创建头节点，其他节点，和尾节点*/</span><br>    head=(listpoint*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listpoint));<br>    head-&gt;information=(data*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(data));<br>    <span class="hljs-comment">/*分配内存*/</span><br>    end=head;<span class="hljs-comment">/*最开始最后一个节点就是头节点，注意因为通过指针可以直接对地址上的东西进行操作，此时end和head指向同一个地址，对end所指向地址进行操作，等同于对head地址所做的操作*/</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++)<br>    &#123;<br>        normal=(listpoint*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(listpoint));<br>        normal-&gt;information=(data*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(data));<br>        <span class="hljs-comment">/*给新节点分配内存*/</span><br>        cout&lt;&lt;<span class="hljs-string">&quot;input the number :&quot;</span>;<br>        cin&gt;&gt;normal-&gt;information-&gt;number;<br>        cout&lt;&lt;<span class="hljs-string">&quot;input the name   :&quot;</span>;<br>        cin&gt;&gt;normal-&gt;information-&gt;name;<br>        cout&lt;&lt;<span class="hljs-string">&quot;input the sex    :&quot;</span>;<br>        cin&gt;&gt;normal-&gt;information-&gt;sex;<br>        cout&lt;&lt;<span class="hljs-string">&quot;----------------------------------&quot;</span>&lt;&lt;endl;<br>       <span class="hljs-comment">/* 往新节点存入数据，注意我们只给后面的节点存入数据，head不存数据*/</span><br>        end-&gt;next=normal;<span class="hljs-comment">/*往end后增添新节点*/</span><br>        normal-&gt;last=end;<span class="hljs-comment">/*新节点的上一个节点就是end*/</span><br>        end=normal;<span class="hljs-comment">/*最后一个节点变成新节点*/</span><br>    &#125;<br>    end-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*链表的最后指向一个新地址*/</span><br>    head-&gt;last=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*链表最开始的节点没有上一个节点*/</span><br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><h5 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表*"></a>循环单链表*</h5><blockquote><p><a href="https://zhuanlan.zhihu.com/p/107808443">数据结构——从单链表到单向循环链表 - 知乎 (zhihu.com)</a></p></blockquote><p> 就是在单链表的基础之上，将最后本指向null的改为指向链表头。</p><p><img src="/2023/04/27/Three/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8.png" alt="循环单链表"></p><p> 循环链表主要用于操作系统中的任务维护。有许多例子，循环链表用于计算机科学，包括浏览器，记录用户过去访问过的页面记录也可以以循环链表的形式保存，并且可以在点击前一个按钮时再次访问。</p><p> 对单向链表中任一个节点的访问都需要从头结点开始；而对单向循环链表从任意节点出发都能遍历整个列表<strong>，</strong>极大的增强了其灵活性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//c++实现</span><br><span class="hljs-comment">//1.节点类，</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-type">int</span> data;<br> Node *pointer=<span class="hljs-literal">NULL</span>;<br>&#125;;<br><span class="hljs-comment">//2.链表类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleLinkedList</span> &#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">SingleLinkedList</span>();<br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>     Node *head;<br>&#125;;<br><span class="hljs-comment">//3.构造函数</span><br>SingleLinkedList::<span class="hljs-built_in">SingleLinkedList</span>() &#123;<br> head = <span class="hljs-keyword">new</span> Node;<br> head-&gt;data = <span class="hljs-number">0</span>;<br> head-&gt;pointer = head;<br>&#125;<br><span class="hljs-comment">//4.判断是否为空：isEmpty()</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">SingleLinkedList::isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 头结点不指向任何结点，为空</span><br> <span class="hljs-keyword">if</span> (head-&gt;pointer == head) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br> &#125;<br>&#125;<br><span class="hljs-comment">//5.头插法：add()</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleLinkedList::add</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span>&#123;<br> <span class="hljs-comment">// 当原列表仅有头结点时，直接插入新节点即可</span><br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isEmpty</span>()) &#123;<br>  head-&gt;pointer = <span class="hljs-keyword">new</span> Node;<br>  head-&gt;pointer-&gt;pointer = head;<br>  head-&gt;pointer-&gt;data = data;<br> &#125;<br> <span class="hljs-comment">// 列表非空时</span><br> <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 临时存储头结点的直接后继</span><br>  Node *temp = head-&gt;pointer;<br>  head-&gt;pointer = <span class="hljs-keyword">new</span> Node;<br>  head-&gt;pointer-&gt;data = data;<br>  head-&gt;pointer-&gt;pointer = temp;<br> &#125;<br>&#125;<br><span class="hljs-comment">//6.遍历：traversal()</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SingleLinkedList::traversal</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 链表为空，结束函数</span><br> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">isEmpty</span>()) &#123;<br>  <span class="hljs-keyword">return</span>;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>  Node *current;<br>  <span class="hljs-comment">// 指向头结点的直接后继</span><br>  current = head-&gt;pointer;<br>  <span class="hljs-type">int</span> counter = <span class="hljs-number">1</span>;<br>  <span class="hljs-comment">// 遍历链表，输出每个节点的值</span><br>  <span class="hljs-keyword">while</span> (current != head)<br>  &#123;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Element in %d is %d \n&quot;</span>, counter, current-&gt;data);<br>   counter++;<br>   current = current-&gt;pointer;<br>  &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表*"></a>循环双链表*</h5><blockquote><p><a href="https://blog.csdn.net/sum_TW/article/details/61624039?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8=">循环双链表</a></p></blockquote><p> 和循环单链表一样，只是多了双链表的属性。</p><p><img src="/2023/04/27/Three/Center.png" alt="img"></p><p>双向循环链表初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//创建链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//存储新的节点</span><br>    Node* p=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头节点的替身</span><br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    pn-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//next指向空</span><br>    pn-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre指向空</span><br>    sum=<span class="hljs-number">1</span>;<br>    *h=pn;<br>    p=*h;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//创建到最后一个节点时，最后一个节点next为头节点</span><br>            p-&gt;next=*h;<br>            (*h)-&gt;pre=p;<span class="hljs-comment">//头节点的pre为最后一个节点</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pn=<span class="hljs-built_in">creteNode</span>(d);<br>        p-&gt;next=pn;<br>        pn-&gt;pre=p;<br>        p=p-&gt;next;<br>        sum++;<span class="hljs-comment">//元素个数++</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>插入操作</p><p><img src="/2023/04/27/Three/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.png" alt="双向循环链表插入"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFont</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//修改头节点  传入二级指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    Node* p=*h;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pn-&gt;next=*h;<span class="hljs-comment">//新节点成为头节点</span><br>    p-&gt;next=pn;<span class="hljs-comment">//最后一个节点p的下一个节点为新节点pn</span><br>    pn-&gt;pre=p;<span class="hljs-comment">//新的头节点的pre为p</span><br> <br>    (*h)-&gt;pre=pn;<span class="hljs-comment">//原头节点的前一个节点为新节点</span><br> <br>    *h=pn;<span class="hljs-comment">//新节点为头节点</span><br> <br>    sum++;<br>&#125;<br> <br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//在n位置插入d</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((n&lt;<span class="hljs-number">1</span>)||(*h==<span class="hljs-literal">NULL</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置不合法||链表为空!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>     Node* pn=<span class="hljs-built_in">creteNode</span>(d);<span class="hljs-comment">//创建新的节点</span><br>    <span class="hljs-comment">//插入位置为1，即插入头节点的位置</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">addFont</span>(d,h);<span class="hljs-comment">//调用头插法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==sum)<br>    &#123;<br>        <span class="hljs-built_in">addBack</span>(d,*h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>       Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>); <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>       pn-&gt;next=pf-&gt;next;<span class="hljs-comment">//前一个节点的next等于新的节点的next</span><br>       pf-&gt;next-&gt;pre=pn;<span class="hljs-comment">//pf的next节点的pre应该为pn</span><br>       pf-&gt;next=pn;<span class="hljs-comment">//前一个节点的next等于新的节点</span><br>       pn-&gt;pre=pf;<span class="hljs-comment">//新节点的前一个节点为找到的前一个节点pf</span><br>       sum++;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>删除操作</p><p><img src="/2023/04/27/Three/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelectFont</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">//DelectFont(h);</span><br>    <span class="hljs-type">int</span> i, n1=sum;<br>    Node* p=*h;<br>    Node* pd=<span class="hljs-literal">NULL</span>;;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n1<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pd=*h;<br>    *h=pd-&gt;next;<span class="hljs-comment">//头节点的下一个节点成头节点</span><br>    <br>    p-&gt;next=*h;<span class="hljs-comment">//最后一个节点的next为头节点</span><br>    <br>    (*h)-&gt;pre=p;<span class="hljs-comment">//pd节点成为了头节点，它的前驱为p</span><br>    sum--;<span class="hljs-comment">//元素个数-1</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-comment">//删除第n个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int i;//循环变量</span><br>    <span class="hljs-comment">//判断头节点是否为空，位置是不是合法</span><br>    <span class="hljs-keyword">if</span>((*h==<span class="hljs-literal">NULL</span>)||(n&lt;<span class="hljs-number">1</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的链表为空||删除的位置不合法！so 插入失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    Node* pd=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//删除头节点</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">DelectFont</span>(h);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//删除</span><br>    <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>    Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>);<br>    pd=pf-&gt;next;<span class="hljs-comment">//将要删除的节点的给pd</span><br>    pf-&gt;next=pd-&gt;next;<span class="hljs-comment">//将删除元素的前一个的next指向删除元素的后一个元素</span><br>    pd-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pd的pre指向空</span><br>   <br>    pd-&gt;next-&gt;pre=pf;<span class="hljs-comment">//将删除元素的后一个元素的前驱给pf</span><br>    pd-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pdnext指向空</span><br>    sum--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>总</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>&#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span>* pre;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> Node;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE sizeof(Node)</span><br><span class="hljs-type">int</span> sum;<span class="hljs-comment">//节点个数</span><br> <br><span class="hljs-function">Node* <span class="hljs-title">creteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span>;<span class="hljs-comment">//创建节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">(Node** h)</span>；<span class="hljs-comment">//创建链表</span></span><br><span class="hljs-function">Node* <span class="hljs-title">findNode</span><span class="hljs-params">(Node* h,<span class="hljs-type">int</span> n)</span>；<span class="hljs-comment">//查找某个节点的位置</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addBack</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node* h)</span>；<span class="hljs-comment">//末尾增加一个新的节点</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFont</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node** h)</span>；<span class="hljs-comment">//修改头节点  传入二级指针</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> d,Node** h)</span>；<span class="hljs-comment">//在n位置插入d</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelectFont</span><span class="hljs-params">(Node** h)</span></span>;<span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,Node** h)</span></span>;<span class="hljs-comment">//删除第n个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Node* h)</span></span>;<span class="hljs-comment">//打印链表</span><br> <br><span class="hljs-comment">//创建节点</span><br><span class="hljs-function">Node* <span class="hljs-title">creteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> d)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* pn=(Node*)<span class="hljs-built_in">malloc</span>(SIZE);<br>    pn-&gt;data=d;<br>    pn-&gt;next=<span class="hljs-literal">NULL</span>;<br>    pn-&gt;pre=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> pn;<br>&#125;<br> <br><span class="hljs-comment">//创建链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">creatList</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//存储新的节点</span><br>    Node* p=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//头节点的替身</span><br>    <span class="hljs-type">int</span> d;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    pn-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//next指向空</span><br>    pn-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pre指向空</span><br>    sum=<span class="hljs-number">1</span>;<br>    *h=pn;<br>    p=*h;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数据\n&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;d);<br>        <span class="hljs-keyword">if</span>(d==<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">//创建到最后一个节点时，最后一个节点next为头节点</span><br>            p-&gt;next=*h;<br>            (*h)-&gt;pre=p;<span class="hljs-comment">//头节点的pre为最后一个节点</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pn=<span class="hljs-built_in">creteNode</span>(d);<br>        p-&gt;next=pn;<br>        pn-&gt;pre=p;<br>        p=p-&gt;next;<br>        sum++;<span class="hljs-comment">//元素个数++</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//查找某个节点的位置</span><br><span class="hljs-function">Node* <span class="hljs-title">findNode</span><span class="hljs-params">(Node* h,<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>((h==<span class="hljs-literal">NULL</span>)||(n&lt;<span class="hljs-number">0</span>)||(n&gt;sum))<br>    &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;查找位置不合法||链表为空！\n&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> h;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;n;i++)<br>    &#123;<br>        h=h-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> h;<br>&#125; <br> <br><span class="hljs-comment">//末尾增加一个新的节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addBack</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node* h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    Node *pn=<span class="hljs-literal">NULL</span>;<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    Node* p=h;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//此时的p指向了最后一个元素</span><br>    p-&gt;next=pn;<span class="hljs-comment">//最后一个节点p的next为新节点</span><br>    pn-&gt;pre=p;<span class="hljs-comment">//新节点的前一个节点为p</span><br>    pn-&gt;next=h;<span class="hljs-comment">//pn的最后一个节点为头节点</span><br>    h-&gt;pre=pn;<span class="hljs-comment">//头节点的pre为新节点</span><br>    sum++;<br>&#125;<br> <br><span class="hljs-comment">//头插法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addFont</span><span class="hljs-params">(<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//修改头节点  传入二级指针</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    Node* pn=<span class="hljs-literal">NULL</span>;<br>    pn=<span class="hljs-built_in">creteNode</span>(d);<br>    Node* p=*h;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pn-&gt;next=*h;<span class="hljs-comment">//新节点成为头节点</span><br>    p-&gt;next=pn;<span class="hljs-comment">//最后一个节点p的下一个节点为新节点pn</span><br>    pn-&gt;pre=p;<span class="hljs-comment">//新的头节点的pre为p</span><br> <br>    (*h)-&gt;pre=pn;<span class="hljs-comment">//原头节点的前一个节点为新节点</span><br> <br>    *h=pn;<span class="hljs-comment">//新节点为头节点</span><br> <br>    sum++;<br>&#125;<br> <br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">insertNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,<span class="hljs-type">int</span> d,Node** h)</span><span class="hljs-comment">//在n位置插入d</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>((n&lt;<span class="hljs-number">1</span>)||(*h==<span class="hljs-literal">NULL</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;插入位置不合法||链表为空!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>     Node* pn=<span class="hljs-built_in">creteNode</span>(d);<span class="hljs-comment">//创建新的节点</span><br>    <span class="hljs-comment">//插入位置为1，即插入头节点的位置</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">addFont</span>(d,h);<span class="hljs-comment">//调用头插法</span><br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(n==sum)<br>    &#123;<br>        <span class="hljs-built_in">addBack</span>(d,*h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>       Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>); <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>       pn-&gt;next=pf-&gt;next;<span class="hljs-comment">//前一个节点的next等于新的节点的next</span><br>       pf-&gt;next-&gt;pre=pn;<span class="hljs-comment">//pf的next节点的pre应该为pn</span><br>       pf-&gt;next=pn;<span class="hljs-comment">//前一个节点的next等于新的节点</span><br>       pn-&gt;pre=pf;<span class="hljs-comment">//新节点的前一个节点为找到的前一个节点pf</span><br>       sum++;<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">//删除头节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">DelectFont</span><span class="hljs-params">(Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">//DelectFont(h);</span><br>    <span class="hljs-type">int</span> i, n1=sum;<br>    Node* p=*h;<br>    Node* pd=<span class="hljs-literal">NULL</span>;;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;n1<span class="hljs-number">-1</span>;i++)<br>    &#123;<br>        p=p-&gt;next;<br>    &#125;<br>    <br>    <span class="hljs-comment">//p为最后一个节点</span><br>    pd=*h;<br>    *h=pd-&gt;next;<span class="hljs-comment">//头节点的下一个节点成头节点</span><br>    <br>    p-&gt;next=*h;<span class="hljs-comment">//最后一个节点的next为头节点</span><br>    <br>    (*h)-&gt;pre=p;<span class="hljs-comment">//pd节点成为了头节点，它的前驱为p</span><br>    sum--;<span class="hljs-comment">//元素个数-1</span><br>  <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br> <br><span class="hljs-comment">//删除第n个位置的元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(<span class="hljs-type">int</span> n,Node** h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//int i;//循环变量</span><br>    <span class="hljs-comment">//判断头节点是否为空，位置是不是合法</span><br>    <span class="hljs-keyword">if</span>((*h==<span class="hljs-literal">NULL</span>)||(n&lt;<span class="hljs-number">1</span>)||(n&gt;sum))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;删除的链表为空||删除的位置不合法！so 插入失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    Node* pd=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//删除头节点</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>    &#123;<br>       <span class="hljs-built_in">DelectFont</span>(h);<br>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br> <br>    <span class="hljs-comment">//删除</span><br>    <span class="hljs-comment">//找到要删除的节点的前一个节点</span><br>    Node* pf=<span class="hljs-built_in">findNode</span>(*h,n<span class="hljs-number">-1</span>);<br>    pd=pf-&gt;next;<span class="hljs-comment">//将要删除的节点的给pd</span><br>    pf-&gt;next=pd-&gt;next;<span class="hljs-comment">//将删除元素的前一个的next指向删除元素的后一个元素</span><br>    pd-&gt;pre=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pd的pre指向空</span><br>   <br>    pd-&gt;next-&gt;pre=pf;<span class="hljs-comment">//将删除元素的后一个元素的前驱给pf</span><br>    pd-&gt;next=<span class="hljs-literal">NULL</span>;<span class="hljs-comment">//pdnext指向空</span><br>    sum--;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br> <br><span class="hljs-comment">//打印链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(Node* h)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,n=sum;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;list:\n&quot;</span>);<br>    Node* p=h;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;正序遍历：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;data);<br>        p=p-&gt;next;<br>    &#125;<br>    <span class="hljs-comment">//上面遍历到第一个节点</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;反序遍历：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,p-&gt;pre-&gt;data);<br>        p=p-&gt;pre;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Node* head=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-built_in">creatList</span>(&amp;head);<br>    <span class="hljs-built_in">deleteNode</span>(<span class="hljs-number">2</span>,&amp;head);<br>    <span class="hljs-built_in">print</span>(head);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="随机链表-（暂时不学）"><a href="#随机链表-（暂时不学）" class="headerlink" title="随机链表*（暂时不学）"></a>随机链表*（暂时不学）</h5><p><img src="/2023/04/27/Three/list.png" alt="list"></p><h4 id="链表实现的功能"><a href="#链表实现的功能" class="headerlink" title="链表实现的功能*"></a>链表实现的功能*</h4><blockquote><p><a href="https://www.jianshu.com/p/5f148c3e4f7d">数据结构中堆、栈和队列的理解</a></p></blockquote><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong>栈的定义：</strong></p><p>栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</p><p>而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。</p><p>堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</p><p><img src="/2023/04/27/Three/%E6%A0%88.png" alt="栈"></p><p>用我们的数组实现的栈，最关键的点在于：我们是否可以直接不管我们插入栈的数据。 栈的原理就是 先进后出 这个我们知道，那么我们只要声明一个数组就可以实现这个功能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//用数组实现栈功能</span><br><span class="hljs-comment">//栈 和 操作栈的变量</span><br><span class="hljs-type">int</span> stk[N],tt;<span class="hljs-comment">//变量用来控制我们的栈的容量</span><br><br><span class="hljs-comment">//插入栈的数据</span><br>stk[++tt] = x;<br><span class="hljs-comment">//pop弹出 这样的数据会直接消失 记得保存stk[kk] 栈顶数据 </span><br>tt--; <br><span class="hljs-comment">//判断栈顶是否为空 (这里是伪代码)</span><br><span class="hljs-keyword">if</span>(tt&gt;<span class="hljs-number">0</span>) no empty;<br><span class="hljs-keyword">else</span> empty;<br><span class="hljs-comment">//栈顶</span><br>stk[kk]<br>  <br><span class="hljs-comment">//总结 </span><br>    栈的作用就是实现两个操作 <span class="hljs-number">1.</span>压栈 <span class="hljs-number">2.</span>弹栈 - 压栈的操作在用数组实现的时候，我们可以理解 竖向数组的增高（但实际上在现实中更像手枪压弹夹一样）弹栈 - 就是去顶（更像手枪把子弹打出去）<br> 通常，声明一个栈的时候，我们会用一个变量来维护我们这个栈。 这个变量起到实现上述两个操作的作用 - 例如： h[N]是我们的一个栈 top是我们维护栈的变量<br> 那么： push操作就是 h[++top] = <span class="hljs-built_in">a</span>(你塞入的子弹)；pop操作就是  top--;<br><span class="hljs-built_in">query</span>(栈头) h[top] <span class="hljs-comment">//重点是插入的时候是先 ++ 在赋值位置的 这样可以保证沉底</span><br><span class="hljs-comment">//stl中的栈</span><br> &lt;stack&gt; 是栈的头文件名称，用的时候声明一下就好了。<br></code></pre></td></tr></table></figure><p>栈的应用——递归</p><p>在高级语言中，调用自己和其它函数没有本质的不同。我们把一个直接用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。每个递归函数必须至少有一个条件，满足时递归不再执行，即不再引用自身而是返回值退出。</p><p>递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。 递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。</p><p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p><h4 id="用栈实现计算器"><a href="#用栈实现计算器" class="headerlink" title="用栈实现计算器"></a><strong>用栈实现计算器</strong></h4><p>中缀表达式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//不支持括号</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span> || i == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>                <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">top</span>();<br>                nums.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n * num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n / num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(-num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>            num = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!nums.<span class="hljs-built_in">empty</span>()) &#123;<br>        res += nums.<span class="hljs-built_in">top</span>();<br>        nums.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;3+2*2&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">calculate</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//支持括号</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    stack&lt;<span class="hljs-type">char</span>&gt; ops;<br>    <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">char</span> c = s[i];<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isdigit</span>(c)) &#123;<br>            num = num * <span class="hljs-number">10</span> + (c - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;(&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, cnt = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (cnt != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;(&#x27;</span>) cnt++;<br>                <span class="hljs-keyword">if</span> (s[j] == <span class="hljs-string">&#x27;)&#x27;</span>) cnt--;<br>                j++;<br>            &#125;<br>            num = <span class="hljs-built_in">calculate</span>(s.<span class="hljs-built_in">substr</span>(i + <span class="hljs-number">1</span>, j - i - <span class="hljs-number">2</span>));<br>            i = j - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isdigit</span>(c) &amp;&amp; c != <span class="hljs-string">&#x27; &#x27;</span> || i == s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>                <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">top</span>();<br>                nums.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n * num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(n / num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!ops.<span class="hljs-built_in">empty</span>() &amp;&amp; (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span> || ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;-&#x27;</span>)) &#123;<br>                <span class="hljs-keyword">if</span> (ops.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>                    nums.<span class="hljs-built_in">push</span>(num);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    nums.<span class="hljs-built_in">push</span>(-num);<br>                &#125;<br>                ops.<span class="hljs-built_in">pop</span>();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push</span>(num);<br>            &#125;<br>            ops.<span class="hljs-built_in">push</span>(c);<br>            num = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!nums.<span class="hljs-built_in">empty</span>()) &#123;<br>        res += nums.<span class="hljs-built_in">top</span>();<br>        nums.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s = <span class="hljs-string">&quot;3+2*(2+1)&quot;</span>;<br>    cout &lt;&lt; <span class="hljs-built_in">calculate</span>(s) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>逆波兰式实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>    stack&lt;<span class="hljs-type">int</span>&gt; nums;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; tokens.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        string s = tokens[i];<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;+&quot;</span> || s == <span class="hljs-string">&quot;-&quot;</span> || s == <span class="hljs-string">&quot;*&quot;</span> || s == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>            <span class="hljs-type">int</span> num2 = nums.<span class="hljs-built_in">top</span>();<br>            nums.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> num1 = nums.<span class="hljs-built_in">top</span>();<br>            nums.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 + num2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 - num2);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 * num2);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nums.<span class="hljs-built_in">push</span>(num1 / num2);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            nums.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">stoi</span>(s));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-built_in">top</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    vector&lt;string&gt; tokens = &#123;<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">evalRPN</span>(tokens) &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：<br> （1）堆中某个节点的值总是不大于或不小于其父节点的值；<br> （2）堆总是一棵完全二叉树。</p><p>堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。</p><p>堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p><p><img src="/2023/04/27/Three/%E4%BA%8C%E5%8F%89%E6%A0%91.webp" alt="优先队列"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><span class="hljs-comment">// 定义堆的最大容量 </span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_SIZE = <span class="hljs-number">100</span>; <br><span class="hljs-comment">// 定义堆的数据结构 </span><br><span class="hljs-type">int</span> heap[MAX_SIZE]; <br><span class="hljs-type">int</span> heapSize; <br><span class="hljs-comment">// 向堆中插入一个元素 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 如果堆已满，则不能插入 </span><br>    <span class="hljs-keyword">if</span> (heapSize == MAX_SIZE) <br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-comment">// 将新元素插入到堆的末尾 </span><br>    heap[heapSize] = data; <br>    heapSize++; <br>    <span class="hljs-comment">// 将新元素上浮到正确的位置 </span><br>    <span class="hljs-type">int</span> current = heapSize - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-number">0</span> &amp;&amp; heap[current] &gt; heap[(current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]) <br>    &#123; <br>        <span class="hljs-type">int</span> temp = heap[(current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>]; <br>        heap[(current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>] = heap[current]; <br>        heap[current] = temp; <br>        current = (current - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; <br>    &#125; <br>&#125; <br><span class="hljs-comment">// 从堆中删除一个元素 </span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteElement</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 如果堆为空，则不能删除 </span><br>    <span class="hljs-keyword">if</span> (heapSize == <span class="hljs-number">0</span>) <br>        <span class="hljs-keyword">return</span>; <br>    <span class="hljs-comment">// 将堆的最后一个元素放到堆顶 </span><br>    heap[<span class="hljs-number">0</span>] = heap[heapSize - <span class="hljs-number">1</span>]; <br>    heapSize--; <br>    <span class="hljs-comment">// 将堆顶元素下沉到正确的位置 </span><br>    <span class="hljs-type">int</span> current = <span class="hljs-number">0</span>; <br>    <span class="hljs-keyword">while</span> (current * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; heapSize) <br>    &#123; <br>        <span class="hljs-type">int</span> largest = current; <br>        <span class="hljs-keyword">if</span> (heap[largest] &lt; heap[current * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>]) <br>            largest = current * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>; <br>        <span class="hljs-keyword">if</span> (current * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &lt; heapSize &amp;&amp; heap[largest] &lt; heap[current * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>]) <br>            largest = current * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <br>        <span class="hljs-keyword">if</span> (largest == current) <br>            <span class="hljs-keyword">break</span>; <br>        <span class="hljs-type">int</span> temp = heap[current]; <br>        heap[current] = heap[largest]; <br>        heap[largest] = temp; <br>        current = largest; <br>    &#125; <br>&#125; <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// 初始化堆 </span><br>    heapSize = <span class="hljs-number">0</span>; <br>    <span class="hljs-comment">// 向堆中插入元素 </span><br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">10</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">20</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">40</span>); <br>    <span class="hljs-built_in">insert</span>(<span class="hljs-number">50</span>); <br>    <span class="hljs-comment">// 从堆中删除元素 </span><br>    <span class="hljs-built_in">deleteElement</span>(); <br>    <span class="hljs-comment">// 输出堆中的元素 </span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; heapSize; i++) <br>        cout &lt;&lt; heap[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>    cout &lt;&lt; endl; <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p><img src="/2023/04/27/Three/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.png" alt="优先队列"></p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p><p>而且队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。</p><p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p><p>队列和游标卡尺差不多，就是一个区间和线段组成的数据类型</p><p><img src="/2023/04/27/Three/%E9%98%9F%E5%88%97.png" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//声明变量 队列的性质就是先进先出</span><br><span class="hljs-type">int</span> q[N],hh,tt;<br><span class="hljs-comment">//插入数据</span><br>q[++tt];<span class="hljs-comment">//hh是头（头是向右边移动的） tt是转移元素的变量（tt是新入队的成员）</span><br><span class="hljs-comment">//可以将 hh 和 tt看做是一个区间</span><br>hh++<span class="hljs-comment">//pop</span><br><span class="hljs-comment">//判断队列是否为空</span><br>  <span class="hljs-keyword">if</span>(hh&lt;=tt) <span class="hljs-keyword">not</span> empty<br>  <span class="hljs-keyword">else</span> empty;<br><span class="hljs-comment">//取出队头元素</span><br>q[hh];<br></code></pre></td></tr></table></figure><h4 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h4><p>在中学的时候，我们会学一种函数的性质，叫做单调性。单调性是指，在一个区间内部我们可以预测这个数据类型的运行方向。那么显而易见的，单调队列指的是，我们可以预计和控制这个数据类型的运行方向。</p><p>队列的性质上面有提到，是一种先进先出的数据结构。我们可以利用这个结构，做一个可动的队列或者说，让数据集通过我们的队列，在通过的时候记录他们的数据变化。这样的操作，就叫做单调队列。</p><p>以一个较简单的例子：滑动窗口，大概题意就是，有一个数据条，需要通过我们的窗口（队列），通过的时候记录这个时候队列的最大值和最小值（或者别的什么东西 - 变化一下题目嘛）。</p><p><img src="/2023/04/27/Three/image-20230504225237230.png" alt="滑动窗口"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//维护窗口</span><br><span class="hljs-type">int</span> h = <span class="hljs-number">1</span>,t = <span class="hljs-number">0</span>; <span class="hljs-comment">//清空队列</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;;i&lt;=n;i++)&#123; <span class="hljs-comment">//枚举数据集</span><br>    <span class="hljs-keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&gt;=a[i]) t--;<span class="hljs-comment">//队尾出队</span><br>    q[++t] = i;<span class="hljs-comment">//队尾入队</span><br>    <span class="hljs-keyword">if</span>(q[h]&lt;i-k+<span class="hljs-number">1</span>) h++;<span class="hljs-comment">//对头出队（滑出窗口）</span><br>    <span class="hljs-keyword">if</span>(i&gt;=k) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,a[q[h]]);<span class="hljs-comment">//打印最值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/27/Three/image-20230504230354394.png" alt="维护窗口最小值"></p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>并查集是一种树形的数据结构，支持两种操作，并：将两个不同的元素合并成一个集合；查：查找一个数据的所在集合</p><p>在模拟树状结构的时候，fa[x]存储的是节点的父节点，可以理解为特定集合的编号。这里的x和赋值给f[x]的值的关系，可以理解为<strong>节点和父节点连接</strong>的关系。初始化的时候，将每一个节点编号都初始化为自己(自己为一个集合)。</p><p><img src="/2023/04/27/Three/image-20230503221426175.png" alt="并查集"></p><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h4><p>可以理解为顺着当前节点向上爬，找到我们当前集合的根节点。但实际上，我们并不是这样做，我们可以将这个操作进行优化，我们在找根节点的过程，可以顺便将每一个经过的节点的<strong>“父节点”都改为我们的“根节点”</strong>，一个查找循环下来，整一个集合的值都是我们的，根节点（也就是我们当前集合编号），下面是代码解释。</p><p><img src="/2023/04/27/Three/image-20230503222836310.png" alt="路径压缩"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//未用路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//如果当前这个节点指向的是根节点，说明我们找到了目标集合，返回就行。</span><br> <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-comment">//如果不是，那就递归查找，直到找到我们的目标集合（一定找得到）。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(fa[x]); <br>&#125;<br><br><span class="hljs-comment">//使用路径压缩</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(fa[x] == x) <span class="hljs-keyword">return</span> x;<br>    <span class="hljs-keyword">return</span> fa[x] = <span class="hljs-built_in">find</span>(f[a]); <span class="hljs-comment">//这里就是给路过的节点赋值 - 用的是递归</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a><strong>合并</strong></h4><p><img src="/2023/04/27/Three/image-20230503224008918.png" alt="合并"></p><p>合并操作，可以理解为两个集合的根节点指向即可。这里举个例子，A集合和B集合，那么B集合序号指向A集合序号即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//合并代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unionset</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    <span class="hljs-comment">//将x的集合编号，赋值成y的集合编号</span><br>    <span class="hljs-comment">//如果再次路径压缩，那么所有x集合的编号都会变成y的编号</span><br>    fa[<span class="hljs-built_in">find</span>(x)] = <span class="hljs-built_in">find</span>(y); <br>&#125;<br></code></pre></td></tr></table></figure><p>但是，这样合并可以进行优化，我们可以这样想，如果我们合并两个集合的数量级不在一个级别上，比如一个集合元素个数为2，一个集合元素个数为2e10，这样将集合元素为2的集合作为新集合的标号，确实不太合适。所以说，我们可以直接给每一个集合标记他们的元素数量，然后对其进行合并即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">siz</span><span class="hljs-params">(N,<span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unioset</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span>&#123;<br>    x = <span class="hljs-built_in">find</span>(x),y = <span class="hljs-built_in">find</span>(y); <span class="hljs-comment">//找到各自的集合编号</span><br>    <span class="hljs-keyword">if</span>(x == y) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span>(siz[x]&gt;siz[y]) <span class="hljs-built_in">swap</span>(x,y);<span class="hljs-comment">//判断哪个集合更大</span><br>    fa[x] = y;<span class="hljs-comment">//小集合指向大集合</span><br>    siz[y]+=siz[x]; <span class="hljs-comment">//合并一个大集合要加数量</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/27/Three/image-20230503230130914.png" alt="并查集的变化"></p><h3 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h3><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p><p>Trie的核心思想是空间换时间。利用字符串的<strong>公共前缀</strong>来降低查询时间的开销以达到提高效率的目的。</p><p><img src="/2023/04/27/Three/image-20230504131211298.png" alt="字典树"></p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>Trie树，就是利用字符串的相同前缀，来节省我们查找的时间。这个树的根没有意义，只是为了构造这个树存在。可以说，根衔接的都是一个独立的单词（子树）。</p><p><img src="/2023/04/27/Three/image-20230504132336132.png" alt="字典树"></p><p>我们可以想象一下，在一个根下面链接一个一个单词会是什么样子，是不是像一个拂尘一样。我们可以在这个基础之上，对这些单词进行处理：单词是由26个字母排列组合成的，所以说不管单词怎么变，肯定有些单词的前缀是相等的。例如：appear 和 apple。这两个前缀相同，那么我们就可以让”app”为同一支，从p分出两个枝e和p。（当然分支最多26个）以此类推构建字典树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//字典树构造</span><br><span class="hljs-type">char</span> s[N]<br>    <br><span class="hljs-type">int</span> ch[N][<span class="hljs-number">26</span>];<span class="hljs-comment">//儿子数组：存储从节点p沿着j这条路走到的子节点。26是26个字母的映射值（就是1代表a，2代表b以此类推）</span><br><br><span class="hljs-type">int</span> cnt[N];<span class="hljs-comment">//存储以节点p结尾的单词的插入次数</span><br><br><span class="hljs-type">int</span> idx;<span class="hljs-comment">//用来节点编号</span><br><br><span class="hljs-comment">//插入字符串</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//遍历全部字符串的字符</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;s[i];i++)&#123;<br>        <span class="hljs-type">int</span> j = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//字母映射 - 变为0-25的编号</span><br>        <span class="hljs-keyword">if</span>(!ch[p][j]) ch[p][j]=++idx;<span class="hljs-comment">//不存在这个值（就是树中无这个子树）</span><br>        p = ch[p][j];<br>    &#125;<br>    cnt[p]++;<span class="hljs-comment">//插入次数 - 表示当前节点子树个数</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>和插入的操作差不多，只要找到我们插入的时候做的标记就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;s[i];i++)<br>    &#123;<br>        <span class="hljs-type">int</span> j = s[i]-<span class="hljs-string">&#x27;a&#x27;</span>;<span class="hljs-comment">//映射</span><br>        <span class="hljs-keyword">if</span>(!ch[p][j]) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;;<br>        p = ch[p][j]; <span class="hljs-comment">//查找符合，直到子串末尾。都符合则成立</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/27/Three/image-20230504140704449.png" alt="总结"></p><h3 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h3><p>在学习kmp算法之前，我们先弄清楚暴力求解字符串匹配问题。</p><p>给出一个主串S，判断字符串F是否是S的子串，如果是返回T在S中出现的第一个位置，否则返回0.</p><p>使用暴力算法解题，从主串S的第一个字符开始和模式串T的第一个字符进行比较，若相等则比较二者后续字符，否则，主串回溯到第二个字符，模式串回溯到第一个字符；继续比较，不匹配，主串回溯到第三个字符，模式串回溯到第一个字符。重新上述过程，直到模式串T中的字符全部比较完毕，说明匹配成功；否则匹配失败。<br>暴力算法将每一种情况都列举了出来，时间复杂度很高(大概是o(n^2))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">BF</span><span class="hljs-params">(<span class="hljs-type">char</span> *S,<span class="hljs-type">char</span> *T)</span></span>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(S[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>&amp;&amp;T[j])&#123;<br>        <span class="hljs-keyword">if</span>(S[i]==T[j])&#123;<br>            i++;<br>            j++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i=i-j+<span class="hljs-number">1</span>;<span class="hljs-comment">//主串回溯到上次回溯位置的下一个位置</span><br>            j=<span class="hljs-number">0</span>;<span class="hljs-comment">//模式串回溯到第一个位置</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(T[j]==<span class="hljs-string">&#x27;\0&#x27;</span>)<br>        <span class="hljs-keyword">return</span> i-j+<span class="hljs-number">1</span>; <span class="hljs-comment">//返回T在S中第一次出现的位置</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-type">char</span> S[<span class="hljs-number">50</span>]=&#123;<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>    <span class="hljs-type">char</span> T[<span class="hljs-number">50</span>]=&#123;<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>&#125;;<br>    cout&lt;&lt;<span class="hljs-built_in">BF</span>(S,T)&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在使用暴力匹配的时候，我们不难发现，每一轮如果匹配失效，那么就会直接放弃这一轮匹配的所有信息；进入到下一轮就重新匹配了。</p><p>Kmp算法就是将这一部分信息利用起来，使得下一轮匹配的时候不用重新开始，而是在前面的基础之上回退我们匹配串和前移我们的主串。这样就保留了匹配的信息。</p><p><img src="/2023/04/27/Three/image-20230504163459568.png" alt="比较"></p><p>那我们怎么利用信息呢：我们需要找到匹配串的相等前后缀，将其记录起来：这里就用next数组存储信息</p><h4 id="next函数"><a href="#next函数" class="headerlink" title="next函数"></a>next函数</h4><p><img src="/2023/04/27/Three/image-20230504164818659.png" alt="相等前后缀"></p><p>那这个next数组有什么用，我们找到相等前后缀的目的是为了保留信息，如果在7这个位置匹配失败了，那么只要找到在6这个位置的前后缀相等的，跳回到最大相等前后缀就行。因为在7之前我们的字符串是完全匹配的，可以吧ne数组理解为匹配位置的长度。</p><p><img src="/2023/04/27/Three/image-20230504170809559.png" alt="next数组"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">ne[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>,j = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;P[i]!=P[j+<span class="hljs-number">1</span>]) j = ne[j];<br>    <span class="hljs-keyword">if</span>(P[i] == P[j+<span class="hljs-number">1</span>]) j++;<br>    ne[i] = j;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/27/Three/image-20230504171245977.png" alt="next构造"></p><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><p>这里，使用了双指针思想。i指针维护主串，j指针维护匹配串，i指针只能向前移动，j指针可以来回调整。</p><p><img src="/2023/04/27/Three/image-20230504172311018.png" alt="匹配过程"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>,j = <span class="hljs-number">0</span>;i&lt;=m;i++)&#123;<br>    <span class="hljs-keyword">while</span>(j&amp;&amp;S[i]!=P[j+<span class="hljs-number">1</span>]) j = ne[j];<span class="hljs-comment">//回调操作 - ne数组存储的是最大匹配串长度（1-j的），这里赋值相当于将j回调到最大匹配的位置</span><br>    <span class="hljs-keyword">if</span>(S[i] == P[j+<span class="hljs-number">1</span>]) j++;<br>    <span class="hljs-keyword">if</span>(j==n) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i-n+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/27/Three/image-20230504172557271.png" alt="kmp时间复杂度"></p><p>那么总的时间复杂度就是O(m+n)</p><p><img src="/2023/04/27/Three/image-20230504173358331.png" alt="总结"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two 对数据的基本操作</title>
      <link href="/2023/04/26/Two/"/>
      <url>/2023/04/26/Two/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第二章-对数据的简单操作"><a href="#第二章-对数据的简单操作" class="headerlink" title="第二章 - 对数据的简单操作"></a>第二章 - 对数据的简单操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>高精度<br><span class="hljs-number">2.</span>简单字符串匹配问题<br><span class="hljs-number">3.</span>数组运用<br></code></pre></td></tr></table></figure><h3 id="前缀和-and-差分"><a href="#前缀和-and-差分" class="headerlink" title="前缀和 and 差分"></a>前缀和 and 差分</h3><blockquote><p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">(112条消息) 前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_林小鹿@的博客-CSDN博客</a></p></blockquote><h4 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h4><p><img src="/.png" alt="前缀和"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。</span><br> 前缀和可以解决区间和的问题，可以理解一个s数组，下标表示我们的数组a（构造前缀和的数组）元素个数的加和。<br><br><span class="hljs-comment">//用朴素方法解决：&quot;输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和&quot;</span><br><span class="hljs-comment">//代码</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a[i]);<br><span class="hljs-keyword">while</span>(m--)<br>&#123;<br>    <span class="hljs-type">int</span> l, r;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = l; i &lt;= r; i++)<br>    &#123; <br>        sum += a[i];<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,sum);<br>&#125;<br><span class="hljs-comment">//时间复杂度为O(n * m) - 两个循环，每次都要重新计算sum的值</span><br><br><span class="hljs-comment">//用前缀和 可以将复杂度降低点到o(n+m)</span><br><br><span class="hljs-comment">//我们给一个递增的数组</span><br><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span><br><span class="hljs-comment">//这个数组 如果我要求 前面4项的和你怎么求</span><br><span class="hljs-comment">//  自然而然 a1+...+a4 是吧</span><br>那么我们可以构造一个数组 来实现这种类似的功能<br>cin&gt;&gt;a[i]; <span class="hljs-comment">//伪代码省略操作  </span><br><span class="hljs-type">int</span> sum[];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();i++) sum[i] = sum[i<span class="hljs-number">-1</span>]+a[i]; 这样就可以实现了<br><span class="hljs-comment">//这样子 sum 中存储的数据 都是对应i值的前n项和</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> sum[N], a[N]; <span class="hljs-comment">//sum[i]=a[1]+a[2]+a[3].....a[i];</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n; i++)<br>&#123; <br>    sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i]; <span class="hljs-comment">//一次性全部算出来 - 只用一个循环的时间   </span><br>&#125;<br><br><span class="hljs-comment">//说白了，就是一个提前把所有数据处理出来，一个没有</span><br></code></pre></td></tr></table></figure><h4 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h4><p><img src="/2023/04/26/Two/%E5%B7%AE%E5%88%86.png" alt="差分"></p><p><img src="/2023/04/26/Two/%E5%B7%AE%E5%88%861.png" alt="差分1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//差分数组：</span><br> 首先给定一个原数组a：a[<span class="hljs-number">1</span>], a[<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>],,,,,, a[n];<br> 然后我们构造一个数组b ： b[<span class="hljs-number">1</span>], b[<span class="hljs-number">2</span>], b[<span class="hljs-number">3</span>],,,,,, b[i];<br> 使得 a[i] = b[<span class="hljs-number">1</span>] + b[<span class="hljs-number">2</span>] + b[<span class="hljs-number">3</span>] + ,,,,,, + b[i]<br>    <span class="hljs-comment">//i表示a[i]需要i个b数组元素构成</span><br><span class="hljs-comment">//也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E5%B7%AE%E5%88%86%E6%9E%84%E6%88%90.png" alt="差分构成"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">b[l] + c，效果使得a数组中 a[l] 及以后的数都加上了<span class="hljs-built_in">c</span>(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 b[r + <span class="hljs-number">1</span>] - c,让a数组中 a[r + <span class="hljs-number">1</span>]及往后的区间再减去<span class="hljs-built_in">c</span>(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。<br>因此我们得出一维差分结论：给a数组中的[ l, r] 区间中的每一个数都加上c,只需对差分数组b做 b[l] + = c, b[r+<span class="hljs-number">1</span>] - = c 。时间复杂度为<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>), 大大提高了效率。<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//差分是解决 - 在数组中的某一个区间中插入或者剔除一个值的问题</span><br> 我们设原数组是：a[i]<br>    b数组的一部分:b[i] = a[i]-a[i<span class="hljs-number">-1</span>];<br> 那么就有： (b[i]+c) = (a[i]+c)-(a[i<span class="hljs-number">-1</span>]+c);<span class="hljs-comment">//这样恒成立</span><br>    (b[i]-c) = (a[i]-c)-(a[i]-c);<br><span class="hljs-comment">//所以我们就要在区间中构造一个这样的b[i] - insert函数</span><br> <span class="hljs-built_in">insert</span>(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)<br>    &#123;<br>        b[l]+=c;<br>        b[r+<span class="hljs-number">1</span>]-=c;<span class="hljs-comment">//这里是为了构造 b[i] = a[i]-a[i-1]; - 每次都超减一位</span><br>    &#125;<br><span class="hljs-comment">//梳理</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<span class="hljs-comment">//这里是输入我们目的处理的数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<span class="hljs-comment">//这里是构造差分数组 - 构造完的由b数组存储</span><br> <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-built_in">insert</span>(l,r,c);<span class="hljs-comment">//这里就是对我们的差分数组处理数据 - 最终结果就是b数组</span><br>    &#125;<br><span class="hljs-comment">//输出结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) c[i] = c[i<span class="hljs-number">-1</span>]+b[i];<span class="hljs-comment">//b数组的所有元素加起来就是a数组</span><br> <span class="hljs-comment">//也就  b[i] = a[i] - a[i-1] 那么把b数组前缀和起来之后就是构造的a数组的序列</span><br> <span class="hljs-comment">//就是  差分数组整合就是构造差分数组的原序列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//模版代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> a[N],b[N],c[N];<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//构造差分数组的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    b[l]+=c;<br>    b[r+<span class="hljs-number">1</span>]-=c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-comment">//输入构造差分数组的原数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-comment">//构造差分序列 - b就是差分数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) <span class="hljs-built_in">insert</span>(i,i,a[i]);<br>    <br>    <span class="hljs-keyword">while</span>(m--)<br>    &#123;<br>        <span class="hljs-type">int</span> l,r,c;<br>        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;<br>        <span class="hljs-comment">//插入更改的值</span><br>        <span class="hljs-built_in">insert</span>(l,r,c);<br>    &#125;<br>    <span class="hljs-comment">//这里是析出原数组</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) c[i] = c[i<span class="hljs-number">-1</span>]+b[i];<br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维前缀和and二维差分"><a href="#二维前缀和and二维差分" class="headerlink" title="二维前缀和and二维差分"></a>二维前缀和and二维差分</h3><h4 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h4><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png" alt="二维前缀和"></p><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E5%88%86%E8%A7%A3.png" alt="二维前缀和分解"></p><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E9%A2%84%E5%A4%84%E7%90%86.png" alt="二维前缀和预处理"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//利用了容斥原理 - 将我们需要的区间分离出来</span><br> 同一维前缀和一样，我们先来定义一个二维数组s[][] , s[i][j] 表示二维数组中，左上角(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)到右下角(i, j)所包围的矩阵元素的和。接下来推导二维前缀和的公式。<span class="hljs-comment">//但是，要是起点不定怎么办呢~~~</span><br>     紫色面积是指(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(i, j - <span class="hljs-number">1</span>)右下角的矩形面积, 绿色面积是指(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(i - <span class="hljs-number">1</span>, j )右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。<br>     从图中我们很容易看出，整个外围蓝色矩形面积s[i][j] = 绿色面积s[i - <span class="hljs-number">1</span>][j] + 紫色面积s[i][j - <span class="hljs-number">1</span>] - 重复加的红色的面积s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + 小方块的面积a[i][j];<br> 因此得出二维前缀和预处理公式 s[i][j] = s[i - <span class="hljs-number">1</span>][j] + s[i][j - <span class="hljs-number">1</span> ] + a[i] [j] - s[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E6%B1%82%E8%B5%B7%E7%82%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="求起点不同的子矩阵"></p><p><img src="/2023/04/26/Two/%E5%88%86%E8%A7%A3%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="分解子矩阵"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。</span><br> 紫色面积是指 (<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(x1 - <span class="hljs-number">1</span>, y2)右下角的矩形面积 ，黄色面积是指(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)左上角到(x2, y1 - <span class="hljs-number">1</span>)右下角的矩形面积；<br> 绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - <span class="hljs-number">1</span>] - 紫色面积s[x1 - <span class="hljs-number">1</span>, y2] + 重复减去的红色面积 s[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br>    因此二维前缀和的结论为：<br>    以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：s[x2, y2] - s[x1 - <span class="hljs-number">1</span>, y2] - s[x2, y1 - <span class="hljs-number">1</span>] + s[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h4 id="二维差分-不太懂"><a href="#二维差分-不太懂" class="headerlink" title="二维差分 - 不太懂"></a>二维差分 - 不太懂</h4><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.png" alt="二维差分"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。</span><br> a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组<br>  原数组： a[i][j]<br>  我们去构造差分数组： b[i][j]<br> 使得a数组中a[i][j]是b数组左上角(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)到右下角(i,j)所包围矩形元素的和。<br><span class="hljs-comment">//如何构造b数组呢？</span><br> 其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。<br> 同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由<span class="hljs-built_in">O</span>(n*n)的时间复杂度优化成<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br> 已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;<br> 始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往后的每一个数。<br> 假定我们已经构造好了b数组，类比一维差分，我们执行以下操作来使被选中的子矩阵中的每个元素的值加上c：<br>  b[x1][y1] + = c ;<br>  b[x1,][y2+<span class="hljs-number">1</span>] - = c;<br>  b[x2+<span class="hljs-number">1</span>][y1] - = c;<br>  b[x2+<span class="hljs-number">1</span>][y2+<span class="hljs-number">1</span>] + = c;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86%E5%88%86%E8%A7%A3.png" alt="二维差分分解"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++">b[x1][y1] += c ; 对应图<span class="hljs-number">1</span> ,让整个a数组中蓝色矩形面积的元素都加上了c。<br>b[x1,][y2 + <span class="hljs-number">1</span>] -= c ; 对应图<span class="hljs-number">2</span> ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。<br>b[x2 + <span class="hljs-number">1</span>][y1] -= c ; 对应图<span class="hljs-number">3</span> ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。<br>b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c; 对应图<span class="hljs-number">4</span>,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。<br>    <br><span class="hljs-comment">//封装插入函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x1,<span class="hljs-type">int</span> y1,<span class="hljs-type">int</span> x2,<span class="hljs-type">int</span> y2,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;  <span class="hljs-comment">//对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c</span><br>    b[x1][y1] += c;<br>    b[x2 + <span class="hljs-number">1</span>][y1] -= c;<br>    b[x1][y2 + <span class="hljs-number">1</span>] -= c;<br>    b[x2 + <span class="hljs-number">1</span>][y2 + <span class="hljs-number">1</span>] += c;<br>&#125;<br><span class="hljs-comment">//构造</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>  &#123;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= m;j++)<br>      &#123;<br>          <span class="hljs-built_in">insert</span>(i, j, i, j, a[i][j]);    <span class="hljs-comment">//构建差分数组</span><br>      &#125;<br>  &#125;<br><br><span class="hljs-comment">//理解</span><br> 我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 c = a[i][j] ，等价于原数组a中(i,j) 到(i,j)范围内 加上了 a[i][j] ,因此执行 n*m次插入操作，就成功构建了差分b数组.<br></code></pre></td></tr></table></figure><h3 id="双指针维护区间"><a href="#双指针维护区间" class="headerlink" title="双指针维护区间"></a>双指针维护区间</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/71643340">算法一招鲜——双指针问题 - 知乎 (zhihu.com)</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//什么是双指针（对撞指针、快慢指针）</span><br> 双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。<br></code></pre></td></tr></table></figure><h4 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。</span><br> 对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。<br>        <br><span class="hljs-comment">//伪代码</span><br><span class="hljs-function">function <span class="hljs-title">fn</span> <span class="hljs-params">(list)</span> </span>&#123;<br>  var left = <span class="hljs-number">0</span>;<br>  var right = list.length - <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">//遍历数组</span><br>  <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>    left++;<br>    <span class="hljs-comment">// 一些条件判断 和处理</span><br>    ... ...<br>    right--;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//对撞指针能够解决：：1.二分查找 2.两数之和 II - 输入有序数组 3.反转字符串 4.反转字符串中的元音字母 5.回文字符串</span><br></code></pre></td></tr></table></figure><h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"> 快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。<br><br><span class="hljs-comment">//伪代码</span><br>slow = head;<br>fast = head;<br><span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>    slow = slow-&gt;next;<br>    fast = fast-&gt;next-&gt;next;<br>    <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br><span class="hljs-comment">//快慢指针能够解决：链表中倒数第k个节点  1.链表的中间节点 2.链表是否有环 3.链表环的长度 4.链表环的起点</span><br><span class="hljs-comment">//判断链表是否有环</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">NULL</span> || head-&gt;next == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    ListNode *slow = head; <span class="hljs-comment">// 慢指针</span><br>    ListNode *fast = head-&gt;next; <span class="hljs-comment">// 快指针</span><br>    <span class="hljs-keyword">while</span> (slow != fast) &#123; <span class="hljs-comment">// 当快慢指针不相遇时</span><br>        <span class="hljs-keyword">if</span> (fast == <span class="hljs-literal">NULL</span> || fast-&gt;next == <span class="hljs-literal">NULL</span>) &#123; <span class="hljs-comment">// 如果快指针到达链表尾部，说明链表没有环</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        slow = slow-&gt;next; <span class="hljs-comment">// 慢指针走一步</span><br>        fast = fast-&gt;next-&gt;next; <span class="hljs-comment">// 快指针走两步</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 如果快慢指针相遇，说明链表有环</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote><p><a href="https://zhuanlan.zhihu.com/p/144296454">图文并茂详解数据结构之哈希表 - 知乎 (zhihu.com)</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//哈希表是散列表 - 可以理解为哈希是映射的因子（我瞎编），哈希表本质上就是两个不同的数据集合映射的过程</span><br>简介：<br> 哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。<br>    哈希表采用的是一种转换思想，其中一个中要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标。我们先来通过一个例子来理解这句话。<span class="hljs-comment">//数字和数字有映射关系，数字和字符要创造映射关系（虽然说字符也是数字，但是他们并没有映射关系：例如 1 - 1有映射，1 - 10086 没有，所以说我们需要用哈希创造他们的映射关系 - 是这样吗？） </span><br> 我们上学的时候，大家都会有一个学号「<span class="hljs-number">1</span>-n号」中的一个号码，如果我们用哈希表来存放班级里面学生信息的话，我们利用学号作为「键」或者「关键字」，这个「键」或者「关键字」就可以直接作为数据的下标，不需要通过哈希函数进行转化。如果我们需要安装学生姓名作为「键」或者「关键字」，这时候我们就需要哈希函数来帮我们转换成数组的下标。<span class="hljs-comment">//键对应关键字 - 这就是映射关系</span><br>    <br><span class="hljs-comment">//哈希函数</span><br>    哈希函数的作用是帮我们把非<span class="hljs-type">int</span>的「键」或者「关键字」转化成<span class="hljs-type">int</span>，可以用来做数组的下标。比如我们上面说的将学生的姓名作为「键」或者「关键字」，这是就需要哈希函数来完成，下图是哈希函数的转换示意图。<span class="hljs-comment">//就是将数据离散化是吧</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/hash.jpg" alt="hash"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//哈希函数的写法有很多中，我们来看看「HashMap」中的哈希函数</span><br> <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        <span class="hljs-type">int</span> h;<br>        <span class="hljs-keyword">return</span> (key == null) ? <span class="hljs-number">0</span> : (h = key.<span class="hljs-built_in">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">//「HashMap」中利用了「hashCode」来完成这个转换。哈希函数不管怎么实现，都应该满足下面三个基本条件：</span><br><br><span class="hljs-comment">//散列函数计算得到的散列值是一个非负整数</span><br> 如果 key1 = key2，那 <span class="hljs-built_in">hash</span>(key1) == <span class="hljs-built_in">hash</span>(key2)<br> 如果 key1 ≠ key2，那 <span class="hljs-built_in">hash</span>(key1) ≠ <span class="hljs-built_in">hash</span>(key2)  <br> 第一点：因为数组的下标是从<span class="hljs-number">0</span>开始，所以哈希函数生成的哈希值也应该是非负数<br> 第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据<span class="hljs-comment">//因为key是查找散列表中的值，如果两个相等的key映射的位置不同的话，那么我们就无法查找散列表的值</span><br> 第三点：看起来非常合理，但是两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突<span class="hljs-comment">//数据足够大的时候，映射的格子不够多，那么就会出现哈希冲突 - 原因是因为映射关系这个本质，我们只是把一一对应离散化了，还是可能出现重复的</span><br><br><span class="hljs-comment">//哈希冲突</span><br>     哈希冲突是不可避免的，我们常用解决哈希冲突的方法有两种「开放地址法」和「链表法」<br></code></pre></td></tr></table></figure><h4 id="链表查找"><a href="#链表查找" class="headerlink" title="链表查找"></a>链表查找</h4><p> 在开放地址法中，若数据不能直接存放在哈希函数计算出来的数组下标时，就需要寻找其他位置来存放。在开放地址法中有三种方式来寻找其他的位置，分别是「线性探测」、「二次探测」、「再哈希法」</p><h5 id="线性探查"><a href="#线性探查" class="headerlink" title="线性探查"></a>线性探查</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性探查  </span><br>  在线性探测哈希表中，数据的插入是线性的查找空白单元，例如我们将数<span class="hljs-number">88</span>经过哈希函数后得到的数组下标是<span class="hljs-number">16</span>，但是在数组下标为<span class="hljs-number">16</span>的地方已经存在元素，那么就找<span class="hljs-number">17</span>,<span class="hljs-number">17</span>还存在元素就找<span class="hljs-number">18</span>，一直往下找，直到找到空白地方存放元素。我们来看下面这张图 <br>    我们向哈希表中添加一个元素钱多多，钱多多经过哈希函数后得到的数组下标为<span class="hljs-number">0</span>，但是在<span class="hljs-number">0</span>的位置已经有张三了，所以下标往前移，直到下标<span class="hljs-number">4</span>才为空，所以就将元素钱多多添加到数组下标为<span class="hljs-number">4</span>的地方。<span class="hljs-comment">//有位填数，没位向下搜索空白的位置 </span><br><span class="hljs-comment">//代码</span><br><span class="hljs-comment">//哈希函数 - size一般是质数？</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (key % size);<br>&#125;<br><span class="hljs-comment">//插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>    <span class="hljs-type">int</span> key = student.<span class="hljs-built_in">getKey</span>();<br>    <span class="hljs-type">int</span> hashVal = <span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-keyword">while</span> (array[hashVal] != <span class="hljs-literal">NULL</span> &amp;&amp; array[hashVal].<span class="hljs-built_in">getKey</span>() != <span class="hljs-number">-1</span>) &#123;<br>        ++hashVal;<br>        <span class="hljs-comment">//超过数组大小 - 从第一个开始找</span><br>        hashVal %= size;<br>    &#125;<br>    array[hashVal] = student;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    LinearProbingHash hash = <span class="hljs-built_in">LinearProbingHash</span>(<span class="hljs-number">10</span>);<br>    Student student = <span class="hljs-built_in">Student</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>    Student student1 = <span class="hljs-built_in">Student</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;王强&quot;</span>);<br>    Student student2 = <span class="hljs-built_in">Student</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;张伟&quot;</span>);<br>    Student student3 = <span class="hljs-built_in">Student</span>(<span class="hljs-number">11</span>,<span class="hljs-string">&quot;宝强&quot;</span>);<br>    hash.<span class="hljs-built_in">insert</span>(student);<br>    hash.<span class="hljs-built_in">insert</span>(student1);<br>    hash.<span class="hljs-built_in">insert</span>(student2);<br>    hash.<span class="hljs-built_in">insert</span>(student3);<br>    hash.<span class="hljs-built_in">disPlayTable</span>();<br>&#125;<br><br><span class="hljs-comment">//查找</span><br><span class="hljs-function">Student* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-type">int</span> hashVal = <span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-keyword">while</span> (array[hashVal] !=<span class="hljs-literal">nullptr</span>)&#123;<br>        <span class="hljs-keyword">if</span> (array[hashVal]-&gt;<span class="hljs-built_in">getKey</span>() == key)&#123;<br>            <span class="hljs-keyword">return</span> array[hashVal];<br>        &#125;<br>        ++hashVal;<br>        hashVal %=size;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%9F%A5.webp" alt="线性探查"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//线性筛查删除</span><br> 线性探测哈希表的删除相对来说比较复杂一点，我们不能简单的把这一项数据删除，让它变成空，为什么呢？<br> 线性探测哈希表在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。？<br> 因此我们需要一个特殊的数据来顶替这个被删除的数据，因为我们的学生学号都是正数，所以我们用学号等于<span class="hljs-number">-1</span>来代表被删除的数据。<br><span class="hljs-comment">//后果</span><br> 这样会带来一个问题，如何在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为<span class="hljs-number">-1</span>的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> key)</span></span>&#123;<br>    <span class="hljs-type">int</span> hashVal = <span class="hljs-built_in">hash</span>(key);<br>    <span class="hljs-keyword">while</span> (array[hashVal] !=null)&#123;<br>        <span class="hljs-keyword">if</span> (array[hashVal].<span class="hljs-built_in">getKey</span>() == key)&#123;<br>            Student temp = array[hashVal];<br>            array[hashVal]= noStudent;<br>            <span class="hljs-keyword">return</span> temp;<br>        &#125;<br>        ++hashVal;<br>        hashVal %=size;<br>    &#125;<br>    <span class="hljs-keyword">return</span> null;<br>&#125;        <br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/hash%E5%88%A0%E9%99%A4.webp" alt="hash删除"></p><h5 id="二次筛查"><a href="#二次筛查" class="headerlink" title="二次筛查"></a>二次筛查</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//当然 二次筛查也不是完美的操作 </span><br> 在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。这个就像我们在逛超市一样，当某个地方人很多时，人只会越来越多，大家都只是想知道这里在干什么。<br> 二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+<span class="hljs-number">1</span>,x+<span class="hljs-number">2</span>,x+<span class="hljs-number">3.</span>.....，以此类推，而在二次探测中，探测过程是x+<span class="hljs-number">1</span>,x+<span class="hljs-number">4</span>,x+<span class="hljs-number">9</span>,x+<span class="hljs-number">16</span>,x+<span class="hljs-number">25.</span>.....,以此类推，到原始距离的步数平方，为了方便理解，我们来看下面这张图<span class="hljs-comment">//就是，我们通过记录前面的探查，可以减少探查的次数</span><br> 还是使用线性探测中的例子，在线性探测中，我们从原始探测位置每次往后推一位，最后找到空位置，在线性探测中我们找到钱多多的存储位置需要经过<span class="hljs-number">4</span>步。在二次探测中，每次是原始距离步数的平方，所以我们只需要两次就找到钱多多的存储位置。<br> 二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。<br> 比如讲<span class="hljs-number">1</span>、<span class="hljs-number">11</span>、<span class="hljs-number">21</span>、<span class="hljs-number">31</span>、<span class="hljs-number">41</span>依次插入到哈希表中，它们映射的位置都是<span class="hljs-number">1</span>，那么<span class="hljs-number">11</span>需要以一为步长探测，<span class="hljs-number">21</span>需要以四为步长探测，<span class="hljs-number">31</span>需要为九为步长探测，<span class="hljs-number">41</span>需要以十六为步长探测，只要有一项映射到<span class="hljs-number">1</span>的位置，就需要更长的步长来探测，这个现象叫做二次聚集。<br></code></pre></td></tr></table></figure><p><img src="https://pic2.zhimg.com/80/v2-0f9eb8694b479a0a5a034251a2b93135_720w.webp" alt="img"></p><h5 id="双哈希"><a href="#双哈希" class="headerlink" title="双哈希"></a>双哈希</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。</span><br>第二个哈希函数必须具备如下特点:<br>  <span class="hljs-number">1.</span>和第一个哈希函数不一样<br>         <span class="hljs-number">2.</span>不能输出为<span class="hljs-number">0</span>，因为步长为<span class="hljs-number">0</span>，每次探测都是指向同一个位置，将进入死循环，经过试验得出stepSize = constant-(key%constant);形式的哈希函数效果非常好，constant是一个质数并且小于数组容量<br><span class="hljs-comment">//我们将上面的添加改变成双哈希探测，示意图如下：           </span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E5%8F%8C%E5%93%88%E5%B8%8C.webp" alt="双哈希"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//双哈希</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> h[N],nxt[N],idx;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=(x%N+N)%N; <span class="hljs-comment">// 计算哈希值</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=h[t];~i;i=nxt[i]) <span class="hljs-comment">// 遍历哈希表中的链表</span><br>        <span class="hljs-keyword">if</span>(e[i]==x)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 如果找到了键 x，返回 1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 否则返回 0</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> t=(x%N+N)%N; <span class="hljs-comment">// 计算哈希值</span><br>    e[idx]=x;nxt[idx]=h[t];h[t]=idx++; <span class="hljs-comment">// 将键值对插入到哈希表中</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h); <span class="hljs-comment">// 初始化哈希表为空</span><br>    <span class="hljs-type">int</span> n;cin&gt;&gt;n;<br>    <span class="hljs-keyword">while</span>(n--)&#123;<br>        <span class="hljs-type">char</span> op;cin&gt;&gt;op;<br>        <span class="hljs-type">int</span> x;cin&gt;&gt;x;<br>        <span class="hljs-keyword">if</span>(op==<span class="hljs-string">&#x27;I&#x27;</span>)<span class="hljs-built_in">insert</span>(x); <span class="hljs-comment">// 如果是插入操作，将键 x 插入到哈希表中</span><br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">find</span>(x))<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>); <span class="hljs-comment">// 如果键 x 在哈希表中，输出 Yes</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>); <span class="hljs-comment">// 否则输出 No</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h5><p><img src="/2023/04/26/Two/%E6%8B%89%E9%93%BE%E6%B3%95.png" alt="拉链"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span> + <span class="hljs-number">3</span>;          <span class="hljs-comment">// 选取的质数为100003</span><br><span class="hljs-type">int</span> h[N], e[N], ne[N], idx;     <span class="hljs-comment">// 构建邻接表</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;             <span class="hljs-comment">// 头插法</span><br>    <span class="hljs-type">int</span> k = (x % N + N) % N;    <span class="hljs-comment">// 除留余数法</span><br>    e[idx] = x;   ne[idx] = h[k];   h[k] = idx++;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span></span>&#123;              <span class="hljs-comment">// 查找</span><br>    <span class="hljs-type">int</span> n = (k % N + N) % N;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[n]; i != <span class="hljs-number">-1</span>; i = ne[i])&#123;<br>        <span class="hljs-keyword">if</span>(e[i] == k)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> m;      <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br>    <span class="hljs-comment">// 初始化邻接表</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= N; i++)       h[i] = <span class="hljs-number">-1</span>;    <br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">char</span> op[<span class="hljs-number">2</span>];     <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, op);<br>        <span class="hljs-type">int</span> x;          <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        <br>        <span class="hljs-keyword">if</span>(*op == <span class="hljs-string">&#x27;I&#x27;</span>)  <span class="hljs-built_in">insert</span>(x);<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">query</span>(x))        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>            <span class="hljs-keyword">else</span>                <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希"></a>字符串哈希</h4><blockquote><p><a href="https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">字符串哈希</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//字符串hash</span><br> 构造唯一数据表示字符串，可以理解为 <span class="hljs-built_in">f</span>(x) = y。就是通过某种方法转化，使得两个毫无相关的数据产生关系。但是为了将映射关系进行一一对应，也就是，一个字符串对应一个数字，那么一个数字也对应一个字符串。<br> 用字符串Hash的目的是，我们如果要比较一个字符串，我们不直接比较字符串，而是比较它对应映射的数字，这样子就知道两个“子串”是否相等。从而达到，子串的Hash值的时间为 <span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)，进而可以利用“空间换时间”来节省时间复杂的。<br>    我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。不用担心，接下来的内容正要讲解。<span class="hljs-comment">//我们只需要用到数字来匹配数据，这样对数字操作就可以得到我们想要的操作了</span><br></code></pre></td></tr></table></figure><h5 id="构造字符串hash"><a href="#构造字符串hash" class="headerlink" title="构造字符串hash"></a>构造字符串hash</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单例子</span><br> 假如给你一个数字<span class="hljs-number">1166</span>，形式上你只知道它只是<span class="hljs-number">1</span>和<span class="hljs-number">6</span>的组合，但你知道它代表的实际大<span class="hljs-number">1</span>*<span class="hljs-number">10</span>^<span class="hljs-number">3</span>+<span class="hljs-number">1</span>*<span class="hljs-number">10</span>^<span class="hljs-number">2</span>+<span class="hljs-number">6</span>*<span class="hljs-number">10</span>^<span class="hljs-number">1</span>+<span class="hljs-number">6</span>*<span class="hljs-number">10</span>^<span class="hljs-number">0</span>。<br> 同理，给你一个字符串，要把它转换为数字，就可以先把每一个字符都先对应一个数字，然后把它们按照顺序乘以进制（Base）的幂进行相加，然后这个数可能很大，所以一般会取余数（MOD）。    <br><span class="hljs-comment">//具体操作</span><br>    根据上面的理解，其实将字符串映射成数字，和我们平时的将一个 某Base进制数，变为一个十进制数，相类似。<span class="hljs-comment">//把字符串当成 某种进制的数据，把字符串拆成很多位，然后对每一个位置的字符都进行哈希操作，再用进制的乘法操作将他们拼接起来。</span><br> 我们先定义以下：<br> 给定一个字符串 S = s1s2s3...sn，对于每一个si就是一个字母，那么我们规定<br>         <span class="hljs-built_in">idx</span>(si) = si-<span class="hljs-string">&#x27;a&#x27;</span>+<span class="hljs-number">1</span> （当然也可以直接用其ASCII值）<br> 构造字符串Hash总共有三种方法。每一种方法，主要都是用使用 Base 和 MOD（都要求是素数），一般都是 Base  &lt; MOD，同时将Base和MOD尽量取大即可，这种情况下，冲突（即不同字符串却有着相同的hash值）的概率是很低的<br><br><span class="hljs-comment">//1.自然溢出方法 - 后面还有</span><br> 对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> 整数的自然溢出<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//怎么构建我们的字符串前缀</span><br>  <span class="hljs-number">1.</span>将整个数组 当做是一个p进制的数。 通过这样的方式，将我们的字符串变成数字进行操作（本质上 字符串也是数字） - 但是我们这个数组转化完成可能会非常大 那么我们就mod一个大的数据 - 通过这样的方法映射到小区间中 <span class="hljs-comment">//取模会重复怎么办 还是说随机存储</span><br>    <span class="hljs-number">2.</span>字符串哈希完全不考虑冲突的情况 <br>    <span class="hljs-number">3.</span> p = <span class="hljs-number">131</span> <span class="hljs-keyword">or</span> <span class="hljs-number">13331</span> - Q = <span class="hljs-number">2e64</span> 这样可以忽略冲突 （溢出等价于 mod <span class="hljs-number">2e64</span>）<br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C.png" alt="image-20230226201946750"></p><p>标准流程</p><p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2hash1.png" alt="原理"></p><p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2hash2.png" alt="原理2"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//相当于将字符型映射为整型（本来就是 将字符串映射成一个p进制的数据 - p一般为质数）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ULL;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> P = <span class="hljs-number">131</span>;<br><span class="hljs-comment">// p[i] = P^i, h[i] = s[1~i]的hash值</span><br>ULL p[N],h[N];<br><br><span class="hljs-comment">//预处理</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//字符串长度就是对应的进制 p^n - 也可以说是长度是项数的个数</span><br>    p[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>,h[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        p[i] = p[i<span class="hljs-number">-1</span>]*P; <span class="hljs-comment">//P是进制</span><br>        h[i] = h[i<span class="hljs-number">-1</span>]*P+s[i];<span class="hljs-comment">//s是对应字符的ASCII值是吧</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//计算s[l~r]的哈希值</span><br><span class="hljs-function">ULL <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">int</span> l,<span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> h[r]-h[l<span class="hljs-number">-1</span>]*p[r-l+<span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">//判断两个子串是否相等</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">substr</span><span class="hljs-params">(<span class="hljs-type">int</span> l1,<span class="hljs-type">int</span> r1,<span class="hljs-type">int</span> l2,<span class="hljs-type">int</span> r2)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">get</span>(l1,r1) == <span class="hljs-built_in">get</span>(l2,r2);<br>&#125;<br><br><span class="hljs-comment">//总结：字符串哈希使用来解决字符串匹配，查找去重的问题的。</span><br></code></pre></td></tr></table></figure><p><img src="/2023/04/26/Two/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E5%8E%9F%E7%90%863.png" alt="原理3"></p><h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="高精度加法计算"><a href="#高精度加法计算" class="headerlink" title="高精度加法计算"></a><strong>高精度加法计算</strong></h4><p>​  如果我们要将一个很大的数据与一个很小的数据相加应该怎么办，你可能会想，直接加就行了嘛，10000+1&#x3D;10001，很简单。但是，在计算机中，我们使用的数据类型在计算的时候，往往会将小的数据忽略掉，也就是，1e99+1 &#x3D; 1e99,而1就不见了。我们需要的是保持精度的情况下进行加法，这个时候我们可以利用我们的线性表，数组来实现这个保留精度的加法。</p><p>A+B（这里的情况是一个大的数据加上另一个大的数据）</p><p>​  依照上面的说法，我们就开辟两个字符串数组（比较好分离数据），一个a【】存A这个数据，一个b【】存B这个数据。但为了方便接下来的操作，我们还是开辟两个Vector(向量：是个容器)，然后将输入的a,b中的数据导入到我们的vector中，这个时候注意一个细节。</p><p>​  我们插入的数据是要倒着插入的，举个例子：123456789，这是一个大的数据，倒着插入意味着个位在数组（容器）的前面（之后的数据以此类推）。在数组中就变成了987654321，这样做的好处是进位不用移动数组中的元素，你看我们的目的是要计算这些大数据的加和，在加和的过程中免不了会产生进位，如果用123456789，进一位的话就要移动整个数组，就十分复杂。如果反过来，我们只需要在进的那位尾插一个数据就行。</p><p>​  同时，计算方法其实就和我们手工计算的差不多，对位计算加上进位即可，举个例子：1+9 &#x3D; 10，其实就是十位上面+进位t&#x3D;1 &#x3D; 10,就是这样。</p><p>代码实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C = A+B c是我们要实现的结果</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<span class="hljs-comment">//这是结果</span><br>    <br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span><span class="hljs-comment">//进位</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//只要没遍历完最长的就继续</span><br>    &#123;<br>        <span class="hljs-comment">//下面实现的是 t在i这个位置的值，然后%10就是这个位置剩下的值，/10就是进位的值保留到i+1（下一位）</span><br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i];<br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t+=B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//将对应位置的数据插入结果</span><br>        t/=<span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(t) C.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<span class="hljs-comment">//进大位，出来t/10还有剩，那肯定进位了（我们是倒叙输入的嘛）</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">//倒叙输入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//自己输入两个大的数据</span><br>    <span class="hljs-comment">//为啥是size-1，就是0到i有i-1个数据嘛</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//倒着插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <span class="hljs-comment">//自动判断是啥类型</span><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">add</span>(A,B);<span class="hljs-comment">//调用模板</span><br>    <span class="hljs-comment">//输出</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br><br></code></pre></td></tr></table></figure><h4 id="高精度减法计算"><a href="#高精度减法计算" class="headerlink" title="高精度减法计算"></a><strong>高精度减法计算</strong></h4><p>​  减法的计算其实和加法差不多，但是我们需要满足一些条件；1.A&gt;&#x3D;B 不满足就要交换两个数据的值（加上负号）2.向前借位是+10（对于当前位数）所以说方向就很明确了，加上一个判断A,B大小的关系，对 t 改一下就行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(A.<span class="hljs-built_in">size</span>()!=B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> A.<span class="hljs-built_in">size</span>()&gt;B.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>        <span class="hljs-keyword">if</span>(A[i]!=B[i]) <span class="hljs-keyword">return</span> A[i]&gt;B[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//C = A-B c是我们要实现的结果</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span>/模板</span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<span class="hljs-comment">//这是结果</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>,t = <span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||i&lt;B.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//只要没遍历完最长的就继续</span><br>    &#123;<br>  t = A[i] - t;<span class="hljs-comment">//t是借位的</span><br>        <span class="hljs-keyword">if</span>(i&lt;B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t+<span class="hljs-number">10</span>)%<span class="hljs-number">10</span>);<span class="hljs-comment">//这里的t有两种情况，一种减完之&lt;0，那就需要借位+10.一种是减完之后&gt;=0，不需要借位。这个时候，(t+10)%10这两种情况都满足，举个例子：1.你减完之后变成了-9，那就是要借一位，就是-9+10 = 1,1%10还是1.2.你减完之后，还剩下9，那么9%10还是9.</span><br>        <span class="hljs-keyword">if</span>(t&lt;<span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>()== <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br><br>&#125;<br><span class="hljs-comment">//倒叙输入</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>  </span><br><span class="hljs-function"></span>&#123;<br>    string a,b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A,B;<br>    cin&gt;&gt;a&gt;&gt;b;<span class="hljs-comment">//自己输入两个大的数据</span><br>    <span class="hljs-comment">//为啥是size-1，就是0到i有i-1个数据嘛</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//倒着插入</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = b.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) B.<span class="hljs-built_in">push_back</span>(b[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>    <br>    <span class="hljs-comment">//用上面的判断，计算A-B 或者 B-A</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">cmp</span>(A,B))<br>    &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(A,B);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i --) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">sub</span>(B,A);<span class="hljs-comment">//B&gt;A</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="高精度乘法计算"><a href="#高精度乘法计算" class="headerlink" title="高精度乘法计算"></a>高精度乘法计算</h4><p>大数据乘小数据</p><p>​ 在人工计算乘法的时候，我们一般是一位一位的计算，例如：123乘12，那么一般是2 <em>123+10</em> 123。但是这样其实比较繁琐，我们在计算高精度的时候，可以把这两个数据中的小数据，单独拿出来做一个整体，就上面那个来说，就变成了1 <em>12</em> 100+2 <em>12</em> 10+3 <em>12</em> 1，竖式就由两个变成一个了。</p><p>​ 同时，在计算的时候，每一个位的位数t也需要注意，举个例子：123456789<em>12，这里的 （第一位）a &#x3D; 9,进位就变成了 t &#x3D; 9</em> 12&#x2F;10，输入到结果C的就变成了 (第一位)C &#x3D; 9*12%10，这样就定下来了。下面是代码演示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b)</span><span class="hljs-comment">//b比较小就直接用int表示（整体）</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;A.<span class="hljs-built_in">size</span>()||t;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(i&lt;A.<span class="hljs-built_in">size</span>()) t+=A[i]*b;<span class="hljs-comment">//遍历位置乘完的数据</span><br>        c.<span class="hljs-built_in">push_back</span>(t%<span class="hljs-number">10</span>);<span class="hljs-comment">//插进去计算完成之后这个位置的具体数</span><br>        t/=<span class="hljs-number">10</span>;<span class="hljs-comment">//进位</span><br>        <br>    &#125;<br>    <span class="hljs-keyword">return</span> C;<br>    <br>&#125;<br><span class="hljs-comment">//插入数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<span class="hljs-comment">//数据大用字符串存储</span><br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//这里是把字符串转化成具体的数，由ASCII决定的，在字符&#x27;0&#x27;代表的是48</span><br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">mul</span>(A,b);<span class="hljs-comment">//调用容器</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="高精度除法计算"><a href="#高精度除法计算" class="headerlink" title="高精度除法计算"></a>高精度除法计算</h4><p>大数据除小数据（一般用的不多）</p><p>​ 在人工计算除法的时候，一般是从大到小位去除的。但是，一个题目难免会出现加减乘除多种运算，所以说我们还是尾插大数据把。具体做法和乘法差不多，就是把小的看成整体（平常我们算除法是这样）下面是代码演示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> &amp;r)</span><span class="hljs-comment">//b是小的</span></span><br><span class="hljs-function"></span>&#123;<br> vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--)<br>    &#123;<br>        r = r*<span class="hljs-number">10</span>+A[i];<span class="hljs-comment">//计算的时候，和我们把上一位除不了移下来算是一个样子的</span><br>        C.<span class="hljs-built_in">push_back</span>(r/b);<span class="hljs-comment">//余数插入结果中</span><br>        r%=b;<span class="hljs-comment">//除完之后的余数</span><br>        <br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(),C.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//翻转</span><br>    <span class="hljs-keyword">while</span>(C.<span class="hljs-built_in">size</span>()&gt;<span class="hljs-number">1</span>&amp;&amp;C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<span class="hljs-comment">//去除前端0</span><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br><span class="hljs-comment">//插入数据</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string a;<span class="hljs-comment">//数据大用字符串存储</span><br>    <span class="hljs-type">int</span> b;<br>    cin&gt;&gt;a&gt;&gt;b;<br>    vector&lt;<span class="hljs-type">int</span>&gt; A;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = a.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) A.<span class="hljs-built_in">push_back</span>(a[i] - <span class="hljs-string">&#x27;0&#x27;</span>);<span class="hljs-comment">//这里是把字符串转化成具体的数，由ASCII决定的，在字符&#x27;0&#x27;代表的是48</span><br>    <span class="hljs-type">int</span> r;<br>    <span class="hljs-keyword">auto</span> C = <span class="hljs-built_in">div</span>(A,b,r);<span class="hljs-comment">//调用容器</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = C.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i&gt;=<span class="hljs-number">0</span>;i--) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,C[i]);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>One 基本算法</title>
      <link href="/2023/04/26/One/"/>
      <url>/2023/04/26/One/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章-基础算法"><a href="#第一章-基础算法" class="headerlink" title="第一章 基础算法"></a>第一章 基础算法</h2><h2 id="时间复杂度和空间复杂度的基本估计"><a href="#时间复杂度和空间复杂度的基本估计" class="headerlink" title="时间复杂度和空间复杂度的基本估计"></a>时间复杂度和空间复杂度的基本估计</h2><p><img src="/2023/04/26/One/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="时间复杂度"></p><h2 id="基本算法说明"><a href="#基本算法说明" class="headerlink" title="基本算法说明"></a>基本算法说明</h2><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.枚举的定义</span><br>  枚举（英语：Enumerate）是基于已有知识来猜测答案的一种问题求解策略。<br>  枚举的思想是不断地猜测，从可能的集合中一一尝试，然后再判断题目的条件是否成立。<br><span class="hljs-comment">//2.简单来说，枚举就是在有限次的比对中，找到与正确答案符合的数据。</span><br>    枚举经常出现，算是最为基本的算法 - 之后对枚举的优化也是一些算法复杂度低的原因<br>    总体来说，枚举的复杂度需要看我们取得的数据的个数 一个那就是 <span class="hljs-built_in">o</span>(n) 多个就是<span class="hljs-built_in">o</span>(n^i)<br><span class="hljs-comment">//3.简单举例</span><br>    要求一个数组中，有多少个<span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = i;i&lt;=n;i++) <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">0</span>) ans++<br>    <span class="hljs-keyword">return</span> ans<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//深入研究</span><br> 枚举算法是我们在日常中使用到的最多的一个算法，它的核心思想就是:枚举所有的可能。<br> 枚举法的本质就是从所有候选答案中去搜索正确的解,使用该算法需要满足两个条件：<br>  (<span class="hljs-number">1</span>)可预先确定候选答案的数量；<span class="hljs-comment">//可以确定答案就在我们枚举的范围之中</span><br>  (<span class="hljs-number">2</span>)候选答案的范围在求解之前必须有一个确定的集合。<span class="hljs-comment">//范围</span><br>  枚举算法简单粗暴，他暴力的枚举所有可能，尽可能地尝试所有的方法。虽然枚举算法非常暴力，而且速度可能很慢，但确实我们最应该优先考虑的！因为枚举法变成实现最简单，并且得到的结果总是正确的。<br> 枚举算法分为循环枚举、子集枚举、排列枚举三种。<br></code></pre></td></tr></table></figure><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//说白了 模拟题就是应用题 给出一个项目让你实现它</span><br><br><span class="hljs-comment">//写模拟题时，遵循以下的建议有可能会提升做题速度：</span><br>  <span class="hljs-number">1.</span>在动手写代码之前，在草纸上尽可能地写好要实现的流程。<br>  <span class="hljs-number">2.</span>在代码中，尽量把每个部分模块化，写成函数、结构体或类。<br>  <span class="hljs-number">3.</span>对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 <span class="hljs-string">&quot;YY-MM-DD 时：分&quot;</span> 把它抽取到一个函数，处理成秒，会减少概念混淆。<br>  <span class="hljs-number">4.</span>调试时分块调试。模块化的好处就是可以方便的单独调某一部分。<br>  <span class="hljs-number">5.</span>写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。<br></code></pre></td></tr></table></figure><h3 id="递归和分治-简单了解"><a href="#递归和分治-简单了解" class="headerlink" title="递归和分治 - 简单了解"></a>递归和分治 - 简单了解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.递归 </span><br> 函数调用自身。递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为了许多性质相同但是规模更小的子问题。求解时只需要关注如何把原问题划分成符合条件的子问题，而不需要过分关注这个子问题是如何被解决的。<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(传入数值)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (终止条件) <span class="hljs-keyword">return</span> 最小子问题解;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">func</span>(缩小规模);<br>  &#125;<br><span class="hljs-comment">//2.递归的实现</span><br> 只需要在乎，把大问题分解为许多小问题就行了，不用在意子问题如何实现。 当然，我们得初始化刚开始的子问题（要不然后面的问题就无法按找 小问题变为大问题递推出来）<br><span class="hljs-comment">//3.缺点</span><br>    递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成 栈溢出 的后果。（但是我没遇过）<br><span class="hljs-comment">//4.递归的要点</span><br>    明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊。（明白每个函数能做的事，并相信他们能够完成和我之前想的不谋而合）<br><span class="hljs-comment">//举例 遍历二叉树</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>     <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-built_in">traverse</span>(root-&gt;left);<br>     <span class="hljs-built_in">traverse</span>(root-&gt;right);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.分治</span><br> 说白了就是，将大问题分成多个小问题（一般都是 二分 logn 次啦），然后再对小问题得出的数据进行操作，归并排序就是将小问题按照既定规则拼回去.其他的也差不多<br><span class="hljs-comment">//2.分治法的流程</span><br> 大概的流程可以分为三步：分解 -&gt; 解决 -&gt; 合并。<br><span class="hljs-number">1.</span>分解原问题为结构相同的子问题。<br><span class="hljs-number">2.</span>分解到某个容易求解的边界之后，进行递归求解。<br><span class="hljs-number">3.</span>将子问题的解合并成原问题的解。<br><br><span class="hljs-comment">//分治法能解决的问题一般有如下特征：</span><br><span class="hljs-number">1.</span>该问题的规模缩小到一定的程度就可以容易地解决。<br><span class="hljs-number">2.</span>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。<br><span class="hljs-number">3.</span>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题（子问题独立）。（公共的子问题需要动态规划来解决）<br></code></pre></td></tr></table></figure><h3 id="贪心-简单了解"><a href="#贪心-简单了解" class="headerlink" title="贪心 - 简单了解"></a>贪心 - 简单了解</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.概念</span><br> 贪心算法（英语：greedy algorithm），是用计算机来模拟一个「贪心」的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。<br> 可想而知，并不是所有的时候贪心法都能获得最优解，所以一般使用贪心法的时候，都要确保自己能证明其正确性。一般来说，我们可以引用某一个步骤来反证我们的答案是否正确<br><span class="hljs-comment">//2.常见题型</span><br> 「我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。」。（离线 先处理在选择）<br>  「我们每次都取 XXX 中最大/小的东西，并更新 XXX。」（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）（边处理 边选择）<br><span class="hljs-comment">//3.两种方法</span><br>      <span class="hljs-number">01.</span>排序解法 用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。<br>      <span class="hljs-number">02.</span>后悔解法 思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。<br><span class="hljs-comment">//4.特殊性质</span><br>      贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行选择，有回退功能。<br></code></pre></td></tr></table></figure><h3 id="排序-简单介绍"><a href="#排序-简单介绍" class="headerlink" title="排序 - 简单介绍"></a>排序 - 简单介绍</h3><blockquote><p><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法 | 菜鸟教程 (runoob.com)</a></p></blockquote><h4 id="排序的时间复杂度分析"><a href="#排序的时间复杂度分析" class="headerlink" title="排序的时间复杂度分析"></a>排序的时间复杂度分析</h4><p><img src="/2023/04/26/One/sort.png" alt="sort"></p><p><img src="/2023/04/26/One/%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83.png" alt="排序数据比较"></p><h4 id="冒泡排序操作"><a href="#冒泡排序操作" class="headerlink" title="冒泡排序操作"></a>冒泡排序操作</h4><p><img src="/2023/04/26/One/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++">冒泡排序<br> 冒泡排序的时间复杂度是 <span class="hljs-built_in">o</span>(n^<span class="hljs-number">2</span>),这个复杂度是由冒泡排序的操作约束的。冒泡排序的原理是，选择我们序列中的一个值，对其进行这样的操作：<br> -将当前这个值和下一个数据对比，如果当前这个值大于下一个数据，交换；否则，下一个值作为新的交换值代替之前的值执行交换程序。直到最后，没有数据进行比对，退出程序。<br><span class="hljs-comment">// 菜鸟 - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</span><br>    <br><span class="hljs-comment">//代码    </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bubble_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i, j;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len - <span class="hljs-number">1</span>; i++)<br>                <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; len - <span class="hljs-number">1</span> - i; j++)<br>                        <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>])<br>                                <span class="hljs-built_in">swap</span>(arr[j], arr[j + <span class="hljs-number">1</span>]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">61</span>, <span class="hljs-number">17</span>, <span class="hljs-number">29</span>, <span class="hljs-number">22</span>, <span class="hljs-number">34</span>, <span class="hljs-number">60</span>, <span class="hljs-number">72</span>, <span class="hljs-number">21</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>, <span class="hljs-number">62</span> &#125;;<br>        <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(*arr);<br>        <span class="hljs-built_in">bubble_sort</span>(arr, len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>                cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        cout &lt;&lt; endl;<br>        <span class="hljs-type">float</span> arrf[] = &#123; <span class="hljs-number">17.5</span>, <span class="hljs-number">19.1</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">1.9</span>, <span class="hljs-number">10.5</span>, <span class="hljs-number">12.4</span>, <span class="hljs-number">3.8</span>, <span class="hljs-number">19.7</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">28.6</span>, <span class="hljs-number">4.4</span>, <span class="hljs-number">23.8</span>, <span class="hljs-number">5.4</span> &#125;;<br>        len = (<span class="hljs-type">float</span>) <span class="hljs-built_in">sizeof</span>(arrf) / <span class="hljs-built_in">sizeof</span>(*arrf);<br>        <span class="hljs-built_in">bubble_sort</span>(arrf, len);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>                cout &lt;&lt; arrf[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;    <br></code></pre></td></tr></table></figure><h4 id="选择排序操作"><a href="#选择排序操作" class="headerlink" title="选择排序操作"></a>选择排序操作</h4><p><img src="/2023/04/26/One/selectionSort.gif" alt="选择排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">2.</span>选择排序<br>    <br><span class="hljs-comment">//选择排序的时间复杂度是o(n^2) - 是因为选择排序需要进行 n-1 轮比较，每轮比较需要比较 n-i 次，所以总共需要比较 (n-1) + (n-2) + … + 1 = n(n-1)/2 次，因此时间复杂度为 O(n²)。</span><br><br> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。就是每次选中一个未排序序列的起点，然后在未排序序列中，找到一个“最小值”直到遍历完区间之后，将其标记未排序序列（区间缩小），重复直到全为排序区间，退出程序。<br>    <br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">//整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">selection_sort</span><span class="hljs-params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-type">int</span> min = i;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; arr.<span class="hljs-built_in">size</span>(); j++)<br>                        <span class="hljs-keyword">if</span> (arr[j] &lt; arr[min])<br>                                min = j;<br>                std::<span class="hljs-built_in">swap</span>(arr[i], arr[min]);<br>        &#125;<br>&#125;     <br></code></pre></td></tr></table></figure><h4 id="插入排序操作"><a href="#插入排序操作" class="headerlink" title="插入排序操作"></a>插入排序操作</h4><p><img src="/2023/04/26/One/insertionSort.gif" alt="插入排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入排序的复杂度是 o(n^2) 每一个数据最多要比较（n-1)次，所以说n*(n-1) = n^2</span><br><br> 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）<br> 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。   <br>        <br><span class="hljs-comment">//和打扑克牌是一个道理，开始的时候我们只有一张牌（假设），我们将这张牌当做一个有序序列，每次加入新的牌的时候和有序序列进行比较插入，按照插入的规则（从小到大 还是 从大到小）进行判断插入。（感觉就是和选择排序是相反的，从无序中抽数据和有序序列进行比对）</span><br><br><span class="hljs-comment">//代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertion_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[],<span class="hljs-type">int</span> len)</span></span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;len;i++)&#123;<br>                <span class="hljs-type">int</span> key=arr[i];<br>                <span class="hljs-type">int</span> j=i<span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">while</span>((j&gt;=<span class="hljs-number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;<br>                        arr[j+<span class="hljs-number">1</span>]=arr[j];<br>                        j--;<br>                &#125;<br>                arr[j+<span class="hljs-number">1</span>]=key;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="希尔排序操作"><a href="#希尔排序操作" class="headerlink" title="希尔排序操作"></a>希尔排序操作</h4><p><img src="/2023/04/26/One/Sorting_shellsort_anim.gif" alt="希尔排序"></p><blockquote><p>引用文章&lt;<a href="https://blog.csdn.net/qq_43473694/article/details/112197066">(106条消息) 排序算法 | 希尔shell排序，算法的图解、实现、复杂度和稳定性分析_shell排序时间复杂度_比特的一天的博客-CSDN博客</a>&gt;</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//希尔排序的时间复杂度是：O(n^1.3） 在最坏情况之下是o(n^2) - 因为是基于插入排序</span><br> 希尔排序：先追求部分元素有序，然后逼近全局有序！希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br> - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；<br> - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；<br> 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = <span class="hljs-number">1</span>；按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 <span class="hljs-number">1</span> 时，整个序列作为一个表来处理，表长度即为整个序列的长度。<br>        <br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-type">void</span> <span class="hljs-built_in">shell_sort</span>(T array[], <span class="hljs-type">int</span> length) &#123;<br>    <span class="hljs-type">int</span> h = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (h &lt; length / <span class="hljs-number">3</span>) &#123;<br>        h = <span class="hljs-number">3</span> * h + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (h &gt;= <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = h; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;<br>                std::<span class="hljs-built_in">swap</span>(array[j], array[j - h]);<br>            &#125;<br>        &#125;<br>        h = h / <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;   <br></code></pre></td></tr></table></figure><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img src="/2023/04/26/One/mergeSort.gif" alt="归并排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//归并排序的时间复杂度是 o(log n)</span><br> 归并排序的算法思想是：分治法。 将大问题分解成许多的子问题，在将子问题合并成为我们的大问题<br><span class="hljs-comment">//实现方法</span><br> 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 <span class="hljs-number">2</span> 种方法）自下而上的迭代<br> 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 <span class="hljs-number">3</span> 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 <br><br><span class="hljs-comment">//非递归</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    T *a = arr;<br>    T *b = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; len; start += seg + seg) &#123;<br>            <span class="hljs-type">int</span> low = start, mid = <span class="hljs-built_in">min</span>(start + seg, len), high = <span class="hljs-built_in">min</span>(start + seg + seg, len);<br>            <span class="hljs-type">int</span> k = low;<br>            <span class="hljs-type">int</span> start1 = low, end1 = mid;<br>            <span class="hljs-type">int</span> start2 = mid, end2 = high;<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)<br>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1)<br>                b[k++] = a[start1++];<br>            <span class="hljs-keyword">while</span> (start2 &lt; end2)<br>                b[k++] = a[start2++];<br>        &#125;<br>        T *temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a != arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            b[i] = a[i];<br>        b = a;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] b;<br>&#125;<br><br><span class="hljs-comment">//递归</span><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt; <span class="hljs-comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(T arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    T *a = arr;<br>    T *b = <span class="hljs-keyword">new</span> T[len];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> seg = <span class="hljs-number">1</span>; seg &lt; len; seg += seg) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> start = <span class="hljs-number">0</span>; start &lt; len; start += seg + seg) &#123;<br>            <span class="hljs-type">int</span> low = start, mid = <span class="hljs-built_in">min</span>(start + seg, len), high = <span class="hljs-built_in">min</span>(start + seg + seg, len);<br>            <span class="hljs-type">int</span> k = low;<br>            <span class="hljs-type">int</span> start1 = low, end1 = mid;<br>            <span class="hljs-type">int</span> start2 = mid, end2 = high;<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)<br>                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];<br>            <span class="hljs-keyword">while</span> (start1 &lt; end1)<br>                b[k++] = a[start1++];<br>            <span class="hljs-keyword">while</span> (start2 &lt; end2)<br>                b[k++] = a[start2++];<br>        &#125;<br>        T *temp = a;<br>        a = b;<br>        b = temp;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (a != arr) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>            b[i] = a[i];<br>        b = a;<br>    &#125;<br>    <span class="hljs-keyword">delete</span>[] b;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img src="/2023/04/26/One/quickSort.gif" alt="快速排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速排序的时间复杂度是o(nlog n),一般而言是比其他nlogn排序是要快的</span><br><br> 从数列中挑出一个元素，称为 <span class="hljs-string">&quot;基准&quot;</span>（pivot）;<br> 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，<span class="hljs-string">&quot;该基准就处于数列的中间位置&quot;</span>。这个称为分区（partition）操作；<br>    递归（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；<br><br><span class="hljs-comment">//就是由基准分成两部分，再由两部分的基准分成另外两部分，以此类推。 - 直到所有部分都符合基准，即可退出。</span><br>        <br><span class="hljs-comment">//代码        </span><br><span class="hljs-comment">//严蔚敏《数据结构》标准分割函数</span><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Paritition1</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> </span>&#123;<br>   <span class="hljs-type">int</span> pivot = A[low];<br>   <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>     <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;<br>       --high;<br>     &#125;<br>     A[low] = A[high];<br>     <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;<br>       ++low;<br>     &#125;<br>     A[high] = A[low];<br>   &#125;<br>   A[low] = pivot;<br>   <span class="hljs-keyword">return</span> low;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//快排母函数</span></span><br><span class="hljs-function"> </span>&#123;<br>   <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>     <span class="hljs-type">int</span> pivot = <span class="hljs-built_in">Paritition1</span>(A, low, high);<br>     <span class="hljs-built_in">QuickSort</span>(A, low, pivot - <span class="hljs-number">1</span>);<br>     <span class="hljs-built_in">QuickSort</span>(A, pivot + <span class="hljs-number">1</span>, high);<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><img src="/2023/04/26/One/heapSort.gif" alt="堆排序"></p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="堆排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆排序 - 是利用数据结构中的堆的性质设计的算法，它的时间复杂度是o(nlogn)</span><br> 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；<br> 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；<br><span class="hljs-comment">//算法步骤</span><br> 创建一个堆 H[<span class="hljs-number">0</span>……n<span class="hljs-number">-1</span>]；<br> 把堆首（最大值）和堆尾互换；<br> 把堆的尺寸缩小 <span class="hljs-number">1</span>，并调用 <span class="hljs-built_in">shift_down</span>(<span class="hljs-number">0</span>)，目的是把新的数组顶端数据调整到相应位置；<br> 重复步骤 <span class="hljs-number">2</span>，直到堆的尺寸为 <span class="hljs-number">1</span>。<br><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">max_heapify</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-comment">// 建立父節點指標和子節點指標</span><br>    <span class="hljs-type">int</span> dad = start;<br>    <span class="hljs-type">int</span> son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (son &lt;= end) &#123; <span class="hljs-comment">// 若子節點指標在範圍內才做比較</span><br>        <span class="hljs-keyword">if</span> (son + <span class="hljs-number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="hljs-number">1</span>]) <span class="hljs-comment">// 先比較兩個子節點大小，選擇最大的</span><br>            son++;<br>        <span class="hljs-keyword">if</span> (arr[dad] &gt; arr[son]) <span class="hljs-comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否則交換父子內容再繼續子節點和孫節點比較</span><br>            <span class="hljs-built_in">swap</span>(arr[dad], arr[son]);<br>            dad = son;<br>            son = dad * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">heap_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> len)</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化，i從最後一個父節點開始調整</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)<br>        <span class="hljs-built_in">max_heapify</span>(arr, i, len - <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">swap</span>(arr[<span class="hljs-number">0</span>], arr[i]);<br>        <span class="hljs-built_in">max_heapify</span>(arr, <span class="hljs-number">0</span>, i - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span> &#125;;<br>    <span class="hljs-type">int</span> len = (<span class="hljs-type">int</span>) <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(*arr);<br>    <span class="hljs-built_in">heap_sort</span>(arr, len);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++)<br>        cout &lt;&lt; arr[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><img src="/2023/04/26/One/countingSort.gif" alt="计数排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</span><br><span class="hljs-comment">//计数排序的时间复杂度是o(n+K)</span><br> 简单说，就是用我们<span class="hljs-string">&quot;需要排序的序列的值&quot;</span>,创建一个标记数组，只要序列出现过的值，都标记成<span class="hljs-number">1</span>，就说明它出现了。但是，这种方法只对数来说比较方便。 - 可以说是数组下标和排序序列有映射关系<br>      <br><span class="hljs-comment">//算法步骤</span><br>（<span class="hljs-number">1</span>）找出待排序的数组中最大和最小的元素<br>（<span class="hljs-number">2</span>）统计数组中每个值为i的元素出现的次数，存入数组C的第i项<br>（<span class="hljs-number">3</span>）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）<br>（<span class="hljs-number">4</span>）反向填充目标数组：将每个元素i放在新数组的第<span class="hljs-built_in">C</span>(i)项，每放一个元素就将<span class="hljs-built_in">C</span>(i)减去<span class="hljs-number">1</span><br><br><span class="hljs-comment">//代码（c）</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_arr</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, arr[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, arr[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">counting_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> *ini_arr, <span class="hljs-type">int</span> *sorted_arr, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> *count_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * <span class="hljs-number">100</span>);<br>        <span class="hljs-type">int</span> i, j, k;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">100</span>; k++)<br>                count_arr[k] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                count_arr[ini_arr[i]]++;<br>        <span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt; <span class="hljs-number">100</span>; k++)<br>                count_arr[k] += count_arr[k - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (j = n; j &gt; <span class="hljs-number">0</span>; j--)<br>                sorted_arr[--count_arr[ini_arr[j - <span class="hljs-number">1</span>]]] = ini_arr[j - <span class="hljs-number">1</span>];<br>        <span class="hljs-built_in">free</span>(count_arr);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> i;<br>        <span class="hljs-type">int</span> *arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);<br>        <span class="hljs-type">int</span> *sorted_arr = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);<br>        <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>                arr[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ini_array: &quot;</span>);<br>        <span class="hljs-built_in">print_arr</span>(arr, n);<br>        <span class="hljs-built_in">counting_sort</span>(arr, sorted_arr, n);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sorted_array: &quot;</span>);<br>        <span class="hljs-built_in">print_arr</span>(sorted_arr, n);<br>        <span class="hljs-built_in">free</span>(arr);<br>        <span class="hljs-built_in">free</span>(sorted_arr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;        <br><br><br></code></pre></td></tr></table></figure><h4 id="桶排序-不懂"><a href="#桶排序-不懂" class="headerlink" title="桶排序 - 不懂"></a>桶排序 - 不懂</h4><p>元素分布在桶中：</p><p><img src="/2023/04/26/One/Bucket_sort_1.svg_.png" alt="桶"></p><p>然后，元素在每个桶中排序：</p><p><img src="/2023/04/26/One/Bucket_sort_2.svg_.png" alt="桶"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</span><br><span class="hljs-comment">//为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</span><br>计数排序每个位置只能装一种数据，而桶排序中，可以装入一个范围（集合）的数据是这个样子吗 - 感觉类似于哈希表<br>        <br>        <br><span class="hljs-comment">//代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> a[N], b[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];<br>    <span class="hljs-type">int</span> maxv = *<span class="hljs-built_in">max_element</span>(a, a + n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) b[a[i]] ++ ;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt;= maxv; i ++ )<br>        <span class="hljs-keyword">while</span> (b[i] -- ) a[j ++ ] = i;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;        <br></code></pre></td></tr></table></figure><h4 id="基数排序-不懂"><a href="#基数排序-不懂" class="headerlink" title="基数排序 - 不懂"></a>基数排序 - 不懂</h4><p><img src="/2023/04/26/One/radixSort.gif" alt="基数排序"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//基数排序：根据键值的每位数字来分配桶；</span><br><span class="hljs-comment">//基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</span><br><br><br><span class="hljs-comment">//代码</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxbit</span><span class="hljs-params">(<span class="hljs-type">int</span> data[], <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//辅助函数，求数据的最大位数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> maxData = data[<span class="hljs-number">0</span>];              <span class="hljs-comment">///&lt; 最大数</span><br>    <span class="hljs-comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (maxData &lt; data[i])<br>            maxData = data[i];<br>    &#125;<br>    <span class="hljs-type">int</span> d = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (maxData &gt;= p)<br>    &#123;<br>        <span class="hljs-comment">//p *= 10; // Maybe overflow</span><br>        maxData /= <span class="hljs-number">10</span>;<br>        ++d;<br>    &#125;<br>    <span class="hljs-keyword">return</span> d;<br><span class="hljs-comment">/*    int d = 1; //保存最大的位数</span><br><span class="hljs-comment">    int p = 10;</span><br><span class="hljs-comment">    for(int i = 0; i &lt; n; ++i)</span><br><span class="hljs-comment">    &#123;</span><br><span class="hljs-comment">        while(data[i] &gt;= p)</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">            p *= 10;</span><br><span class="hljs-comment">            ++d;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    return d;*/</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">radixsort</span><span class="hljs-params">(<span class="hljs-type">int</span> data[], <span class="hljs-type">int</span> n)</span> <span class="hljs-comment">//基数排序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> d = <span class="hljs-built_in">maxbit</span>(data, n);<br>    <span class="hljs-type">int</span> *tmp = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n];<br>    <span class="hljs-type">int</span> *count = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//计数器</span><br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-type">int</span> radix = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt;= d; i++) <span class="hljs-comment">//进行d次排序</span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = <span class="hljs-number">0</span>; <span class="hljs-comment">//每次分配前清空计数器</span><br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>; <span class="hljs-comment">//统计每个桶中的记录数</span><br>            count[k]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">10</span>; j++)<br>            count[j] = count[j - <span class="hljs-number">1</span>] + count[j]; <span class="hljs-comment">//将tmp中的位置依次分配给每个桶</span><br>        <span class="hljs-keyword">for</span>(j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) <span class="hljs-comment">//将所有桶中记录依次收集到tmp中</span><br>        &#123;<br>            k = (data[j] / radix) % <span class="hljs-number">10</span>;<br>            tmp[count[k] - <span class="hljs-number">1</span>] = data[j];<br>            count[k]--;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; n; j++) <span class="hljs-comment">//将临时数组的内容复制到data中</span><br>            data[j] = tmp[j];<br>        radix = radix * <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">delete</span> []tmp;<br>    <span class="hljs-keyword">delete</span> []count;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>md标注方法</title>
      <link href="/2023/04/21/%E6%A0%BC%E5%BC%8F/"/>
      <url>/2023/04/21/%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="md的书写样式练习"><a href="#md的书写样式练习" class="headerlink" title="md的书写样式练习"></a><strong>md的书写样式练习</strong></h2><h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a><strong>书写格式</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">代码框书写格式<br>     <span class="hljs-string">&quot;``` bash(这里是代码的样式 - 看你输入的是什么语言)&quot;</span> <br>        中间这里输入你的代码<br>     <span class="hljs-string">&quot;```&quot;</span><br></code></pre></td></tr></table></figure><h3 id="Front-matter修改"><a href="#Front-matter修改" class="headerlink" title="Front-matter修改"></a><strong>Front-matter修改</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash">Page Front-matter 用于页面配置<br>Post Front-matter 用于文章页配置<br>    这两个就是你md文档的最顶部的两个 --- ---之间,用来配置hexo的网页功能<br><br><span class="hljs-comment"># 功能样式</span><br><span class="hljs-comment"># 当前文章题目</span><br>title:  <br><span class="hljs-comment"># 当前文章创建日期</span><br><span class="hljs-built_in">date</span>:<br><span class="hljs-comment"># 当前文章更新日期</span><br>updated:<br><span class="hljs-comment"># 标签、分类和友情链接三个页面需要配置 - 这个是啥暂时不知道</span><br><span class="hljs-built_in">type</span>:<br><span class="hljs-comment"># 显示评论模块(默认 true)</span><br>comments:<br><span class="hljs-comment"># 页面描述</span><br>description:<br><span class="hljs-comment"># 页面关键字</span><br>keywords:<br><span class="hljs-comment"># 顶部图片 - 这里修改优先级最高</span><br>top_img:<br><span class="hljs-comment"># 显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false) - 不清楚</span><br>mathjax:<br><span class="hljs-comment"># 【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false) - 不清楚</span><br>katex:<br><span class="hljs-comment"># 显示侧边栏 (默认 true)</span><br>aside:<br><span class="hljs-comment"># 在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span><br>aplayer:<br><span class="hljs-comment"># 配置代码框是否展开 (true/false) (默认为设置中highlight_shrink的配置)</span><br>highlight_shrink:<br></code></pre></td></tr></table></figure><h3 id="md-表格创建"><a href="#md-表格创建" class="headerlink" title="md_表格创建"></a><strong>md_表格创建</strong></h3><p>要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列.您可以选择在表的任一端添加管道</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">| Syntax    | Description |<br>| --------- | ----------- |<br>| Header    | Title       |<br>| Paragraph | Text        |<br></code></pre></td></tr></table></figure><p>实现效果</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><p>创建表格可以使用：<a href="https://www.tablesgenerator.com/markdown_tables"><strong>label</strong></a>是一个创建md格式表格的好工具</p><h3 id="md基础语法"><a href="#md基础语法" class="headerlink" title="md基础语法"></a><strong>md基础语法</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>标题：<br>    在头部用<span class="hljs-string">&quot;#&quot;</span>修饰即可，<span class="hljs-string">&quot;#&quot;</span>数量代表着标题的序数。还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。<br><span class="hljs-number">2.</span>段落：<br>    在需要分段的文字尾部，两个空格以上就是独立的段落了。（有个问题就是，上下空格数是否要相同）。注意的是，md语法中没有缩进段落的选项，所以说不能用缩进来操作段落。<br><span class="hljs-number">3.</span>换行：<br>    建议用&lt;br&gt; - html中的语法。<br><span class="hljs-number">4.</span>强调<br>    在两边加入两个*,就可以加粗我们选中的字体了。<br><span class="hljs-number">5.</span>斜体<br>    添加一个*就可以实现斜体。<br><span class="hljs-number">6.</span>强调斜体<br>    加三个***就可以了<br><span class="hljs-number">7.</span>引用<br>    &gt;添加一个这个符号就可以实现引用框框了，如果多加一个&gt;就是嵌套环境,<br>&gt; <br>&gt; <span class="hljs-comment">//上面就是初级引用</span><br>&gt;&gt; <span class="hljs-comment">//这样子就算是嵌套了</span><br><span class="hljs-number">8.</span>无序列表<br>    - 空格 加入输入的文字，这就算是一个无序列表了<br><span class="hljs-number">9.</span>列表<br>    可以用html中的创建列表的语法，&lt;ol&gt; &gt; &lt;li&gt; *。或者直接在前面加上标题就可以<br></code></pre></td></tr></table></figure><h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a><strong>嵌套规则</strong></h3><h4 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a><strong>在列表中嵌套其他元素</strong></h4><p>我们简单创建一个无序列表：</p><ul><li>三天打鱼两天晒网</li><li>六天打鱼四天晒网</li></ul><p>我们在其中插入一个引用数据，只需要用到&gt;即可</p><ul><li>三天打鱼两天晒网<blockquote><p>不能打鱼，我们要摆烂 ૮꒰ ˶• ༝ •˶꒱ა</p></blockquote></li><li>六天打鱼四天晒网<blockquote><p>不能打鱼，我们要摆烂 ૮꒰ ˶• ༝ •˶꒱ა</p></blockquote></li></ul><p>要是想要在列表中输入代码框,就直接用代码行格式就行（没必要用几个制表符或者空格来说明）。</p><ul><li>写一个简单代码</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Test<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>写两个简单代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a;<br>    cin&gt;&gt;a;<br>    cout&lt;&lt;a&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。</p><hr><p>如果出现了其他内容，就会变成这样</p><p>——-你好,所以说不要在分割线上加东西</p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[]() - 中括号中写入的是你要实现的超链接的名称<br>     - 小括号中写入的是你要跳转的链接<br></code></pre></td></tr></table></figure><p>超链接格式和我们的图片格式是相似的 <a href="https://markdown.com.cn/basic-syntax/links.html"><strong>md语法</strong></a></p><hr><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">图片格式限定，![]()，[] - 是照片的名字，()是照片的文件地址<br>和超链接比较就多了一个！<br>存储文件的时候记得，新开一个文件夹，以防图片数据互相影响<br></code></pre></td></tr></table></figure><p>图片演示</p><p><img src="/../picture/format/Different%20from%20the%20usual%20of%20you.jpg" alt="与平常的你不同"></p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;&gt; - (这里面放的是网址信息，出现的链接这样就可以点击了)<br></code></pre></td></tr></table></figure><p><a href="https://markdown.com.cn/">https://markdown.com.cn</a></p><h4 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h4><p>强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">就是在链接处加入我们的强调修饰符号：**[]()**<br></code></pre></td></tr></table></figure><p>渲染效果如下（还有其他链接方式暂时不学）：</p><!-- 这里是强调链接 链接不一定存在 --><p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em></p><hr><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><h4 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h4><p><img src="/../picture/format/turn.png" alt="转义字符"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
