<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>English</title>
    <url>/2023/05/24/English/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="简单句"><a href="#简单句" class="headerlink" title="简单句"></a>简单句</h3><p>在英语语法中，有五种基本的简单句结构，它们分别是：</p>
<ol>
<li>主语 + 动词 (Subject + Verb)：这是最基本的简单句结构，主语是句子中的主要名词或代词，动词描述主语的动作或状态。例如：”She sings.”（她唱歌。）</li>
<li>主语 + 动词 + 宾语 (Subject + Verb + Object)：除了主语和动词，这种简单句还包括一个宾语，宾语是动作的接受者或影响者。例如：”I love you.”（我爱你。）</li>
<li>主语 + 动词 + 表语 (Subject + Verb + Predicative)：表语是对主语的描述或补充，通常使用形容词或名词。例如：”He is a doctor.”（他是一名医生。）</li>
<li>主语 + 动词 + 间接宾语 + 直接宾语 (Subject + Verb + Indirect Object + Direct Object)：这种结构中，动作的影响对象由直接宾语表示，而间接宾语表示受益人或间接对象。例如：”She gave me a book.”（她给了我一本书。）</li>
<li>主语 + 动词 + 宾语 + 宾补 (Subject + Verb + Object + Object Complement)：宾补是对宾语的进一步描述或补充，通常使用形容词或名词。例如：”They elected him president.”（他们选举他为总统。）</li>
</ol>
<p>所有句子都是基于以上的句子构成，至于修饰语是和主语结合形成一个新的“主语”。要单拿出来解释的有</p>
<h4 id="补语"><a href="#补语" class="headerlink" title="补语"></a>补语</h4><p>在英语中，补语通常出现在以下几种情况下：</p>
<ol>
<li><p>表语（Predicative Complement）：表语是用来描述或补充主语的成分。它可以是名词、形容词、代词或介词短语。例如：</p>
<ul>
<li><p>She is a doctor.（表语是名词）</p>
</li>
<li><p>He seems happy.（表语是形容词）</p>
</li>
<li><p>They elected her as the president.（表语是介词短语）</p>
<blockquote>
<p>作为表语的动词没有实际意义，只起到了链接主语和宾语的作用，相当于绳子一样系住，所以被称之为系动词。</p>
<p>同时，be动词单拿出来有一个含义是：存在的意思。</p>
<p><strong>To be or not to be, that is the question.</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>宾语补足语（Object Complement）：宾语补足语用来补充或描述及物动词后面的宾语。它通常是名词、形容词或介词短语。例如：</p>
<ul>
<li><p>They made him the captain.（宾语补足语是名词）</p>
</li>
<li><p>She painted the walls blue.（宾语补足语是形容词）</p>
<blockquote>
<p>宾补是用来描述宾语的状态，完善句子结构的一个词类。</p>
<p>宾补一般是形容词，如果是名词的话，我们可以理解宾语和宾补是一种主系表的关系，相当于宾语is宾补这样（去掉的be动词）。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>主语补足语（Subject Complement）：主语补足语出现在系动词（be动词、感官动词、变化动词等）后面，用来补充或描述主语。它通常是名词、形容词或介词短语。例如：</p>
<ul>
<li><p>He is a teacher.（主语补足语是名词）</p>
</li>
<li><p>She became angry.（主语补足语是形容词）</p>
<blockquote>
<p>就是主系表，这里描述主语被修饰的部分。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h4 id="双宾语"><a href="#双宾语" class="headerlink" title="双宾语"></a>双宾语</h4><p>在句子中，宾语、宾语补足语和双宾语是不同的语法成分，它们在句子结构和功能上有所区别。下面是对它们的解释和区分：</p>
<ol>
<li><p>宾语（Object）：宾语是一个句子中的核心成分，它接受动作的影响或指示动作的对象。宾语通常是动词的直接接受者或受益者。在英语中，宾语通常是名词、代词或名词性短语。例如：</p>
<ul>
<li>她买了一本书。 She bought a book.</li>
<li>他给我一杯咖啡。 He gave me a cup of coffee.</li>
</ul>
<p>在这些例句中，”一本书”和”一杯咖啡”是宾语，它们接受动词的动作。</p>
</li>
<li><p>宾语补足语（Object Complement）：宾语补足语是用来进一步描述、补充或修改宾语的成分。它通常出现在及物动词或使役动词后面，用来提供额外的信息来描述宾语的性质、状态、身份等。宾语补足语可以是形容词、名词、介词短语等。例如：</p>
<ul>
<li>我发现他很聪明。 I found him intelligent.</li>
<li>她把那个男孩称为英雄。 She called that boy a hero.</li>
</ul>
<p>在这些例句中，”聪明”和”英雄”是宾语补足语，它们进一步描述了宾语的特征。</p>
</li>
<li><p>双宾语（Double Object）：双宾语结构是一种特殊的情况，其中动词可以带有两个宾语，一个直接宾语和一个间接宾语。直接宾语是接受动作的直接对象，而间接宾语是动作的受益者或间接对象。在英语中，直接宾语通常是名词或代词，而间接宾语通常是介词短语或代词。例如：</p>
<ul>
<li>我送给她一束花。 I gave her a bouquet of flowers.</li>
<li>他买了我一杯咖啡。 He bought me a cup of coffee.</li>
</ul>
<p>在这些例句中，”一束花”和”一杯咖啡”是直接宾语，”她”和”我”是间接宾语。直接宾语接受动作，而间接宾语是动作的受益者。</p>
</li>
</ol>
<h3 id="名词性成分"><a href="#名词性成分" class="headerlink" title="名词性成分"></a>名词性成分</h3><h4 id="动名词"><a href="#动名词" class="headerlink" title="动名词"></a>动名词</h4><p>在英语中，动名词（Gerund）可以作为动词的形式在句子中充当多种语法角色。以下是动名词可能出现的几种语法角色和用法：</p>
<ol>
<li>主语（Subject）：<ul>
<li>Swimming is my favorite hobby.（游泳是我最喜欢的爱好。）</li>
<li>Jogging helps me stay fit.（慢跑帮助我保持健康。）</li>
</ul>
</li>
<li>宾语（Object）：<ul>
<li>I enjoy swimming in the ocean.（我喜欢在海里游泳。）</li>
<li>She loves reading books.（她喜欢读书。）</li>
</ul>
</li>
<li>宾语补足语（Object Complement）：<ul>
<li>He made a living by teaching English.（他靠教英语谋生。）</li>
<li>They find joy in helping others.（他们从帮助他人中找到快乐。）</li>
</ul>
</li>
<li>介词宾语（Object of Preposition）：<ul>
<li>She is interested in painting.（她对绘画感兴趣。）</li>
<li>We talked about going on a trip.（我们谈论去旅行的事。）</li>
</ul>
</li>
<li>主格形式（Subjective Form）：<ul>
<li>Swimming is a great exercise.（游泳是一项很好的运动。）</li>
<li>Running can be tiring but rewarding.（跑步可能会令人疲劳，但是有回报。）</li>
</ul>
</li>
</ol>
<p>需要注意的是，动名词在功能上可以类似名词，但它保留了动词的性质和特点，可以带有动词的补语或修饰语。动名词以-ing 结尾，并且可以有自己的宾语、副词修饰等。</p>
<h4 id="名词短语"><a href="#名词短语" class="headerlink" title="名词短语"></a>名词短语</h4><p>名词短语（Noun Phrase）是由一个名词（或代词）充当核心，并且可能由其他修饰语或补语组成的短语。名词短语具有以下特点：</p>
<ol>
<li><p>名词核心：名词短语的核心是一个名词或代词，它给出短语所描述的事物、人或概念的基本标识。例如，”a book”（一本书）中的名词短语核心是”book”（书）。</p>
</li>
<li><p>修饰语：名词短语可以由多个修饰语组成，这些修饰语在语法上修饰或限定名词的含义、特征或属性。修饰语可以是形容词、限定词、副词或其他名词短语等。例如，”a beautiful old house”（一座美丽的古老房屋）中的”beautiful”（美丽的）和”old”（古老的）都是修饰语。</p>
</li>
<li><p>补语：名词短语还可以包含补语，补语是对名词的进一步补充或说明。常见的补语包括形容词短语、介词短语或从句等。例如，”the president of the company”（公司的总裁）中的”of the company”（公司的）是一个介词短语作为补语。</p>
</li>
<li><p>可拓展性：名词短语可以根据需要进行扩展，以提供更多的信息或详细描述。可以添加更多的修饰语、补语或其他成分来进一步丰富名词短语的含义。例如，”a small red leather-bound book on the shelf”（架子上一本小巧的红色皮封书）中的名词短语逐渐扩展，包含了多个修饰语和补语。</p>
</li>
<li><p>在句子中的作用：名词短语在句子中可以作为主语、宾语、表语、定语或同位语等。它们在句子中承担名词的角色，并根据语境和句子结构发挥不同的语法功能。</p>
<blockquote>
<p>名词短语包括 1.限定词 2.形容词 3.名词构成，任意一个部分都可能被省略</p>
</blockquote>
</li>
</ol>
<p>名词短语在语言中起到重要的作用，它们用来描述和指代具体的事物、人或概念，并且在句子中扮演多种语法角色。名词短语的特点包括核心名词、修饰语、补语、可拓展性和语法功能的多样性。</p>
<h4 id="名词性从句"><a href="#名词性从句" class="headerlink" title="名词性从句"></a>名词性从句</h4><p>名词性从句（Noun Clauses）是一种在句子中充当名词的从句，它可以担任名词在句子中的各种功能，例如主语、宾语、表语、补足语等。以下是名词性从句的几个特点：</p>
<ol>
<li>充当名词角色：名词性从句在句子中充当名词的角色，可以出现在与名词相同的位置。例如：<ul>
<li>主语：What she said is true.（她说的是真的。）</li>
<li>宾语：I don’t know where he went.（我不知道他去哪了。）</li>
<li>表语：Her dream is that she wants to travel the world.（她的梦想是她想环游世界。）</li>
<li>宾补：I made a promise that I would help him.（我许下承诺，我会帮助他。）</li>
</ul>
</li>
<li>引导词：名词性从句通常由引导词引导，常见的引导词包括：<ul>
<li>连接代词：who, whom, whose, which, what</li>
<li>连接副词：where, when, why, how</li>
</ul>
</li>
<li>可以包含陈述句、疑问句或感叹句的结构：名词性从句可以采用陈述句、疑问句或感叹句的结构，根据从句的具体功能和意义进行相应的语序调整。例如：<ul>
<li>陈述句结构：I know that he is coming.（我知道他要来。）</li>
<li>疑问句结构：Can you tell me where she lives?（你能告诉我她住在哪里吗？）</li>
<li>感叹句结构：What a beautiful day it is!（多么美好的一天啊！）</li>
</ul>
</li>
<li>可以包含其他从句或从句成分：名词性从句内部可以包含其他从句或从句成分，形成更复杂的句子结构。例如：<ul>
<li>I don’t know what he said when he left.（我不知道他离开时说了什么。）</li>
<li>The question is whether they will attend the party.（问题是他们是否会参加聚会。）</li>
</ul>
</li>
</ol>
<p>总之，名词性从句在句子中具有名词的功能，可以出现在与名词相同的位置，并由引导词引导。它可以采用陈述句、疑问句或感叹句的结构，还可以包含其他从句或从句成分。名词性从句在句子中起着重要的名词替代作用，丰富了句子的表达和结构。</p>
<h3 id="形容词成分"><a href="#形容词成分" class="headerlink" title="形容词成分"></a>形容词成分</h3><p>在英语中，以下成分可以充当形容词：</p>
<ol>
<li>形容词（Adjectives）：它们直接修饰名词或代词，描述其特征或性质。例如：beautiful（美丽的）、old（老的）。</li>
<li>限定词（Determiners）：这些词修饰名词并限定其范围。它们可以指示数量、所有权、特定性等。例如：a（一个）、my（我的）、this（这个）。</li>
<li>数词（Numerals）：它们表示数量，可以是基数词（cardinal numbers）或序数词（ordinal numbers）。例如：three（三）、first（第一）。</li>
<li>不定代词（Indefinite Pronouns）：这些代词在句子中充当形容词的角色，描述某种未指定的事物或人。例如：some（一些）、any（任何）。</li>
<li>分词（Participles）：它们是动词的非谓语形式，可以作为形容词使用。分词通常用来描述名词所具有的状态或特征。例如：broken（破碎的）、fascinating（迷人的）。</li>
<li>物质名词（Nouns as Adjectives）：有时，名词被用作形容词来描述其他名词。例如：water（水）可以修饰bottle（瓶子），形成water bottle（水瓶）。</li>
</ol>
<p>这些是一些常见的充当形容词的成分，它们在句子中起到描述或修饰名词的作用。</p>
<h4 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h4><p>在英语中，分词（Participles）具有以下特点：</p>
<ol>
<li>非谓语形式：分词是动词的非谓语形式，不具备时态和主语一致的特征。它们可以被用作形容词或副词，描述名词或修饰动词。</li>
<li>形容词性质：分词在形式上类似于形容词，可以用来描述名词的特征或状态。例如，”a broken cup”（一个破碎的杯子），其中的”broken”是现在分词作为形容词修饰”cup”。</li>
<li>副词性质：分词也可以作为副词修饰动词，表示动作的方式、原因或时间等。例如，”He ran, breathing heavily”（他跑着，大口喘着气），其中的”breathing”是现在分词作为副词修饰”ran”。</li>
<li>主动或被动：根据分词的形式，可以区分主动分词（Present Participle）和过去分词（Past Participle）。主动分词以-ing结尾（例如”running”），而过去分词通常以-ed、-en、-d、-t或其他变体结尾（例如”broken”）。它们在形式上不同，但在用法上有一些共同之处。</li>
<li>修饰名词：分词可以直接修饰名词或代词，描述其特征或状态。例如，”a sleeping baby”（一个正在睡觉的宝宝），其中的”sleeping”是现在分词作为形容词修饰”baby”。</li>
<li>时间关系：分词可以表达动作发生的时间关系，例如表示同时进行的动作、先后发生的动作或完成的动作等。这取决于上下文和其他句子成分的配合使用。</li>
</ol>
<p>分词是英语中一种灵活的语法结构，可以增加句子的表达能力和丰富性。了解分词的特点和用法，有助于正确使用和理解它们在句子中的作用。</p>
<h4 id="定语从句"><a href="#定语从句" class="headerlink" title="定语从句"></a>定语从句</h4><p>在英语中，定语从句（Relative Clause）是一种用来修饰名词或代词的从句。它提供了额外的信息，帮助我们更清楚地理解或限定被修饰的名词或代词。定语从句通常由一个关系词引导，如”who”、”whom”、”whose”、”which”、”that”等。</p>
<p>以下是一些示例：</p>
<blockquote>
<ol>
<li>The man who is standing over there is my brother. （站在那边的那个男人是我的兄弟。） 在这个例子中，定语从句 “who is standing over there” 修饰并进一步描述了名词 “man”。</li>
<li>The book that I borrowed from the library is very interesting. （我从图书馆借的那本书非常有趣。） 这个定语从句 “that I borrowed from the library” 修饰并描述了名词 “book”。</li>
<li>This is the house whose roof was damaged in the storm. （这是屋顶在风暴中受损的那所房子。） 定语从句 “whose roof was damaged in the storm” 修饰并限定了名词 “house”。</li>
</ol>
</blockquote>
<p>定语从句可以提供额外的信息，如对名词的身份、特征、归属关系等进行描述，使句子更加具体和明确。在构建定语从句时，需要注意关系词的选择和从句的位置，以确保句子的准确性和流畅性。</p>
<blockquote>
<p>定语从句可以被理解为形容词从句，因为它们都用来修饰名词或代词，提供额外的描述或限定。形容词从句描述或限定名词的方式与定语从句相似。</p>
<p>形容词从句通常由一个关系词引导，如”who”、”whom”、”whose”、”which”、”that”等。这些关系词在形容词从句中起到连接主句和从句的作用。</p>
<p>下面是一个示例，展示了形容词从句的使用：</p>
<p>原句：The girl is very intelligent. 改为形容词从句：The girl who is very intelligent is my sister. （那个非常聪明的女孩是我的姐妹。）</p>
<p>在这个例子中，形容词从句 “who is very intelligent” 修饰并进一步描述了名词 “girl”。这个形容词从句提供了关于女孩聪明程度的信息。</p>
<p>因此，定语从句可以被视为形容词从句，因为它们都在句子中充当形容词的角色，对名词进行修饰和描述。</p>
</blockquote>
<h3 id="时态"><a href="#时态" class="headerlink" title="时态"></a>时态</h3><p>在英语中，动词时态（Verb Tense）用于表示动作或状态发生的时间。英语中常见的动词时态包括以下几种（这里只讨论时态）：</p>
<ol>
<li>现在时态（Present Tense）：<ul>
<li>简单现在时（Simple Present）：表示经常性、习惯性的动作或普遍真理。例如：”I play tennis every Sunday.”（我每个星期天打网球。）</li>
<li>现在进行时（Present Continuous）：表示正在进行的动作。例如：”She is watching TV now.”（她正在看电视。）</li>
<li>现在完成时（Present Perfect）：表示过去发生的动作对现在的影响或状态。例如：”I have finished my homework.”（我已经完成作业。）</li>
</ul>
</li>
<li>过去时态（Past Tense）：<ul>
<li>简单过去时（Simple Past）：表示过去发生的具体动作或状态。例如：”He played football yesterday.”（他昨天踢足球。）</li>
<li>过去进行时（Past Continuous）：表示过去某一时刻正在进行的动作。例如：”They were watching a movie when I arrived.”（当我到达时，他们正在看电影。）</li>
<li>过去完成时（Past Perfect）：表示过去某一时刻之前已经发生的动作或状态。例如：”She had already left when I called her.”（我打电话给她时，她已经离开了。）</li>
</ul>
</li>
<li>将来时态（Future Tense）：<ul>
<li>简单将来时（Simple Future）：表示将来发生的动作或状态。例如：”I will go to the beach tomorrow.”（明天我会去海滩。）</li>
<li>将来进行时（Future Continuous）：表示将来某一时刻正在进行的动作。例如：”They will be having a party this weekend.”（他们将在这个周末举办派对。）</li>
<li>将来完成时（Future Perfect）：表示将来某一时刻之前已经完成的动作或状态。例如：”By the time you arrive, I will have finished cooking dinner.”（你到达时，我会已经做完晚饭了。）</li>
</ul>
</li>
</ol>
<p>此外，英语中还有其他时态形式，如进行完成时（Present Perfect Continuous、Past Perfect Continuous、Future Perfect Continuous）等，用于表示更加复杂的时间关系。正确使用动词时态可以帮助清晰地表达动作发生的时间和顺序。</p>
<blockquote>
<p>其实有更好理解的方法,时态只有两种: 1.简单式 2.完成式</p>
<p>将句子中的be单拿出来，作为我们的动词，剩下的“动词”作为我们be动词的形容词补语。简单式分为三个时间  1.过去时间 2.现在时间 3.未来时间</p>
<p>同时，在简单句中，时间范围我们可以想象为一个括号，时间我们可以想象成一个轴。简单句所表达的时态，都可以清晰的用括号圈出来。</p>
<p>例句（过去时间）：<strong>The movable print was introduced to England in 1485</strong></p>
<p>将这句话的动词，be和时间状语in 1485比对，发现动词要变状态为was。be动词变化体现了时态的变化。形容词补语（本来的动词变化，体现了语态的变化，后面会讲）。括弧时间就是，1485.</p>
<p>例句（现在时间）：<strong>I drink coffee every morning</strong></p>
<p>这句话的动词涵盖的时间范围比较大。括弧时间将now都给涵盖了。所以说用一般时就行。</p>
<p>例句（将来时间）：<strong>There will be a major election in March</strong></p>
<p>将来时态，就是在be动词前加上will。</p>
<p>反正不管怎么变，时态的变化只体现在be动词处。</p>
<p>完成句:在完成句中，时间范围就不是括弧了，就是箭头。因为完成式是会有时间结束的点的，表示持续一段时间后结束了。</p>
<p>具体的变形要看时间箭头结束的地方，也就是时间副词？</p>
<p>例句：（现在时间）<strong>I’m sure I have  seen this face somewhere</strong></p>
<p>例句：（过去时间）<strong>Many soldiers had died from pneumonia before the discovery of penicillin.</strong></p>
<p>例句：（未来时间）<strong>Next April,I will have worked here for 20 years</strong></p>
</blockquote>
<h3 id="语态"><a href="#语态" class="headerlink" title="语态"></a>语态</h3><p>在英语中，语态（Voice）是用来表示动作或状态与主语之间关系的一种语法特征。英语中有两种主要的语态：主动语态（Active Voice）和被动语态（Passive Voice）。</p>
<ol>
<li>主动语态（Active Voice）：主动语态是最常用的语态形式。在主动语态中，主语是执行动作的实施者或行为的主体。动作的执行者位于句子的主语位置，而动作的接受者或承受者通常位于动词后的宾语位置。例如：<ul>
<li>“John reads a book.”（约翰读一本书。）</li>
<li>“She ate an apple.”（她吃了一个苹果。）</li>
</ul>
</li>
<li>被动语态（Passive Voice）：被动语态用于强调动作的接受者或承受者，而不是动作的执行者。在被动语态中，动词由”be”（根据时态变化）和过去分词形式构成，并且动作的接受者成为句子的主语。动作的执行者通常作为介词短语（通常是”by”）或省略不表达。例如：<ul>
<li>“The book is read by John.”（这本书被约翰读了。）</li>
<li>“An apple was eaten by her.”（一个苹果被她吃了。）</li>
</ul>
</li>
</ol>
<p>被动语态常用于以下情况：</p>
<ul>
<li>强调动作的接受者或承受者，而不是执行者。</li>
<li>当执行者未知、不重要或明显时。</li>
<li>当描述一般真理或客观事实时。</li>
</ul>
<p>需要注意的是，被动语态的使用要根据上下文和需要选择，有时也可以使用主动语态来表达相同的意思。了解和正确使用语态对于准确表达和理解英语句子至关重要。</p>
<h4 id="被动语态"><a href="#被动语态" class="headerlink" title="被动语态"></a>被动语态</h4><p>被动语态（Passive Voice）在英语中具有以下特点：</p>
<ol>
<li>动作接受者为主语：在被动语态中，动作的接受者或承受者成为句子的主语，突出了接受动作的对象。主动语态中的宾语通常变为被动语态中的主语。例如，”John reads a book”（约翰读一本书）的被动语态是”The book is read by John”（这本书被约翰读了）。</li>
<li>动词形式变化：被动语态的动词由”be”（根据时态变化）和过去分词形式构成。”be”的形式根据时态的不同而变化，如”is”、”was”、”will be”等。过去分词形式是动词的第三态形式，通常以”-ed”或”-en”结尾。例如，”read”（读）的过去分词形式是”read”，在被动语态中变为”read”。</li>
<li>执行者省略或通过介词短语表示：在被动语态中，动作的执行者（主动语态中的主语）可以被省略不表达，尤其当执行者未知、不重要或明显时。但如果需要明确指出执行者，可以通过介词短语（通常是”by”）来表达。例如，”The book is read”（这本书被读）中的执行者未指定，而”The book is read by John”（这本书被约翰读）中的执行者为John。</li>
<li>强调动作接受者或承受者：被动语态常用于强调动作的接受者或承受者，而不是动作的执行者。通过使用被动语态，可以将注意力放在受影响的对象上，使其成为句子的焦点。例如，”The house was built by my grandfather”（这座房子是我爷爷建造的）强调的是房子被建造的事实和建造者。</li>
<li>用于一般真理或客观事实：被动语态常用于表达一般真理、客观事实或普遍规律。通过使用被动语态，可以使句子更加客观和中性，避免强调特定的个体或行为。例如，”Water is boiled at 100 degrees Celsius”（水在100摄氏度沸腾）表达的是一般真理。</li>
</ol>
<p>需要注意的是，被动语态并非在所有情况下都适用，而且过度使用被动语态可能会使句子显得笨拙或不自然。正确地运用被动语态需要根据上下文和意图进行</p>
<h3 id="读音"><a href="#读音" class="headerlink" title="读音"></a>读音</h3><h4 id="元音"><a href="#元音" class="headerlink" title="元音"></a>元音</h4><p>元音在语言中扮演着多个重要角色，它们的作用包括：</p>
<ol>
<li>声音的核心：元音是构成语言中音节的基本成分，可以说是语言的核心音素。它们通常具有较长的持续时间，起到音节的骨架作用。其他音素如辅音则常常围绕着元音而存在。</li>
<li>词汇和语法的区分：元音的使用可以区分不同的词汇和语法形式。在许多语言中，改变元音的音素可以改变词汇的意义，例如英语中的 “bit”（一点）和 “bat”（球拍）。元音还可以用来表示时态、人称、性别等语法上的差异。</li>
<li>发音的清晰度：元音对于清晰发音至关重要。它们通常具有较高的音量和音高，有助于使语音更加清晰明确。元音的正确发音可以帮助人们准确地表达和理解语言。</li>
<li>语音韵律和重音的形成：元音在语音韵律中起到重要作用。它们可以用来区分重音和非重音音节，进一步影响句子的语调和语气。元音的长短、音高和强度的变化也可以帮助构建句子的韵律和节奏。</li>
<li>语音系统的多样性：元音在不同语言中呈现出丰富多样的系统。不同语言中的元音数量、品质和分布都有所不同。通过对元音系统的研究，可以深入了解不同语言之间的差异和相似之处。</li>
</ol>
<p>总之，元音在语言中起到了连接词汇和语法、帮助发音清晰、形成韵律和重音、以及构建语音系统多样性等重要作用。它们是语言中不可或缺的一部分，对于有效的交流和理解起着至关重要的作用。</p>
<blockquote>
<p>英语中有五个元音字母，它们分别是：a、e、i、o、u。</p>
<p>此外，在一些特定的情况下，字母y也可以被视为元音。当y在单词的音节中表示元音音素时，它可以被视为元音。例如，在单词”myth”中，字母y表示元音音素 &#x2F;ɪ&#x2F;，因此可以视为元音。</p>
</blockquote>
<h4 id="元音定位单词"><a href="#元音定位单词" class="headerlink" title="元音定位单词"></a>元音定位单词</h4><p>一个单词如果失去元音，那么这个单词就不能发声。我们可以对a e i o u进行定位，使用元音定位来推断一个单词的拼写。元音定位是一种通过识别单词中的元音字母来猜测单词的方法。以下是一个示例：</p>
<p>假设你听到一个单词的发音，但不知道它的拼写。你可以通过以下步骤使用元音定位来推测单词的拼写：</p>
<ol>
<li>听单词的发音，尝试识别其中的元音音素。元音音素是构成单词的元音字母的音值。</li>
<li>确定元音在单词中的位置。元音可以出现在单词的开头、中间或结尾。尝试确定哪个元音在单词中的位置是关键。</li>
<li>根据已确定的元音音素和位置，尝试拼写单词。你可以使用字母组合来形成可能的单词。</li>
</ol>
<p>请注意，元音定位是一种猜测单词拼写的方法，可能存在不确定性。有时，不同的单词可能具有相同的元音音素和位置，因此你需要根据上下文和其他线索来做出最准确的推断。</p>
<h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><h3 id="简单句直译"><a href="#简单句直译" class="headerlink" title="简单句直译"></a>简单句直译</h3>]]></content>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2023/04/30/Linux/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础知识和起源"><a href="#基础知识和起源" class="headerlink" title="基础知识和起源"></a>基础知识和起源</h2><blockquote>
<p><a href="https://www.runoob.com/linux/linux-intro.html">https://www.runoob.com/linux/linux-intro.html</a></p>
</blockquote>
<p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p>
<p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p>
<p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<p><img src="/2023/04/30/Linux/%E5%8F%91%E8%A1%8C.jpg" alt="发行"></p>
<p><img src="/2023/04/30/Linux/linux%E5%92%8Cwindows%E5%8C%BA%E5%88%AB.png" alt="linux和windows区别"></p>
<blockquote>
<p>我们只要知道创始人很牛逼就行，然后知道Linux其实和window一样是一个操作系统。</p>
</blockquote>
<p>对于这个操作系统，并不是像我们常用的window系统一样是有图像图标的，对次系统的操作是通过命令行操作的</p>
<p><img src="/2023/04/30/Linux/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%9B%BE%E7%89%87.png" alt="命令行演示"></p>
<p>当然，在对其操作之前，我们得把Linux启动,启动Linux分为5个阶段：</p>
<ul>
<li>内核的引导。</li>
<li>运行 init。</li>
<li>系统初始化。</li>
<li>建立终端 。</li>
<li>用户登录系统。</li>
</ul>
<h3 id="内核引导"><a href="#内核引导" class="headerlink" title="内核引导"></a><strong>内核引导</strong></h3><p>当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</p>
<blockquote>
<p>BIOS，可以理解为自检，控制我们主板其他硬件的各种参数，比如可以调整CPU频率，修改内存时序。就是控制硬件的一个简单程序吧</p>
</blockquote>
<p>操作系统接管硬件以后，首先读入 &#x2F;boot 目录下的内核文件。</p>
<p><img src="/2023/04/30/Linux/%E5%86%85%E6%A0%B8%E5%BC%95%E5%AF%BC.png" alt="内核引导"></p>
<h3 id="运行init"><a href="#运行init" class="headerlink" title="运行init"></a><strong>运行init</strong></h3><p>init 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</p>
<blockquote>
<p>我们在算法中，init函数通常被声明为初始化函数，用在这里也可以这样理解。理解为初始化系统的一个程序吧。</p>
</blockquote>
<p>init 程序首先是需要读取配置文件 &#x2F;etc&#x2F;inittab。</p>
<p><img src="/2023/04/30/Linux/init%E8%BF%9B%E7%A8%8B.png" alt="init()"></p>
<p>运行级别</p>
<p>许多程序需要开机启动。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）。</p>
<p>init进程的一大任务，就是去运行这些开机启动的程序。</p>
<p>但是，不同的场合需要启动不同的程序，比如用作服务器时，需要启动Apache，用作桌面就不需要。</p>
<p>Linux允许为不同的场合，分配不同的开机启动程序，这就叫做”运行级别”（runlevel）。也就是说，启动时根据”运行级别”，确定要运行哪些程序。</p>
<p><img src="/2023/04/30/Linux/%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB.png" alt="运行级别"></p>
<blockquote>
<p>可以理解为，为了适应不同的功能，才出对应的级别。让程序运行有针对性。</p>
</blockquote>
<p>Linux系统有7个运行级别(runlevel)：</p>
<ul>
<li>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动</li>
<li>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登录</li>
<li>运行级别2：多用户状态(没有NFS)</li>
<li>运行级别3：完全的多用户状态(有NFS)，登录后进入控制台命令行模式</li>
<li>运行级别4：系统未使用，保留</li>
<li>运行级别5：X11控制台，登录后进入图形GUI模式</li>
<li>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</li>
</ul>
<h3 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化*"></a><strong>系统初始化</strong>*</h3><blockquote>
<p>这里我就看不懂了，涉及到shell。&#x2F;etc&#x2F;init.d&#x2F;是一个目录，里面存放着很多系统服务的启动和停止脚本。它可以控制各种系统服务的运行状态，比如网络、防火墙、数据库等。您可以使用 &#x2F;etc&#x2F;init.d&#x2F;目录下的脚本来启动、停止或重启某个服务，比如 &#x2F;etc&#x2F;init.d&#x2F;network restart 就是重启网络服务。</p>
</blockquote>
<p>在init的配置文件中有这么一行： si::sysinit:&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit　它调用执行了&#x2F;etc&#x2F;rc.d&#x2F;rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</p>
<p>它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">l5:5:wait:/etc/rc.d/rc 5</span><br></pre></td></tr></table></figure>

<p>这一行表示以5为参数运行&#x2F;etc&#x2F;rc.d&#x2F;rc，&#x2F;etc&#x2F;rc.d&#x2F;rc是一个Shell脚本，它接受5作为参数，去执行&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录下的所有的rc启动脚本，&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;目录中的这些启动脚本实际上都是一些连接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在&#x2F;etc&#x2F;rc.d&#x2F;init.d&#x2F;目录下。</p>
<p>而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。</p>
<p>&#x2F;etc&#x2F;rc.d&#x2F;rc5.d&#x2F;中的rc启动脚本通常是K或S开头的连接文件，对于以 S 开头的启动脚本，将以start参数来运行。</p>
<p>而如果发现存在相应的脚本也存在K打头的连接，而且已经处于运行态了(以&#x2F;var&#x2F;lock&#x2F;subsys&#x2F;下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。</p>
<p>这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。</p>
<p>至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的”System Services”来自行设定。</p>
<p><img src="/2023/04/30/Linux/etc-init.png" alt="etc"></p>
<blockquote>
<p>理解为系统的关键部分吧</p>
</blockquote>
<h3 id="建立终端"><a href="#建立终端" class="headerlink" title="建立终端"></a>建立终端</h3><p>rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</p>
<p>init接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1:2345:respawn:/sbin/mingetty tty1</span><br><span class="line">2:2345:respawn:/sbin/mingetty tty2</span><br><span class="line">3:2345:respawn:/sbin/mingetty tty3</span><br><span class="line">4:2345:respawn:/sbin/mingetty tty4</span><br><span class="line">5:2345:respawn:/sbin/mingetty tty5</span><br><span class="line">6:2345:respawn:/sbin/mingetty tty6</span><br></pre></td></tr></table></figure>

<p>从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。</p>
<p>同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。</p>
<h3 id="用户登录系统"><a href="#用户登录系统" class="headerlink" title="用户登录系统*"></a>用户登录系统*</h3><p>一般来说，用户的登录方式有三种：</p>
<ul>
<li>（1）命令行登录</li>
<li>（2）ssh登录</li>
<li>（3）图形界面登录</li>
</ul>
<p><img src="/2023/04/30/Linux/%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95.png" alt="img"></p>
<p>对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入 KDE、Gnome 等窗口管理器。</p>
<p>而本文主要讲的还是文本方式登录的情况：当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。</p>
<p>Linux 的账号验证程序是 login，login 会接收 mingetty 传来的用户名作为用户名参数。</p>
<p>然后 login 会对用户名进行分析：如果用户名不是 root，且存在 &#x2F;etc&#x2F;nologin 文件，login 将输出 nologin 文件的内容，然后退出。</p>
<p>这通常用来系统维护时防止非root用户登录。只有&#x2F;etc&#x2F;securetty中登记了的终端才允许 root 用户登录，如果不存在这个文件，则 root 用户可以在任何终端上登录。</p>
<p>&#x2F;etc&#x2F;usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。</p>
<h3 id="图形模式与文字模式的切换方式"><a href="#图形模式与文字模式的切换方式" class="headerlink" title="图形模式与文字模式的切换方式*"></a>图形模式与文字模式的切换方式*</h3><p>Linux预设提供了六个命令窗口终端机让我们来登录。</p>
<p>默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，你可以按下Ctrl + Alt + F1 ~ F6 来切换它们。</p>
<p>如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。</p>
<p>当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。</p>
<p>如果你用的vmware 虚拟机，命令窗口切换的快捷键为 Alt + Space + F1<del>F6. 如果你在图形界面下请按Alt + Shift + Ctrl + F1</del>F6 切换至命令窗口。</p>
<p><img src="/2023/04/30/Linux/%E5%88%87%E6%8D%A2.png" alt="切换"></p>
<h3 id="Linux-关机"><a href="#Linux-关机" class="headerlink" title="Linux 关机*"></a>Linux 关机*</h3><p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p>
<p>正确的关机流程为：sync &gt; shutdown &gt; reboot &gt; halt</p>
<p>关机指令为：shutdown ，你可以man shutdown 来看一下帮助文档。</p>
<p>例如你可以运行如下命令关机：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sync 将数据由内存同步到硬盘中。</span><br><span class="line"></span><br><span class="line">shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><br><span class="line"></span><br><span class="line">shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。</span><br><span class="line"></span><br><span class="line">shutdown –h now 立马关机</span><br><span class="line"></span><br><span class="line">shutdown –h 20:25 系统会在今天20:25关机</span><br><span class="line"></span><br><span class="line">shutdown –h +10 十分钟后关机</span><br><span class="line"></span><br><span class="line">shutdown –r now 系统立马重启</span><br><span class="line"></span><br><span class="line">shutdown –r +10 系统十分钟后重启</span><br><span class="line"></span><br><span class="line">reboot 就是重启，等同于 shutdown –r now</span><br><span class="line"></span><br><span class="line">halt 关闭系统，等同于shutdown –h now 和 poweroff</span><br></pre></td></tr></table></figure>

<p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p>
<p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p>
<h2 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h2><h3 id="基本文件介绍"><a href="#基本文件介绍" class="headerlink" title="基本文件介绍"></a>基本文件介绍</h3><p>登录系统后，在当前命令窗口下输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls / </span><br></pre></td></tr></table></figure>

<p>你会看到如下图所示:</p>
<p><img src="/2023/04/30/Linux/ls%E5%8A%9F%E8%83%BD.png" alt="ls功能"></p>
<p>树状目录结构：</p>
<p><img src="/2023/04/30/Linux/d0c50-linux2bfile2bsystem2bhierarchy.jpg" alt="树状目录"></p>
<p>以下是对这些目录的解释：</p>
<ul>
<li><p><strong>&#x2F;bin</strong>：<br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>&#x2F;boot：</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>&#x2F;dev ：</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
</li>
<li><p><strong>&#x2F;etc：</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
</li>
<li><p><strong>&#x2F;home</strong>：<br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
</li>
<li><p><strong>&#x2F;lib</strong>：<br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p><strong>&#x2F;lost+found</strong>：<br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>&#x2F;media</strong>：<br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>&#x2F;mnt</strong>：<br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 &#x2F;mnt&#x2F; 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>&#x2F;opt</strong>：<br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>&#x2F;proc</strong>：<br>proc 是 Processes(进程) 的缩写，&#x2F;proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。<br>这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>&#x2F;root</strong>：<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>&#x2F;sbin</strong>：<br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>&#x2F;selinux</strong>：<br> 这个目录是 Redhat&#x2F;CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
<li><p><strong>&#x2F;srv</strong>：<br> 该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p><strong>&#x2F;sys</strong>：</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>&#x2F;tmp</strong>：<br>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。</p>
</li>
<li><p><strong>&#x2F;usr</strong>：<br> usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;bin：</strong><br>系统用户使用的应用程序。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;sbin：</strong><br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p><strong>&#x2F;usr&#x2F;src：</strong><br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>&#x2F;var</strong>：<br>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p><strong>&#x2F;run</strong>：<br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 &#x2F;var&#x2F;run 目录，应该让它指向 run。</p>
</li>
</ul>
<p><strong>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</strong></p>
<p><strong>&#x2F;etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p>
<p><strong>&#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin, &#x2F;usr&#x2F;sbin</strong>: 这是系统预设的执行文件的放置目录，比如 <strong>ls</strong> 就是在 <strong>&#x2F;bin&#x2F;ls</strong> 目录下的。</p>
<p>值得提出的是 <strong>&#x2F;bin</strong>、**&#x2F;usr&#x2F;bin** 是给系统用户使用的指令（除 root 外的通用用户），而&#x2F;sbin, &#x2F;usr&#x2F;sbin 则是给 root 使用的指令。</p>
<p><strong>&#x2F;var</strong>： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 &#x2F;var&#x2F;log 目录下，另外 mail 的预设放置也是在这里。</p>
<h3 id="文件基本属性"><a href="#文件基本属性" class="headerlink" title="文件基本属性*"></a>文件基本属性*</h3><blockquote>
<p><a href="https://www.runoob.com/linux/linux-file-attr-permission.html">https://www.runoob.com/linux/linux-file-attr-permission.html</a></p>
</blockquote>
<h3 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h3><p>我们知道 Linux 的目录结构为树状结构，最顶级的目录为根目录 **&#x2F;**。</p>
<p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p>
<p>在开始本教程前我们需要先知道什么是绝对路径与相对路径。</p>
<ul>
<li><strong>绝对路径：</strong><br>路径的写法，由根目录 <strong>&#x2F;</strong> 写起，例如： &#x2F;usr&#x2F;share&#x2F;doc 这个目录。</li>
<li><strong>相对路径：</strong><br>路径的写法，不是由 <strong>&#x2F;</strong> 写起，例如由 &#x2F;usr&#x2F;share&#x2F;doc 要到 &#x2F;usr&#x2F;share&#x2F;man 底下时，可以写成： <strong>cd ..&#x2F;man</strong> 这就是相对路径的写法。</li>
</ul>
<h2 id="处理目录的常用命令"><a href="#处理目录的常用命令" class="headerlink" title="处理目录的常用命令"></a>处理目录的常用命令</h2><p>接下来我们就来看几个常见的处理目录的命令吧：</p>
<ul>
<li>ls（英文全拼：list files）: 列出目录及文件名</li>
<li>cd（英文全拼：change directory）：切换目录</li>
<li>pwd（英文全拼：print work directory）：显示目前的目录</li>
<li>mkdir（英文全拼：make directory）：创建一个新的目录</li>
<li>rmdir（英文全拼：remove directory）：删除一个空的目录</li>
<li>cp（英文全拼：copy file）: 复制文件或目录</li>
<li>rm（英文全拼：remove）: 删除文件或目录</li>
<li>mv（英文全拼：move file）: 移动文件与目录，或修改文件与目录的名称</li>
</ul>
<p>你可以使用 <em>man [命令]</em> 来查看各个命令的使用文档，如 ：man cp。</p>
<p><strong>操作演示：</strong></p>
<p><img src="/2023/04/30/Linux/image-20230503104713448.png" alt="ls演示"></p>
<p><img src="/2023/04/30/Linux/image-20230503104745656.png" alt="切换目录"></p>
<p><img src="/2023/04/30/Linux/image-20230503104833277.png" alt="显示目录"></p>
<h3 id="ls-列出目录"><a href="#ls-列出目录" class="headerlink" title="ls (列出目录)"></a>ls (列出目录)</h3><p>在Linux系统当中， ls 命令可能是最常被运行的。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls [-aAdfFhilnrRSt] 目录名称</span><br><span class="line">[root@www ~]# ls [--color=&#123;never,auto,always&#125;] 目录名称</span><br><span class="line">[root@www ~]# ls [--full-time] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li>
<li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li>
<li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li>
</ul>
<p>将目录下的所有文件列出来(含属性与隐藏档)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# ls -al ~</span><br></pre></td></tr></table></figure>

<h3 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd (切换目录)"></a>cd (切换目录)</h3><p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> cd [相对路径或绝对路径]</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 <span class="built_in">mkdir</span> 命令创建 runoob 目录</span></span><br><span class="line">[root@www ~]# mkdir runoob</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用绝对路径切换到 runoob 目录</span></span><br><span class="line">[root@www ~]# cd /root/runoob/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用相对路径切换到 runoob 目录</span></span><br><span class="line">[root@www ~]# cd ./runoob/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示回到自己的家目录，亦即是 /root 这个目录</span></span><br><span class="line">[root@www runoob]# cd ~</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示去到目前的上一级目录，亦即是 /root 的上一级目录的意思；</span></span><br><span class="line">[root@www ~]# cd ..</span><br></pre></td></tr></table></figure>

<p>接下来大家多操作几次应该就可以很好的理解 cd 命令的。</p>
<h3 id="pwd-显示目前所在的目录"><a href="#pwd-显示目前所在的目录" class="headerlink" title="pwd (显示目前所在的目录)"></a>pwd (显示目前所在的目录)</h3><p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# pwd [-P]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-P</strong> ：显示出确实的路径，而非使用链接 (link) 路径。</li>
</ul>
<p>实例：单纯显示出目前的工作目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# pwd</span><br><span class="line">/root   &lt;== 显示出目录啦～</span><br></pre></td></tr></table></figure>

<p>实例显示出实际的工作目录，而非链接档本身的目录名而已。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cd /var/mail   &lt;==注意，/var/mail是一个链接档</span><br><span class="line">[root@www mail]# pwd</span><br><span class="line">/var/mail         &lt;==列出目前的工作目录</span><br><span class="line">[root@www mail]# pwd -P</span><br><span class="line">/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～</span><br><span class="line">[root@www mail]# ls -ld /var/mail</span><br><span class="line">lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">看到这里应该知道为啥了吧？因为 /var/mail 是链接档，链接到 /var/spool/mail</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所以，加上 <span class="built_in">pwd</span> -P 的选项后，会不以链接档的数据显示，而是显示正确的完整路径啊！</span></span><br></pre></td></tr></table></figure>

<h3 id="mkdir-创建新目录"><a href="#mkdir-创建新目录" class="headerlink" title="mkdir (创建新目录)"></a>mkdir (创建新目录)</h3><p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir [-mp] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li>
<li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li>
</ul>
<p>实例：请到&#x2F;tmp底下尝试创建数个新目录看看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cd /tmp</span><br><span class="line">[root@www tmp]# mkdir test    &lt;==创建一名为 test 的新目录</span><br><span class="line">[root@www tmp]# mkdir test1/test2/test3/test4</span><br><span class="line">mkdir: cannot create directory `test1/test2/test3/test4&#x27;: </span><br><span class="line">No such file or directory       &lt;== 没办法直接创建此目录啊！</span><br><span class="line">[root@www tmp]# mkdir -p test1/test2/test3/test4</span><br></pre></td></tr></table></figure>

<p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p>
<p>实例：创建权限为 <strong>rwx–x–x</strong> 的目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mkdir -m 711 test2</span><br><span class="line">[root@www tmp]# ls -l</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure>

<p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p>
<p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x–x 的权限。</p>
<h3 id="rmdir-删除空的目录"><a href="#rmdir-删除空的目录" class="headerlink" title="rmdir (删除空的目录)"></a>rmdir (删除空的目录)</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir [-p] 目录名称</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-p ：</strong>从该目录起，一次删除多级空目录</li>
</ul>
<p>删除 runoob 目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# rmdir runoob/</span><br></pre></td></tr></table></figure>

<p>将 mkdir 实例中创建的目录(&#x2F;tmp 底下)删除掉！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# ls -l   &lt;==看看有多少目录存在？</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test</span><br><span class="line">drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br><span class="line">[root@www tmp]# rmdir test   &lt;==可直接删除掉，没问题</span><br><span class="line">[root@www tmp]# rmdir test1  &lt;==因为尚有内容，所以无法删除！</span><br><span class="line">rmdir: `test1&#x27;: Directory not empty</span><br><span class="line">[root@www tmp]# rmdir -p test1/test2/test3/test4</span><br><span class="line">[root@www tmp]# ls -l        &lt;==您看看，底下的输出中test与test1不见了！</span><br><span class="line">drwx--x--x  2 root  root 4096 Jul 18 12:54 test2</span><br></pre></td></tr></table></figure>

<p>利用 -p 这个选项，立刻就可以将 test1&#x2F;test2&#x2F;test3&#x2F;test4 一次删除。</p>
<p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p>
<h3 id="cp-复制文件或目录"><a href="#cp-复制文件或目录" class="headerlink" title="cp (复制文件或目录)"></a>cp (复制文件或目录)</h3><p>cp 即拷贝文件和目录。</p>
<p>语法:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp [-adfilprsu] 来源档(source) 目标档(destination)</span><br><span class="line">[root@www ~]# cp [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li>
<li><strong>-d：</strong>若来源档为链接档的属性(link file)，则复制链接档属性而非文件本身；</li>
<li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li>
<li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li>
<li><strong>-l：</strong>进行硬式链接(hard link)的链接档创建，而非复制文件本身；</li>
<li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li>
<li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li>
<li><strong>-s：</strong>复制成为符号链接档 (symbolic link)，亦即『捷径』文件；</li>
<li><strong>-u：</strong>若 destination 比 source 旧才升级 destination ！</li>
</ul>
<p>用 root 身份，将 root 目录下的 .bashrc 复制到 &#x2F;tmp 下，并命名为 bashrc</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cp ~/.bashrc /tmp/bashrc</span><br><span class="line">[root@www ~]# cp -i ~/.bashrc /tmp/bashrc</span><br><span class="line">cp: overwrite `/tmp/bashrc&#x27;? n  &lt;==n不覆盖，y为覆盖</span><br></pre></td></tr></table></figure>

<h3 id="rm-移除文件或目录"><a href="#rm-移除文件或目录" class="headerlink" title="rm (移除文件或目录)"></a>rm (移除文件或目录)</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm [-fir] 文件或目录</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li>
<li>-i ：互动模式，在删除前会询问使用者是否动作</li>
<li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li>
<li></li>
</ul>
<p>将刚刚在 cp 的实例中创建的 bashrc 删除掉！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# rm -i bashrc</span><br><span class="line">rm: remove regular file `bashrc&#x27;? y</span><br></pre></td></tr></table></figure>

<p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p>
<h3 id="mv-移动文件与目录，或修改名称"><a href="#mv-移动文件与目录，或修改名称" class="headerlink" title="mv (移动文件与目录，或修改名称)"></a>mv (移动文件与目录，或修改名称)</h3><p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# mv [-fiu] source destination</span><br><span class="line">[root@www ~]# mv [options] source1 source2 source3 .... directory</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li>
</ul>
<p>复制一文件，创建一目录，将文件移动到目录中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cd /tmp</span><br><span class="line">[root@www tmp]# cp ~/.bashrc bashrc</span><br><span class="line">[root@www tmp]# mkdir mvtest</span><br><span class="line">[root@www tmp]# mv bashrc mvtest</span><br></pre></td></tr></table></figure>

<p>将某个文件移动到某个目录去，就是这样做！</p>
<p>将刚刚的目录名称更名为 mvtest2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www tmp]# mv mvtest mvtest2</span><br></pre></td></tr></table></figure>

<h2 id="Linux-文件内容查看"><a href="#Linux-文件内容查看" class="headerlink" title="Linux 文件内容查看"></a>Linux 文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容：</p>
<ul>
<li>cat 由第一行开始显示文件内容</li>
<li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li>
<li>nl  显示的时候，顺道输出行号！</li>
<li>more 一页一页的显示文件内容</li>
<li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li>
<li>head 只看头几行</li>
<li>tail 只看尾巴几行</li>
</ul>
<p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p>
<h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>由第一行开始显示文件内容</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat [-AbEnTv]</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li>
<li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li>
<li>-E ：将结尾的断行字节 $ 显示出来；</li>
<li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li>
<li>-T ：将 [tab] 按键以 ^I 显示出来；</li>
<li>-v ：列出一些看不出来的特殊字符</li>
</ul>
<p>检看 &#x2F;etc&#x2F;issue 这个文件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# cat /etc/issue</span><br><span class="line">CentOS release 6.4 (Final)</span><br><span class="line">Kernel \r on an \m</span><br></pre></td></tr></table></figure>

<h3 id="tac"><a href="#tac" class="headerlink" title="tac"></a>tac</h3><p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# tac /etc/issue</span><br><span class="line"></span><br><span class="line">Kernel \r on an \m</span><br><span class="line">CentOS release 6.4 (Final)</span><br></pre></td></tr></table></figure>

<h3 id="nl"><a href="#nl" class="headerlink" title="nl"></a>nl</h3><p>显示行号</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nl [-bnw] 文件</span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-b ：指定行号指定的方式，主要有两种：<br>-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；<br>-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li>
<li>-n ：列出行号表示的方法，主要有三种：<br>-n ln ：行号在荧幕的最左方显示；<br>-n rn ：行号在自己栏位的最右方显示，且不加 0 ；<br>-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li>
<li>-w ：行号栏位的占用的位数。</li>
</ul>
<p>实例一：用 nl 列出 &#x2F;etc&#x2F;issue 的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# nl /etc/issue</span><br><span class="line">     1  CentOS release 6.4 (Final)</span><br><span class="line">     2  Kernel \r on an \m</span><br></pre></td></tr></table></figure>

<h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>一页一页翻动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# more /etc/man_db.config </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Generated automatically from man.conf.in by the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configure script.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># man.conf from man-1.6d</span></span></span><br><span class="line">....(中间省略)....</span><br><span class="line"><span class="meta prompt_">--More--(28%</span><span class="language-bash">)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令</span></span><br></pre></td></tr></table></figure>

<p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p>
<ul>
<li>空白键 (space)：代表向下翻一页；</li>
<li>Enter     ：代表向下翻『一行』；</li>
<li>&#x2F;字串     ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li>
<li>:f      ：立刻显示出档名以及目前显示的行数；</li>
<li>q       ：代表立刻离开 more ，不再显示该文件内容。</li>
<li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li>
</ul>
<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>一页一页翻动，以下实例输出&#x2F;etc&#x2F;man.config文件的内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# less /etc/man.config</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># Generated automatically from man.conf.in by the</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">configure script.</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># man.conf from man-1.6d</span></span></span><br><span class="line">....(中间省略)....</span><br><span class="line">:   &lt;== 这里可以等待你输入命令！</span><br></pre></td></tr></table></figure>

<p>less运行时可以输入的命令有：</p>
<ul>
<li>空白键  ：向下翻动一页；</li>
<li>[pagedown]：向下翻动一页；</li>
<li>[pageup] ：向上翻动一页；</li>
<li>&#x2F;字串   ：向下搜寻『字串』的功能；</li>
<li>?字串   ：向上搜寻『字串』的功能；</li>
<li>n     ：重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>N     ：反向的重复前一个搜寻 (与 &#x2F; 或 ? 有关！)</li>
<li>q     ：离开 less 这个程序；</li>
</ul>
<h3 id="head"><a href="#head" class="headerlink" title="head"></a>head</h3><p>取出文件前面几行</p>
<p>语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">head [-n number] 文件 </span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# head /etc/man.config</span><br></pre></td></tr></table></figure>

<p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@www ~]# head -n 20 /etc/man.config</span><br></pre></td></tr></table></figure>

<h3 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h3><p>取出文件后面几行</p>
<p>语法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tail [-n number] 文件 </span><br></pre></td></tr></table></figure>

<p>选项与参数：</p>
<ul>
<li>-n ：后面接数字，代表显示几行的意思</li>
<li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[root@www ~]<span class="meta"># tail /etc/man.config</span></span><br><span class="line"># 默认的情况中，显示最后的十行！若要显示最后的 <span class="number">20</span> 行，就得要这样：</span><br><span class="line">[root@www ~]<span class="meta"># tail -n 20 /etc/man.config</span></span><br></pre></td></tr></table></figure>

<h2 id="调用代码演示"><a href="#调用代码演示" class="headerlink" title="调用代码演示"></a>调用代码演示</h2><p>常用命令介绍：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(1) ctrl c: 取消命令，并且换行</span><br><span class="line">(2) ctrl u: 清空本行命令</span><br><span class="line">(3) tab键：可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项</span><br><span class="line">(4) ls: 列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</span><br><span class="line">(5) pwd: 显示当前路径</span><br><span class="line">(6) cd XXX: 进入XXX目录下, cd .. 返回上层目录</span><br><span class="line">(7) cp XXX YYY: 将XXX文件复制成YYY，XXX和YYY可以是一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt</span><br><span class="line">(8) mkdir XXX: 创建目录XXX</span><br><span class="line">(9) rm XXX: 删除普通文件;  rm XXX -r: 删除文件夹</span><br><span class="line">(10) mv XXX YYY: 将XXX文件移动到YYY，和cp命令一样，XXX和YYY可以是一个路径；重命名也是用这个命令</span><br><span class="line">(11) touch XXX: 创建一个文件</span><br><span class="line">(12) cat XXX: 展示文件XXX中的内容</span><br><span class="line">(13) 复制文本</span><br><span class="line">    windows/Linux下：Ctrl + insert，Mac下：command + c</span><br><span class="line">(14) 粘贴文本</span><br><span class="line">    windows/Linux下：Shift + insert，Mac下：command + v</span><br></pre></td></tr></table></figure>

<p>作业：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建好作业后，先进入文件夹/home/acs/homework/lesson_1/，然后：</span><br><span class="line">(0) 进入homework_0文件夹，分别创建文件夹dir_a, dir_b, dir_c</span><br><span class="line">(1) 进入homework_1文件夹，将a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak</span><br><span class="line">(2) 进入homework_2文件夹，将a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt</span><br><span class="line">(3) 进入homework_3文件夹，将dir_a文件夹下的a.txt, b.txt, c.txt分别移动到文件夹dir_b下</span><br><span class="line">(4) 进入homework_4文件夹，将普通文件a.txt, b.txt, c.txt删除</span><br><span class="line">(5) 进入homework_5文件夹，将文件夹dir_a, dir_b, dir_c删除</span><br><span class="line">(6) 进入homework_6文件夹，查看task.txt的内容，并按其指示进行操作</span><br><span class="line">(7) 进入homework_7文件夹，创建文件夹dir_0, dir_1, dir_2，</span><br><span class="line">    将a.txt, b.txt, c.txt复制到dir_0下，重命名为a0.txt, b0.txt, c0.txt;</span><br><span class="line">    将a.txt, b.txt, c.txt复制到dir_1下，重命名为a1.txt, b1.txt, c1.txt;</span><br><span class="line">    将a.txt, b.txt, c.txt复制到dir_2下，重命名为a2.txt, b2.txt, c2.txt;</span><br><span class="line">(8) 进入homework_8文件夹，分别在dir_a, dir_b, dir_c文件夹下查看task.txt的内容，并分别按照指示进行操作</span><br><span class="line">(9) 进入homework_9文件夹，将其中所有txt类型的文件删除</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>前端三件套 - 简单介绍</title>
    <url>/2023/04/30/Web/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="HTML超文本标记语言"><a href="#HTML超文本标记语言" class="headerlink" title="HTML超文本标记语言"></a>HTML超文本标记语言</h2><p>HTML（HyperText Markup Language）是一种用于创建网页结构和内容的标记语言。它使用标签（tag）来定义网页中的各种元素，如标题、段落、链接、图像等。HTML文件由一系列标签和文本内容组成，浏览器根据这些标签解析并显示网页的结构和内容。</p>
<p>HTML相当于我们文章的文本，内部存在一些标签，来对这些文本修饰和美化，相当于我们的大纲，通过与CSS结合使用，可以通过样式规则控制文本的外观和呈现方式。下面我们来介绍一些基础的标签。</p>
<h3 id="基础框架"><a href="#基础框架" class="headerlink" title="基础框架"></a>基础框架</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><code>&lt;!DOCTYPE html&gt;</code>：声明文档类型，告诉浏览器这是一个HTML5文档。</li>
<li><code>&lt;html&gt;</code>：根元素，表示整个HTML文档的开始和结束。</li>
<li><code>&lt;head&gt;</code>：头部元素，用于定义文档的元数据和引入外部资源，如CSS和JavaScript文件等。</li>
<li><code>&lt;meta charset=&quot;UTF-8&quot;&gt;</code>：指定文档的字符编码为UTF-8，确保网页中的文本可以正确地显示。</li>
<li><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</code>：定义浏览器的兼容性模式，确保在Internet Explorer浏览器中以最新的渲染模式显示。</li>
<li><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code>：设置视口的宽度和初始缩放级别，使网页在移动设备上能够适应屏幕大小。</li>
<li><code>&lt;title&gt;</code>：定义网页的标题，显示在浏览器的标题栏或标签页上。</li>
<li><code>&lt;body&gt;</code>：主体元素，包含了网页的可见内容，如文本、图像、链接等。</li>
</ol>
<h3 id="基础标签"><a href="#基础标签" class="headerlink" title="基础标签"></a>基础标签</h3><p>在介绍完基础框架后，我们来学习一下基本构建网站的标签。它们通常都是书写在我们的body标签处</p>
<h4 id="h标签"><a href="#h标签" class="headerlink" title="h标签"></a><strong>h标签</strong></h4><p> h标签是文章的标题，一共有6个级别，h1…h6。每一个级别代表着一个标签头。我们书写一个这样的案例，按照6个级别分别输出我们的标题。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 试试打开全部的标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是标题3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h4</span>&gt;</span>我是标题4<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h5</span>&gt;</span>我是标题5<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h6</span>&gt;</span>我是标题6<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517201250588.png" alt="image-20230517201250588"></p>
<h4 id="p标签"><a href="#p标签" class="headerlink" title="p标签"></a><strong>p标签</strong></h4><p>p标签是文章的段落，被p标签修饰的字段，会有执行文章段落的规则，浏览器通常会在段落前后添加一些默认的空间和换行，以显示段落的分隔效果。</p>
<p>块级元素：<code>&lt;p&gt;</code>标签是一个块级元素，它会占据一行或多行的空间。相邻的<code>&lt;p&gt;</code>标签会在页面上垂直排列，每个<code>&lt;p&gt;</code>标签之间会有一定的间距。</p>
<blockquote>
<p>块级元素：块级元素（Block-level elements）是HTML中的一个概念，用于描述元素在文档流中的布局和行为方式。以下是块级元素的特点：</p>
<ol>
<li>独占一行：块级元素通常会在页面上独占一行，即使它的内容没有填满整行。相邻的块级元素会在页面上垂直排列。</li>
<li>宽度默认为100%：块级元素的默认宽度会填满其父元素的可用宽度，除非通过CSS显式设置其宽度。</li>
<li>可以设置宽度、高度、内边距和外边距：块级元素可以通过CSS属性设置其宽度、高度、内边距和外边距，以调整布局和样式。</li>
<li>可以包含内联元素和其他块级元素：块级元素可以包含其他块级元素和内联元素。这使得可以构建复杂的布局结构，并且在其中放置各种内容。</li>
<li>默认情况下会产生一些垂直间距：块级元素通常会在其上下产生一些默认的垂直间距，例如段落之间的间距。</li>
</ol>
<p>一些常见的块级元素包括<code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;h1&gt;</code>到<code>&lt;h6&gt;</code>、<code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code>、<code>&lt;li&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;form&gt;</code>等。这些元素在默认情况下都是块级元素，但也可以通过CSS进行样式上的修改。</p>
<p>相对于块级元素，还有另一类元素称为内联元素（Inline elements），它们通常不会独占一行，而是在同一行内水平排列。内联元素的特点包括不能设置宽度和高度，不能独占一行，只能容纳其他内联元素或者文本内容。常见的内联元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>等。</p>
</blockquote>
<p>文本包裹：<code>&lt;p&gt;</code>标签用于包裹一段文本，该文本可以是普通的纯文本，也可以包含其他内联元素或标记。例如，你可以在<code>&lt;p&gt;</code>标签内使用<code>&lt;strong&gt;</code>或<code>&lt;em&gt;</code>标签来加粗或斜体显示文本。</p>
<p>默认样式：浏览器会对<code>&lt;p&gt;</code>标签应用一些默认样式，例如设定一定的行间距、字体样式和段落缩进。这些样式可以通过CSS进行自定义调整。</p>
<blockquote>
<p>以下是一些常见的CSS属性，可以用来修饰段落：</p>
<ol>
<li><code>color</code>：设置文本的颜色。</li>
<li><code>font-size</code>：设置文本的字体大小。</li>
<li><code>font-family</code>：设置文本的字体系列。</li>
<li><code>font-weight</code>：设置文本的粗细程度，例如使用值<code>bold</code>加粗文本。</li>
<li><code>text-align</code>：设置文本的对齐方式，例如使用值<code>center</code>使文本居中对齐。</li>
<li><code>line-height</code>：设置行高，控制行与行之间的垂直间距。</li>
<li><code>padding</code>：设置段落的内边距，即段落内容与边框之间的空间。</li>
<li><code>margin</code>：设置段落的外边距，即段落与相邻元素之间的空间。</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- css样式 - 建议封装在外部 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">165</span>, <span class="number">42</span>, <span class="number">128</span>);</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 字体大小 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">16px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* css样式居中 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">padding</span>: <span class="number">10px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>试试段落的特点<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个段落是一个块 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落，它有什么特点<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 尝试用css来修饰这个段落 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517203408632.png" alt="image-20230517203408632"></p>
<h4 id="a标签"><a href="#a标签" class="headerlink" title="a标签"></a><strong>a标签</strong></h4><p>a标签是HTML中用于创建超链接的标签，它具有以下特点：</p>
<ol>
<li><p>超链接功能：<code>&lt;a&gt;</code>标签用于创建链接到其他网页、文档或特定位置的超链接。通过设置<code>href</code>属性来指定链接目标的URL或文档片段标识符。</p>
</li>
<li><p>文本或图像链接：<code>&lt;a&gt;</code>标签可以包裹文本或图像，使其成为可点击的链接。例如，可以使用<code>&lt;a&gt;</code>标签将文本或图像转换为链接，使用户能够点击并导航到链接目标。</p>
</li>
<li><p>打开新窗口：使用<code>target</code>属性可以控制链接在新窗口或当前窗口中打开。例如，设置<code>target=&quot;_blank&quot;</code>可以在新的浏览器窗口或选项卡中打开链接。</p>
</li>
<li><p>可以包含其他元素：<code>&lt;a&gt;</code>标签可以包含其他内联元素或块级元素，例如文本、图像、按钮等。这样可以在链接中添加更丰富的内容和样式。</p>
</li>
<li><p>可以添加标题：使用<code>title</code>属性可以为链接添加鼠标悬停时显示的标题文本，提供额外的描述或信息。</p>
</li>
<li><p>可以与JavaScript交互：<code>&lt;a&gt;</code>标签可以与JavaScript代码结合使用，例如通过添加事件处理程序来实现自定义行为或交互效果。  </p>
<blockquote>
<p>通过添加事件处理程序，你可以为<code>&lt;a&gt;</code>标签或其它元素添加自定义的行为或交互效果。事件处理程序是一段JavaScript代码，用于响应用户与页面元素的交互，例如点击、鼠标移入、键盘按下等事件。</p>
<p>在HTML中，你可以通过在元素上添加事件属性来指定事件处理程序。常见的事件属性包括<code>onclick</code>（点击事件）、<code>onmouseover</code>（鼠标悬停事件）、<code>onkeydown</code>（键盘按下事件）等。</p>
<p>就是一些按钮啊，点击啊之类的(＾▽＾)</p>
</blockquote>
</li>
</ol>
<p>需要注意的是，<code>&lt;a&gt;</code>标签本身并没有默认的样式，它可以通过CSS进行样式上的修改，如更改颜色、添加下划线等。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>超链接实验<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.创建连接指向我们的hexo --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/zh-cn/index.html&quot;</span>&gt;</span>hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.控制链接跳转，生成新的网页 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>hexo_open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.包括其他块级元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>你说我这个算不算链接啊<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>试一下第二行有没有用<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.添加标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/zh-cn/index.html&quot;</span> <span class="attr">title</span>=<span class="string">&quot;这是通向hexo的链接&quot;</span>&gt;</span>?????<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5.图片链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://hexo.io/zh-cn/index.html&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img\Different from the usual of you.jpg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517204933935.png" alt="image-20230517204933935"></p>
<h4 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a><strong>img标签</strong></h4><p>img标签是HTML中用于插入图像的标签，它具有以下特点：</p>
<ol>
<li><p>插入图像：<code>&lt;img&gt;</code>标签用于在网页中插入图像。通过设置<code>src</code>属性来指定要插入的图像的路径或URL。</p>
</li>
<li><p>自闭合标签：<code>&lt;img&gt;</code>标签是一个自闭合标签，不需要闭合标签。例如：<code>&lt;img src=&quot;image.jpg&quot; alt=&quot;图像&quot;&gt;</code></p>
</li>
<li><p>显示图像：<code>&lt;img&gt;</code>标签会在网页中显示指定的图像。网页加载时，图像会根据<code>src</code>属性指定的路径下载并显示在指定位置。</p>
</li>
<li><p>替代文本：通过<code>alt</code>属性可以提供替代文本（alternative text），当图像无法加载时，或用于辅助技术（如屏幕阅读器）读取图像时，会显示替代文本。</p>
</li>
<li><p>调整尺寸：通过<code>width</code>和<code>height</code>属性可以设置图像的宽度和高度。可以使用具体像素值或百分比来调整图像的大小。</p>
</li>
<li><p>添加标题：使用<code>title</code>属性可以为图像添加鼠标悬停时显示的标题文本，提供额外的描述或信息。</p>
</li>
<li><p>响应式设计：通过CSS或使用<code>width</code>属性设置百分比值，可以使图像在不同屏幕尺寸下自动调整大小，实现响应式设计。</p>
<blockquote>
<p>响应式设计（Responsive Design）是一种设计方法和技术，旨在使网页或应用程序能够根据不同设备（如桌面电脑、平板电脑、手机等）和屏幕尺寸的变化而自动调整其布局和外观。</p>
<p>传统的网页设计通常是为特定的屏幕尺寸和设备进行优化，这导致在不同设备上访问同一网页时可能会出现布局错乱、内容溢出等问题。而响应式设计的目标是提供一种灵活的布局和界面，使网页能够适应不同的屏幕尺寸，从而提供更好的用户体验。</p>
<p>在响应式设计中，通过使用CSS媒体查询（Media Queries）和流式布局（Fluid Layouts），可以根据屏幕宽度、高度、像素密度等特性，动态地调整网页元素的大小、位置和样式。这样，网页的内容和布局会根据设备的大小和方向进行自适应，以适应不同的屏幕。</p>
<p>就是，可以随着用户的放大和缩小图片的大小，或者设定图片的格式固定啥的。<br>(￣▽￣)ノ</p>
</blockquote>
</li>
<li><p>支持多种图像格式：<code>&lt;img&gt;</code>标签可以加载多种图像格式，如JPEG、PNG、GIF等。</p>
</li>
</ol>
<p>需要注意的是，图像的实际大小和显示效果会受到浏览器窗口大小、图像本身尺寸以及CSS样式的影响。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 默认样式 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.responsive-img</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 图片宽度填满父容器 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: auto;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 根据宽度等比例调整高度 */</span></span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 在屏幕宽度小于等于600px时调整图片大小 */</span></span></span><br><span class="line"><span class="language-css">        <span class="keyword">@media</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="language-css">            <span class="selector-class">.responsive-img</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">                <span class="comment">/* 图片宽度为父容器宽度的50% */</span></span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>插入图片试试<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.简单插入图片 由于尺寸太大了 限制一下--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img\照片素材\800 (1).jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;报错了QAQ&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.alt用法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;im\照片素材\800 (1).jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;我是故意的&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3.加个标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;img\照片素材\市.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;你好&quot;</span> <span class="attr">width</span>=<span class="string">&quot;300&quot;</span> <span class="attr">height</span>=<span class="string">&quot;300&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.响应式设计 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;responsive-img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;img\照片素材\雪山.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;响应式图片&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517213938193.png" alt="image-20230517213938193"></p>
<h3 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h3><h4 id="ul和li"><a href="#ul和li" class="headerlink" title="ul和li"></a>ul和li</h4><p><code>&lt;ul&gt;</code>（无序列表）和 <code>&lt;li&gt;</code>（列表项）是 HTML 中用于创建列表的标签，它们具有以下特点：</p>
<p><code>&lt;ul&gt;</code> 标签的特点：</p>
<ol>
<li>无序列表：<code>&lt;ul&gt;</code> 表示无序列表，其中的列表项 <code>&lt;li&gt;</code> 不会按照特定的顺序排列，而是作为一个项目列表显示。</li>
<li>项目符号：无序列表使用项目符号来表示每个列表项，默认情况下是一个实心圆点（•）。</li>
<li>嵌套列表：<code>&lt;ul&gt;</code> 元素可以嵌套在另一个 <code>&lt;ul&gt;</code> 或有序列表 <code>&lt;ol&gt;</code> 中，以创建多层级的列表。</li>
</ol>
<blockquote>
<p>ul理解为容器，像是状li的罐子</p>
</blockquote>
<p><code>&lt;li&gt;</code> 标签的特点：</p>
<ol>
<li>列表项：<code>&lt;li&gt;</code> 表示列表中的每个项目或条目。每个 <code>&lt;li&gt;</code> 标签通常包裹在 <code>&lt;ul&gt;</code> 或 <code>&lt;ol&gt;</code> 标签中。</li>
<li>顺序无关：<code>&lt;li&gt;</code> 列表项的排列顺序与其在代码中的位置无关，它们将按照显示时的顺序呈现。</li>
<li>嵌套列表项：<code>&lt;li&gt;</code> 列表项可以包含嵌套的列表，创建层级结构的子列表。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.构造一个简单无序列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>321<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>321<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517222930214.png" alt="image-20230517222930214"></p>
<h4 id="ol和li"><a href="#ol和li" class="headerlink" title="ol和li"></a>ol和li</h4><p>在HTML中，<code>&lt;ol&gt;</code>和<code>&lt;li&gt;</code>标签通常一起使用来创建有序列表。</p>
<p><code>&lt;ol&gt;</code>标签表示有序列表，具有以下特点：</p>
<ul>
<li>有序列表中的项目通常按照顺序进行编号，可以是数字、字母或罗马数字。</li>
<li><code>&lt;ol&gt;</code>标签创建一个包含多个列表项的块级元素。</li>
<li>有序列表项的默认样式是按照顺序编号显示。</li>
</ul>
<p><code>&lt;li&gt;</code>标签用于定义列表项，它的特点包括：</p>
<ul>
<li><code>&lt;li&gt;</code>标签包裹在<code>&lt;ol&gt;</code>或<code>&lt;ul&gt;</code>标签内部，表示一个列表项。</li>
<li>列表项可以包含文本、图像、链接或其他HTML元素。</li>
<li>列表项默认以项目符号或顺序编号显示，但可以通过CSS样式进行自定义。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1.构造一个简单无序列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>321<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>123<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>321<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2.构造一个简单有序列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230517223129645.png" alt="image-20230517223129645"></p>
<h4 id="div标签"><a href="#div标签" class="headerlink" title="div标签"></a>div标签</h4><div>标签是HTML中用于定义一个文档的区域或容器的元素。它具有以下特点：

<ol>
<li><p>区域划分：div标签可以用来将HTML文档划分为不同的区域或块。通过使用<div>标签，可以将页面的不同部分进行逻辑上的分组，从而方便样式和布局的控制。</p>
</li>
<li><p>块级元素：div标签是一个块级元素，它在页面中独占一行。这意味着它会自动换行，并且可以设置宽度、高度、内边距和外边距等属性。</p>
</li>
<li><p>无语义性：div标签本身没有特定的语义含义，它只是一个通用的容器。它不会给其中的内容赋予特定的含义，而是依赖于CSS样式和嵌套的内容来定义其作用和意义。</p>
</li>
<li><p>可嵌套性：div标签可以嵌套在其他HTML元素中，也可以包含其他HTML元素，包括文本、图像、链接等。这使得它成为构建复杂页面结构和布局的重要工具。</p>
</li>
<li><p>样式控制：通过为<div>标签添加CSS类或ID，可以对其应用样式规则。这使得开发者可以通过定义相应的CSS样式，实现对<div>元素及其内容的外观和布局的定制。</p>
<blockquote>
<p>要修改<code>&lt;div&gt;</code>元素的大小，可以使用CSS样式来控制其宽度和高度。有几种常见的方法可以实现这一点：</p>
<ol>
<li>使用CSS的<code>width</code>和<code>height</code>属性：通过设置<code>width</code>属性来定义<code>&lt;div&gt;</code>元素的宽度，使用<code>height</code>属性来定义其高度。可以使用像素（px）、百分比（%）或其他支持的单位来指定具体的数值。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cssCopy code<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.my-div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  <img src="/2023/04/30/Web/image-20230518215731263.png" alt="image-20230518215731263"></p>
<ol start="2">
<li>使用CSS的<code>max-width</code>和<code>max-height</code>属性：这些属性允许指定元素的最大宽度和最大高度，如果内容不足以填满指定的尺寸，则元素的大小会自动调整。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cssCopy code<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.my-div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">max-width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">max-height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>  <img src="/2023/04/30/Web/image-20230518215751511.png" alt="image-20230518215751511"></p>
<ol start="3">
<li>使用CSS的<code>min-width</code>和<code>min-height</code>属性：这些属性允许指定元素的最小宽度和最小高度，确保元素不会小于指定的尺寸。</li>
</ol>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">cssCopy code<span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.my-div</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">min-height</span>: <span class="number">150px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my-div&quot;</span>&gt;</span>这是一个<span class="tag">&lt;<span class="name">div</span>&gt;</span>元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="/2023/04/30/Web/image-20230518220351244.png" alt="image-20230518220351244"></p>
<p>怎么修改都不会小于40px</p>
</blockquote>
<p>这些是常见的方法，可以根据具体的需求和情况选择适合的方式来修改<code>&lt;div&gt;</code>元素的大小。</p>
<blockquote>
<p>注：可以在浏览器中，按f12进入调试，这样就可以调整数据来看盒子大小了。</p>
<p><img src="/2023/04/30/Web/image-20230518220007950.png" alt="image-20230518220007950"></p>
</blockquote>
</blockquote>
</li>
</ol>
<p>总之，div标签是HTML中的一个通用容器元素，用于划分页面区域和组织内容，它的特点包括块级元素、无语义性、可嵌套性和样式控制。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- css样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.my_div</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 设置我们盒子的高度 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 修改第二个样式 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.my_div2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 自动变形的盒子 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">max-width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">max-height</span>: <span class="number">400px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.my_div3</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">min-width</span>: <span class="number">30px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">min-height</span>: <span class="number">40px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>div盒子样式1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 类选择器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my_div&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1.可以装其他标签 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个结构是什么1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>div盒子样式2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my_div2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个结构是什么2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>div盒子演示3<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;my_div3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>这个结构是什么3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="容器标签"><a href="#容器标签" class="headerlink" title="容器标签"></a>容器标签</h3><h4 id="span标签"><a href="#span标签" class="headerlink" title="span标签"></a>span标签</h4><p><code>&lt;span&gt;</code>标签是HTML中的一个内联元素，它用于对文本进行分组或标记，而不会对文本添加额外的语义或影响文档的结构。下面是<code>&lt;span&gt;</code>标签的几个特点：</p>
<ol>
<li><p>内联元素：<code>&lt;span&gt;</code>是内联元素，与其他内联元素（如<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>等）类似。它不会在文档中创建新的块级盒子，而是将其内容作为行内元素嵌入到文本中。</p>
<blockquote>
<p>内联元素（Inline Element）是HTML中的一种元素类型，它用于表示文档中的内联内容，这些内容通常嵌套在块级元素内部或直接位于文本流中。与块级元素不同，内联元素不会创建独立的块，并且它们在文档中水平排列，不会强制换行。</p>
<p>以下是内联元素的特点：</p>
<ol>
<li>水平排列：内联元素默认以水平方向排列，相邻的内联元素会在同一行上显示。</li>
<li>不独占一行：内联元素不会强制换行，除非遇到换行符或父元素的宽度不足以容纳内联内容。</li>
<li>无法设置宽度和高度：内联元素的宽度和高度通常由其内容决定，无法直接通过CSS属性设置固定的宽度和高度。</li>
<li>可以与其他内联元素共享水平空间：内联元素会根据其内容的大小动态分配水平空间，并且可以与其他内联元素共享同一行的空间。</li>
<li>支持部分CSS属性：内联元素支持一部分CSS属性，如颜色、字体大小、字体样式等，可以通过CSS样式对其进行样式调整。</li>
</ol>
<p>一些常见的内联元素包括<code>&lt;span&gt;</code>、<code>&lt;a&gt;</code>、<code>&lt;strong&gt;</code>、<code>&lt;em&gt;</code>、<code>&lt;i&gt;</code>等。需要注意的是，并非所有元素都是内联元素，还有块级元素和行内块元素等不同类型的元素，它们具有不同的布局和行为特点。</p>
<p>使用内联元素可以方便地对文本或行内内容进行标记、样式化和操作，从而实现更灵活的页面设计和排版效果。</p>
<p><strong>可以理解为，内联标签是一个括号，可以将文本的一段括号起来，以便我们单独对这个括号执行修饰。^-^</strong></p>
</blockquote>
</li>
<li><p>无语义：<code>&lt;span&gt;</code>标签本身没有特定的语义含义。它主要用于通过CSS样式或JavaScript脚本来对文本进行分组、标记或添加样式。</p>
</li>
<li><p>文本容器：<code>&lt;span&gt;</code>可以包裹文本内容，使得可以对其中的文本进行样式或操作。它通常用于设置特定文本的样式，如颜色、字体大小、字体样式等。</p>
</li>
<li><p>嵌套使用：<code>&lt;span&gt;</code>标签可以嵌套在其他元素内部，以便于对特定部分进行样式控制。通过嵌套使用<code>&lt;span&gt;</code>，可以对文档进行更精细的标记和样式调整。</p>
<blockquote>
<p><code>&lt;span&gt;</code>标签是HTML中的一个内联元素，它没有特定的语义含义，主要用于对文本或行内内容进行分组、标记或样式化。下面是<code>&lt;span&gt;</code>标签的几个常见的用途：</p>
<p>文本标记：<code>&lt;span&gt;</code>标签可以用来标记文本的特定部分，以便后续通过CSS或JavaScript对其进行样式或操作。例如，可以给某个词语、短语或字符添加特定的样式或行为。</p>
<p><img src="/2023/04/30/Web/image-20230521194049707.png" alt="image-20230521194049707"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span>文本的示例。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>样式控制：<code>&lt;span&gt;</code>标签可以用来包裹需要进行样式控制的文本或行内内容。通过为<code>&lt;span&gt;</code>标签添加CSS类或内联样式，可以对其内部的内容应用特定的样式属性，如颜色、字体大小、字体样式等。</p>
<p><img src="/2023/04/30/Web/image-20230521194102324.png" alt="image-20230521194102324"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-weight: bold;&quot;</span>&gt;</span>红色粗体<span class="tag">&lt;/<span class="name">span</span>&gt;</span>文本的示例。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JavaScript操作：<code>&lt;span&gt;</code>标签可以用作JavaScript操作的目标元素。通过为<code>&lt;span&gt;</code>标签添加标识符或事件处理程序，可以对其进行动态操作或交互效果。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>点击这个<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;clickable-text&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;你点击了文本！&#x27;)&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>可以触发一个弹窗。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230521194231941.png" alt="image-20230521194231941"></p>
<p>文本分组：<code>&lt;span&gt;</code>标签可以用于将文本或行内内容进行逻辑上的分组。通过使用<code>&lt;span&gt;</code>标签，可以在文本中划分多个区块，从而方便对这些区块进行整体样式或操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;group1&quot;</span>&gt;</span>第一组<span class="tag">&lt;/<span class="name">span</span>&gt;</span>和<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;group2&quot;</span>&gt;</span>第二组<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230521194421688.png" alt="image-20230521194421688"></p>
<p>需要注意的是，<code>&lt;span&gt;</code>标签本身不会对文档结构产生显著影响，它主要用于样式和操作层面的处理。使用<code>&lt;span&gt;</code>标签需要结合CSS或JavaScript来实现相应的效果和功能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行这个修饰style会显示字体颜色 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.highlight</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-weight</span>: bold;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.group1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.group2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 运行这个函数的时候会弹出警告框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">myFunction</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//警告提示行</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;Hello, World!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>span标签的用法<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- span就是在文本中圈出一块区域，对这个区域可以用其他的例如css和js来操控这个圈出区域的文本样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>突出显示<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用span标签赋予文字属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点击这里<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 段落之间会有合适间距，不用换 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;highlight&quot;</span>&gt;</span>高亮<span class="tag">&lt;/<span class="name">span</span>&gt;</span>文本的示例。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red; font-weight: bold;&quot;</span>&gt;</span>红色粗体<span class="tag">&lt;/<span class="name">span</span>&gt;</span>文本的示例。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>点击这个<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;clickable-text&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;你点击了文本！&#x27;)&quot;</span>&gt;</span>文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>可以触发一个弹窗。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;group1&quot;</span>&gt;</span>第一组<span class="tag">&lt;/<span class="name">span</span>&gt;</span>和<span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;group2&quot;</span>&gt;</span>第二组<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230521194453684.png" alt="image-20230521194453684"></p>
</blockquote>
</li>
</ol>
<p>下面是一个示例，展示了如何使用<code>&lt;span&gt;</code>标签为文本添加样式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">htmlCopy code</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一段包含<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;color: red;&quot;</span>&gt;</span>红色文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>和<span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;font-weight: bold;&quot;</span>&gt;</span>粗体文本<span class="tag">&lt;/<span class="name">span</span>&gt;</span>的示例。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>&lt;span&gt;</code>标签用于分别标记红色文本和粗体文本，并通过内联样式来指定它们的样式属性。</p>
<p>总结而言，<code>&lt;span&gt;</code>标签是一个非常通用的标签，用于对文本进行包装和样式控制。它在HTML文档中提供了灵活的文本处理能力，可用于各种定制和设计需求。</p>
<h4 id="table标签"><a href="#table标签" class="headerlink" title="table标签*"></a>table标签*</h4><p><code>&lt;table&gt;</code>标签是HTML中用于创建表格的元素。下面是<code>&lt;table&gt;</code>标签的一些特点：</p>
<ol>
<li><p>表格结构：<code>&lt;table&gt;</code>标签用于创建表格结构，它可以包含一个或多个行（<code>&lt;tr&gt;</code>标签），每行可以包含一个或多个单元格（<code>&lt;td&gt;</code>标签或<code>&lt;th&gt;</code>标签）。通过使用<code>&lt;table&gt;</code>标签及其相关标签，可以实现复杂的表格布局。</p>
<blockquote>
<p>可以将table分为三个部分，第一个部分是表头thead，另一个部分是表体tbody.最后一个是这个表的名称caption<br>在thead中，行修饰标tr是不变的，但是在内部我们要编写行的标题，也就是首行。内部标签变为th</p>
<p>在tbody中，行修饰标tr是不变的，内部标签变为td</p>
<p>在table中可以加入caption作为表的标题</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用css样式设置边框 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.table_1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 边框合并 - 相邻有相同的元素就会合并在一起 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-collapse</span>: collapse;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="comment">/* 可以用table父类引用子类别 */</span></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.table_1</span> <span class="selector-tag">th</span>,</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.table_1</span> <span class="selector-tag">td</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* 设置边框样式 */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">border</span>: <span class="number">1px</span> solid black</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>表修饰1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">&quot;table_1&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 表标题 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 首列标题 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>数学<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>语文<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>英语<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 第一行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>90<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>85<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>92<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 第二行 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>88<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>92<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">td</span>&gt;</span>87<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/30/Web/image-20230522140911732.png" alt="image-20230522140911732"></p>
</blockquote>
</li>
<li><p>行和列：表格由行和列组成。每个行使用<code>&lt;tr&gt;</code>标签表示，而每个单元格使用<code>&lt;td&gt;</code>标签表示。在表头部分，可以使用<code>&lt;th&gt;</code>标签表示表头单元格，用于标识列的标题或表格的相关信息。</p>
</li>
<li><p>单元格合并：通过使用<code>colspan</code>和<code>rowspan</code>属性，可以将单元格进行合并，从而跨越多个行或多个列。这使得可以创建具有复杂布局的表格。</p>
</li>
<li><p>表格标题和描述：可以使用<code>&lt;caption&gt;</code>标签为表格添加标题，用于描述表格的内容或目的。同时，可以使用<code>&lt;thead&gt;</code>、<code>&lt;tbody&gt;</code>和<code>&lt;tfoot&gt;</code>标签对表格内容进行分组，以提高可读性和语义性。</p>
</li>
<li><p>表格样式和格式：通过CSS可以对表格进行样式和格式化，如设置边框、背景色、字体样式等。使用CSS，还可以实现表格的响应式布局，以适应不同的屏幕尺寸和设备。</p>
</li>
<li><p>无障碍性支持：表格元素提供了一些属性和技术，以支持无障碍访问。例如，可以使用<code>scope</code>属性来指定表格单元格的作用范围，或者使用<code>headers</code>属性来建立单元格与表头之间的关联。</p>
</li>
</ol>
<p>需要注意的是，使用表格时应谨慎考虑其语义和结构，以确保表格的正确使用和可访问性。对于非表格数据或纯粹的布局需求，应该使用CSS布局技术而不是滥用表格元素。</p>
<p>总结而言，<code>&lt;table&gt;</code>标签是用于创建表格的HTML元素，它提供了创建、布局和样式化表格的功能。表格可以具有复杂的结构和样式，适用于展示和组织数据。</p>
<h4 id="from标签"><a href="#from标签" class="headerlink" title="from标签"></a>from标签</h4><p>表单（form）标签是HTML中用于创建用户交互表单的元素。下面是表单标签的一些特点：</p>
<ol>
<li>用户输入收集：表单标签用于创建包含用户输入字段的交互式表单，如文本输入框、复选框、单选按钮、下拉列表等。用户可以在表单中填写信息或选择选项。</li>
<li>数据提交：通过表单，用户可以将填写的数据提交到服务器或指定的处理程序进行处理。表单可以使用<code>&lt;form&gt;</code>标签指定提交方法（GET或POST）和目标URL。</li>
<li>表单字段：表单标签提供了一系列用于收集用户数据的字段标签，如<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等。这些标签可以设置不同类型的输入控件，以满足不同的数据输入需求。</li>
<li>表单控件组织：表单标签可以包含多个表单字段，通过在<code>&lt;form&gt;</code>标签内嵌套其他表单字段标签，可以组织和布局表单内容。</li>
<li>提交按钮：通过添加<code>&lt;input type=&quot;submit&quot;&gt;</code>或<code>&lt;button type=&quot;submit&quot;&gt;</code>标签，可以在表单中添加提交按钮，以便用户点击提交表单数据。</li>
<li>表单验证：HTML5提供了表单验证功能，可以通过设置表单字段的属性来进行客户端验证，如必填字段、最小长度、数据类型等。还可以使用JavaScript进行自定义的表单验证。</li>
<li>表单样式和布局：通过使用CSS，可以对表单进行样式化和布局控制，如设置字段的尺寸、背景色、边框样式等。使用CSS框架和技术，可以实现响应式表单布局。</li>
<li>安全性考虑：在处理敏感信息的表单时，应考虑使用安全传输协议（如HTTPS）以保护数据的安全性。</li>
</ol>
<p>需要注意的是，表单只是提供了前端的数据收集和提交机制，实际的数据处理和验证通常需要与后端服务器端编程语言（如PHP、Java、Python等）结合使用。</p>
<p>总结而言，表单标签用于创建用户交互表单，收集用户数据并提交到服务器进行处理。它提供了丰富的表单字段选项和验证功能，可通过CSS进行样式和布局控制。使用表单可以实现各种用户输入场景，如注册表单、登录表单、调查问卷等。</p>
<h3 id="小标签"><a href="#小标签" class="headerlink" title="小标签"></a>小标签</h3><h4 id="br标签"><a href="#br标签" class="headerlink" title="br标签"></a>br标签</h4><p><code>&lt;br&gt;</code>标签是HTML中用于创建换行的元素，它具有以下特点：</p>
<ol>
<li>换行功能：<code>&lt;br&gt;</code>标签用于在文本或行内内容中创建一个显式的换行。当浏览器遇到<code>&lt;br&gt;</code>标签时，会将文本或行内内容的换行位置断开，并在该位置插入一个换行符。</li>
<li>单标签：<code>&lt;br&gt;</code>标签是一个单标签，不需要闭合标签。它没有内容，只是一个用于表示换行的标记。</li>
<li>内联元素：<code>&lt;br&gt;</code>标签是内联元素（inline element），在默认情况下不会产生块级元素的换行效果。它可以在行内元素或块级元素内使用，用于插入换行符而不会创建新的块。</li>
<li>可嵌套性：<code>&lt;br&gt;</code>标签通常不会嵌套在其他标签内部，它在文本内容中直接使用，用于插入换行。</li>
<li>语义简单：<code>&lt;br&gt;</code>标签的语义非常简单明确，只表示一个显式的换行符，不会添加其他语义含义。</li>
</ol>
<p>需要注意的是，HTML中的换行通常由浏览器根据文本和元素的自然流进行处理。通常情况下，使用合适的HTML和CSS来实现布局和分隔效果，而不是过度依赖<code>&lt;br&gt;</code>标签进行换行。</p>
<p>使用<code>&lt;br&gt;</code>标签时应注意适度使用，避免滥用，以保持代码的可读性和语义化。在大多数情况下，最好使用合适的HTML元素和CSS样式来实现更灵活和语义化的布局效果。</p>
<h4 id="hr标签"><a href="#hr标签" class="headerlink" title="hr标签"></a>hr标签</h4><p><code>&lt;hr&gt;</code>标签是HTML中用于创建水平分隔线的元素，它具有以下特点：</p>
<ol>
<li>分隔线功能：<code>&lt;hr&gt;</code>标签用于在文档中创建一条水平的分隔线，可以用于将内容分隔为不同的段落或节。</li>
<li>单标签：<code>&lt;hr&gt;</code>标签是一个单标签，不需要闭合标签。它表示一个完整的水平分隔线，不包含任何内容。</li>
<li>默认样式：<code>&lt;hr&gt;</code>标签具有默认的样式属性，通常表现为一条水平线，具体的样式可以通过CSS进行自定义。</li>
<li>块级元素：<code>&lt;hr&gt;</code>标签在默认情况下是一个块级元素，会独占一行。它会创建一个与其他块级元素（如段落、标题等）相邻的分隔线。</li>
<li>可调整性：<code>&lt;hr&gt;</code>标签可以通过CSS进行样式调整，如设置颜色、宽度、边距等。通过调整样式属性，可以改变分隔线的外观和布局。</li>
<li>语义简单：<code>&lt;hr&gt;</code>标签的语义非常简单明确，只表示一个水平分隔线，不会添加其他语义含义。</li>
</ol>
<p>需要注意的是，<code>&lt;hr&gt;</code>标签在现代Web开发中的使用逐渐减少，因为分隔线的样式和布局通常可以通过CSS来实现，从而提供更大的灵活性和控制。因此，在实际应用中，最好使用合适的HTML元素和CSS样式来实现分隔线的效果，而不是依赖于<code>&lt;hr&gt;</code>标签。</p>
<p>使用<code>&lt;hr&gt;</code>标签时应注意适度使用，避免滥用，以保持代码的可读性和语义化。在大多数情况下，最好使用CSS样式来创建定制化的分隔线，以满足具体的设计和布局需求。</p>
<h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><p>CSS（层叠样式表，Cascading Style Sheets）是一种用于描述网页（HTML 或 XML 等文档）外观和样式的标记语言。它与 HTML 一起使用，通过为 HTML 元素应用样式规则，控制网页的布局、字体、颜色、大小和其他视觉方面的属性。</p>
<p>CSS 提供了一种将样式与内容分离的方法，使得开发人员可以单独管理网页的样式而无需修改 HTML 结构。通过使用 CSS，可以在不改变网页内容的情况下改变其外观和布局，从而实现更好的灵活性和可维护性。</p>
<p>CSS 使用选择器来选择要应用样式的 HTML 元素，然后使用属性和值来定义元素的样式。可以通过内联样式表、嵌入式样式表或外部样式表的方式将 CSS 应用到 HTML 文档中。</p>
<p>CSS 是 Web 开发中的重要技术之一，它使得网页设计变得更加灵活和美观，并提供了更好的用户体验。</p>
<blockquote>
<p>可以创建一个新的css样式文件，并将css和html链接。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;链接文件&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>相应的，我们要记住css常见的功能</p>
<blockquote>
<p>CSS具有许多功能和特性，用于控制和样式化网页的外观和布局。以下是CSS中常用的一些功能：</p>
<ol>
<li>选择器：CSS选择器用于选择要应用样式的HTML元素。常见的选择器包括类选择器（.class）、ID选择器（#id）、元素选择器（element）等，还有更高级的选择器如属性选择器、伪类选择器和伪元素选择器等。</li>
<li>盒子模型：CSS盒子模型描述了HTML元素的布局结构，包括内容区域、内边距、边框和外边距。通过控制盒子模型的属性（如width、height、padding、border、margin），可以实现元素的尺寸和间距的调整。</li>
<li>字体和文本样式：CSS提供了丰富的字体和文本样式属性，包括字体族（font-family）、字体大小（font-size）、字体粗细（font-weight）、行高（line-height）、文字颜色（color）等，可以用于设置元素的文本样式。</li>
<li>背景和边框：CSS提供了一系列的背景属性（如background-color、background-image、background-size）和边框属性（如border-color、border-style、border-width），用于设置元素的背景和边框样式。</li>
<li>定位和布局：CSS提供了多种定位和布局属性，如position（用于设置元素的定位方式）、display（用于设置元素的显示方式）、float（用于实现元素的浮动布局）、flexbox（用于弹性盒子布局）和grid（用于网格布局）等，可以实现灵活的页面布局。</li>
<li>动画和过渡：CSS动画和过渡属性（如animation、transition）允许在元素上创建平滑的过渡效果和动画效果，使页面更具交互性和生动性。</li>
<li>响应式设计：通过使用CSS媒体查询和响应式布局技术，可以根据设备的不同屏幕尺寸和特性，自适应地调整网页的布局和样式，以提供更好的用户体验。</li>
</ol>
<p>这只是CSS的一小部分功能，还有许多其他功能和属性可用于创建丰富的网页样式和布局。CSS的灵活性使得开发人员能够自定义和控制网页的外观和行为。</p>
</blockquote>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>CSS选择器用于选择网页中的特定元素，从而将样式应用于这些元素。它们允许您根据元素的标签名、类名、ID、属性等特征来选择元素。</p>
<p>使用CSS选择器，您可以针对不同的元素应用不同的样式，或者根据需要对一组元素进行样式化。通过选择器，您可以精确地控制网页中的元素，并根据需要调整其外观和布局。</p>
<blockquote>
<p>在选择器中，有一些常见的属性是我们要记住的。</p>
<ol>
<li><code>color</code>：用于设置文本颜色，可以使用颜色名称、十六进制值或RGB值。</li>
<li><code>background-color</code>：用于设置元素的背景颜色，同样可以使用颜色名称、十六进制值或RGB值。</li>
<li><code>font-size</code>：用于设置字体大小，可以使用像素、百分比、em等单位。</li>
<li><code>font-family</code>：用于设置字体家族，可以指定多个字体备选项。</li>
<li><code>font-weight</code>：用于设置字体粗细，可以使用关键词如<code>normal</code>、<code>bold</code>，或使用数值如<code>400</code>、<code>700</code>。</li>
<li><code>text-align</code>：用于设置文本对齐方式，可以是<code>left</code>、<code>right</code>、<code>center</code>、<code>justify</code>等。</li>
<li><code>width</code>、<code>height</code>：用于设置元素的宽度和高度，可以使用像素、百分比、em等单位。</li>
<li><code>margin</code>、<code>padding</code>：用于设置元素的外边距和内边距，可以使用像素、百分比、em等单位。</li>
<li><code>border</code>：用于设置元素的边框样式，可以指定边框宽度、边框颜色和边框样式。</li>
<li><code>display</code>：用于设置元素的显示方式，如<code>block</code>、<code>inline</code>、<code>inline-block</code>等。</li>
</ol>
</blockquote>
<p>class选择器</p>
<p>类选择器是CSS中一种常用的选择器，用于选择具有相同类名的元素并应用相应的样式。以下是类选择器的一些特点：</p>
<ol>
<li><p>选择多个元素：类选择器可以选择HTML文档中具有相同类名的多个元素，并为它们应用相同的样式。</p>
</li>
<li><p>重复使用：可以在同一个HTML文档中多次使用相同的类名，从而在不同位置和元素上应用相同的样式。</p>
</li>
<li><p>独立于元素类型：类选择器与元素类型无关，可以应用于任意HTML元素，如 <code>&lt;div&gt;</code>、<code>&lt;p&gt;</code>、<code>&lt;span&gt;</code> 等等。</p>
</li>
<li><p>可组合：可以将类选择器与其他选择器组合使用，以更精确地选择和样式化元素。例如，结合标签选择器和类选择器可以选择特定类型的元素中具有特定类名的元素。</p>
</li>
<li><p>优先级较低：类选择器的优先级相对较低，如果与其他选择器具有相同的特定性（specificity），其他选择器的样式可能会覆盖类选择器的样式。</p>
</li>
<li><p>可重复使用性和可维护性：通过使用类选择器，可以在多个元素上应用相同的样式，并且可以在整个网站上重复使用相同的类名，从而实现样式的重用和维护性。</p>
<blockquote>
<p> 类选择器的使用十分简单，在标签内部加入类名称，就可以对这个标签进行操作了。如果想要使用css，就在style样式中，用**.**操作符操作对应标签的类名就行。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css_1.css&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置了类选择器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">&quot;heading&quot;</span>&gt;</span>Hello, World!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;paragraph&quot;</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 标签样式 */</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Arial, sans-serif;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="comment">/* 容器的样式 */</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.heading</span> &#123;</span><br><span class="line">    <span class="comment">/* 标题的样式 */</span></span><br><span class="line">    <span class="attribute">color</span>: aqua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.paragraph</span> &#123;</span><br><span class="line">    <span class="comment">/* 段落的样式 */</span></span><br><span class="line">    <span class="attribute">color</span>: wheat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p>id选择器</p>
<p>ID选择器在Web开发中具有以下特点：</p>
<ol>
<li><p>唯一性：每个HTML文档中的ID应该是唯一的。一个元素只能有一个ID，不能重复使用。这使得ID选择器非常适合选择具有特定标识符的单个元素。</p>
<blockquote>
<p>如果在HTML文档中违反了ID选择器的唯一性原则，即多个元素具有相同的ID，可能会导致以下问题：</p>
<ol>
<li>不可预测的行为：当多个元素具有相同的ID时，根据HTML规范，浏览器只会选择第一个具有该ID的元素作为目标元素。其他具有相同ID的元素将被忽略。这可能导致无法预测的行为，例如样式应用于错误的元素或JavaScript操作作用于错误的元素。</li>
<li>样式冲突：如果多个元素具有相同的ID并且应用了不同的样式规则，那么由于ID选择器的高优先级，只有第一个具有该ID的元素将应用正确的样式规则。其他具有相同ID的元素将无法正确显示所期望的样式。</li>
<li>JavaScript操作错误：如果在JavaScript中使用了重复的ID，并且依赖于通过ID选择器获取元素或处理元素的特定行为，将会出现问题。JavaScript操作可能应用于错误的元素或无法正常工作。</li>
</ol>
<p>总之，违反ID选择器的唯一性原则会引发不可预测的行为、样式冲突和JavaScript操作错误。为了避免这些问题，应确保在HTML文档中每个ID都是唯一的，并合理使用其他选择器来选择多个元素。</p>
</blockquote>
</li>
<li><p>高优先级：ID选择器的优先级非常高，比其他选择器（如类选择器、元素选择器）更具特权。当使用ID选择器选择一个元素时，它的权重比其他选择器更高，这意味着它的样式规则将覆盖其他选择器的样式规则。</p>
</li>
<li><p>快速查找：由于ID在文档中应该是唯一的，浏览器可以通过ID快速准确定位到对应的元素。因此，使用ID选择器可以提高选择元素的效率和性能。</p>
</li>
<li><p>用途广泛：ID选择器常用于为特定的元素应用唯一的样式规则或添加特定的JavaScript交互行为。通过给元素添加ID，可以方便地针对该元素进行样式设置或JavaScript操作。</p>
</li>
<li><p>不易复用：由于ID选择器的唯一性，通常不建议将ID选择器用于多个元素。如果多个元素具有相同的样式或行为，应该使用类选择器或其他更适合的选择器。</p>
</li>
</ol>
<p>需要注意的是，在编写CSS样式时，应合理使用ID选择器，并避免过度依赖ID选择器的高优先级。合理选择合适的选择器可以使代码更具灵活性、可维护性和可复用性。</p>
<blockquote>
<p>使用方法和类选择器是一样的（基本上所有的都是一样的），只是在css中，不再使用.而是改为#</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;hlf&quot;</span>&gt;</span>djaslkhflkas<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#hlf</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>CSS中有多个用于设置元素背景的属性，包括以下常用属性：</p>
<ol>
<li><p>background-color：设置元素的背景颜色。可以使用颜色名称、十六进制值、RGB值或RGBA值来指定颜色。例如：<code>background-color: blue;</code></p>
<blockquote>
<p><img src="/2023/04/30/Web/image-20230523121833418.png" alt="image-20230523121833418"></p>
</blockquote>
</li>
<li><p>background-image：设置元素的背景图像。可以指定图像的URL路径或使用<code>url()</code>函数。例如：<code>background-image: url(&#39;image.jpg&#39;);</code></p>
</li>
<li><p>background-repeat：指定背景图像的重复方式。常见的取值有：<code>repeat</code>（默认，图像在水平和垂直方向上平铺）、<code>repeat-x</code>（只在水平方向上平铺）、<code>repeat-y</code>（只在垂直方向上平铺）、<code>no-repeat</code>（不重复）等。</p>
</li>
<li><p>background-position：指定背景图像的位置。可以使用关键字（如<code>left</code>、<code>center</code>、<code>right</code>、<code>top</code>、<code>bottom</code>）或百分比值、像素值来定位。例如：<code>background-position: center top;</code></p>
</li>
<li><p>background-size：设置背景图像的大小。可以使用关键字（如<code>auto</code>、<code>cover</code>、<code>contain</code>）或像素值、百分比值来指定大小。例如：<code>background-size: cover;</code></p>
</li>
<li><p>background-attachment：指定背景图像的滚动行为。常见的取值有：<code>scroll</code>（默认，背景图像会随着元素内容的滚动而滚动）、<code>fixed</code>（背景图像固定在视口中，不随滚动而移动）等。</p>
</li>
<li><p>background-origin：指定背景图像的定位起点。常见的取值有：<code>padding-box</code>（背景图像相对于内边距框定位）、<code>border-box</code>（背景图像相对于边框框定位）、<code>content-box</code>（背景图像相对于内容框定位）等。</p>
</li>
<li><p>background-clip：指定背景图像的裁剪区域。常见的取值有：<code>border-box</code>（默认，背景图像延伸到边框外沿）、<code>padding-box</code>（背景图像延伸到内边距外沿）、<code>content-box</code>（背景图像裁剪为内容框内部）等。</p>
</li>
</ol>
<p>这些属性可以单独使用或组合使用，通过设置不同的值来创建各种背景效果。</p>
<h3 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h3><p>在CSS中，可以使用边框属性来定义元素的边框样式、宽度和颜色。以下是常用的边框属性：</p>
<ol>
<li>border-width：设置边框的宽度。可以使用像素值、百分比值或预定义的关键字（如<code>thin</code>、<code>medium</code>、<code>thick</code>）来指定。例如：<code>border-width: 2px;</code></li>
<li>border-style：设置边框的样式。常见的取值有：<code>none</code>（无边框）、<code>solid</code>（实线边框）、<code>dotted</code>（点状边框）、<code>dashed</code>（虚线边框）等。例如：<code>border-style: solid;</code></li>
<li>border-color：设置边框的颜色。可以使用颜色名称、十六进制值、RGB值或RGBA值来指定颜色。例如：<code>border-color: red;</code></li>
<li>border：可以同时设置边框的宽度、样式和颜色。属性值的顺序可以是宽度、样式和颜色，也可以是样式、宽度和颜色。例如：<code>border: 2px solid red;</code></li>
<li>border-radius：设置边框的圆角半径，使边框呈现圆角效果。可以指定一个值来应用相同的圆角半径，或使用四个值分别指定每个角的圆角半径。例如：<code>border-radius: 5px;</code> 或 <code>border-radius: 5px 10px 15px 20px;</code></li>
</ol>
<p>这些边框属性可以在单独的样式规则中使用，也可以组合在一起来创建自定义的边框样式。同时，还可以使用<code>border-top</code>、<code>border-right</code>、<code>border-bottom</code>和<code>border-left</code>属性分别设置上、右、下和左边框的样式、宽度和颜色。</p>
<h3 id="盒子"><a href="#盒子" class="headerlink" title="盒子"></a>盒子</h3><p>在CSS中，盒子（Box）是用于布局和定位元素的基本单位。每个元素都被看作一个矩形盒子，具有四个边框、内边距和内容区域。以下是与CSS盒子相关的常见属性：</p>
<ol>
<li>width：设置盒子的宽度。可以使用像素值、百分比值或其他长度单位来指定。例如：<code>width: 200px;</code></li>
<li>height：设置盒子的高度。与<code>width</code>属性类似，可以使用不同的单位来指定高度。</li>
<li>padding：设置盒子的内边距。内边距是指元素内容与边框之间的空间。可以使用像素值或百分比值来指定内边距。例如：<code>padding: 10px;</code> 或 <code>padding: 10px 20px;</code>（分别表示上下内边距为10像素，左右内边距为20像素）。</li>
<li>border：设置盒子的边框样式、宽度和颜色。可以使用<code>border-width</code>、<code>border-style</code>和<code>border-color</code>属性分别指定边框的宽度、样式和颜色。例如：<code>border: 1px solid black;</code></li>
<li>margin：设置盒子的外边距。外边距是指元素与相邻元素之间的间隔。可以使用像素值或百分比值来指定外边距。例如：<code>margin: 10px;</code> 或 <code>margin: 10px 20px;</code>（分别表示上下外边距为10像素，左右外边距为20像素）。</li>
<li>box-sizing：定义元素的盒模型计算方式。常见的取值有：<code>content-box</code>（默认，宽度和高度只包括内容区域）、<code>border-box</code>（宽度和高度包括内容区域、内边距和边框）等。</li>
</ol>
<p>这些属性用于控制盒子的尺寸、内外边距和边框样式。通过合理地使用这些属性，可以实现灵活的布局和设计效果。</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题日记</title>
    <url>/2023/04/28/%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>unity</title>
    <url>/2023/08/24/unity/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划and贪心</title>
    <url>/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a><a href="https://cloud.tencent.com/developer/article/1692068">动态规划</a></h2><blockquote>
<p>只有多练才能积累，之后就变练变总结，不要写云里雾里的东西了。</p>
</blockquote>
<p>动态规划（Dynamic Programming，简称DP）是一种解决多阶段决策问题的数学优化方法和算法思想。它通常用于解决具有重叠子问题和最优子结构性质的问题，其中最优子结构指的是问题的最优解可以由其子问题的最优解组合而成，而重叠子问题指的是在问题的求解过程中，同一个子问题会被多次计算，这导致了子问题的重复求解。</p>
<p>说人话就是，在计算到我们结果的过程中，有一部分的数据我们已经算了一遍了（甚至需要多遍），我们将这些<code>重叠字</code>记录起来，可以方便我们使用。还有呢就是，我们相当于将我们结果的大问题拆开，大问题包裹着小问题，就和俄罗斯套娃一样，只有到了最开始的子问题的时候，才会一层一层往上走。</p>
<p>下面举一个例子：<strong>斐波那契（Fibonacci）数列的第n项</strong></p>
<blockquote>
<p>写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) &#x3D; 0, F(1) &#x3D; 1 F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
</blockquote>
<p>先用传统递归思想解决这道题：思路平平无奇</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Fc</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Fc</span>(n<span class="number">-1</span>)+<span class="built_in">Fc</span>(n<span class="number">-2</span>); </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">fc</span>(i)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">0</span>) = <span class="number">0</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">2</span>) = <span class="number">1</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">3</span>) = <span class="number">2</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">4</span>) = <span class="number">3</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">5</span>) = <span class="number">5</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">6</span>) = <span class="number">8</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">7</span>) = <span class="number">13</span></span><br><span class="line"><span class="built_in">F</span>(<span class="number">8</span>) = <span class="number">21</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果输入的是 8 那么所有的结果会是：</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">8</span>) = <span class="built_in">f</span>(<span class="number">7</span>) + <span class="built_in">f</span>(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">7</span>) = <span class="built_in">f</span>(<span class="number">6</span>) + <span class="built_in">f</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">6</span>) = <span class="built_in">f</span>(<span class="number">5</span>) + <span class="built_in">f</span>(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">5</span>) = <span class="built_in">f</span>(<span class="number">4</span>) + <span class="built_in">f</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">4</span>) = <span class="built_in">f</span>(<span class="number">3</span>) + <span class="built_in">f</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">3</span>) = <span class="built_in">f</span>(<span class="number">2</span>) + <span class="built_in">f</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">f</span>(<span class="number">2</span>) = <span class="built_in">f</span>(<span class="number">1</span>) + <span class="built_in">f</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了<strong>重复计算</strong>（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了<strong>又一次的重复计算</strong>，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。</p>
<p>代码中，在计算N的时候就去递归计算 <code>fib(N-1) + fib(N-2)</code>，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。</p>
<p>可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。</p>
<blockquote>
<p>参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等</p>
<p><strong>注意：</strong>递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入</p>
</blockquote>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/bkaejoe5ad.png" alt="img"></p>
<p>为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算<code>F(5)</code>的时候，会递归调用<code>F(4)</code>和<code>F(3)</code>，而在下图中，计算<code>F(4)</code>的时候，又会完整的去计算<code>F(3)</code>。这样，如果N很大的话，会有更大的时间消耗. </p>
<p>这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.</p>
<p>时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将<strong>过去计算</strong>过的节点<strong>进行保存</strong>。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效. </p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/et3sz0g04k.png" alt="img"></p>
<blockquote>
<p>时间复杂度：$O(2^N)$   —&gt; 指数级</p>
<p>空间复杂度：$O(N)$</p>
</blockquote>
<hr>
<p><strong>动态规划：</strong>我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用<strong>过去的状态</strong>以及<strong>当前状态</strong>的情况而达到一个当前的最优状态.</p>
<p><strong>规划：</strong>在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的<strong>一维表格</strong>还是复杂一点的<strong>二维表格</strong>，都是以<strong>开辟空间换时间</strong>的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.</p>
<p><strong>动态：</strong>用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.</p>
<p>因此，动态规划可以避免重复计算，达到了时间上的最优，从<code>O(2^N)</code>指数级变为<code>O(N)</code>常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.</p>
<p><strong>那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决</strong></p>
<p>依据题中的规则：</p>
<p><code>F(0) = 0, F(1) = 1</code></p>
<p><code>F(N) = F(N - 1) + F(N - 2),  when N &gt; 1</code></p>
<p>那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇</p>
<p>a. 初始化值 : <code>F(0) = 0, F(1) = 1</code></p>
<p>b. 想要计算得到<code>F(2)</code>， 那么<code>F(2) = F(0) + F(1)   --&gt;  保存 F(2)</code></p>
<p>c. 想要计算得到<code>F(3)</code>， 那么<code>F(3) = F(2) + F(1)   --&gt;  保存 F(3)</code></p>
<p>d. 想要计算得到<code>F(3)</code>， 那么<code>F(4) = F(3) + F(2)   --&gt;  保存 F(4)</code></p>
<p>利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6qd2ia8jfj.png" alt="img"></p>
<p>是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。</p>
<p>想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的</p>
<p>话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：</p>
<p>a. 初始化值 : F(0) &#x3D; 0, F(1) &#x3D; 1</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/t36rk0x8sx.png" alt="img"></p>
<p>b. 想要计算得到F(2)， 那么F(2) &#x3D; F(0) + F(1)   –&gt;  保存 F(2)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">顺带将<span class="title function_">F</span>(<span class="number">1</span>)赋值给dp1， <span class="title function_">f</span>(<span class="number">2</span>)赋值给dp2</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/y5moqglg82.png" alt="img"></p>
<p>c. 想要计算得到F(3)， 那么F(3) &#x3D; F(2) + F(1)   –&gt;  保存 F(3)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">顺带将<span class="title function_">F</span>(<span class="number">2</span>)赋值给dp1， <span class="title function_">F</span>(<span class="number">3</span>)赋值给dp2</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/nnxa1qxt39.png" alt="img"></p>
<p>d. 想要计算得到F(3)， 那么F(4) &#x3D; F(3) + F(2)   –&gt;  保存 F(4)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">顺带将<span class="title function_">F</span>(<span class="number">3</span>)赋值给dp1， <span class="title function_">F</span>(<span class="number">4</span>)赋值给dp2</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5efrj8zz5e.png" alt="img"></p>
<p>至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化</p>
<p>下面是这个程序的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fbnq</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;++i) dp[i] = dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"> 	cout&lt;&lt;<span class="built_in">fbnq</span>(n)&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>简单来说就是空间换时间，发现的细节就是每个数据都与前面两个计算的数据强关联，这样就可以得出我们<code>dp</code>数组的构造。</p>
</blockquote>
<hr>
<p>上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下</p>
<p>在后面的案例中将会尽量严格按照这几个步骤进行解决问题</p>
<blockquote>
<p>步骤一：定义<code>dp</code>数组的含义</p>
<p>步骤二：定义状态转移方程</p>
<p>步骤三：初始化过程转移的初始值</p>
<p>步骤四：可优化点(可选)</p>
</blockquote>
<p>步骤一：定义<code>dp</code>数组的含义</p>
<p>绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存<strong>从开始到当前情况的最优值</strong>，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）</p>
<p><strong>所以，<code>dp</code>无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值</strong></p>
<p>步骤二：定义状态转移方程</p>
<p>什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决</p>
<p>通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) &#x3D; F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.</p>
<p>步骤三：初始化过程转移的初始值</p>
<p>顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个<strong>支点</strong>来撬动它进行不断的计算下去。</p>
<p>那么，这个<strong>支点</strong>就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) &#x3D; 0和F(1) &#x3D; 1，有了这两个值，它的动态方程F(N) &#x3D; F(N - 1) + F(N - 2)就可以进行下去了</p>
<p>这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.</p>
<p>步骤四：可优化点(可选)</p>
<p>可优化的这里，最重要的会是<code>dp</code>数组这块，也会有不同问题不同的优化点</p>
<p>在例子中，我们会进行不同的优化. </p>
<p>总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了. </p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p>背包问题（Knapsack problem）是一种组合优化的NP完全<code>（NP-Complete，NPC）</code>问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。<code>NPC</code>问题是没有多项式时间复杂度的解法的，但是利用动态规划，我们可以以伪多项式时间复杂度求解背包问题。一般来讲，背包问题有以下几种分类：</p>
<blockquote>
<p>01背包问题</p>
<p>完全背包问题</p>
<p>多重背包问题</p>
</blockquote>
<h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a><code>01</code>背包问题</h3><p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230319202209832.png" alt="image-20230319202209832"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230319214127252.png" alt="image-20230319214127252"></p>
<p>动态规划重点的是状态转移方程:<code> 01</code>背包，代表着物品只有两种可能性 - 放和不放</p>
<p><code>f[i][j] </code>中的前i件物品放入容量为j的背包中。我们很容易可以看出，数组的第一个维度我们存储的是物品的不同种类，第二个维度存储的是我们的背包容量。</p>
<blockquote>
<p>可以这样理解，<code>f[i][j]</code>就是<code>i</code>物品放入背包容量为<code>j</code>的状态</p>
</blockquote>
<p>更新容量我们就使用：<code>max(f[i-1][j-w[i]]+c[i],f[i-1][j])</code></p>
<p>当然放入物品的时候有两种情况，我们分别判断一下：<br>     第一种：我们放入我们的i物品，那么<code>f[i][j] = f[i-1][j-w[i]]+c[i]</code>,就是这样子，我们从两个维度解释一下： 第一个维度<code>f[i-1]</code>:很简单就是我们已经选择了<code>i</code>物品了，那么从全部物品中，就少了我们的<code>i</code>，因此就是<code>i-1</code>。 第二个维度就是<code>f[j-w[i]]</code>,就是我们既然选择了<code>i</code>，那么就把我们的背包中直接塞入我们的物品，这个物品就会占据位置嗯。<br>     第二种：不放我们的i物品，就是<code>f[i][j] = f[i-1][j]</code>，不放物品我们的<code>j</code>这容量肯定就不会变化，同时，我们不放这个物品的话，就只能从别的物品选择，那就是只剩下<code>i-1</code>种物品了。</p>
<blockquote>
<p>第一种情况：选择放入第<code>i</code>个物品。在这种情况下，你需要考虑背包容量减去第<code>i</code>个物品的重量后剩余的容量<code>j - w[i]</code>，以及背包容量<code>j</code>时的最大价值<code>f[i][j]</code>等于在背包容量<code>j - w[i]</code>时的最大价值<code>f[i-1][j - w[i]]</code>加上第<code>i</code>个物品的价值<code>c[i]</code>。这表示你将第<code>i</code>个物品放入背包中，然后继续考虑前<code>i-1</code>个物品和剩余容量<code>j - w[i]</code>。</p>
<p>第二种情况：不选择放入第<code>i</code>个物品。在这种情况下，背包容量<code>j</code>时的最大价值<code>f[i][j]</code>等于在背包容量<code>j</code>时的最大价值<code>f[i-1][j]</code>。这表示你不将第<code>i</code>个物品放入背包中，继续考虑前<code>i-1</code>个物品和容量<code>j</code>。</p>
</blockquote>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230319202536339.png" alt="image-20230319202536339"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模版思想研究</span></span><br><span class="line"><span class="comment">//用二维数组来理解</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i]) <span class="comment">//先决条件：这个位置放不了i这个物品了</span></span><br><span class="line">                f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-w[i]]+c[i]); </span><br><span class="line"> cout&lt;&lt;f[n][m];</span><br></pre></td></tr></table></figure>

<hr>
<p>用二维数组来理解十分容易，但是会浪费一些容量。我们不妨使用滚动数组来构造背包问题。思路如下：</p>
<blockquote>
<ul>
<li><p>外层循环遍历每个物品<code>i</code>。</p>
</li>
<li><p>内层循环遍历背包的容量<code>j</code>。</p>
</li>
<li><p>如果当前物品的重量<code>w[i]</code>大于背包的容量<code>j</code>，表示无法将物品<code>i</code>放入背包中，因此<code>f[j]</code>的值不变，即<code>f[j] = f[j]</code>。这对应于你提到的“不放入我们的i”情况。</p>
</li>
<li><p>否则，如果<code>w[i]</code>小于或等于背包容量<code>j</code>，表示可以考虑将物品<code>i</code></p>
<p>放入背包中。在这种情况下，需要比较两种情况：</p>
<ul>
<li><code>f[j]</code>表示不放入物品<code>i</code>时的最大价值（对应于你提到的<code>f[j] = f[j]</code>情况）。</li>
<li><code>f[j-w[i]] + c[i]</code>表示放入物品<code>i</code>后的最大价值，其中<code>f[j-w[i]]</code>是在剩余容量<code>j-w[i]</code>下的最大价值，而<code>c[i]</code>是物品<code>i</code>的价值。你需要选择这两种情况中的较大值作为<code>f[j]</code>的新值，即<code>f[j] = max(f[j], f[j-w[i]] + c[i])</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230319202555236.png" alt="image-20230319202555236"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用j逆序排序</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m;j&gt;=<span class="number">1</span>;j--)</span><br><span class="line">            <span class="keyword">if</span>(j&lt;w[i]) f[j] = f[j];</span><br><span class="line">   			<span class="keyword">else</span> f[j] = <span class="built_in">max</span>(f[j],f[j-w[i]]+c[i]);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230319202608455.png" alt="image-20230319202608455"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模版</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> N, V; <span class="comment">// N表示物品个数，V表示背包容量</span></span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN]; <span class="comment">// w[i]表示第i个物品的重量，v[i]表示第i个物品的价值</span></span><br><span class="line"><span class="type">int</span> dp[MAXN]; <span class="comment">// dp[i]表示容量为i的背包所能装下的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; N &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="built_in">sizeof</span>(dp)); <span class="comment">// 初始化dp数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= w[i]; j--) &#123; <span class="comment">// 从后往前遍历，避免重复选择物品</span></span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]); <span class="comment">// 状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[V] &lt;&lt; endl; <span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320144822881.png" alt="image-20230320144822881"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320144830870.png" alt="image-20230320144830870"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320144922085.png" alt="image-20230320144922085"></p>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320175854308.png" alt="image-20230320175854308"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320175908237.png" alt="image-20230320175908237"></p>
<p>完全背包问题，就是01背包的变形，每个物品可以无限次放入。<code>f[i][j]</code>依然和01背包问题相同的，i表示的是我们物品的种类，j表示的是我们背包的容量。放入物品的时候，我们需要选择放入这个物品我们的价值是否会增加</p>
<p><strong>过程:</strong></p>
<p>背包容量放不下我们当前这个物品 条件就是<code>j&lt;w[i]</code> 所以说我们的容量还是不变<code> f[i][j] = f[i-1][j]</code>; (这也就解释了我们可以使用一维数组来维护我们的背包)，这里的<code>i-1</code>表示的是前一个物品，就是我们不会改变当前的背包状态</p>
<ul>
<li><p>当背包可以放入我们当前这个物品，条件也就是<code>j&gt;=w[i]</code>我们有两种选择 - 放入和不放入。放入的话就是  <code>f[i][j] = f[i][j-w[i]]+c[i] </code></p>
</li>
<li><p><code>c[i]</code>是我们的价值(这里的i的意思就是我们物品是无穷的，每一个i表示的意思就是取出当前i这个物品的其中一个)<br>    不放入就是<br>   <code>f[i][j] = f[i-1][j]</code>  j就不会变化</p>
</li>
<li><p>我们最终的转移方程就是 上面两个合并的结果<br>   <code>f[i][j] = f[i-1][j] (j&lt;w[i])</code><br>   <code> f[i][j] = max(f[i-1][j],f[i][j-w[i]]+c[i])</code><br>重点就是理解，变量其实是我们选不选择这个物品！！！！</p>
</li>
</ul>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320175946146.png" alt="image-20230320175946146"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320175955400.png" alt="image-20230320175955400"></p>
<p>下面是代码模版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++) <span class="comment">//这里m是容量</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(j&lt;w[i]) f[i][j] = f[i<span class="number">-1</span>][j];</span><br><span class="line">		<span class="keyword">else</span> f[i][j] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-w[i]]+c[i]); <span class="comment">//c[i]是i物品的价值</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n][m]);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320180004395.png" alt="image-20230320180004395"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320180015757.png" alt="image-20230320180015757"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320180027068.png" alt="image-20230320180027068"></p>
<p>为什么一维数组(滚动数组)适合：</p>
<blockquote>
<ul>
<li>使用动态规划算法解决完全背包问题时，可以采用一维数组进行实现。这是因为完全背包问题具有“无后效性”和“最优子结构”这两个特点。</li>
<li>无后效性指的是，当我们决定选择一个物品放入背包时，我们不需要再考虑该物品是否被选择过或未来是否还会选择该物品。也就是说，每个阶段的最优状态可以通过之前阶段的某个状态推导得到，而不受后续状态的影响。</li>
<li>最优子结构指的是，每个阶段的最优状态可以由前一个阶段的最优状态推导得到，并且每个阶段的最优状态之间没有相互制约的关系，即它们是相互独立的。</li>
</ul>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">        <span class="keyword">if</span>(j&lt;w[i]) f[j] = f[j];</span><br><span class="line"> <span class="keyword">else</span> f[j] = <span class="built_in">max</span>(f[j],f[j-w[i]]+c[i]);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320180039797.png" alt="image-20230320180039797"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320180103129.png" alt="image-20230320180103129"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全背包问题的动态规划解法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(<span class="type">int</span> W, vector&lt;<span class="type">int</span>&gt;&amp; wt, vector&lt;<span class="type">int</span>&gt;&amp; val)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = wt.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = wt[i<span class="number">-1</span>]; j &lt;= W; j++) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - wt[i<span class="number">-1</span>]] + val[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; wt = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; val = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">int</span> W = <span class="number">8</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最大价值为：&quot;</span> &lt;&lt; <span class="built_in">knapsack</span>(W, wt, val) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320182532855.png" alt="image-20230320182532855"></p>
<h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>在<code>01</code>背包的基础之上，让每一种物品都有对应的容量。只需要多加一个枚举数量的变量就行。</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320145257361.png" alt="image-20230320145257361"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145415756.png" alt="image-20230320145415756"></p>
<blockquote>
<p>需要注意的是，我们for循环枚举的是位置，而不是值。每一个位置对应的值才是我们需要注意的关键。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在01背包的基础上，让每一件物品都有他们的数量</span></span><br><span class="line"> <span class="comment">//1.v[i],w[i] 体积和价值</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="comment">//物品种类</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = m; j&gt;=v[i];j--) <span class="comment">//背包容量</span></span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-v[i]]+w[i]);</span><br><span class="line"> <span class="comment">//2.v[i],w[i],s[i]; 体积 价值 数量 </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = m;j&gt;=v[i];j--)</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++) </span><br><span class="line">                    <span class="comment">//这里的k表示的是选择物品的数量 - s[i]表示的是当前位置的i物品的数量</span></span><br><span class="line">                    f[j] = <span class="built_in">max</span>(f[j],f[j-k*v[i]]+k*w[i]);</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> v[N],w[N],s[N]; <span class="comment">//体积 价值 数量</span></span><br><span class="line"><span class="type">int</span> f[N][N]; <span class="comment">//这个是我们的状态转移数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i]&gt;&gt;s[i]; <span class="comment">//这里就是输入对应的价值，由i下标规定数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;=s[i]&amp;&amp;k*v[i]&lt;=j;k++)</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i]*k]+w[i]*k); <span class="comment">//这里i-1是把这个i物品选择了（选够了就剔除） - 只要找到一个符合的k就行（我们不管怎么实现的就行）</span></span><br><span class="line">    cout&lt;&lt;f[n][m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145513754.png" alt="image-20230320145513754"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145617888.png" alt="image-20230320145617888"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制的转化就是 - 我们不再是一个一个数了，我们现在是两个两个数的</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">1</span>;<span class="comment">//拆分计数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="comment">//v,w,s; 体积，价值，数量</span></span><br><span class="line">    cin&gt;&gt;v&gt;&gt;w&gt;&gt;s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=s;j&lt;&lt;=<span class="number">1</span>)&#123; <span class="comment">//&lt;&lt;=是左移位赋值运算符，它将左操作数向左移动右操作数指定的位数，并将结果赋值给左操作数</span></span><br><span class="line">        vv[num] = j*v; <span class="comment">//存体积</span></span><br><span class="line">        ww[num++] = j*w; <span class="comment">//存价值</span></span><br><span class="line">        s-=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s)&#123;</span><br><span class="line">        vv[num] = s*v;</span><br><span class="line">        ww[num++] = s*w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//01背包问题 - 基础</span></span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;num;i++)</span><br><span class="line">        <span class="keyword">for</span>(j = m;j&gt;=vv[i];j--)</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j],f[j-vv[i]]+ww[i]);</span><br><span class="line">cout&lt;&lt;f[m];</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1005</span>; <span class="comment">// 物品的最大数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXV = <span class="number">100005</span>; <span class="comment">// 背包的最大容量</span></span><br><span class="line"><span class="type">int</span> n, V; <span class="comment">// 物品的数量和背包的容量</span></span><br><span class="line"><span class="type">int</span> w[MAXN], v[MAXN], s[MAXN]; <span class="comment">// 分别表示物品的重量、价值和数量</span></span><br><span class="line"><span class="type">int</span> dp[MAXV]; <span class="comment">// dp[i]表示容量为i的情况下，可以获得的最大价值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制优化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">binary_optimization</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = V; j &gt;= x; j--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s[y] &amp;&amp; k * x &lt;= j; k++) &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j], dp[j - k * x] + k * y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; V;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= s[i]; j *= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">binary_optimization</span>(w[i] * j, v[i] * j); <span class="comment">// 调用二进制优化函数</span></span><br><span class="line">            s[i] -= j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">binary_optimization</span>(w[i] * s[i], v[i] * s[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; dp[V] &lt;&lt; endl; <span class="comment">// 输出答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二进制优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            <span class="comment">//这里是二进制优化的核心 - 就是将s拆成2进制</span></span><br><span class="line">            <span class="comment">//核心是将物品拆分为2的幂次方个物品</span></span><br><span class="line">            <span class="comment">//每次都拿s拆开二进制的数量</span></span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230321174757054.png" alt="image-20230321174757054"></p>
<h3 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h3><p>在01背包的基础上，增加了物品序列号。只需要将价值生成一个组的序列号就行，然后照常枚举出我们需要的值。</p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230321181451351.png" alt="image-20230321181451351"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230321181510913.png" alt="image-20230321181510913"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//朴素做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=V;j++)<span class="comment">//体积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;=s[i];k++) &#123; <span class="comment">//决策</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=v[i][k])</span><br><span class="line">                f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">                <span class="comment">//不选取i  选取i</span></span><br><span class="line">        &#125;</span><br><span class="line">cout&lt;&lt;f[n][V];</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230321181526186.png" alt="image-20230321181526186"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230321181540822.png" alt="image-20230321181540822"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分组朴素做法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=V;j++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;=s[i];k++)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="keyword">if</span>(j&gt;=v[i][k])</span><br><span class="line">    f[i][j] = <span class="built_in">max</span>(f[i][j],f[i<span class="number">-1</span>][j-v[i][k]]+w[i][k]);</span><br><span class="line">  &#125;</span><br><span class="line">cout&lt;&lt;f[n][V];</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230321181555557.png" alt="image-20230321181555557"></p>
<blockquote>
<p>应该也可以用二进制优化策略</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">12010</span>, M = <span class="number">2010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> v[N], w[N];</span><br><span class="line"><span class="type">int</span> f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b, s;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里是将s数量分二进制</span></span><br><span class="line">        <span class="keyword">while</span> (k &lt;= s)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * k;</span><br><span class="line">            w[cnt] = b * k;</span><br><span class="line">            s -= k;</span><br><span class="line">            k *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里就构造二进制数组</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            v[cnt] = a * s;</span><br><span class="line">            w[cnt] = b * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    n = cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.这里就是选择最大</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;= v[i]; j -- )</span><br><span class="line">            f[j] = <span class="built_in">max</span>(f[j], f[j - v[i]] + w[i]);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; f[m] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="混合背包问题"><a href="#混合背包问题" class="headerlink" title="混合背包问题"></a>混合背包问题</h3><p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320145732542.png" alt="image-20230320145732542"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320145752872.png" alt="image-20230320145752872"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320145806496.png" alt="image-20230320145806496"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//三个背包综合考虑</span></span><br></pre></td></tr></table></figure>

<h2 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a><a href="https://zhuanlan.zhihu.com/p/438406757">记忆化搜索</a></h2><h3 id="树塔"><a href="#树塔" class="headerlink" title="树塔"></a>树塔</h3><p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153726163.png" alt="image-20230320153726163"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153741418.png" alt="image-20230320153741418"></p>
<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320153805063.png" alt="image-20230320153805063"></p>
<h2 id="线性dp"><a href="#线性dp" class="headerlink" title="线性dp"></a><a href="https://zhuanlan.zhihu.com/p/98405912">线性dp</a></h2><h3 id="大盗阿福"><a href="#大盗阿福" class="headerlink" title="大盗阿福"></a>大盗阿福</h3><p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320151317664.png" alt="image-20230320151317664"></p>
<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230320151339739.png" alt="image-20230320151339739"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性dp</span></span><br><span class="line"> 在这个题目中，f数组存储的是我们偷取的物品价值是吧，然后我们要选择偷取价值最大化，每一个下标都代表着一个店铺是这个样子？</span><br><span class="line"><span class="comment">//写</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"> <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        </span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        f[<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用下标代表选择 - 是这个样子的</span></span><br><span class="line">        <span class="comment">//用数组存储价值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            f[i] = <span class="built_in">max</span>(f[i<span class="number">-1</span>],f[i<span class="number">-2</span>]+w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n]);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151353844.png" alt="image-20230320151353844"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用二维数组构造</span></span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line"> <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">        <span class="comment">//用第二维的数据表示选择 0不选 1选择</span></span><br><span class="line">        f[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;f[<span class="number">1</span>][<span class="number">1</span>] = w[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="comment">//不选择i</span></span><br><span class="line">            f[<span class="number">1</span>][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//选择了i这个物品</span></span><br><span class="line">            f[i][<span class="number">1</span>] = f[i<span class="number">-1</span>][<span class="number">0</span>]+w[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="built_in">max</span>(f[n][<span class="number">0</span>],f[n][<span class="number">1</span>]));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320151402877.png" alt="image-20230320151402877"></p>
<h3 id="数字三角形"><a href="#数字三角形" class="headerlink" title="数字三角形"></a>数字三角形</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字三角形</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>,INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> g[N][N],f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        cin&gt;&gt;g[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j&lt;=i+<span class="number">1</span>;j++)</span><br><span class="line">        f[i][j] = -INF;<span class="comment">//j从0开始是为了确定子树的选择</span></span><br><span class="line">    </span><br><span class="line">    f[<span class="number">1</span>][<span class="number">1</span>] = g[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">        f[i][j] = g[i][j] + <span class="built_in">max</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>],f[i<span class="number">-1</span>][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res = -INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) res = <span class="built_in">max</span>(res,f[n][i]);<span class="comment">//第n行 选择i的结果</span></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最长上升子序列-or-二分优化"><a href="#最长上升子序列-or-二分优化" class="headerlink" title="最长上升子序列 or 二分优化"></a>最长上升子序列 or 二分优化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最长上升子序列</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>; <span class="comment">// 只有a[i]一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j ++ )</span><br><span class="line">        <span class="comment">//前小于后 严格单调</span></span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">                f[i] = <span class="built_in">max</span>(f[i], f[j] + <span class="number">1</span>);<span class="comment">//连续走 or 跳着走</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) res = <span class="built_in">max</span>(res, f[i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = len;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (q[mid] &lt; a[i]) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分找目标值 更新len</span></span><br><span class="line">        len = <span class="built_in">max</span>(len, l + <span class="number">1</span>);</span><br><span class="line">        q[r + <span class="number">1</span>] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求公共子序列"><a href="#求公共子序列" class="headerlink" title="求公共子序列"></a>求公共子序列</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];<span class="comment">//一维指的是a前n个数据 - 二位指的是b前n个数据？</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, a + <span class="number">1</span>, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//f[i-1][j] 表示删除a的第i个字符后与b的前j个字符的最长公共子序列长度；</span></span><br><span class="line">     <span class="comment">//f[i][j-1] 表示删除b的第j个字符后与a的前i个字符的最长公共子序列长度；</span></span><br><span class="line">            f[i][j] = <span class="built_in">max</span>(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);<span class="comment">//符合就选择两者变化的最大值</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230326134216185.png" alt="image-20230326134216185"></p>
<h3 id="最短编辑距离"><a href="#最短编辑距离" class="headerlink" title="最短编辑距离"></a>最短编辑距离</h3><p><img src="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230326135739598.png" alt="image-20230326135739598"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> a[N], b[N];</span><br><span class="line"><span class="type">int</span> f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, a + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;m, b + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化竖和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i ++ ) f[<span class="number">0</span>][i] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++ ) f[i][<span class="number">0</span>] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            f[i][j] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][j] + <span class="number">1</span>, f[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> f[i][j] = <span class="built_in">min</span>(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[n][m]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 基础算法介绍</title>
    <url>/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础算法"><a href="#基础算法" class="headerlink" title="基础算法"></a>基础算法</h2><h2 id="时间复杂度和空间复杂度的基本估计"><a href="#时间复杂度和空间复杂度的基本估计" class="headerlink" title="时间复杂度和空间复杂度的基本估计"></a>时间复杂度和空间复杂度的基本估计</h2><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt="时间复杂度"></p>
<h2 id="基本算法思想说明"><a href="#基本算法思想说明" class="headerlink" title="基本算法思想说明"></a>基本算法思想说明</h2><p>下面简单介绍一下各种算法的思想，每个思想都会举一个例题包括一个模版，并不会太仔细。本文以算法竞赛入门指南和大佬的博客作为参考。<strong>标注：只看不练是傻蛋</strong></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a><a href="https://algo.itcharge.cn/09.Algorithm-Base/01.Enumeration-Algorithm/01.Enumeration-Algorithm/">枚举</a></h3><p><strong>枚举算法（Enumeration Algorithm）</strong>：也称为穷举算法，指的是按照问题本身的性质，一一列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。在列举的过程中，既不能遗漏也不能重复。</p>
<p>由于枚举算法要通过列举问题的所有状态来得到满足条件的解，因此，在问题规模变大时，其效率一般是比较低的。但是枚举算法也有自己特有的优点：</p>
<ol>
<li><p>多数情况下容易编程实现，也容易调试。</p>
</li>
<li><p>建立在考察大量状态、甚至是穷举所有状态的基础上，所以算法的正确性比较容易证明。</p>
<blockquote>
<p>所以，枚举算法通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法出现，通过枚举一些信息并进行保存，而这些消息的有无对主算法效率的高低有着较大影响。</p>
</blockquote>
</li>
</ol>
<p>枚举思想说直白点就是暴力解题法，将所有的情况枚举出来，取得我们需要的结果即可。但是枚举也是需要技巧的，我们在运用的时候需要控制枚举的范围，可以节省一些时间。</p>
<p>下面用一道题说明枚举算法：</p>
<p><strong>案例：<a href="https://blog.csdn.net/xinzhilinger/article/details/109266058">百鸡问题</a></strong></p>
<blockquote>
<p>有鸡翁一，值钱伍；鸡母一，值钱三；鸡鶵三，值钱一。凡百钱买鸡百只，问鸡翁、母、鶵各几何？</p>
</blockquote>
<p><strong>对本问题分析，三种鸡的数量关系满足：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">nub（公鸡）+nub（母鸡）+nub（小鸡）=<span class="number">100</span></span><br><span class="line">nub（公鸡）* <span class="number">5</span>+nub（母鸡）* <span class="number">3</span>+nub（小鸡）=<span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>按照中学的逻辑，两个方程无法求出三个变量。但在程序中，我们可以对一个变量进行约束，去改变另外两个变量的值，来达到我们求出另外两个变量的结果。下面是具体的程序。</p>
<blockquote>
<p>三个变量只有两个公式如何求解呢，这个时候只能固定一个变量，然后求另外两个变量，枚举法就是基于这样的思想，对于所有可能性进行遍历</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetC</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> n,m,k; <span class="comment">//公鸡 - 母鸡 - 小鸡 </span></span><br><span class="line"> <span class="comment">//公鸡上限20 因为 20*5 = 100 - 这里体现了枚举的有穷性</span></span><br><span class="line"> <span class="keyword">for</span>(n = <span class="number">0</span>;n&lt;=<span class="number">20</span>;n++)</span><br><span class="line"> <span class="comment">//母鸡上限33 </span></span><br><span class="line">  <span class="keyword">for</span>(m = <span class="number">0</span>;m&lt;=<span class="number">33</span>;m++)&#123;</span><br><span class="line">   k = <span class="number">100</span>-n-m;</span><br><span class="line">   <span class="comment">//有一种符合输出一种 </span></span><br><span class="line">   <span class="keyword">if</span>(n*<span class="number">15</span>+<span class="number">9</span>*m+k*<span class="number">1</span>==<span class="number">300</span>) cout&lt;&lt;n&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;k&lt;&lt;endl; </span><br><span class="line">  &#125;</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//目的求出三种鸡的个数</span></span><br><span class="line"> <span class="built_in">GetC</span>();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>枚举是没有规律的情况下来使用，所以就很难来推算什么情况来使用是合适的，不过总的来说，枚举还是适用于那些量级比较小的，循环使用痕迹比较重的情况</p>
</blockquote>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a><a href="https://juejin.cn/post/6961403096085823501">模拟</a></h3><p>说白了 模拟题就是应用题 给出一个项目让你实现它，写模拟题时，遵循以下的建议有可能会提升做题速度：</p>
<blockquote>
<p>在动手写代码之前，在草纸上尽可能地写好要实现的流程。<br>在代码中，尽量把每个部分模块化，写成函数、结构体或类。<br>对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 “YY-MM-DD 时：分” 把它抽取到一个函数，处理成秒，会减少概念混淆。<br>调试时分块调试。模块化的好处就是可以方便的单独调某一部分。<br>写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。</p>
</blockquote>
<p>下面用一道题说明模拟：</p>
<p><strong>案例：Z字形变换</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。</span><br><span class="line"></span><br><span class="line">比如输入字符串为 <span class="string">&quot;PAYPALISHIRING&quot;</span> 行数为 <span class="number">3</span> 时，排列如下：</span><br><span class="line"></span><br><span class="line">P   A   H   N</span><br><span class="line">A P L S I I G</span><br><span class="line">Y   I   R</span><br><span class="line">之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：<span class="string">&quot;PAHNAPLSIIGYIR&quot;</span>。</span><br><span class="line"></span><br><span class="line">请你实现这个将字符串进行指定行数变换的函数：</span><br><span class="line"></span><br><span class="line">string <span class="title function_">convert</span>(string s, int numRows);</span><br></pre></td></tr></table></figure>

<p>这道题目是非常典型的模拟算法题，介绍内容给到我们：输入、转变的条件、期待的结果，甚至连解题的思路都给我们提供了。不信？我们来看看：</p>
<blockquote>
<p>输入是一个字符串和一个行数，从上往下排列。</p>
<p>到了尾行时进行翻转，从左到右斜向上排列，到了顶行时再次翻转，再从上往下排列。</p>
<p>重复过程2，到了字符串尾部时，结束翻转。</p>
</blockquote>
<p>按照整理完成的思路实现代码即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只有一列 - 输出</span></span><br><span class="line">    <span class="keyword">if</span> (numRows == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">//翻转的规律</span></span><br><span class="line">    <span class="type">int</span> roundNum = <span class="number">2</span> * (numRows - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//标注当前行，flag标注移动方向</span></span><br><span class="line">    <span class="type">int</span> nowRow = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 声明一个长度为行数的字符串数组，用于存储每一行的字符</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">finalArr</span><span class="params">(numRows, <span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 当到首行时，翻转flag，从上往下排列</span></span><br><span class="line">        <span class="keyword">if</span> (i % roundNum == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当到尾行时，翻转flag，从下往上排列</span></span><br><span class="line">        <span class="keyword">if</span> (i % roundNum == numRows - <span class="number">1</span>) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">   <span class="comment">// 把对应的行的内容填充到行数组中</span></span><br><span class="line">        finalArr[nowRow] += s[i];</span><br><span class="line">        <span class="comment">// 行数根据flag进行上移或下移</span></span><br><span class="line">        nowRow = flag ? (nowRow + <span class="number">1</span>) : (nowRow - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// 将行数组中的字符串拼接后返回</span></span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> string&amp; row : finalArr) &#123;</span><br><span class="line">        result += row;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s = <span class="string">&quot;PAYPALISHIRING&quot;</span>;</span><br><span class="line">    <span class="type">int</span> numRows = <span class="number">3</span>;</span><br><span class="line">    string converted = <span class="built_in">convert</span>(s, numRows);</span><br><span class="line">    cout &lt;&lt; converted &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这里是大佬给的解释，建议直接点标题看一下大佬的解析</p>
<p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/image-20230826215420723-1693058064666-1.png" alt="image-20230826215420723"></p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a><a href="https://zhuanlan.zhihu.com/p/635141199">递归</a></h3><p>递归是一种编程技术，它通过在函数内部反复调用自身来解决问题。当一个程序调用自己时，这就称为递归调用。递归可以有助于简化某些算法的实现和理解。在递归过程中，每个调用都会将一些数据保存在栈上，直到递归结束后才能被处理并弹出栈。</p>
<p>递归通常有两个部分：基本情况和递归情况。基本情况是在函数执行之前判断是否需要递归，如果不需要，则直接返回结果。递归情况是函数需要递归时，它会调用自身，但是传入的参数通常会有所不同，以便最终能够达到基本情况而结束递归。</p>
<p>虽然递归可以使代码更加简洁，但是需要注意的是，在一些情况下，它可能会导致性能问题或者栈溢出等问题。因此，在编写递归代码时，需要仔细考虑算法的边界条件和递归深度等因素。</p>
<p><strong>递归函数</strong></p>
<p>递归函数是一种函数，它在其定义中调用自身。通常情况下，递归函数包含两个部分：基本情况和递归情况。</p>
<p>基本情况是指在递归函数中需要判断是否需要终止递归的条件。当满足这个条件时，递归就会停止。</p>
<p>递归情况是指在递归函数中需要调用自身的情况。在每次调用时，函数的参数都应该有所不同，以便最终能够达到基本情况而停止递归。</p>
<p>递归函数通常用于处理树形结构、图形结构或其他类型的嵌套结构数据。例如，在二叉树中查找某一个值，就可以使用递归函数来实现。</p>
<p>下面用一道题说明递归：</p>
<p><strong>案例：斐波那契数列</strong></p>
<p>斐波那契数列是一个经典的数学问题，由0和1开始，之后的每一项都是其前面两项的和。也就是说，斐波那契数列的前几个数是：0、1、1、2、3、5、8、13、21、34……依次类推。</p>
<p>斐波那契数列在自然界中有很多应用，比如植物的叶子排列、蜂窝的构造等等。除此之外，在计算机科学领域内，斐波那契数列也有着广泛的应用，例如在排序算法、密码学等领域。</p>
<p>斐波那契数列的通项公式是：F(n) &#x3D; F(n-1) + F(n-2)，其中F(0)&#x3D;0，F(1)&#x3D;1。根据这个公式可以使用递归函数或循环语句来实现求斐波那契数列的第n项。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现斐波那契数列</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fbnq</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fbnq</span>(n<span class="number">-1</span>)+<span class="built_in">fbnq</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a><a href="https://imzhanghao.com/2020/04/15/5-classic-algorithms-2-greedy-algorithm/">贪心</a></h3><p>运用贪心算法求解问题时，会将问题分为若干个子问题，可以将其想象成俄罗斯套娃，利用贪心的原则从内向外依次求出当前子问题的最优解，也就是该算法不会直接从整体考虑问题，而是想要达到局部最优。只有内部的子问题求得最优解，才能继续解决包含该子问题的下一个子问题，所以前一个子问题的最优解会是下一个子问题最优解的一部分，重复这个操作直到堆叠出该问题的最优解。</p>
<p>贪心算法最关键的部分在于贪心策略的选择，贪心选择的意思是对于所求问题的整体最优解可以通过一系列的局部最优选择求得。而必须注意的是，贪心选择必须具备无后效性，也就是某个状态不会影响之前求得的局部最优解。</p>
<p>运动贪心算法解决相应问题时会比较简单和高效，省去了寻找全局最优解很多不必要的穷举操作，由于贪心算法问题并没有固定的贪心策略，所以唯一的难点就是找到带求解问题的贪心策略，但毕竟熟能生巧嘛，算法的基本思想总是固定不变的。</p>
<p>下面用一道题说明贪心：</p>
<p><strong>案例：活动时间安排问题</strong></p>
<p>设有n个活动的集合<code>E=&#123;1, 2, …, n&#125;</code>，其中，每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。</p>
<p>每个活动i都有一个要求使用该资源的起始时间<code>si</code>和一个结束时间<code>fi</code>，且<code>si &lt; fi</code>。如果选择了活动i，则它在半开时间区间<code>[si, fi)</code>内占用资源。若区间<code>[si, fi)</code>与区间<code>[sj, fj)</code>不相交，则称活动i与活动j是相容的。也就是说，当 <code>si ≥ fj</code>或 <code>sj ≥ fi</code> 时，活动 i 与活动 j 相容。</p>
<p>活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。</p>
<p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%B4%BB%E5%8A%A8%E6%97%B6%E9%97%B4%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98.jpg" alt="活动时间安排问题"></p>
<p>上图为每个活动的开始和结束时间，我们的任务就是设计程序输出哪些活动可以占用会议室！</p>
<p><strong>求解思路</strong><br>将活动按照结束时间进行从小到大排序。然后用i代表第i个活动，s[i]代表第i个活动开始时间，f[i]代表第i个活动的结束时间。按照从小到大排序，挑选出结束时间尽量早的活动，并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。事实上系统一次检查活动i是否与当前已选择的所有活动相容。若相容活动i加入已选择活动的集合中，否则，不选择活动i，而继续下一活动与集合A中活动的相容性。若活动i与之相容，则i成为最近加入集合A的活动，并取代活动j的位置。</p>
<p>下面给出求解活动安排问题的贪心算法，各活动的起始时间和结束时间存储于数组s和f中，且按结束时间的非减序排列。如果所给的活动未按此序排列，可以用O(nlogn)的时间重排。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GreedyChoose</span><span class="params">(<span class="type">int</span> len,<span class="type">int</span> *s,<span class="type">int</span> *f,<span class="type">bool</span> *flag)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s[<span class="number">11</span>] =&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">12</span>&#125;;</span><br><span class="line">  <span class="type">int</span> f[<span class="number">11</span>] =&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> mark[<span class="number">11</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">GreedyChoose</span>(<span class="number">11</span>,s,f,mark);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">11</span>;i++)</span><br><span class="line">    <span class="keyword">if</span> (mark[i])</span><br><span class="line">      cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GreedyChoose</span><span class="params">(<span class="type">int</span> len,<span class="type">int</span> *s,<span class="type">int</span> *f,<span class="type">bool</span> *flag)</span> </span>&#123;</span><br><span class="line">  flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i)</span><br><span class="line">    <span class="keyword">if</span> (s[i] &gt;= f[j]) &#123;</span><br><span class="line">      flag[i] = <span class="literal">true</span>;</span><br><span class="line">      j = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a><a href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">排序</a></h3><h4 id="排序的时间复杂度分析"><a href="#排序的时间复杂度分析" class="headerlink" title="排序的时间复杂度分析"></a>排序的时间复杂度分析</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/sort.png" alt="sort"></p>
<p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E6%8E%92%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%AF%94%E8%BE%83.png" alt="排序数据比较"></p>
<h4 id="冒泡排序操作"><a href="#冒泡排序操作" class="headerlink" title="冒泡排序操作"></a>冒泡排序操作</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.gif" alt="冒泡排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*冒泡排序</span></span><br><span class="line"><span class="comment"> 冒泡排序的时间复杂度是 o(n^2),这个复杂度是由冒泡排序的操作约束的。冒泡排序的原理是，选择我们序列中的一个值，对其进行这样的操作：</span></span><br><span class="line"><span class="comment"> -将当前这个值和下一个数据对比，如果当前这个值大于下一个数据，交换；否则，下一个值作为新的交换值代替之前的值执行交换程序。直到最后，没有数据进行比对，退出程序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 菜鸟 - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//代码    </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(&gt;)运算符</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">                                <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> arr[] = &#123; <span class="number">61</span>, <span class="number">17</span>, <span class="number">29</span>, <span class="number">22</span>, <span class="number">34</span>, <span class="number">60</span>, <span class="number">72</span>, <span class="number">21</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">62</span> &#125;;</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arr, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="type">float</span> arrf[] = &#123; <span class="number">17.5</span>, <span class="number">19.1</span>, <span class="number">0.6</span>, <span class="number">1.9</span>, <span class="number">10.5</span>, <span class="number">12.4</span>, <span class="number">3.8</span>, <span class="number">19.7</span>, <span class="number">1.5</span>, <span class="number">25.4</span>, <span class="number">28.6</span>, <span class="number">4.4</span>, <span class="number">23.8</span>, <span class="number">5.4</span> &#125;;</span><br><span class="line">        len = (<span class="type">float</span>) <span class="built_in">sizeof</span>(arrf) / <span class="built_in">sizeof</span>(*arrf);</span><br><span class="line">        <span class="built_in">bubble_sort</span>(arrf, len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                cout &lt;&lt; arrf[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<h4 id="选择排序操作"><a href="#选择排序操作" class="headerlink" title="选择排序操作"></a>选择排序操作</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/selectionSort.gif" alt="选择排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序的时间复杂度是o(n^2) - 是因为选择排序需要进行 n-1 轮比较，每轮比较需要比较 n-i 次，所以总共需要比较 (n-1) + (n-2) + … + 1 = n(n-1)/2 次，因此时间复杂度为 O(n²)。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。就是每次选中一个未排序序列的起点，然后在未排序序列中，找到一个“最小值”直到遍历完区间之后，将其标记未排序序列（区间缩小），重复直到全为排序区间，退出程序。*/</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">//整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（&gt;）的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(std::vector&lt;T&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                <span class="type">int</span> min = i;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++)</span><br><span class="line">                        <span class="keyword">if</span> (arr[j] &lt; arr[min])</span><br><span class="line">                                min = j;</span><br><span class="line">                std::<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>

<h4 id="插入排序操作"><a href="#插入排序操作" class="headerlink" title="插入排序操作"></a>插入排序操作</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/insertionSort.gif" alt="插入排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序的复杂度是 o(n^2) 每一个数据最多要比较（n-1)次，所以说n*(n-1) = n^2</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</span></span><br><span class="line"><span class="comment"> 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。*/</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//和打扑克牌是一个道理，开始的时候我们只有一张牌（假设），我们将这张牌当做一个有序序列，每次加入新的牌的时候和有序序列进行比较插入，按照插入的规则（从小到大 还是 从大到小）进行判断插入。（感觉就是和选择排序是相反的，从无序中抽数据和有序序列进行比对）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="type">int</span> key=arr[i];</span><br><span class="line">                <span class="type">int</span> j=i<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>((j&gt;=<span class="number">0</span>) &amp;&amp; (key&lt;arr[j]))&#123;</span><br><span class="line">                        arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">                        j--;</span><br><span class="line">                &#125;</span><br><span class="line">                arr[j+<span class="number">1</span>]=key;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="希尔排序操作"><a href="#希尔排序操作" class="headerlink" title="希尔排序操作"></a><a href="https://blog.csdn.net/qq_43473694/article/details/112197066">希尔排序操作</a></h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/Sorting_shellsort_anim.gif" alt="希尔排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//希尔排序的时间复杂度是：O(n^1.3） 在最坏情况之下是o(n^2) - 因为是基于插入排序</span></span><br><span class="line"> <span class="comment">/*希尔排序：先追求部分元素有序，然后逼近全局有序！希尔排序是基于插入排序的以下两点性质而提出改进方法的：</span></span><br><span class="line"><span class="comment"> - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</span></span><br><span class="line"><span class="comment"> - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</span></span><br><span class="line"><span class="comment"> 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。*/</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shell_sort</span><span class="params">(T array[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; length / <span class="number">3</span>) &#123;</span><br><span class="line">        h = <span class="number">3</span> * h + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = h; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt;= h &amp;&amp; array[j] &lt; array[j - h]; j -= h) &#123;</span><br><span class="line">                std::<span class="built_in">swap</span>(array[j], array[j - h]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/mergeSort.gif" alt="归并排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 归并排序的时间复杂度是 o(log n),归并排序的算法思想是：分治法。 将大问题分解成许多的子问题，在将子问题合并成为我们的大问题</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 实现方法:</span></span><br><span class="line"><span class="comment">自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）自下而上的迭代</span></span><br><span class="line"><span class="comment">申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 整數或浮點數皆可使用,若要使用物件(class)時必須設定&quot;小於&quot;(&lt;)的運算子功能</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(T arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    T *a = arr;</span><br><span class="line">    T *b = <span class="keyword">new</span> T[len];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> seg = <span class="number">1</span>; seg &lt; len; seg += seg) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> start = <span class="number">0</span>; start &lt; len; start += seg + seg) &#123;</span><br><span class="line">            <span class="type">int</span> low = start, mid = <span class="built_in">min</span>(start + seg, len), high = <span class="built_in">min</span>(start + seg + seg, len);</span><br><span class="line">            <span class="type">int</span> k = low;</span><br><span class="line">            <span class="type">int</span> start1 = low, end1 = mid;</span><br><span class="line">            <span class="type">int</span> start2 = mid, end2 = high;</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1 &amp;&amp; start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start1] &lt; a[start2] ? a[start1++] : a[start2++];</span><br><span class="line">            <span class="keyword">while</span> (start1 &lt; end1)</span><br><span class="line">                b[k++] = a[start1++];</span><br><span class="line">            <span class="keyword">while</span> (start2 &lt; end2)</span><br><span class="line">                b[k++] = a[start2++];</span><br><span class="line">        &#125;</span><br><span class="line">        T *temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a != arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            b[i] = a[i];</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/quickSort.gif" alt="快速排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序的时间复杂度是o(nlog n),一般而言是比其他nlogn排序是要快的</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/*从数列中挑出一个元素，称为 &quot;基准&quot;（pivot）;</span></span><br><span class="line"><span class="comment"> 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，&quot;该基准就处于数列的中间位置&quot;。这个称为分区（partition）操作；</span></span><br><span class="line"><span class="comment">    递归（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//就是由基准分成两部分，再由两部分的基准分成另外两部分，以此类推。 - 直到所有部分都符合基准，即可退出。</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//代码        </span></span><br><span class="line"><span class="comment">//严蔚敏《数据结构》标准分割函数</span></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">Paritition1</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> pivot = A[low];</span><br><span class="line">   <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[high] &gt;= pivot) &#123;</span><br><span class="line">       --high;</span><br><span class="line">     &#125;</span><br><span class="line">     A[low] = A[high];</span><br><span class="line">     <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= pivot) &#123;</span><br><span class="line">       ++low;</span><br><span class="line">     &#125;</span><br><span class="line">     A[high] = A[low];</span><br><span class="line">   &#125;</span><br><span class="line">   A[low] = pivot;</span><br><span class="line">   <span class="keyword">return</span> low;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> <span class="comment">//快排母函数</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">     <span class="type">int</span> pivot = <span class="built_in">Paritition1</span>(A, low, high);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, low, pivot - <span class="number">1</span>);</span><br><span class="line">     <span class="built_in">QuickSort</span>(A, pivot + <span class="number">1</span>, high);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/heapSort.gif" alt="堆排序"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif" alt="堆排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//堆排序 - 是利用数据结构中的堆的性质设计的算法，它的时间复杂度是o(nlogn)</span></span><br><span class="line"><span class="comment"> 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</span></span><br><span class="line"><span class="comment"> 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</span></span><br><span class="line"><span class="comment">//算法步骤</span></span><br><span class="line"><span class="comment"> 创建一个堆 H[0……n-1]；</span></span><br><span class="line"><span class="comment"> 把堆首（最大值）和堆尾互换；</span></span><br><span class="line"><span class="comment"> 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</span></span><br><span class="line"><span class="comment"> 重复步骤 2，直到堆的尺寸为 1。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">max_heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 建立父節點指標和子節點指標</span></span><br><span class="line">    <span class="type">int</span> dad = start;</span><br><span class="line">    <span class="type">int</span> son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (son &lt;= end) &#123; <span class="comment">// 若子節點指標在範圍內才做比較</span></span><br><span class="line">        <span class="keyword">if</span> (son + <span class="number">1</span> &lt;= end &amp;&amp; arr[son] &lt; arr[son + <span class="number">1</span>]) <span class="comment">// 先比較兩個子節點大小，選擇最大的</span></span><br><span class="line">            son++;</span><br><span class="line">        <span class="keyword">if</span> (arr[dad] &gt; arr[son]) <span class="comment">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// 否則交換父子內容再繼續子節點和孫節點比較</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[dad], arr[son]);</span><br><span class="line">            dad = son;</span><br><span class="line">            son = dad * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化，i從最後一個父節點開始調整</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, i, len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="built_in">max_heapify</span>(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">6</span> &#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(*arr);</span><br><span class="line">    <span class="built_in">heap_sort</span>(arr, len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/countingSort.gif" alt="计数排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</span></span><br><span class="line"><span class="comment">//计数排序的时间复杂度是o(n+K)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">简单说，就是用我们&quot;需要排序的序列的值&quot;,创建一个标记数组，只要序列出现过的值，都标记成1，就说明它出现了。但是，这种方法只对数来说比较方便。 - 可以说是数组下标和排序序列有映射关系</span></span><br><span class="line"><span class="comment">      </span></span><br><span class="line"><span class="comment">算法步骤</span></span><br><span class="line"><span class="comment">（1）找出待排序的数组中最大和最小的元素</span></span><br><span class="line"><span class="comment">（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项</span></span><br><span class="line"><span class="comment">（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）</span></span><br><span class="line"><span class="comment">（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//代码（c）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_arr</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot; %d&quot;</span>, arr[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">counting_sort</span><span class="params">(<span class="type">int</span> *ini_arr, <span class="type">int</span> *sorted_arr, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *count_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * <span class="number">100</span>);</span><br><span class="line">        <span class="type">int</span> i, j, k;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                count_arr[ini_arr[i]]++;</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt; <span class="number">100</span>; k++)</span><br><span class="line">                count_arr[k] += count_arr[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (j = n; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">                sorted_arr[--count_arr[ini_arr[j - <span class="number">1</span>]]] = ini_arr[j - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">free</span>(count_arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> *arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="type">int</span> *sorted_arr = (<span class="type">int</span> *) <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">int</span>) * n);</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                arr[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;ini_array: &quot;</span>);</span><br><span class="line">        <span class="built_in">print_arr</span>(arr, n);</span><br><span class="line">        <span class="built_in">counting_sort</span>(arr, sorted_arr, n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sorted_array: &quot;</span>);</span><br><span class="line">        <span class="built_in">print_arr</span>(sorted_arr, n);</span><br><span class="line">        <span class="built_in">free</span>(arr);</span><br><span class="line">        <span class="built_in">free</span>(sorted_arr);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="桶排序-不懂"><a href="#桶排序-不懂" class="headerlink" title="桶排序 - 不懂"></a>桶排序 - 不懂</h4><p>元素分布在桶中：</p>
<p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/Bucket_sort_1.svg_.png" alt="桶"></p>
<p>然后，元素在每个桶中排序：</p>
<p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/Bucket_sort_2.svg_.png" alt="桶"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</span></span><br><span class="line"><span class="comment">//为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</span></span><br><span class="line"><span class="comment">/*计数排序每个位置只能装一种数据，而桶排序中，可以装入一个范围（集合）的数据是这个样子吗 - 感觉类似于哈希表*/</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="type">int</span> maxv = *<span class="built_in">max_element</span>(a, a + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) b[a[i]] ++ ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= maxv; i ++ )</span><br><span class="line">        <span class="keyword">while</span> (b[i] -- ) a[j ++ ] = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h4 id="基数排序-不懂"><a href="#基数排序-不懂" class="headerlink" title="基数排序 - 不懂"></a>基数排序 - 不懂</h4><p><img src="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/radixSort.gif" alt="基数排序"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//基数排序：根据键值的每位数字来分配桶；</span></span><br><span class="line"><span class="comment">//基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxbit</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//辅助函数，求数据的最大位数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> maxData = data[<span class="number">0</span>];              <span class="comment">///&lt; 最大数</span></span><br><span class="line">    <span class="comment">/// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxData &lt; data[i])</span><br><span class="line">            maxData = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span> (maxData &gt;= p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//p *= 10; // Maybe overflow</span></span><br><span class="line">        maxData /= <span class="number">10</span>;</span><br><span class="line">        ++d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line"><span class="comment">/*    int d = 1; //保存最大的位数</span></span><br><span class="line"><span class="comment">    int p = 10;</span></span><br><span class="line"><span class="comment">    for(int i = 0; i &lt; n; ++i)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        while(data[i] &gt;= p)</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            p *= 10;</span></span><br><span class="line"><span class="comment">            ++d;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    return d;*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixsort</span><span class="params">(<span class="type">int</span> data[], <span class="type">int</span> n)</span> <span class="comment">//基数排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">maxbit</span>(data, n);</span><br><span class="line">    <span class="type">int</span> *tmp = <span class="keyword">new</span> <span class="type">int</span>[n];</span><br><span class="line">    <span class="type">int</span> *count = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i, j, k;</span><br><span class="line">    <span class="type">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= d; i++) <span class="comment">//进行d次排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = <span class="number">0</span>; <span class="comment">//每次分配前清空计数器</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>; <span class="comment">//统计每个桶中的记录数</span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j]; <span class="comment">//将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) <span class="comment">//将所有桶中记录依次收集到tmp中</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = (data[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = data[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; n; j++) <span class="comment">//将临时数组的内容复制到data中</span></span><br><span class="line">            data[j] = tmp[j];</span><br><span class="line">        radix = radix * <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> []tmp;</span><br><span class="line">    <span class="keyword">delete</span> []count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 图论</title>
    <url>/2023/04/28/%E5%9B%BE%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学习。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>  要了解上述两个遍历模型，就要了解二叉树。二叉树是图的一种特殊造型，二叉树有两种主要形式：满二叉树和完全二叉树.满二叉树的深度和结点是有关系的，一个深度为k的满二叉树，它的节点数是2^k - 1（每一层是两个，减去我们的头结点就ok了）</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>  完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数 都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h层，则该层包含 1~ 2^h -1 个节点。（就是叶子结点左边可以不满，其他必须满是这个意思是吗）。</p>
<p>​        <img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216131827500-16923746582101.png" alt="image-20230216131827500"></p>
<blockquote>
<p>二叉搜索树（建立在完全二叉树的基础之上）<br>有如下的规则（简单来说，左边的都是小于根节点，右边的都是大于根节点）<br> 若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；<br> 若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；<br> 它的左、右⼦树也分别为⼆叉排序树</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308312338279.png" alt="image-20230216133015856"></p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>平衡⼆叉搜索树：又被称为AVL<code>（Adelson-Velsky and Landis）</code>树，且具有以下性质：它是 ⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。（高度差 注意是高度差！！！！！）</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216133247245-16923744811933.png" alt="image-20230216133247245"></p>
<h4 id="用数组实现二叉树"><a href="#用数组实现二叉树" class="headerlink" title="用数组实现二叉树"></a>用数组实现二叉树</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216134441813-16923744802222.png" alt="image-20230216134441813"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">⽤数组来存储⼆叉树如何遍历的呢？ 如果⽗节点的数组下表是i，那么它的左孩⼦就是i * <span class="number">2</span> + <span class="number">1</span>，右孩⼦就是 i * <span class="number">2</span> + <span class="number">2</span>。 </span><br><span class="line">但是⽤链式表⽰的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。</span><br><span class="line">所以⼤家要了解，⽤数组依然可以表⽰⼆叉树</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的链式实现"><a href="#二叉树的链式实现" class="headerlink" title="二叉树的链式实现"></a>二叉树的链式实现</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;<span class="comment">//定义left指针 指向左子树</span></span><br><span class="line">  TreeNode *right;<span class="comment">//right指针 指向右子树</span></span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用二叉树理解递归"><a href="#用二叉树理解递归" class="headerlink" title="用二叉树理解递归"></a>用二叉树理解递归</h4><p>实现递归的三要素：</p>
<blockquote>
<ol>
<li>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。</li>
<li>确定终⽌条件： 写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者 终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果 递归没有终⽌，操作系统的内存栈必然就会溢出。</li>
<li>确定单层递归的逻辑：<br>确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程</li>
</ol>
</blockquote>
<p>为什么用二叉树可以实现递归，首先让我们回到二叉树中。如果我们搜索一个二叉树的随机节点的值，应该怎么办。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216134441813-16923744802222.png" alt="image-20230216134441813"></p>
<p>如果我们要查找e这个位置的数据，依靠上帝视角我们可以直接0-1-4即可查询。但是如果这个树十分庞大导致无法一眼看出，而且计算机也无法做到这么复杂的识别方式，那我们怎么做。</p>
<p>最简单的方法就是一条线查找下去（从左到右）或者说一层层查找（从上到下）。那这个和递归有什么关系呢。</p>
<p>我们现在是在一个二叉树内找数据，从一个节点到另一个节点只有两种方式，要么向左要么向右。而每个节点只有两种情况，要么有值要么没值。遍历的过程每一条线都是独立的，且每次遍历都高度相似（因为向下延伸只有两种方式）。终止条件就是找到我们需要的值。所以说这样的遍历方式符合使用递归的情况，一下是实现递归的具体步骤。</p>
<blockquote>
<p>下面用递归实现二叉树的遍历，二叉树的遍历有三种。前中后序遍历，但是基本上是差不多的，我们可以通过这三个遍历来看看改变递归函数的语句会产生什么变化。</p>
</blockquote>
<p>在遍历构造之前，我们先构造树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;<span class="comment">//定义left指针 指向左子树</span></span><br><span class="line">  TreeNode *right;<span class="comment">//right指针 指向右子树</span></span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历（对于单独）的逻辑是，从根节点出发，找到左子树，再到右子树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;<span class="comment">//定义left指针 指向左子树</span></span><br><span class="line">  TreeNode *right;<span class="comment">//right指针 指向右子树</span></span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PT</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果访问的节点没有子节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印遍历的节点数据</span></span><br><span class="line">    cout&lt;&lt;root-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历左子树</span></span><br><span class="line">    <span class="built_in">PT</span>(root -&gt; left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历右子树</span></span><br><span class="line">    <span class="built_in">PT</span>(root -&gt; right);    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>中序遍历的逻辑是，从左子树出发，到根节点，再到右节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//和上面相比，就改变了顺序</span></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的逻辑是通过<code>inorderTraversal(root-&gt;left);</code>这个语句到达我们的最下左节点，然后执行打印<code> cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;</code>最后查询当前遍历到节点的右节点，直到最后没有节点为止。</p>
</blockquote>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>后序遍历的逻辑是左子树到右子树到根节点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//一样的改变顺序</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们只针对于遍历到第一个节点来思考，如果我们需要打印这个节点就需要执行前面两个语句，<code>postorderTraversal(root-&gt;left);</code>和<code>postorderTraversal(root-&gt;right);</code>。我们<strong>执行完了第一个语句</strong>，这个时候就返回了<code>root -&gt; 树中最左的节点（执行的是一个函数嘛）</code>，然后执行第二个函数<code>postorderTraversal(root-&gt;right);</code>由于这个函数查询了当前这个节点<code>(root -&gt; 树中最左的节点（执行的是一个函数嘛）)-&gt;right</code> 这个结果，其实就是<code>null</code>。所以说当前这个递归的其中一个函数结束了，也就是打印了第一个值。</p>
<p>结束了递归中的第一个函数，不代表全部函数都结束了。由第一个函数引发的全部函数（大概是2的倍数差不多），还在继续运行以第一个函数举例。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root-&gt;left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//当执行完这两个句子的时候，就会打印值</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left-&gt;left);</span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样你就能理解了吗，再说下去就会乱了。执行完全部子函数，就可以执行完这个递归函数了。</p>
</blockquote>
<h5 id="层序遍历（补充）"><a href="#层序遍历（补充）" class="headerlink" title="层序遍历（补充）"></a>层序遍历（补充）</h5><p>层序遍历，就是从根节点出发，一层一层的遍历我们的树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一排一排的遍历 利用队列的特性哟，将根结点入队列 然后然后出入队列，出队列后将其左右孩子结点入队列</span></span><br><span class="line"><span class="comment">//直到队列为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqTraverse</span><span class="params">(BiTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SeqQueue queue = <span class="built_in">Init_SeqQueue</span>();</span><br><span class="line">	<span class="built_in">Push_SeqQueue</span>(queue, tree);</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">IsEmpty_SeqQueue</span>(queue))</span><br><span class="line">	&#123;</span><br><span class="line">		BiTree root = <span class="built_in">Pop_SeqQueue</span>(queue);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">        <span class="comment">//遍历两个孩子就行 - 因为是二叉树嘛</span></span><br><span class="line">		<span class="keyword">if</span> (root-&gt;lchild)</span><br><span class="line">			<span class="built_in">Push_SeqQueue</span>(queue, root-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;rchild)</span><br><span class="line">			<span class="built_in">Push_SeqQueue</span>(queue, root-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图的介绍"><a href="#图的介绍" class="headerlink" title="图的介绍"></a>图的介绍</h3><p>图，是一种抽象的数据结构，在我们学习数学的时候，最早接触的图像就是三角形，三角形的属性有三个边，并且是封闭的。在数据结构中，图的理论也和我们的数学是一样的，在其基础之上，我们衍生出了节点，和边集关系。用这些属性，可以帮助我们快速的构造一个像样的图。</p>
<p>对于图，我们可以这样理解，就是节点与节点之间的关系，且关系成环（至少有一个环），如果没有环的话，其实是一种特殊的图像，也就是二叉树。节点彼此的关系，可以理解为边，毕竟声明一个图主要用途就是寻找路径和定位。在此基础上增加了几个定义。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809211226304.png" alt="image-20230809211226304"></p>
<p>相对比而言，图严格证明的定义是十分多的，如果要细究会十分抽象和麻烦。我们这边就记几个比较常用语算法中的概念，如果有需要可以去翻维基百科，里面有详细的定义和概念。</p>
<p>首先我们需要了解，组成一个图需要什么，你可能会说，找几个定点将之链接起来，围成一片区域，这样形成的图像不就是图吗。但是，严格来说，单个节点其实也是个图，这样的图被称之为<strong>独立节点</strong>-最简单的图像。这里就引出了图中的第一个概念，顶点。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809212302594.png" alt="image-20230809212302594"></p>
<p>在这一张图中，顶点其实没有属性，只有编号，但是顶点可以赋值属性。这就要具体题目具体分析*。类似于我们城市的路线图。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809212603095.png" alt="image-20230809212603095"></p>
<p>在这些图中，每个节点都有相应的关系，通过一个线来表示。这个被我们称之为<strong>边</strong>，边中可以赋值，上面的城市路线图，边就承接了两个城市之间的距离这个信息。对于边我们可以用邻接矩阵来承接边的信息，这个信息被称之为<strong>权</strong>。下面就举一个简单的例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码 - 二维数组表示邻接矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 每一个位置表示一个顶点</span></span><br><span class="line">f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们有四个节点 1 2 3 4 那么</span></span><br><span class="line">f[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">//表示1链接2</span></span><br><span class="line">f[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>; <span class="comment">//表示1节点到2节点的边权为1</span></span><br></pre></td></tr></table></figure>

<p>在这里我们只举了单向的边来表示，只有单向的边的图叫做<strong>有向图</strong>，如果链接之间没有方向，那么被称之为<strong>无向图</strong>。前面说，二叉树是一种特殊的图，但是树有一个特点，就是不存在环，但是一般出现的图呢，很正常会出现<strong>环</strong>，那么环的概念是什么呢。</p>
<p><strong>图环</strong>（Cycle）是指图中的一条路径，它从一个顶点出发，经过一系列不同的顶点，最后回到起始顶点，形成一个闭合的回路。换句话说，图环是一个不包含重复顶点的路径，其起始顶点和终止顶点相同，并且至少包含3条边（或2个顶点）。</p>
<p>从这个概念，我们可以得到环的特殊变式，<strong>连通图</strong>和<strong>强连通图</strong>。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809214600123.png" alt="image-20230809214600123"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809214636189.png" alt="image-20230809214636189"></p>
<p>具体细节可以看这篇<a href="http://data.biancheng.net/view/201.html">博客</a>,我的理解是，<strong>联通图是，从一个节点可以到达任意的节点。强连通图是在连通图的基础上，有两个方向都可通行。</strong>如果让你编写一个程序判断图是否是连通图你会写吗？其实很简单，只要将我们图中的每个节点遍历一遍即可，遍历到说明在图中，遍历不到说明在这之外。这就是我们之后会涉及到的，图的遍历的两种方法，深度优先遍历和广度优先遍历（不过图还是深度用的多）。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809220406017.png" alt="image-20230809220406017"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809220953852.png" alt="image-20230809220953852"></p>
<p>下一个概念是，<strong>子图</strong>，也被称之为图的子集。如果我们需要求得一个图有多少个子集，可以使用幂集的概念。一个包含n个元素的集合的幂集包含2^n个子集，其中包括空集和全集。对于图来说，子集的数量与图的顶点数量有关。假设图有n个顶点，那么图的所有可能子集数量为2^n。这是因为每个顶点都可以选择是否包含在子集中，有包含和不包含两种选择，所以总的可能性是2^n。具体到图的应用中，可以将每个顶点看作是一个元素，然后使用幂集的概念计算子集的数量。这在某些问题中可能是有用的，例如在某些组合问题中，需要考虑图中的顶点子集。需要注意的是，幂集包括空集和全集，所以实际有效的非空子集数量是2^n - 1。</p>
<p>子图对于我们将图转化为树或者说森林也有帮助，这里就不在赘述。在离散数学中也有对于的体型，感兴趣可以去看看离散数学。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809221018966.png" alt="image-20230809221018966"></p>
<p>完全图： 具有n个顶点的无向图，每一对不同的顶点之间都存在一条边。两点关系的一种特殊情况。知道概念就行。一般来说也不是很常见，和普通的图一样。</p>
<p>度数：和树的概念其实是一样的，这里就表示的是当前顶点连接了几个其他顶点。然后出度表示出去的边的数量，入度表示进来的边的数量。</p>
<p>邻接矩阵和邻接表等等讲，就是用来表示图的结构的一种数据结构。下面是总概念，可以简单看看，建议结合教材。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809221035439.png" alt="image-20230809221035439"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809213919067.png" alt="image-20230809213919067"></p>
<h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><p>在讲遍历之前，我们先讲几个常见的存储图的方式。</p>
<h5 id="领接矩阵"><a href="#领接矩阵" class="headerlink" title="领接矩阵"></a>领接矩阵</h5><p>开一个二维数组，每一个数组位置相当于一个二维坐标，每个二位坐标存储图中的一个数据。图是二维的嘛，所以说用二维数组存储很好理解。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230305080127311.png" alt="image-20230305080127311"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//领接矩阵声明，开一个二维数组； 1.二维数组w[u][v],存储u - v的边权（就是这个连线多长）2.只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）</span></span><br><span class="line"><span class="comment">//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N][N]; <span class="comment">//声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c</span></span><br><span class="line"><span class="type">int</span> vis[N];<span class="comment">//点集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,u,v,w[u][v]);</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[a][b] = c; <span class="comment">//赋予权值（a点 和 b点）（算是连线）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果矩阵的点很散，例如三个点<code>（1,1）,(10000,10000),(100000,100000)</code>,那么开的空间很多都会被浪费，所以说只适合用于稠密图。</p>
</blockquote>
<h5 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230305080154969.png" alt="image-20230305080154969"></p>
<p>声明了一个结构体，存储我们两个节点对应的边。好处就是不用按照数组下标开对应大的数组。其实很好理解，声明两个变量存储对应的节点序列，然后声明一个变量存储权即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//边集数组</span></span><br><span class="line"><span class="comment">//结构体下标联系三者</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>()&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w; <span class="comment">//两点 和 权</span></span><br><span class="line">&#125;e[M]; <span class="comment">//边集合</span></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">//点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v,w = e[i].w; <span class="comment">//用结构体中对应的值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,u,v,w); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>; <span class="comment">//这个点到过了</span></span><br><span class="line">        <span class="built_in">dfs</span>(e[i].v);<span class="comment">//下一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[i] = &#123;a,b,c&#125;;</span><br><span class="line">        <span class="comment">//e[i] = &#123;b,a,c&#125;; //无向图就要加上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="领接表"><a href="#领接表" class="headerlink" title="领接表"></a>领接表</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302110544398.png" alt="image-20230302110544398"></p>
<p>对于每个节点，领接表创建的结构体数组，存储的是当前节点的所有出边（和图的出度是一个概念），结构体中声明两个变量，一个存储当前节点指向的节点，一个存储连接的边权。（不过我刚开始理解的时候，对于这个<code>vector&lt;edge&gt; e[N]</code>理解的有点抽象，感觉是数组的数组，但是确实是:joy:）</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230831223534628.png" alt="image-20230831223534628"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//领接表（将图用dfs序输出）</span></span><br><span class="line"><span class="comment">//出边数组e[u][i] 存储u点的所有出边&#123;终点 v ， 边权 w&#125;。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edga</span>&#123;<span class="type">int</span> v,w;&#125;; <span class="comment">//声明结构体（代表每个点有的属性）</span></span><br><span class="line">vector&lt;edga&gt; e[N];<span class="comment">//存储的是每一个起点（有n个）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u]) <span class="comment">//遍历当前层的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;<span class="comment">//判重（父节点记录父节点是否走过）（u和fa是交替使用的）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d，%d,%d\n&quot;</span>,u,v,w);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);<span class="comment">// （u,fa,v,u,v,u.......） //fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//无向图 两边都要连接</span></span><br><span class="line">        e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(&#123;c,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父节点是相互的，我们用领接表存储的时候，只要连接就是父和子的叠加态（这也解释了为什么可以回溯）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链式领接表"><a href="#链式领接表" class="headerlink" title="链式领接表"></a>链式领接表</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302111110291.png" alt="image-20230302111110291"></p>
<p>与前面的领接表不同，是按照输入循序给与节点编号，按照编号存储我们的出边的信息，并且用这些信息构造一个数组<code>h[N]</code>来存储。然后在一个桶数组，以编号的形式插入我们的数据，就构成了一个链式领接表（是尾插法，<code>vector</code>变长数组）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链式领接表</span></span><br><span class="line"><span class="comment">/*两个变量：1.边集数组 2.表头数组</span></span><br><span class="line"><span class="comment">1.边集数组存储的是第几条边的属性：e[j]存储第j条边的&#123;起点u，终点v，边权w&#125;</span></span><br><span class="line"><span class="comment">2.表头数组存储的是u点的所有出边的编号：h[u][j](u表示的是当前的点)（j表示的是当前点连接的出边）*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,w&#125;;</span><br><span class="line">vector&lt;edge&gt; e; <span class="comment">//边集合（边的属性）</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; h[N]; <span class="comment">//点的所有出边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.<span class="built_in">push_back</span>(&#123;a,b,c&#125;); <span class="comment">// 对应边的属性压入</span></span><br><span class="line">    h[a].<span class="built_in">push_back</span>(e.<span class="built_in">szie</span>()<span class="number">-1</span>); <span class="comment">//当前边权数组的大小-1（这里的应该是桶数组）    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//u当前节点 fa-父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;h[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = h[u][j];<span class="comment">//表示的是当前的点？</span></span><br><span class="line">        <span class="type">int</span> v = e[j].v,w = e[j].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//邻接表存储数据</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302112003101.png" alt="image-20230302112003101"></p>
<p>e数组表示的是每一个出边的编号，现在相当于是双向的了（<code>1-4</code>的同时也<code>4-1</code>）,h数组表示出边的编号，编号用节点的编号表示就行，反正每一个节点都是独一无二的。然后在桶数组中，以链表的形式存储就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;;<span class="comment">//ne是链接点的编号 - 例如1-4</span></span><br><span class="line">edge e[M]; <span class="comment">// 存储的是所有的边</span></span><br><span class="line"><span class="type">int</span> idx,h[N]; <span class="comment">//点的第一条出边（每个点都有）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第一个出边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = &#123;b,c,h[a]&#125;; <span class="comment">// e结构体存储的是这个边的信息</span></span><br><span class="line">    <span class="comment">//idx给每一个边都搞一个编号 - 独一无二的</span></span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//横向遍历是为了回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];~i;i=e[i].ne)&#123; <span class="comment">//~i表示i不等于-1</span></span><br><span class="line">        <span class="type">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;<span class="comment">//判重 回溯</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);/深入</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">//初始化表头</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//无向图构图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302112236202.png" alt="image-20230302112236202"></p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a><a href="https://www.cxyxiaowu.com/9854.html">图的遍历</a></h3><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216151302883.png" alt="遍历逻辑"></p>
<p>讲完了二叉树的遍历，我们来讲讲图的遍历，图和二叉树的逻辑其实也是一样的（因为二叉树也是图）。下面讲讲用深度优先遍历和程序遍历来遍历我们的图。</p>
<p>但是对于图来说，遍历不像二叉树一样简单了，二叉树每个节点最多两个选择，但是对于图来说，每个节点连接的节点数是不一样的，导致递归次数会比树多很多。</p>
<h4 id="dfs过程的实现"><a href="#dfs过程的实现" class="headerlink" title="dfs过程的实现"></a>dfs过程的实现</h4><p>深度优化遍历( <strong>Depth First Search</strong> )，也有称为 <strong>深度优化搜索</strong> ，简称为 <strong><code>DFS</code></strong> 。事实上，我们在树的遍历中早已涉及<code>DFS</code>，层序遍历、中序遍历和后序遍历都属于深度优先遍历的方式，因为这些遍历方式本质上都归结于<strong>栈</strong>。为了讲清楚<code>DFS</code>，我们先来看两个概念。</p>
<p><strong>右手原则：</strong> 在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。</p>
<p><strong>左手原则：</strong> 在没有碰到重复顶点的情况下，分叉路口始终是向左手边走，每路过一个顶点就做一个记号。</p>
<p>本文约定以<strong>右手原则</strong>进行深度优先遍历。废话不多说，我们以下图说明深度优先搜索。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850315-3ce63cac0c52019-1693495997261-22.png" alt="1589850315-3ce63cac0c52019"></p>
<p>原则上，我们可以从图中的任何一个顶点开始，进行深度优先遍历，假设我们从顶点A开始，遍历过程中的每一步如下：</p>
<p>第一步：从顶点A开始，将顶点A标记为已访问顶点。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850315-906ab179bb5b850-1693496008513-24.png" alt="1589850315-906ab179bb5b850"></p>
<p>第二步：根据约定的右手原则，访问顶点B，并将B标记为已访问顶点。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850315-906ab179bb5b850-1-1693496019174-26.png" alt="1589850315-906ab179bb5b850-1"></p>
<p>第三步：右手原则，访问顶点C</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850316-453854f971022e4-1693496121022-34.png" alt="1589850316-453854f971022e4"></p>
<p>第四步：右手原则，访问顶点D</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850316-6b252e146243857-1693496098000-30.png" alt="1589850316-6b252e146243857"></p>
<p>第五步：右手原则，访问顶点E</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850316-6600fddac3ef23a-1693496111738-32.png" alt="1589850316-6600fddac3ef23a"></p>
<p>第六步：右手原则，访问顶点F</p>
<p><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202309041521437.png" alt="第六步"></p>
<p>第七步：右手原则，应该先访问顶点F的邻接顶点A，但发现A已被访问，则访问除A之外的最右侧顶点G。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850317-1becc6e66c4855c-1693496129403-36.png" alt="1589850317-1becc6e66c4855c"></p>
<p>第八步：右手原则，先访问顶点B，顶点B已被访问；再访问顶点D，顶点D已经被访问；最后访问顶点H。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850317-9b188e21831899e-1693496146605-38.png" alt="1589850317-9b188e21831899e"></p>
<p>第九步：发现顶点H的邻接顶点均已被访问，则退回到顶点G;</p>
<p>第十步：顶点G的邻接顶点均已被访问，则退回到顶点F；</p>
<p>第十一步：顶点F的邻接顶点已被访问，则退回到顶点E；</p>
<p>第十二步：顶点E的邻接顶点均已被访问，则退回到顶点D；</p>
<p>第十三步：顶点D的邻接顶点I尚未被访问，则访问顶点I；</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850318-e17b709eef68580-1693496178677-42.png" alt="1589850318-e17b709eef68580"></p>
<p>第十四步：顶点I的邻接顶点均已被访问，则退回到顶点D;</p>
<p>顶点D的邻接顶点均已被访问，退回到顶点C；顶点C的邻接顶点均已被访问，则退回到顶点B；顶点B的邻接顶点均已被访问，则退回到顶点A，顶点A为<strong>起始顶点</strong>，深度优先搜索结束。</p>
<blockquote>
<p>上述步骤记录的递归遍历图的过程，可以发现，是从一个节点出发一直延伸到全部。</p>
<p>如果我们只看第一次遍历到的节点，只需要判断当前节点的下一个为位置是否为空，不为空打印，为空就返回<code>null</code>,然后每经过一个节点就记录该节点已经遍历过了。</p>
<p>而对于每一个节点来说，都可以利用这一个函数。所以说就构造递归函数实现遍历。</p>
</blockquote>
<p>下面是实现递归的模版：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">level</span>(root, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(TreeNode* root, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == level) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[level].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">level</span>(root-&gt;left, level + <span class="number">1</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">level</span>(root-&gt;right, level + <span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result = solution.<span class="built_in">levelOrder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出层次遍历结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; level : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : level) &#123;</span><br><span class="line">            cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> root-&gt;left-&gt;left;</span><br><span class="line">    <span class="keyword">delete</span> root-&gt;left-&gt;right;</span><br><span class="line">    <span class="keyword">delete</span> root-&gt;left;</span><br><span class="line">    <span class="keyword">delete</span> root-&gt;right;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="dfs序列"><a href="#dfs序列" class="headerlink" title="dfs序列"></a>dfs序列</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs模板（感觉是遍历 这个树hhh）</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">//这个就是 表示树（宽度 和 深度）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span><span class="comment">//fa表示树的根结点（醍醐灌顶）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> sz = g[u].<span class="built_in">size</span>(); <span class="comment">// 整个树的节点个数</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++) <span class="comment">// 遍历每一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(g[u][i]!=fa) <span class="comment">// u（代表当前层的一个数据）的i(表示下一层的数据)没用过</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加一个辅助数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  dfs_[++len] = u; <span class="comment">//遍历的就是当前的父节点 记录一下 （每次走过的就当是根 - 父节点的就可以了）</span></span><br><span class="line">  <span class="type">int</span> sz = g[u].<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(g[u][i]!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(g[u][i],u);<span class="comment">//根节点替换</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//一维数组 可以用作二维数组吗</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dfs_[<span class="number">200020</span>],len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs_[++len]=u;  </span><br><span class="line">    <span class="type">int</span> sz=g[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//两个点 不同方向都有一条边</span></span><br><span class="line">        <span class="type">int</span> from,to;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);</span><br><span class="line">        g[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        g[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dfs_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = len+<span class="number">1</span>;<span class="comment">//数组拓展</span></span><br><span class="line">    s[++len] = ++time; </span><br><span class="line">   dfs_[len] = u;<span class="comment">//存储dfs序列</span></span><br><span class="line">   <span class="type">int</span> sz = g[u].<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(g[u][i] == fa)&#123;</span><br><span class="line">          <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   e[x] = time;<span class="comment">//存储对应 根节点到子节点的时间区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。（算导里称之为括号化定理）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>dfs序列作用</strong></p>
<p>子树加权</p>
<p>​	在dfs序列中，一个结点的子树序列是连续的。 - 看下面的树： <code>abdegcfh </code>我们关注 b结点 发现b - deg 这一段是连续的，就可以利用差分的操作就行加权。然后我们可以发现B字树B-D-E-G，C子树C-F-H都在一段连续的区间中。那么这有什么好处呢？比如说现在有一道题：给你一颗树，给出m个x和w，意为将x子树中的所有点加上一个权值w，最后询问所有点的权值 - 既然dfs序中x和他的所有子节点都在连续的区间上，那么我们就可以将它简化成差分的问题。比如说给b节点加2，就可以简化为给b的差分数组+2，c的差分数组-2 。（又涉及到了差分数组了）怎么找第一个不在B子树中的点 引入时间戳</p>
<p>时间戳</p>
<p>作用：记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。（用数组记录时间）</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1188068-20171027104122883-1380446385.png" alt="img"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230301212454581.png" alt="image-20230301212454581"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//代码 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dfs_[<span class="number">200020</span>],len,time,s[<span class="number">200020</span>],e[<span class="number">200020</span>],pos[<span class="number">200020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=len+<span class="number">1</span>;</span><br><span class="line">    s[++len]=++time;<span class="comment">//当前点 时间起点</span></span><br><span class="line">    dfs_[len]=u;</span><br><span class="line">    pos[u]=len;</span><br><span class="line">    <span class="type">int</span> sz=g[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e[x]=time;<span class="comment">//时间终点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="comment">//输入我们的树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//用邻接表表示树</span></span><br><span class="line">        <span class="type">int</span> from,to;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);</span><br><span class="line">        g[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        g[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x=pos[x];</span><br><span class="line">        y=pos[y];</span><br><span class="line">        <span class="keyword">if</span>(s[x]&lt;=s[y]&amp;&amp;e[y]&lt;=e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/">层序遍历</a></h4><p>层序遍历是用队列构造的，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。</p>
<p><code>BFS</code>使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。<code>BFS</code>总共有两个模板：</p>
<p>1.如果不需要确定当前遍历到了哪一层，<code>BFS</code>模板如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的节点数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 节点的值</span></span><br><span class="line">    vector&lt;Node*&gt; neighbors;  <span class="comment">// 相邻节点列表</span></span><br><span class="line">    <span class="type">bool</span> visited;  <span class="comment">// 标记节点是否已经访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">visited</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Node* start)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;visited) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Visiting node with value: &quot;</span> &lt;&lt; cur-&gt;value &lt;&lt; endl;</span><br><span class="line">            cur-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node* neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (neighbor &amp;&amp; !neighbor-&gt;visited) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建图节点</span></span><br><span class="line">    Node* node1 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    Node* node2 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* node3 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    Node* node4 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立节点之间的连接关系</span></span><br><span class="line">    node1-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line">    node2-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node3-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node4-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起始节点开始BFS遍历</span></span><br><span class="line">    <span class="built_in">bfs</span>(node1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> node1;</span><br><span class="line">    <span class="keyword">delete</span> node2;</span><br><span class="line">    <span class="keyword">delete</span> node3;</span><br><span class="line">    <span class="keyword">delete</span> node4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.如果要确定当前遍历到了哪一层，<code>BFS</code>模板如下。 这里增加了<code>level</code>表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。<code>size</code>表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的节点数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 节点的值</span></span><br><span class="line">    vector&lt;Node*&gt; neighbors;  <span class="comment">// 相邻节点列表</span></span><br><span class="line">    <span class="type">bool</span> visited;  <span class="comment">// 标记节点是否已经访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">visited</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS按层级遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsByLevel</span><span class="params">(Node* start)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;visited) &#123;</span><br><span class="line">                cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cur-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Node* neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (neighbor &amp;&amp; !neighbor-&gt;visited) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建图节点</span></span><br><span class="line">    Node* node1 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    Node* node2 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* node3 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    Node* node4 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立节点之间的连接关系</span></span><br><span class="line">    node1-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line">    node2-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node3-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node4-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起始节点开始按层级BFS遍历</span></span><br><span class="line">    <span class="built_in">bfsByLevel</span>(node1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> node1;</span><br><span class="line">    <span class="keyword">delete</span> node2;</span><br><span class="line">    <span class="keyword">delete</span> node3;</span><br><span class="line">    <span class="keyword">delete</span> node4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个是通用模板，在任何题目中都可以用，是要记住的！</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><a href="https://zhuanlan.zhihu.com/p/135094687">拓扑排序</a></h3><p>拓扑排序只是针对特定的一类图,也就是有向无环图。</p>
<ul>
<li><p>这个图的边必须是有方向的；</p>
</li>
<li><p>图内无环。</p>
</li>
</ul>
<p>为什么必须要无环呢，如果有环，拓扑排序将会是一个无限的序列，将无限自指。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-1e72742f8cc825e716ab74f68a3d38f6_720w.webp" alt="img"></p>
<p>如果一个图里有环，比如上图，想执行1就要先执行3，想执行3就要先执行2，想执行2就要先执行1，这成了个死循环，无法找到正确的打开方式，所以找不到它的一个拓扑序。</p>
<blockquote>
<p>其实和缺氧的科技树很像，你必须要完成前置条件才能达到我们最终的条件。或者拿<code>moba</code>游戏，你只有把全部防御塔推了才能推掉对面的水晶。</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-49a86090444ba413a1d11e09715d1283_720w.webp" alt="img"></p>
<p>这种图叫 <code>AOV </code>(Activity On Vertex) 网络，在这种图里：</p>
<ul>
<li>顶点：表示活动；</li>
<li>边：表示活动间的先后关系</li>
</ul>
<p>在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。</p>
<p><strong>所以一个 AOV 网应该是一个 DAG，即有向无环图，否则某些活动会无法进行。</strong><br><strong>那么所有活动可以排成一个可行线性序列，这个序列就是<code>拓扑序列</code>。</strong></p>
<p>那么这个序列的<code>实际意义</code>是：<br><strong>按照这个顺序，在每个项目开始时，能够保证它的前驱活动都已完成，从而使整个工程顺利进行。</strong></p>
<blockquote>
<p>注意，有时候拓扑序并不是唯一的，比如在这个例子中，先学 <code>C1 再学 C2</code>，和先 <code>C2 后 C1</code> 都行，都是这个图的正确的拓扑序，但这是两个顺序了。</p>
</blockquote>
<p>在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。</p>
<blockquote>
<p>那么我们回想一下刚刚自己找拓扑序的过程，为什么我们先看上了 <code>C1, C2?</code></p>
</blockquote>
<p>因为它们没有依赖别人啊，<br>也就是它的<code>入度为 0</code>.</p>
<blockquote>
<p><strong>入度</strong>：顶点的入度是指「<strong>指向该顶点的边</strong>」的数量；<br><strong>出度</strong>：顶点的出度是指该顶点指向其他点的边的数量。</p>
</blockquote>
<p>所以我们先执行入度为 0 的那些点，<br>那也就是要记录每个顶点的入度。<br>因为<strong>只有当它的 <code>入度 = 0</code> 的时候，我们才能执行它。</strong></p>
<p>在刚才的例子里，最开始 <code>C1, C2 </code>的入度就是 0，所以我们可以先执行这两个。</p>
<p>那在这个算法里第一步就是得到每个顶点的入度。</p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>拿到了这个之后，就可以执行入度为<code>0</code>的这些点了，也就是 <code>C1, C2.</code></p>
<p>那我们把可以被执行的这些点，放入一个<code>待执行的容器</code>里，这样之后我们一个个的从这个容器里取顶点就好了。</p>
<p>至于这个<code>容器</code>究竟选哪种<code>数据结构</code>，这取决于我们需要做哪些<code>操作</code>，再看哪种数据结构可以为之服务。</p>
<p>那么首先可以把<code>[C1, C2]</code>放入<code>容器</code>中，</p>
<p>然后想想我们需要哪些操作吧！</p>
<p>我们最常做的操作无非就是<code>把点放进来</code>，<code>把点拿出去</code>执行了，也就是需要一个 <code>offer</code> 和 <code>poll</code> 操作比较高效的数据结构，那么 <code>queue</code> 就够用了。</p>
<p>（其他的也行，放进来这个容器里的顶点的地位都是一样的，都是可以执行的，和进来的顺序无关，但何必非得给自己找麻烦呢？一个常规顺序的简简单单的 <code>queue</code> 就够用了。）</p>
<blockquote>
<p>解析实现顺序可以去标题的博客看，下面是具体实现拓扑排序的代码</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302193314874.png" alt="image-20230302193314874"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302195721755.png" alt="image-20230302195721755"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302195739338.png" alt="image-20230302195739338"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302195757415.png" alt="image-20230302195757415"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*简单来说就是 按照 前面点最少的顺序排序（也就是入度从小到大）</span></span><br><span class="line"><span class="comment">1.Kahn算法</span></span><br><span class="line"><span class="comment">   起点是从入度为0的点开始的（这样才能入度从小到大），使用队列来维护我们的点；1.初始化：将所有入度为0的点压入我们的队列（顺序不重要）；2.每次从q中取出一个点x放入数组tp（存储最终序列）；3.将x的所有出边删除：这个时候的x是队头，边被删除那么对应的连接点的入度就变成0，就可以压入队列；4.重复23步骤。5.如果tp中的数据和我们的点的数量一样，那么就有拓扑序列，如果不一样，那就没有。（有向 无环图才有拓扑序列）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],tp;<span class="comment">//tp是我们最终输出的拓扑序列</span></span><br><span class="line"><span class="type">int</span> din[N]<span class="comment">//存储着点的入度（画图是不是要用领接表）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//让入度0的进入队伍</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(din[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i); <span class="comment">// din数组记录的是入度</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">//让队头出栈 并且删除对应的边</span></span><br><span class="line">        tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[N])&#123;</span><br><span class="line">            <span class="keyword">if</span>(--din[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(y);<span class="comment">//删除对应的边 并且让对应的数据入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> tp.<span class="built_in">size</span>() = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        din[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>) ; <span class="comment">//如果数量不满足 则说明这个不是拓扑序列</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> x:tp) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x); <span class="comment">//将拓扑序列输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dfs求拓扑序列(变色法)</span></span><br><span class="line"><span class="comment">//不懂翻转序列 - 翻转序列是因为尾插法吧</span></span><br><span class="line"><span class="comment">/*1.染色法（yxc用的）</span></span><br><span class="line"><span class="comment">    每个点的颜色都会变化，从0 - -1 - 1，经历三次变色；1.初始状态，所有点染色为0；2.枚举每一个点，进入x点（是我们的指针），把x染色为-1，枚举x的儿子y，如果y的颜色为0，那么说明没碰过该点，进入y继续走（这里应该是检测有无环 - 会不会回到x）；3.如果枚举完x（当前数据 - 也算是队头）的儿子，将x压入tp数组；4.如果发现，有-1的出现（那么就是有环出现了），返回false，退出。*/</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],tp;<span class="comment">//e[N] 应该是树，，或者是领接表画的图</span></span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">//染色数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y:e[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[y]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//有环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!c[y])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(y)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[x] = <span class="number">1</span>;</span><br><span class="line">    tp.<span class="built_in">push_back</span>(x); <span class="comment">//当前这个数据遍历完成 压入我们的tp数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c)); <span class="comment">// 初始化 - 刚开始全部点的颜色为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">        <span class="keyword">if</span>(!c[x])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">reverse</span>(tp.<span class="built_in">begin</span>(),tp.<span class="built_in">end</span>());<span class="comment">//翻转序列 为啥？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h3><p>顾名思义，从任意顶点出发到另一顶点的最短距离。也就是权重最小。</p>
<h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a><a href="https://www.zhihu.com/tardis/zm/art/40338107?source_id=1003">Dijkstra</a></h4><blockquote>
<p>基于贪心思想，也就是每次选择的路径权重是最小的，达成局部最小变为全局最小。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230904102403004.png" alt="image-20230904102403004"></p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302202401928.png" alt="image-20230302202401928"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302204100958.png" alt="image-20230302204100958"></p>
<blockquote>
<p>简单来说：就是每次选择最短路线进行前进</p>
<p>三个数组：</p>
<p>​	e[u] 存储节点u的所有出边的终点和边权 </p>
<p>​	d[u] 存储u到源点的最小距离（源点就是当前连边的点）（d[u]需要遍历）</p>
<p>​	vis[u] 标记是否出圈<br>​    1.初始的时候，所有点都在圈中，vis &#x3D; 0,d[s] &#x3D; 0,d[其他点] &#x3D; 正无穷<br>​    2.从圈中选择一个距离最小的点，u，打标记出圈（贪心）<br>​    3.对u的所有出边执行松弛操作 - 尝试更新邻点v的最小距离<br>​    4.重复2,3操作，直到圈内为空</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>; <span class="comment">// 最大节点数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>(); <span class="comment">// 无穷大表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w; <span class="comment">// 边的目标节点和权值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; e[N]; <span class="comment">// 邻接表表示图</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储最短距离</span></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">// 标记节点是否已经访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        d[i] = inf; <span class="comment">// 初始化距离为无穷大</span></span><br><span class="line">        vis[i] = <span class="number">0</span>; <span class="comment">// 初始化节点未访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 起点到自身距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择未访问节点中距离最小的节点 u</span></span><br><span class="line">        <span class="comment">//第一次更新找到哪个点都无所谓 - 后面for遍历全部会松弛一遍的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; d[u]) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[u] = <span class="number">1</span>; <span class="comment">// 标记节点 u 为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新从节点 u 出发的边的目标节点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">            <span class="comment">//松弛操作 - 将无穷大的值松弛为输入值</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                d[v] = d[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; <span class="comment">// 输入节点数量、边数量和起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; <span class="comment">// 输入边的起点、终点和权值</span></span><br><span class="line">        e[a].<span class="built_in">push_back</span>(&#123;b, c&#125;); <span class="comment">// 添加边到邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(s, n); <span class="comment">// 调用 Dijkstra 算法计算最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出从起点到每个节点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest distance from &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; d[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302204110774.png" alt="image-20230302204110774"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302205328621.png" alt="image-20230302205328621"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里用的是小根堆 - 就不用加-号了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆优化 - 用优先队列维护被更新点的集合</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 全部点的距离都是无穷大</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + N, inf);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建小根堆（最小堆） - pair的第一个元素是距离</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环迭代</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                d[v] = d[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == inf) cout &lt;&lt; <span class="string">&quot;INF &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302205410861.png" alt="image-20230302205410861"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//就是两个模板 优化的地方就是枚举的时候用队列维护</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N],vis[N]; <span class="comment">//边 和 点</span></span><br><span class="line"><span class="comment">//s是起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++) d[i] = <span class="number">0x3f3f3f</span>; <span class="comment">//无穷大的值</span></span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">//对于自己和自己的距离当然是0了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//枚举次数</span></span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//优化 就是把这里优化了 取消了枚举全部点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++) <span class="comment">//枚举点</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123; <span class="comment">//ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）</span></span><br><span class="line">            <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w) &#123;</span><br><span class="line">                d[v] = d[u]+w;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;-d[v],v&#125;);<span class="comment">//插入到 大根堆上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302205417632.png" alt="image-20230302205417632"></p>
<h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford*"></a><a href="https://zhuanlan.zhihu.com/p/352724346">Bellman-Ford</a>*</h4><blockquote>
<p>贝尔曼-福特算法（Bellman-Ford）是由理查德·贝尔曼和莱斯特·福特创立的，求解<strong>单源最短路径问题</strong>的一种算法。它的原理是对图进行V-1次<strong>松弛操作</strong>，得到所有可能的最短路径。其优于Dijkstra算法的方面是边的权值可以为<strong>负数</strong>、实现简单，缺点是时间复杂度过高，高达<code>O(VE)</code></p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-3253617aa1280adbe911e9fae4133584_720w.webp" alt="img"></p>
<blockquote>
<p>然后迭代对于起点链接的节点进行松弛</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-b79ce7e33dcee4a3e915bd1d1d2866e7_720w.webp" alt="img"></p>
<blockquote>
<p>每一个节点的距离 - 起点的距离 &#x3D; 和起点的距离</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-f407fdcc6ac680d357f535258e3f12d8_720w.webp" alt="img"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-0b8efc7f4fcf5d767fc7b678c1d08c8c_720w.webp" alt="img"></p>
<p><code>Bllman-Ford </code>算法是一种用于求解带权图中单源最短路径的算法，可以处理负权边，但不能处理负权环。<br> 它的时间复杂度为 <code>O(VE)</code>，其中 V 是顶点数，E是边数。Bellman-Ford 算法的基本思想是对所有的边进行 V-1 轮松弛操作，以求出所有可能的最短路径。如果在第 V轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。</p>
<blockquote>
<p>单源最短路<br>    单源最短路问题是图论中的一个基本问题，它指的是给定一张有权图，如何求某两点之间的最短路径1。解决这个问题的算法有很多，比如Dijkstra算法和Bellman-Ford算法等。</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212846831.png" alt="image-20230304212846831"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304210834724.png" alt="image-20230304210834724"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212028882.png" alt="image-20230304212028882"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>; <span class="comment">// 根据你的需求设置节点数量上限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + n, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 最多执行 n-1 轮松弛操作</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[u] == INF) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">                <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                    d[v] = d[u] + w;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>; <span class="comment">// 如果本轮没有更新，提前退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否存在负权环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] == INF) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在负权环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在负权环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spfa-算法"><a href="#spfa-算法" class="headerlink" title="spfa 算法"></a><a href="https://wat1r.github.io/2020/09/21/spfa-algorithm-master/">spfa 算法</a></h4><blockquote>
<p>何为<code>SPFA（Shortest Path Faster Algorithm）</code>算法:</p>
<p><strong>给定一个加权连通图，选取一个顶点，称为起点，求取起点到其它所有顶点之间的最短距离，其显著特点是可以求含负权图的单源最短路径，且效率较高。（</strong><code>spfa</code>是求单源<a href="http://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">最短路径</a>的一种算法，它还有一个重要的功能是判负环（在差分约束系统中会得以体现），在<a href="http://baike.baidu.com/item/Bellman-ford">Bellman-ford</a>算法的基础上加上一个队列优化，减少了冗余的<a href="http://baike.baidu.com/item/%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C">松弛操作</a>，是一种高效的最短路算法。）</p>
<p><strong><code>spfa算法思想</code>：</strong><code>spfa</code>就是<code>BellmanFord</code>的一种实现方式，其具体不同在于，对于处理松弛操作时，采用了队列（先进先出方式）操作，从而大大降低了时间复杂度</p>
<p>但是<code>spfa</code>容易被卡常数，所以说最差复杂度和BF算法差不多,而且<code>spfa</code>不适用负权环，只适用于负权边。还是推荐用<code>bf</code>算法</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20200921211548307.png" alt="image-20200921211548307.png"></p>
<blockquote>
<p><code>spfa</code>可以用来判断图中是否有环</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212218685.png" alt="image-20230304212218685"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212529352.png" alt="image-20230304212529352"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212738052.png" alt="image-20230304212738052"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//堆优化 bellman 算法 - spfa算法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];<span class="comment">//点集合</span></span><br><span class="line"><span class="type">int</span> d[N],cnt[N],vis[N]; <span class="comment">//边 边数 开关</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,inf,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="comment">//开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集</span></span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; q.<span class="built_in">push</span>(s); </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//这里是将前面初始化的点操作的地方，每次都只操作一个点</span></span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[u] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v , w = ed.w;</span><br><span class="line">            <span class="comment">//比较枚举点和当前点 的长度 更新最短值</span></span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">                d[v] = d[u]+w;</span><br><span class="line">                cnt[v] = cnt[u]+<span class="number">1</span>; <span class="comment">//记录边数</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[v]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法 "></a><a href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd">Floyd算法 </a></h4><p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。</p>
<p>从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p>
<p>从任意节点i到任意节点j的最短路径不外乎2种可能，<strong>1是直接从i到j，2是从i经过若干个节点k到j。</strong>所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查**<code>Dis(i,k) + Dis(k,j) &lt; Dis(i,j)</code><strong>是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置</strong><code>Dis(i,j) = Dis(i,k) + Dis(k,j)</code>**，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<blockquote>
<p>可以用滚动数组，在动态规划会讲解</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307160057133.png" alt="image-20230307160057133"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307160205801.png" alt="image-20230307160205801"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307160839691.png" alt="image-20230307160839691"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）</span></span><br><span class="line"><span class="comment">// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k;k&lt;=n;k++) <span class="comment">//以k为桥(k枚举的是所有点)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">mid</span>(d[i][j],d[i][k]+d[k][j]); <span class="comment">//二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307161152125.png" alt="image-20230307161152125"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//路径记录原理不了解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">fill</span>(d[<span class="number">0</span>],d[<span class="number">0</span>]+N*N,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(d[a][b] &gt; <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307161434260.png" alt="image-20230307161434260"></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308192754299.png" alt="image-20230308192754299"></p>
<blockquote>
<p>Prim算法的基本思路：</p>
<ol>
<li>选择一个起始节点（可以是任意节点），将其加入生成树中，初始化生成树为空。</li>
<li>在每一步中，从已经在生成树中的节点集合出发，选择一个距离生成树最近的节点（即与生成树中的某个节点相邻且权重最小的节点），将其加入生成树中。这个过程重复执行，直到生成树包含了图中的所有节点为止。</li>
<li>最终生成的树就是最小生成树。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有优化版本 - 基于贪心算法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N],vis[N];<span class="comment">//d是边的长度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++) d[i] = inf;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="comment">//排除选过的点 - 这里是选领点的（懂了）</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        ans+=d[u];<span class="comment">//边权和（最小生成树的边权和）</span></span><br><span class="line">        <span class="keyword">if</span>(d[u]!=inf) cnt++; <span class="comment">//判断是否联通</span></span><br><span class="line">        <span class="comment">//遍历到u这个点（u之前的也是一起的，算是连续的）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;w)&#123;</span><br><span class="line">                d[v] = w;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n; <span class="comment">//返回true就是有最小生成树的 返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308110618789.png" alt="image-20230308110618789"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。</span></span><br><span class="line"><span class="type">int</span> n,m,s,a,b,c,ans,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;; <span class="comment">//构造一个结构体 内部有点和边的属性</span></span><br><span class="line">vector&lt;edge&gt; e[N];<span class="comment">//领点（也算是所有点？）</span></span><br><span class="line"><span class="type">int</span> d[N],vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q; <span class="comment">//这里创一个优先队列（就是堆）</span></span><br><span class="line"><span class="comment">//s是起点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++) d[i] = inf; <span class="comment">//先初始化全部的边 - 每个边都是无穷大</span></span><br><span class="line">    <span class="comment">//起点</span></span><br><span class="line">    d[s] = <span class="number">0</span>;q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//取出q队列的点？ - 后面有进入点？</span></span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; </span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        ans+=d[u]; cnt++;</span><br><span class="line">        <span class="comment">//这里应该就是插入 领点的步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;w)&#123;</span><br><span class="line">                d[v] = w; <span class="comment">//对应点v边权最小的边</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-d[v],v&#125;);<span class="comment">//大根堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n; <span class="comment">//这里判断的是啥？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308110724388.png" alt="image-20230308110724388"></p>
<h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><blockquote>
<p>Kruskal算法的基本思路如下：</p>
<ol>
<li>将图中的所有边按照权重从小到大进行排序。</li>
<li>初始化一个空的最小生成树。</li>
<li>从权重最小的边开始，依次考虑每条边，如果该边不会导致生成树中出现环路（即加入这条边后，两个节点已经在同一个连通分量中），就将这条边加入生成树中。</li>
<li>重复步骤3，直到生成树中包含了图中的所有节点，此时最小生成树构建完成。</li>
</ol>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308125205044.png" alt="image-20230308125205044"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308125225033.png" alt="image-20230308125225033"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//结构体存储边的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="comment">//比较函数 （用来作为排序算法的参数）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge x,edge y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);</span><br><span class="line">    <span class="comment">//排序边权（我们是用贪心来筛选的）</span></span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）</span></span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">find</span>(e[i].a),b=<span class="built_in">find</span>(e[i].b),w=e[i].w;</span><br><span class="line">        <span class="comment">//查一下是否是连通块</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            <span class="comment">//纳入后宫</span></span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;  <span class="comment">//成树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);<span class="comment">//输出边权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图*"></a>二分图*</h3><h4 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230314143817025.png" alt="image-20230314143817025"></p>
<blockquote>
<p>以下是染色法的基本思路：</p>
<ol>
<li>选择一个起始节点，将其染成颜色A（可以用0和1表示两种颜色）。</li>
<li>从起始节点开始，对于与其相邻的节点，将其染成颜色B。</li>
<li>继续递归地对与颜色A节点相邻的节点染成颜色B，与颜色B节点相邻的节点染成颜色A。</li>
<li>如果在染色的过程中发现相邻的两个节点已经被染成了相同的颜色，那么图不是二分图。</li>
<li>如果成功染色完所有节点而没有发现相邻节点颜色相同的情况，那么图是二分图。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//染色法判断二分图</span></span><br><span class="line">首先随机选择一个未染色的顶点，将其染成红色或蓝色（或其他任意两种不同颜色）。</span><br><span class="line">然后将与该顶点相邻的所有顶点染成与其不同的颜色。</span><br><span class="line">重复上述过程，直到所有顶点都被染色或者发现某个顶点和它相邻的顶点已经被染成了相同的颜色。</span><br><span class="line">如果所有顶点都被染色，那么这个图就是二分图；如果发现有冲突，那么这个图就不是二分图。</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分图</span></span><br><span class="line">二分图是图论中的一种特殊模型，它的定义是<span class="number">1234</span>：如果一个无向图的顶点集可以分成两个互不相交的子集，使得每条边的两个端点分别属于这两个子集，那么这个无向图就是二分图。例如，下图就是一个二分图：</span><br><span class="line">    A   B   C</span><br><span class="line">    | / | / |</span><br><span class="line">    D   E   F</span><br><span class="line">就是映射是吧，两个不同的集合中有连边，相同集合的不连边</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断此图是否是二分图</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>,M = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[M],idx; <span class="comment">//e是点集 ne是边集</span></span><br><span class="line"><span class="type">int</span> color[N]; <span class="comment">//存储每一个点的状态 一共有三种 起始0 染色 1 - 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a],h[a] = idx++; <span class="comment">//把h[a]理解为前面的桶形数组就好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次访问一个顶点u，就会先递归地访问它的所有邻接点，直到没有未访问的邻接点为止，</span></span><br><span class="line"><span class="comment">//然后再回溯到上一层。这样可以保证每个连通分量内的顶点都被染色。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">//c是什么意思 - 是当前点的染色状态 （只有三种 0 1 2 用3减去就前后不一样了）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i;i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">//邻点</span></span><br><span class="line">        <span class="keyword">if</span>(!color[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//这个是递归地调用dfs函数，给顶点j和它的邻接点染色，并判断是否有冲突。</span></span><br><span class="line">        <span class="comment">//如果返回false，就说明发现了不符合二分图的情况，就返回false。</span></span><br><span class="line">        <span class="comment">//冲突是指同一个子集内的顶点颜色相同，或者不同子集内的顶点颜色不同。</span></span><br><span class="line">        <span class="comment">//这些情况都不满足二分图的定义，所以要返回false。</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果顶点j已经被染色，并且与u的颜色相同，就说明同一个子集内有边相连，不符合二分图的定义，就返回false。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b); <span class="built_in">add</span>(b,a); <span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">           &#123;</span><br><span class="line">               flag = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image-20230314144148781.png" alt="image-20230314144148781"></p>
<p><img src="/image-20230314144232392.png" alt="image-20230314144232392"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>; <span class="comment">// 顶点数的最大值</span></span><br><span class="line"><span class="type">int</span> n1, n2; <span class="comment">// 二分图左右两边的顶点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N]; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> match[N]; <span class="comment">// match[i]表示右边第i个点当前匹配的左边的点</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]表示右边第i个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二分图中寻找增广路</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二分图最大匹配数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">    <span class="type">int</span> m; <span class="comment">// 边数</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 最大匹配数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法*"></a>匈牙利算法*</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230314205307317.png" alt="image-20230314205307317"></p>
<blockquote>
<p>匈牙利算法的基本思路：</p>
<ol>
<li>选择一个未匹配的左侧节点作为起始点，如果所有左侧节点都已经匹配，则说明找到了一个最大匹配。</li>
<li>对于选定的起始点，尝试将其与未匹配的右侧节点进行匹配。如果可以找到一个未匹配的右侧节点与起始点相连接，那么建立这个匹配，否则，尝试改变匹配路径。</li>
<li>如果可以改变匹配路径，就寻找一条增广路径（alternating path），这是一条交替经过匹配边和非匹配边的路径，以尽量多地增加匹配数目。增广路径的搜索通常使用深度优先搜索（DFS）或广度优先搜索（BFS）。</li>
<li>如果找到了增广路径，就根据这条路径来改变匹配，然后返回步骤1，继续查找下一个未匹配的左侧节点。</li>
<li>如果没有找到增广路径，说明已经找到了最大匹配，算法终止。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1.匈牙利算法 - 二分图的最大匹配</span></span><br><span class="line"><span class="comment"> 二分图，简单来说就是不同集合有联系；同一集合不可以有联系； - 边数最多的一组匹配被称之为最大匹配</span></span><br><span class="line"><span class="comment"> 在二分图的前提下： 1.交替路 2.增广路  - 交替路就是匹配和不匹配边交替出现 - 增光路就是匹配和不匹配交换身份，看有没有多路径，多了就是增广路*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>,M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a,b,ans,idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M]; <span class="comment">//点（对应位置的妹子） ne 另一集合的点是吗</span></span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],match[M]; <span class="comment">//标记 和 匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[++idx] = &#123;b,h[a]&#125;;</span><br><span class="line">    h[a] = idx++; <span class="comment">//横置数组向右移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//男女匹配问题 (boy and girl）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//每一个都要匹配看看</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i;i = e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v; <span class="comment">//妹子</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>; <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123; <span class="comment">//没有匹配 || 能不能换（dfs的功能就是判断能不能换）</span></span><br><span class="line">            match[v] = u;<span class="comment">//成对</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++) cin&gt;&gt;a&gt;&gt;b,<span class="built_in">add</span>(a,b); <span class="comment">//建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a><a href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">最近公共祖先</a></h3><h4 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h4><p><img src="/image-20230319121246852.png" alt="image-20230319121246852"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN]; <span class="comment">// 邻接表存储树</span></span><br><span class="line"><span class="type">int</span> depth[MAXN], parent[MAXN]; <span class="comment">// 深度和父亲节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索遍历计算深度和父亲节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[p] + <span class="number">1</span>;</span><br><span class="line">    parent[u] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : tree[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != p) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个节点的最近公共祖先</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (depth[u] &gt; depth[v]) u = parent[u];</span><br><span class="line">    <span class="keyword">while</span> (depth[v] &gt; depth[u]) v = parent[v];</span><br><span class="line">    <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">        u = parent[u];</span><br><span class="line">        v = parent[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 读入节点数和查询数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 读入边</span></span><br><span class="line">        tree[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        tree[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 计算深度和父亲节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 读入查询</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span>(u, v) &lt;&lt; endl; <span class="comment">// 输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">这个模板中，n 是树的节点数，m 是查询数量。对于每组查询，它读入两个节点编号 u 和 v，然后调用函数 <span class="built_in">lca</span>(u,v) 来获取它们的最近公共祖先。</span><br></pre></td></tr></table></figure>

<h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p><img src="/image-20230314144355261.png" alt="image-20230314144355261"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Tarjan算法是由Robert Tarjan发明的一种图算法。它可以用于解决许多不同类型的问题，包括寻找强连通分量、双连通分量、割点和割边等。其中一种应用是在树中查找节点对的最近公共祖先（LCA）。Tarjan算法通过深度优先搜索和并查集数据结构来高效地解决这个问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan算法 ： 利用并查集</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; query[N];</span><br><span class="line"><span class="type">int</span> fa[N],vis[N],ans[M];</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == fa[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    fa[u] = u; <span class="comment">// 初始化父亲为自己</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>; <span class="comment">// 标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            tarjan[v];</span><br><span class="line">            fa[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q:query[u])&#123;</span><br><span class="line">        <span class="type">int</span> v = q.first,i = q.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) ans[i] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树链剖分-不理解"><a href="#树链剖分-不理解" class="headerlink" title="树链剖分(不理解)"></a>树链剖分(不理解)</h4><p><img src="/image-20230315210121556.png" alt="image-20230315210121556"></p>
<p><img src="/image-20230315210610462.png" alt="image-20230315210610462"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],son[N],sz[N];</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">    fa[u] = father, dep[u] = dep[father]+<span class="number">1</span>,sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u]&lt;dep[v]?u:v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="倍增算法（不理解）"><a href="#倍增算法（不理解）" class="headerlink" title="倍增算法（不理解）"></a>倍增算法（不理解）</h4><p><img src="/image-20230315210919875.png" alt="image-20230315210919875"></p>
<p><img src="/image-20230315210938761.png" alt="image-20230315210938761"></p>
<p><img src="/image-20230315210958755.png" alt="image-20230315210958755"></p>
<p><img src="/image-20230315210622550.png" alt="image-20230315210622550"></p>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树*"></a>线段树*</h3><p><img src="/image-20230401100823894.png" alt="image-20230401100823894"></p>
<p><img src="/image-20230401100840271.png" alt="image-20230401100840271"></p>
<p><img src="/image-20230401100850209.png" alt="image-20230401100850209"></p>
<p><img src="/image-20230401100859800.png" alt="image-20230401100859800"></p>
<p><img src="/image-20230401100913730.png" alt="image-20230401100913730"></p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组*"></a>树状数组*</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构 - 简单数据结构</title>
    <url>/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表和数组的区别"><a href="#链表和数组的区别" class="headerlink" title="链表和数组的区别"></a>链表和数组的区别</h2><p><strong>数组</strong> 和 <strong>链表</strong> 之间的主要区别在于它们的结构。数组是基于索引的数据结构，其中每个元素与索引相关联。另一方面，链表 依赖于引用，其中每个节点由数据和对前一个和下一个元素的引用组成。</p>
<ul>
<li><p>数组是数据结构，包含类似类型数据元素的集合，而链表被视为非基元数据结构，包含称为节点的无序链接元素的集合。</p>
</li>
<li><p>在数组中元素属于索引，即，如果要进入第四个元素，则必须在方括号内写入变量名称及其索引或位置。但是，在链接列表中，您必须从头开始并一直工作，直到达到第四个元素。</p>
</li>
<li><p>虽然访问元素数组很快，而链接列表需要线性时间，但速度要慢得多。</p>
</li>
<li><p>数组中插入和删除等操作会占用大量时间。另一方面，链接列表中这些操作的性能很快。</p>
</li>
<li><p>数组具有固定大小。相比之下，链接列表是动态和灵活的，可以扩展和缩小其大小。</p>
</li>
<li><p>在数组中，在编译期间分配内存，而在链接列表中，在执行或运行时分配内存。</p>
</li>
<li><p>元素连续存储在数组中，而它随机存储在链接列表中。</p>
</li>
<li><p>由于实际数据存储在数组中的索引中，因此对内存的要求较少。相反，由于存储了额外的下一个和前一个引用元素，因此链接列表中需要更多内存。</p>
</li>
<li><p>此外，阵列中的内存利用效率低下。相反，内存利用率在阵列中是有效的。    </p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2019-07-20-difference-between-array-and-linked-list-1693299145961-8.jpg" alt="数组和链表的对比"></p>
</li>
</ul>
<p>需要额外说明的是: **即便是排好序的数组，你用二分查找，时间复杂度也是 <code>O(logn)</code>。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**。</p>
<p><strong>如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，触发语言本身的垃圾回收操作。</strong></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230829170835292.png" alt="image-20230829170835292"></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230729150121694.png" alt="image-20230729150121694"></p>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a><a href="https://blog.51cto.com/u_15018701/2616916">单链表</a></h2><blockquote>
<p>定义：链表是一种递归的数据结构，他或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。</p>
</blockquote>
<p>我们来对其解读一下，链表是一种常见且基础的数据结构，是一种线性表，但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址。我们也可以这样理解，链表是通过指针串联在一起的线性结构，每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向null。也就是我们所说的空指针。</p>
<blockquote>
<p>简单的理解（这里忽略计算机内存那些的引用）链表和数组不同的在于他们的索引，数组所用的索引是数组下标，而链表的索引是他们下一个数据的位置。每一个位置存储当前的值和下一个位置的地址</p>
</blockquote>
<p>我们先来看一下链表的可视化表示方法，以便更好的对其理解。一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。我们通过上面说到的可视化表示方法，将单链表可视化，如图所示。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/resize,m_fixed,w_1184.webp" alt="链表看这一篇真的就够了！_java"></p>
<p>下面是实现单链表模板代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next; <span class="comment">// 下一个节点的指针，data 存储的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始构造函数</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Node* head; <span class="comment">// 头指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 头指针默认为nullptr - 刚开始没有数据嘛 - 注意头指针是可以存值的</span></span><br><span class="line">    <span class="built_in">LinkedList</span>() : <span class="built_in">head</span>(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(value);</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node* current = head;</span><br><span class="line">        Node* prev = <span class="literal">nullptr</span>; <span class="comment">// 这里应该是 prev 而不是 prevNode</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历单链表的每一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断当前节点是否为目标节点</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;data == value) &#123;</span><br><span class="line">                <span class="comment">// 删除的位置是头指针</span></span><br><span class="line">                <span class="keyword">if</span> (prev == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    head = current-&gt;next;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 前一个指针指向删除 value 指针的后面</span></span><br><span class="line">                    prev-&gt;next = current-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 保存当前节点的下一个节点</span></span><br><span class="line">                Node* nextNode = current-&gt;next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 释放被删除节点的内存</span></span><br><span class="line">                <span class="keyword">delete</span> current;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 current 指针移动到下一个节点 - 为空</span></span><br><span class="line">                current = nextNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果当前节点不是目标节点，继续遍历下一个节点</span></span><br><span class="line">                prev = current;</span><br><span class="line">                current = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* current = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 打印 current 位置的值</span></span><br><span class="line">            cout &lt;&lt; current-&gt;data &lt;&lt; endl;</span><br><span class="line">            <span class="comment">// 更新 current 的位置</span></span><br><span class="line">            current = current-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedList list;</span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">    list.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">    list.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">display</span>(); <span class="comment">// 输出：7 5 3</span></span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    list.<span class="built_in">display</span>(); <span class="comment">// 输出：7 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不用<a href="https://www.zhihu.com/question/31022750">指针</a>来实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>; <span class="comment">// 假设链表最大节点数为100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> data[MAX_SIZE]; <span class="comment">// 存储节点的值</span></span><br><span class="line"> <span class="type">int</span> next[MAX_SIZE]; <span class="comment">// 存储节点之间的连接关系</span></span><br><span class="line"> <span class="type">int</span> head; <span class="comment">// 头指针，表示链表的头节点的索引</span></span><br><span class="line"> <span class="type">int</span> size; <span class="comment">// 链表的当前大小</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">LinkedList</span>() : <span class="built_in">head</span>(<span class="number">-1</span>), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">     <span class="comment">// 初始化连接关系数组，表示链表为空</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++) &#123;</span><br><span class="line">         next[i] = <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// 创建新节点，并将新节点的值存入数组</span></span><br><span class="line">     data[size] = value;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (head == <span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="comment">// 如果链表为空，将头指针指向新节点</span></span><br><span class="line">         head = size;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 如果链表不为空，将新节点插入到链表的头部</span></span><br><span class="line">         next[size] = head;</span><br><span class="line">         head = size;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     size++; <span class="comment">// 链表大小加1</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> current = head;</span><br><span class="line">     <span class="type">int</span> prev = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (current != <span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (data[current] == value) &#123;</span><br><span class="line">             <span class="keyword">if</span> (prev == <span class="number">-1</span>) &#123;</span><br><span class="line">                 head = next[current];</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 next[prev] = next[current];</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 将当前节点从链表中移除</span></span><br><span class="line">             <span class="comment">// 此处可以根据实际情况进行资源回收，但为了简化示例，不做处理</span></span><br><span class="line">             data[current] = <span class="number">0</span>;</span><br><span class="line">             next[current] = <span class="number">-1</span>;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         prev = current;</span><br><span class="line">         current = next[current];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="type">int</span> current = head;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span> (current != <span class="number">-1</span>) &#123;</span><br><span class="line">         <span class="comment">// 打印当前节点的值</span></span><br><span class="line">         cout &lt;&lt; data[current] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 更新 current 指向下一个节点</span></span><br><span class="line">         current = next[current];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     cout &lt;&lt; endl;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> LinkedList list;</span><br><span class="line"></span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"> list.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line"> list.<span class="built_in">display</span>(); <span class="comment">// 输出：7 5 3</span></span><br><span class="line"></span><br><span class="line"> list.<span class="built_in">remove</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"> list.<span class="built_in">display</span>(); <span class="comment">// 输出：7 3</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>链表的存储方式<br>我们知道了如何构造链表，我们再来说一下链表的存储方式。</p>
<p>我们都知道数组在内存中是连续分布的，但是链表在内存不是连续分配的。链表是通过指针域的指针链接内存中的各个节点。</p>
<p>所以链表在内存中是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。我们可以根据下图来进行理解。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/resize,m_fixed,w_1184-1693299787406-13.webp" alt="链表看这一篇真的就够了！_java_03"></p>
<blockquote>
<p>链表的索引主要是以引用的方式存在，数据主要是在堆中存储。</p>
</blockquote>
<p>下面我们用一道题来说明链表的功能</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230718080352568.png" alt="image-20230718080352568"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用结构体 - 构造链表</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">	<span class="type">int</span> val;</span><br><span class="line">	ListNode* next; <span class="comment">//这个指针</span></span><br><span class="line">	<span class="comment">//结构体的构造函数 - nullptr是空指针常量 就是value赋值val 和 next赋值 </span></span><br><span class="line">	<span class="built_in">ListNode</span>(<span class="type">int</span> value) : <span class="built_in">val</span>(value),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125; </span><br><span class="line">	</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转以链表头开始的 k 个节点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseKGroup</span><span class="params">(ListNode* head, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算链表长度</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保链表长度大于等于 k</span></span><br><span class="line">    <span class="keyword">if</span> (length &lt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode* prev_tail = <span class="literal">nullptr</span>; <span class="comment">// 上一组翻转后的尾节点</span></span><br><span class="line">    ListNode* new_head = <span class="literal">nullptr</span>; <span class="comment">// 新的链表头，用于返回结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head) &#123;</span><br><span class="line">        <span class="type">int</span> count = k;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>; <span class="comment">// 用于翻转链表的前一个节点</span></span><br><span class="line">        ListNode* curr = head; <span class="comment">// 用于翻转链表的当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转当前的 k 个节点</span></span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span> &amp;&amp; curr) &#123;</span><br><span class="line">            ListNode* next_node = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next_node;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果翻转后的尾节点为空，表示当前是第一组翻转，更新新的链表头</span></span><br><span class="line">        <span class="keyword">if</span> (!new_head) &#123;</span><br><span class="line">            new_head = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果上一组翻转后的尾节点不为空，将其连接到当前组的头节点</span></span><br><span class="line">        <span class="keyword">if</span> (prev_tail) &#123;</span><br><span class="line">            prev_tail-&gt;next = prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将上一组翻转后的尾节点更新为当前组的尾节点</span></span><br><span class="line">        prev_tail = head;</span><br><span class="line">        head = curr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current) &#123;</span><br><span class="line">        cout &lt;&lt; current-&gt;val &lt;&lt; <span class="string">&quot; -&gt; &quot;</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    head-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    head-&gt;next-&gt;next-&gt;next-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;原链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printList</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">2</span>; <span class="comment">// 或者其他合适的 k 值</span></span><br><span class="line">    ListNode* reversedHead = <span class="built_in">reverseKGroup</span>(head, k);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;翻转后的链表：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printList</span>(reversedHead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 释放链表内存，防止内存泄漏</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-1693298571267-3.png" alt="双向链表"></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/7c0d280244b244ae9d46d3e9843c9b1dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp" alt="image.png"></p>
<p>在单链表的基础上，往回加一个指针，不说指针了也就是再加一个数组来记录我们的链接方式，这样我们就可以向后检索，两面检索。减少时间。在机制和性质上，和我们的单链表是一样的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l[N], r[N], idx, e[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，设置虚拟头节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    l[<span class="number">0</span>] = <span class="number">-1</span>;      <span class="comment">// 虚拟头节点的左指针为-1，表示不存在左边节点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">0</span>;       <span class="comment">// 虚拟头节点的右指针指向自身，表示链表为空</span></span><br><span class="line">    idx = <span class="number">1</span>;        <span class="comment">// 当前可用的节点索引从1开始（0已被虚拟头节点占用）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在k的右边插入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_right</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;     <span class="comment">// 新节点的值为x</span></span><br><span class="line">    r[idx] = r[k];  <span class="comment">// 新节点的右指针指向k节点原来的右边节点</span></span><br><span class="line">    l[idx] = k;     <span class="comment">// 新节点的左指针指向k节点</span></span><br><span class="line">    l[r[k]] = idx;  <span class="comment">// k节点原来的右边节点的左指针指向新节点</span></span><br><span class="line">    r[k] = idx;     <span class="comment">// k节点的右指针指向新节点，完成插入</span></span><br><span class="line">    idx++;          <span class="comment">// 更新节点索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往k的左边插入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_left</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    e[idx] = x;     <span class="comment">// 新节点的值为x</span></span><br><span class="line">    <span class="keyword">if</span> (l[k] != <span class="number">-1</span>) &#123;</span><br><span class="line">        r[idx] = k;     <span class="comment">// 新节点的右指针指向k节点</span></span><br><span class="line">        l[idx] = l[k];  <span class="comment">// 新节点的左指针指向k节点原来的左边节点</span></span><br><span class="line">        r[l[k]] = idx;  <span class="comment">// k节点原来的左边节点的右指针指向新节点</span></span><br><span class="line">        l[k] = idx;     <span class="comment">// k节点的左指针指向新节点，完成插入</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r[idx] = k;     <span class="comment">// 新节点的右指针指向k节点</span></span><br><span class="line">        l[idx] = <span class="number">-1</span>;    <span class="comment">// 新节点的左指针指向虚拟头节点</span></span><br><span class="line">        l[k] = idx;     <span class="comment">// k节点的左指针指向新节点，完成插入</span></span><br><span class="line">    &#125;</span><br><span class="line">    idx++;          <span class="comment">// 更新节点索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();         <span class="comment">// 初始化链表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">add_right</span>(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// 在虚拟头节点右边插入1，链表变为：0 -&gt; 1  0是虚拟节点 </span></span><br><span class="line">    <span class="built_in">add_left</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 在节点1的左边插入2，链表变为：2 -&gt; 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出链表的值 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = r[<span class="number">0</span>]; i != <span class="number">0</span>; i = r[i]) &#123;</span><br><span class="line">        cout &lt;&lt; e[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出：2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a><a href="https://www.dotcpp.com/course/100">循环链表</a></h2><p>对于单链表以及双向链表，其就像一个小巷，无论怎么样最终都能从一端走到另一端，然而循环链表则像一个有传送门的小巷，因为循环链表当你以为你走到结尾的时候，其实你又回到了开头。</p>
<p>循环链表和非循环链表其实创建的过程以及思路几乎完全一样，唯一不同的是，非循环链表的尾结点指向空（<code>NULL</code>），而循环链表的尾指针指向的是链表的开头。通过将单链表的尾结点指向头结点的链表称之为循环单链表（<code>Circular linkedlist</code>）</p>
<p>如图，为一个完整的循环单链表</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1562924138210258.png" alt="循环链表"></p>
<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a><a href="https://zhuanlan.zhihu.com/p/107808443">循环单链表</a></h3><p>对于循环单链表的结点，可以完全参照于单链表的结点设计，如图：</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1562924163903311.png" alt="单向循环链表结点"></p>
<p>data表示数据，其可以是简单的类型（如int,double等等），也可以是复杂的结构体（struct类型）</p>
<p>next表示指针，它永远指向自身的下一个结点，对于只有一个结点的存在，这个next指针则永远指向自身，对于一个链表的尾部结点，next永远指向开头。</p>
<p>其代码可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">list</span>&#123;</span><br><span class="line">    <span class="type">int</span> data; <span class="comment">//当前位置的值</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">list</span>* next; <span class="comment">//下一个位置的地址</span></span><br><span class="line">&#125;list;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8.png" alt="循环单链表"></p>
<p>如同单链表的创建，我们需要先创建一个头结点并且给其开辟内存空间，但与单链表不同的是，我们需要在开辟内存空间成功之后将头结点的<code>next指向head</code>自身，我们可以创建一个<code>init</code>函数来完成这件事情，为了以后的重复创建和插入，我们可以考虑在<code>init</code>重创建的结点next指向空，而在主函数调用创建之后手动讲head头结点的next指针指向自身。</p>
<p>这样的操作方式可以方便过后的创建单链表，直接利用多次调用的插入函数即可完成整体创建。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始结点</span></span><br><span class="line"><span class="function">list *<span class="title">initlist</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//分配了足够大小以容纳一个 list 类型对象的内存块，并将其起始地址存储在名为 head 的指针变量中。这通常用于创建一个链表数据结构中的头节点。</span></span><br><span class="line">    list *head=(list*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(list));</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建失败，退出程序&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list *head = <span class="built_in">initlist</span>();</span><br><span class="line">    head-&gt;next = head;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1562924267248299.png" alt="循环链表的创建"></p>
<p>我们可以通过逐步的插入操作，创建一个新的节点，将原有链表尾结点的next指针修改指向到新的结点，新的结点的next指针再重新指向头部结点，然后逐步进行这样的插入操作，最终完成整个单项循环链表的创建。</p>
<p>其代码可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建——插入数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insert_list</span><span class="params">(list *head)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> data;   <span class="comment">//插入的数据类型</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入要插入的元素：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;data);</span><br><span class="line">  </span><br><span class="line">    list *node=<span class="built_in">initlist</span>();</span><br><span class="line">    node-&gt;data=data;</span><br><span class="line">    <span class="comment">//初始化一个新的结点，准备进行链接</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span>(head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        list *p=head;</span><br><span class="line">        <span class="comment">//找到最后一个数据</span></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=head)&#123;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;next=node;</span><br><span class="line">        node-&gt;next=head;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;头结点已无元素\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a><a href="https://blog.csdn.net/sum_TW/article/details/61624039?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8=">循环双链表</a></h3><p> 和循环单链表一样，只是多了双链表的属性。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Center.png" alt="img"></p>
<p>双向循环链表初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatList</span><span class="params">(Node** h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* pn=<span class="literal">NULL</span>;<span class="comment">//存储新的节点</span></span><br><span class="line">    Node* p=<span class="literal">NULL</span>;<span class="comment">//头节点的替身</span></span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数据\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">    pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">    pn-&gt;next=<span class="literal">NULL</span>;<span class="comment">//next指向空</span></span><br><span class="line">    pn-&gt;pre=<span class="literal">NULL</span>;<span class="comment">//pre指向空</span></span><br><span class="line">    sum=<span class="number">1</span>;</span><br><span class="line">    *h=pn;</span><br><span class="line">    p=*h;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数据\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建到最后一个节点时，最后一个节点next为头节点</span></span><br><span class="line">            p-&gt;next=*h;</span><br><span class="line">            (*h)-&gt;pre=p;<span class="comment">//头节点的pre为最后一个节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">        p-&gt;next=pn;</span><br><span class="line">        pn-&gt;pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        sum++;<span class="comment">//元素个数++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>插入操作</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5.png" alt="双向循环链表插入"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addFont</span><span class="params">(<span class="type">int</span> d,Node** h)</span><span class="comment">//修改头节点  传入二级指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,n=sum;</span><br><span class="line">    Node* pn=<span class="literal">NULL</span>;</span><br><span class="line">    pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">    Node* p=*h;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p为最后一个节点</span></span><br><span class="line">    pn-&gt;next=*h;<span class="comment">//新节点成为头节点</span></span><br><span class="line">    p-&gt;next=pn;<span class="comment">//最后一个节点p的下一个节点为新节点pn</span></span><br><span class="line">    pn-&gt;pre=p;<span class="comment">//新的头节点的pre为p</span></span><br><span class="line"> </span><br><span class="line">    (*h)-&gt;pre=pn;<span class="comment">//原头节点的前一个节点为新节点</span></span><br><span class="line"> </span><br><span class="line">    *h=pn;<span class="comment">//新节点为头节点</span></span><br><span class="line"> </span><br><span class="line">    sum++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertNode</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> d,Node** h)</span><span class="comment">//在n位置插入d</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((n&lt;<span class="number">1</span>)||(*h==<span class="literal">NULL</span>)||(n&gt;sum))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法||链表为空!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     Node* pn=<span class="built_in">creteNode</span>(d);<span class="comment">//创建新的节点</span></span><br><span class="line">    <span class="comment">//插入位置为1，即插入头节点的位置</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">addFont</span>(d,h);<span class="comment">//调用头插法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addBack</span>(d,*h);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       Node* pf=<span class="built_in">findNode</span>(*h,n<span class="number">-1</span>); <span class="comment">//找到要删除的节点的前一个节点</span></span><br><span class="line">       pn-&gt;next=pf-&gt;next;<span class="comment">//前一个节点的next等于新的节点的next</span></span><br><span class="line">       pf-&gt;next-&gt;pre=pn;<span class="comment">//pf的next节点的pre应该为pn</span></span><br><span class="line">       pf-&gt;next=pn;<span class="comment">//前一个节点的next等于新的节点</span></span><br><span class="line">       pn-&gt;pre=pf;<span class="comment">//新节点的前一个节点为找到的前一个节点pf</span></span><br><span class="line">       sum++;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除操作</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除头节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DelectFont</span><span class="params">(Node** h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//DelectFont(h);</span></span><br><span class="line">    <span class="type">int</span> i, n1=sum;</span><br><span class="line">    Node* p=*h;</span><br><span class="line">    Node* pd=<span class="literal">NULL</span>;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n1<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p为最后一个节点</span></span><br><span class="line">    pd=*h;</span><br><span class="line">    *h=pd-&gt;next;<span class="comment">//头节点的下一个节点成头节点</span></span><br><span class="line">    </span><br><span class="line">    p-&gt;next=*h;<span class="comment">//最后一个节点的next为头节点</span></span><br><span class="line">    </span><br><span class="line">    (*h)-&gt;pre=p;<span class="comment">//pd节点成为了头节点，它的前驱为p</span></span><br><span class="line">    sum--;<span class="comment">//元素个数-1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除第n个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> n,Node** h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int i;//循环变量</span></span><br><span class="line">    <span class="comment">//判断头节点是否为空，位置是不是合法</span></span><br><span class="line">    <span class="keyword">if</span>((*h==<span class="literal">NULL</span>)||(n&lt;<span class="number">1</span>)||(n&gt;sum))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除的链表为空||删除的位置不合法！so 插入失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* pd=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">DelectFont</span>(h);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="comment">//找到要删除的节点的前一个节点</span></span><br><span class="line">    Node* pf=<span class="built_in">findNode</span>(*h,n<span class="number">-1</span>);</span><br><span class="line">    pd=pf-&gt;next;<span class="comment">//将要删除的节点的给pd</span></span><br><span class="line">    pf-&gt;next=pd-&gt;next;<span class="comment">//将删除元素的前一个的next指向删除元素的后一个元素</span></span><br><span class="line">    pd-&gt;pre=<span class="literal">NULL</span>;<span class="comment">//pd的pre指向空</span></span><br><span class="line">   </span><br><span class="line">    pd-&gt;next-&gt;pre=pf;<span class="comment">//将删除元素的后一个元素的前驱给pf</span></span><br><span class="line">    pd-&gt;next=<span class="literal">NULL</span>;<span class="comment">//pdnext指向空</span></span><br><span class="line">    sum--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* next;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">node</span>* pre;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> Node;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE sizeof(Node)</span></span><br><span class="line"><span class="type">int</span> sum;<span class="comment">//节点个数</span></span><br><span class="line"> </span><br><span class="line"><span class="function">Node* <span class="title">creteNode</span><span class="params">(<span class="type">int</span> d)</span></span>;<span class="comment">//创建节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatList</span><span class="params">(Node** h)</span>；<span class="comment">//创建链表</span></span></span><br><span class="line"><span class="function">Node* <span class="title">findNode</span><span class="params">(Node* h,<span class="type">int</span> n)</span>；<span class="comment">//查找某个节点的位置</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addBack</span><span class="params">(<span class="type">int</span> d,Node* h)</span>；<span class="comment">//末尾增加一个新的节点</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addFont</span><span class="params">(<span class="type">int</span> d,Node** h)</span>；<span class="comment">//修改头节点  传入二级指针</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertNode</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> d,Node** h)</span>；<span class="comment">//在n位置插入d</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DelectFont</span><span class="params">(Node** h)</span></span>;<span class="comment">//删除头节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> n,Node** h)</span></span>;<span class="comment">//删除第n个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Node* h)</span></span>;<span class="comment">//打印链表</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建节点</span></span><br><span class="line"><span class="function">Node* <span class="title">creteNode</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* pn=(Node*)<span class="built_in">malloc</span>(SIZE);</span><br><span class="line">    pn-&gt;data=d;</span><br><span class="line">    pn-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    pn-&gt;pre=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pn;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">creatList</span><span class="params">(Node** h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* pn=<span class="literal">NULL</span>;<span class="comment">//存储新的节点</span></span><br><span class="line">    Node* p=<span class="literal">NULL</span>;<span class="comment">//头节点的替身</span></span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数据\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">    pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">    pn-&gt;next=<span class="literal">NULL</span>;<span class="comment">//next指向空</span></span><br><span class="line">    pn-&gt;pre=<span class="literal">NULL</span>;<span class="comment">//pre指向空</span></span><br><span class="line">    sum=<span class="number">1</span>;</span><br><span class="line">    *h=pn;</span><br><span class="line">    p=*h;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入数据\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line">        <span class="keyword">if</span>(d==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建到最后一个节点时，最后一个节点next为头节点</span></span><br><span class="line">            p-&gt;next=*h;</span><br><span class="line">            (*h)-&gt;pre=p;<span class="comment">//头节点的pre为最后一个节点</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">        p-&gt;next=pn;</span><br><span class="line">        pn-&gt;pre=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        sum++;<span class="comment">//元素个数++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//查找某个节点的位置</span></span><br><span class="line"><span class="function">Node* <span class="title">findNode</span><span class="params">(Node* h,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>((h==<span class="literal">NULL</span>)||(n&lt;<span class="number">0</span>)||(n&gt;sum))</span><br><span class="line">    &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;查找位置不合法||链表为空！\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        h=h-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="comment">//末尾增加一个新的节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addBack</span><span class="params">(<span class="type">int</span> d,Node* h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,n=sum;</span><br><span class="line">    Node *pn=<span class="literal">NULL</span>;</span><br><span class="line">    pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">    Node* p=h;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时的p指向了最后一个元素</span></span><br><span class="line">    p-&gt;next=pn;<span class="comment">//最后一个节点p的next为新节点</span></span><br><span class="line">    pn-&gt;pre=p;<span class="comment">//新节点的前一个节点为p</span></span><br><span class="line">    pn-&gt;next=h;<span class="comment">//pn的最后一个节点为头节点</span></span><br><span class="line">    h-&gt;pre=pn;<span class="comment">//头节点的pre为新节点</span></span><br><span class="line">    sum++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addFont</span><span class="params">(<span class="type">int</span> d,Node** h)</span><span class="comment">//修改头节点  传入二级指针</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,n=sum;</span><br><span class="line">    Node* pn=<span class="literal">NULL</span>;</span><br><span class="line">    pn=<span class="built_in">creteNode</span>(d);</span><br><span class="line">    Node* p=*h;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//p为最后一个节点</span></span><br><span class="line">    pn-&gt;next=*h;<span class="comment">//新节点成为头节点</span></span><br><span class="line">    p-&gt;next=pn;<span class="comment">//最后一个节点p的下一个节点为新节点pn</span></span><br><span class="line">    pn-&gt;pre=p;<span class="comment">//新的头节点的pre为p</span></span><br><span class="line"> </span><br><span class="line">    (*h)-&gt;pre=pn;<span class="comment">//原头节点的前一个节点为新节点</span></span><br><span class="line"> </span><br><span class="line">    *h=pn;<span class="comment">//新节点为头节点</span></span><br><span class="line"> </span><br><span class="line">    sum++;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertNode</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> d,Node** h)</span><span class="comment">//在n位置插入d</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((n&lt;<span class="number">1</span>)||(*h==<span class="literal">NULL</span>)||(n&gt;sum))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;插入位置不合法||链表为空!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     Node* pn=<span class="built_in">creteNode</span>(d);<span class="comment">//创建新的节点</span></span><br><span class="line">    <span class="comment">//插入位置为1，即插入头节点的位置</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">addFont</span>(d,h);<span class="comment">//调用头插法</span></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==sum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addBack</span>(d,*h);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       Node* pf=<span class="built_in">findNode</span>(*h,n<span class="number">-1</span>); <span class="comment">//找到要删除的节点的前一个节点</span></span><br><span class="line">       pn-&gt;next=pf-&gt;next;<span class="comment">//前一个节点的next等于新的节点的next</span></span><br><span class="line">       pf-&gt;next-&gt;pre=pn;<span class="comment">//pf的next节点的pre应该为pn</span></span><br><span class="line">       pf-&gt;next=pn;<span class="comment">//前一个节点的next等于新的节点</span></span><br><span class="line">       pn-&gt;pre=pf;<span class="comment">//新节点的前一个节点为找到的前一个节点pf</span></span><br><span class="line">       sum++;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除头节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DelectFont</span><span class="params">(Node** h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//DelectFont(h);</span></span><br><span class="line">    <span class="type">int</span> i, n1=sum;</span><br><span class="line">    Node* p=*h;</span><br><span class="line">    Node* pd=<span class="literal">NULL</span>;;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n1<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//p为最后一个节点</span></span><br><span class="line">    pd=*h;</span><br><span class="line">    *h=pd-&gt;next;<span class="comment">//头节点的下一个节点成头节点</span></span><br><span class="line">    </span><br><span class="line">    p-&gt;next=*h;<span class="comment">//最后一个节点的next为头节点</span></span><br><span class="line">    </span><br><span class="line">    (*h)-&gt;pre=p;<span class="comment">//pd节点成为了头节点，它的前驱为p</span></span><br><span class="line">    sum--;<span class="comment">//元素个数-1</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//删除第n个位置的元素</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">deleteNode</span><span class="params">(<span class="type">int</span> n,Node** h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int i;//循环变量</span></span><br><span class="line">    <span class="comment">//判断头节点是否为空，位置是不是合法</span></span><br><span class="line">    <span class="keyword">if</span>((*h==<span class="literal">NULL</span>)||(n&lt;<span class="number">1</span>)||(n&gt;sum))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;删除的链表为空||删除的位置不合法！so 插入失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node* pd=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//删除头节点</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">DelectFont</span>(h);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="comment">//找到要删除的节点的前一个节点</span></span><br><span class="line">    Node* pf=<span class="built_in">findNode</span>(*h,n<span class="number">-1</span>);</span><br><span class="line">    pd=pf-&gt;next;<span class="comment">//将要删除的节点的给pd</span></span><br><span class="line">    pf-&gt;next=pd-&gt;next;<span class="comment">//将删除元素的前一个的next指向删除元素的后一个元素</span></span><br><span class="line">    pd-&gt;pre=<span class="literal">NULL</span>;<span class="comment">//pd的pre指向空</span></span><br><span class="line">   </span><br><span class="line">    pd-&gt;next-&gt;pre=pf;<span class="comment">//将删除元素的后一个元素的前驱给pf</span></span><br><span class="line">    pd-&gt;next=<span class="literal">NULL</span>;<span class="comment">//pdnext指向空</span></span><br><span class="line">    sum--;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Node* h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i,n=sum;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;list:\n&quot;</span>);</span><br><span class="line">    Node* p=h;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;正序遍历：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;data);</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面遍历到第一个节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;反序遍历：\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,p-&gt;pre-&gt;data);</span><br><span class="line">        p=p-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node* head=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">creatList</span>(&amp;head);</span><br><span class="line">    <span class="built_in">deleteNode</span>(<span class="number">2</span>,&amp;head);</span><br><span class="line">    <span class="built_in">print</span>(head);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a><a href="https://zhuanlan.zhihu.com/p/45798936">队列</a></h2><p>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。</p>
<p>而且队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。</p>
<p>解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p>
<blockquote>
<p>什么是<a href="https://www.dotcpp.com/course/107">假溢出</a>？打一个比方：</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1564998238118812.png" alt="顺序队列">（示例顺序队列)</p>
<p>回顾一下队列的性质，首先我们有一个顺序队列，这个队列的大小为5，其已经包含了四个元素<code>data1,data2,data3,data4,</code>接着，我们对这个队列进行出队操作，出队2个元素，队列就变成了这个样子：</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1564998282898186.png" alt="顺序队列2"></p>
<p>目前看起来没有问题，那么我们接着再进行入队操作，我们入队2个元素，分别是<code>data5和data6</code>，此时我们已经发现问题了，尾指针移动到我们可以进行队列操作的范围之外去了，我们称呼作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为”假溢出”。</p>
</blockquote>
<p>队列和游标卡尺差不多，就是一个区间和线段组成的数据类型</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%98%9F%E5%88%97.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明变量 队列的性质就是先进先出</span></span><br><span class="line"><span class="type">int</span> q[N],hh,tt;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">q[++tt];<span class="comment">//hh是头（头是向右边移动的） tt是转移元素的变量（tt是新入队的成员）</span></span><br><span class="line"><span class="comment">//可以将 hh 和 tt看做是一个区间</span></span><br><span class="line">hh++<span class="comment">//pop</span></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line">  <span class="keyword">if</span>(hh&lt;=tt) <span class="keyword">not</span> empty</span><br><span class="line">  <span class="keyword">else</span> empty;</span><br><span class="line"><span class="comment">//取出队头元素</span></span><br><span class="line">q[hh];</span><br></pre></td></tr></table></figure>

<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><p>在中学的时候，我们会学一种函数的性质，叫做单调性。单调性是指，在一个区间内部我们可以预测这个数据类型的运行方向。那么显而易见的，单调队列指的是，我们可以预计和控制这个数据类型的运行方向。</p>
<p>队列的性质上面有提到，是一种先进先出的数据结构。我们可以利用这个结构，做一个可动的队列或者说，让数据集通过我们的队列，在通过的时候记录他们的数据变化。这样的操作，就叫做单调队列。</p>
<p>以一个较简单的例子：滑动窗口，大概题意就是，有一个数据条，需要通过我们的窗口（队列），通过的时候记录这个时候队列的最大值和最小值（或者别的什么东西 - 变化一下题目嘛）。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230504225237230.png" alt="滑动窗口"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维护窗口</span></span><br><span class="line"><span class="type">int</span> h = <span class="number">1</span>,t = <span class="number">0</span>; <span class="comment">//清空队列</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;;i&lt;=n;i++)&#123; <span class="comment">//枚举数据集</span></span><br><span class="line">    <span class="keyword">while</span>(h&lt;=t &amp;&amp; a[q[t]]&gt;=a[i]) t--;<span class="comment">//队尾出队</span></span><br><span class="line">    q[++t] = i;<span class="comment">//队尾入队</span></span><br><span class="line">    <span class="keyword">if</span>(q[h]&lt;i-k+<span class="number">1</span>) h++;<span class="comment">//对头出队（滑出窗口）</span></span><br><span class="line">    <span class="keyword">if</span>(i&gt;=k) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[h]]);<span class="comment">//打印最值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230504230354394.png" alt="维护窗口最小值"></p>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/v2-c21942aff1bebe48296dacca04a3ef5b_720w.webp" alt="img"></p>
<p>原理是和队列是一样的，区别可以从两个方向对数据进行插入或者删除，双端队列使用双链表实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体，存储位置和变量值</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;      <span class="comment">// 存储数据的变量值</span></span><br><span class="line">    <span class="type">int</span> pre, next; <span class="comment">// pre和next分别表示前一个节点和后一个节点的索引</span></span><br><span class="line">&#125; node[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx, head, tail;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化，设置虚拟头尾节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = <span class="number">0</span>;        <span class="comment">// 虚拟头节点的索引，它不存储数据</span></span><br><span class="line">    tail = <span class="number">1</span>;        <span class="comment">// 虚拟尾节点的索引，它不存储数据</span></span><br><span class="line">    node[head].next = tail;    <span class="comment">// 头节点的下一个节点是尾节点</span></span><br><span class="line">    node[tail].pre = head;     <span class="comment">// 尾节点的前一个节点是头节点</span></span><br><span class="line">    idx = <span class="number">2</span>;          <span class="comment">// 当前可用的节点索引从2开始，因为0和1被头尾节点占用了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队头插入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    node[idx].val = x;   <span class="comment">// 将数据x存储到新节点中</span></span><br><span class="line">    node[idx].pre = head;    <span class="comment">// 新节点的前一个节点是头节点</span></span><br><span class="line">    node[idx].next = node[head].next;   <span class="comment">// 新节点的下一个节点是原头节点的下一个节点</span></span><br><span class="line">    node[head].next = idx;    <span class="comment">// 更新头节点的下一个节点为新节点</span></span><br><span class="line">    node[node[idx].next].pre = idx;   <span class="comment">// 更新原头节点的下一个节点的前一个节点为新节点</span></span><br><span class="line">    idx++;          <span class="comment">// 更新节点索引，为下次插入做准备</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在队尾插入数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    node[idx].val = x;    <span class="comment">// 将数据x存储到新节点中</span></span><br><span class="line">    node[idx].pre = node[tail].pre;   <span class="comment">// 新节点的前一个节点是原尾节点的前一个节点</span></span><br><span class="line">    node[idx].next = tail;   <span class="comment">// 新节点的下一个节点是尾节点</span></span><br><span class="line">    node[tail].pre = idx;    <span class="comment">// 更新尾节点的前一个节点为新节点</span></span><br><span class="line">    node[node[idx].pre].next = idx;   <span class="comment">// 更新原尾节点的前一个节点的下一个节点为新节点</span></span><br><span class="line">    idx++;          <span class="comment">// 更新节点索引，为下次插入做准备</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node[head].next != tail) &#123;   <span class="comment">// 确保队列非空</span></span><br><span class="line">        <span class="type">int</span> to_delete = node[head].next;   <span class="comment">// 获取要删除的节点索引</span></span><br><span class="line">        node[head].next = node[to_delete].next;   <span class="comment">// 更新头节点的下一个节点为要删除节点的下一个节点</span></span><br><span class="line">        node[node[to_delete].next].pre = head;   <span class="comment">// 更新要删除节点的下一个节点的前一个节点为头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队尾弹出数据</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop_back</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node[tail].pre != head) &#123;   <span class="comment">// 确保队列非空</span></span><br><span class="line">        <span class="type">int</span> to_delete = node[tail].pre;   <span class="comment">// 获取要删除的节点索引</span></span><br><span class="line">        node[tail].pre = node[to_delete].pre;   <span class="comment">// 更新尾节点的前一个节点为要删除节点的前一个节点</span></span><br><span class="line">        node[node[to_delete].pre].next = tail;   <span class="comment">// 更新要删除节点的前一个节点的下一个节点为尾节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出双端队列的值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_deque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = node[head].next; i != tail; i = node[i].next) &#123;</span><br><span class="line">        cout &lt;&lt; node[i].val &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">// 依次输出双端队列中的元素值</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();         <span class="comment">// 初始化双端队列</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">push_back</span>(<span class="number">1</span>);   <span class="comment">// 队列变为：1</span></span><br><span class="line">    <span class="built_in">push_front</span>(<span class="number">2</span>);  <span class="comment">// 队列变为：2 1</span></span><br><span class="line">    <span class="built_in">push_back</span>(<span class="number">3</span>);   <span class="comment">// 队列变为：2 1 3</span></span><br><span class="line">    <span class="built_in">pop_front</span>();    <span class="comment">// 队列变为：1 3</span></span><br><span class="line">    <span class="built_in">push_back</span>(<span class="number">4</span>);   <span class="comment">// 队列变为：1 3 4</span></span><br><span class="line">    <span class="built_in">pop_back</span>();     <span class="comment">// 队列变为：1 3</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print_deque</span>();  <span class="comment">// 输出：1 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="随机链表"><a href="#随机链表" class="headerlink" title="随机链表"></a><a href="https://zhuanlan.zhihu.com/p/100388274">随机链表</a></h2><p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/list.png" alt="list"></p>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a><a href="https://zhuanlan.zhihu.com/p/346164833">栈</a></h2><p>栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。</p>
<p>而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。</p>
<p>堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88.png" alt="栈"></p>
<p>用我们的数组实现的栈，最关键的点在于：我们是否可以直接不管我们插入栈的数据。 栈的原理就是 先进后出。那么我们只要声明一个数组就可以实现这个功能</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用数组实现栈功能</span></span><br><span class="line"><span class="comment">//栈 和 操作栈的变量</span></span><br><span class="line"><span class="type">int</span> stk[N],tt;<span class="comment">//变量用来控制我们的栈的容量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入栈的数据</span></span><br><span class="line">stk[++tt] = x;</span><br><span class="line"><span class="comment">//pop弹出 这样的数据会直接消失 记得保存stk[kk] 栈顶数据 </span></span><br><span class="line">tt--; </span><br><span class="line"><span class="comment">//判断栈顶是否为空 (这里是伪代码)</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>) no empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[kk]</span><br><span class="line">  </span><br><span class="line"><span class="comment">//总结 </span></span><br><span class="line">    栈的作用就是实现两个操作 <span class="number">1.</span>压栈 <span class="number">2.</span>弹栈 - 压栈的操作在用数组实现的时候，我们可以理解 竖向数组的增高（但实际上在现实中更像手枪压弹夹一样）弹栈 - 就是去顶（更像手枪把子弹打出去）</span><br><span class="line"> 通常，声明一个栈的时候，我们会用一个变量来维护我们这个栈。 这个变量起到实现上述两个操作的作用 - 例如： h[N]是我们的一个栈 top是我们维护栈的变量</span><br><span class="line"> 那么： push操作就是 h[++top] = <span class="built_in">a</span>(你塞入的子弹)；pop操作就是  top--;</span><br><span class="line"><span class="built_in">query</span>(栈头) h[top] <span class="comment">//重点是插入的时候是先 ++ 在赋值位置的 这样可以保证沉底</span></span><br><span class="line"><span class="comment">//stl中的栈</span></span><br><span class="line"> &lt;stack&gt; 是栈的头文件名称，用的时候声明一下就好了。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>栈的应用——递归</p>
<p>在高级语言中，调用自己和其它函数没有本质的不同。我们把一个直接用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。每个递归函数必须至少有一个条件，满足时递归不再执行，即不再引用自身而是返回值退出。</p>
<p>递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。 递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。</p>
<p>在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。</p>
</blockquote>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a><a href="https://juejin.cn/post/7134880984528814110">堆</a></h2><p>堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：<br> （1）堆中某个节点的值总是不大于或不小于其父节点的值；<br> （2）堆总是一棵完全二叉树。</p>
<p>堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。</p>
<p>堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91.webp" alt="优先队列"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 定义堆的最大容量 </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">100</span>; </span><br><span class="line"><span class="comment">// 定义堆的数据结构 </span></span><br><span class="line"><span class="type">int</span> heap[MAX_SIZE]; </span><br><span class="line"><span class="type">int</span> heapSize; </span><br><span class="line"><span class="comment">// 向堆中插入一个元素 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> data)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 如果堆已满，则不能插入 </span></span><br><span class="line">    <span class="keyword">if</span> (heapSize == MAX_SIZE) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// 将新元素插入到堆的末尾 </span></span><br><span class="line">    heap[heapSize] = data; </span><br><span class="line">    heapSize++; </span><br><span class="line">    <span class="comment">// 将新元素上浮到正确的位置 </span></span><br><span class="line">    <span class="type">int</span> current = heapSize - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (current != <span class="number">0</span> &amp;&amp; heap[current] &gt; heap[(current - <span class="number">1</span>) / <span class="number">2</span>]) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> temp = heap[(current - <span class="number">1</span>) / <span class="number">2</span>]; </span><br><span class="line">        heap[(current - <span class="number">1</span>) / <span class="number">2</span>] = heap[current]; </span><br><span class="line">        heap[current] = temp; </span><br><span class="line">        current = (current - <span class="number">1</span>) / <span class="number">2</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 从堆中删除一个元素 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteElement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 如果堆为空，则不能删除 </span></span><br><span class="line">    <span class="keyword">if</span> (heapSize == <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// 将堆的最后一个元素放到堆顶 </span></span><br><span class="line">    heap[<span class="number">0</span>] = heap[heapSize - <span class="number">1</span>]; </span><br><span class="line">    heapSize--; </span><br><span class="line">    <span class="comment">// 将堆顶元素下沉到正确的位置 </span></span><br><span class="line">    <span class="type">int</span> current = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">while</span> (current * <span class="number">2</span> + <span class="number">1</span> &lt; heapSize) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="type">int</span> largest = current; </span><br><span class="line">        <span class="keyword">if</span> (heap[largest] &lt; heap[current * <span class="number">2</span> + <span class="number">1</span>]) </span><br><span class="line">            largest = current * <span class="number">2</span> + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (current * <span class="number">2</span> + <span class="number">2</span> &lt; heapSize &amp;&amp; heap[largest] &lt; heap[current * <span class="number">2</span> + <span class="number">2</span>]) </span><br><span class="line">            largest = current * <span class="number">2</span> + <span class="number">2</span>; </span><br><span class="line">        <span class="keyword">if</span> (largest == current) </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="type">int</span> temp = heap[current]; </span><br><span class="line">        heap[current] = heap[largest]; </span><br><span class="line">        heap[largest] = temp; </span><br><span class="line">        current = largest; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 初始化堆 </span></span><br><span class="line">    heapSize = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 向堆中插入元素 </span></span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">10</span>); </span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">20</span>); </span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">30</span>); </span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">40</span>); </span><br><span class="line">    <span class="built_in">insert</span>(<span class="number">50</span>); </span><br><span class="line">    <span class="comment">// 从堆中删除元素 </span></span><br><span class="line">    <span class="built_in">deleteElement</span>(); </span><br><span class="line">    <span class="comment">// 输出堆中的元素 </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heapSize; i++) </span><br><span class="line">        cout &lt;&lt; heap[i] &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    cout &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对堆栈的理解"><a href="#对堆栈的理解" class="headerlink" title="对堆栈的理解"></a><a href="https://zhuanlan.zhihu.com/p/78478567">对堆栈的理解</a></h2><blockquote>
<p>一、预备知识—程序的内存分配</p>
<p>一个由C&#x2F;C++编译的程序占用的内存分为以下几个部分<br>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其<br>操作方式类似于数据结构中的栈。<br>2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回<br>收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。<br>3、全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的<br>全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另<br>一块区域。 - 程序结束后由系统释放。<br>4、文字常量区 —常量字符串就是放在这里的。 程序结束后由系统释放<br>5、程序代码区—存放函数体的二进制代码。</p>
</blockquote>
<p><strong>例子程序</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.cpp    </span></span><br><span class="line">  <span class="type">int</span>   a   =   <span class="number">0</span>;   全局初始化区    </span><br><span class="line">  <span class="type">char</span>   *p1;   全局未初始化区    </span><br><span class="line">  <span class="built_in">main</span>()    </span><br><span class="line">  &#123;    </span><br><span class="line">  <span class="type">int</span>   b;   栈    </span><br><span class="line">  <span class="type">char</span>   s[]   =   <span class="string">&quot;abc&quot;</span>;   栈    </span><br><span class="line">  <span class="type">char</span>   *p2;   栈    </span><br><span class="line">  <span class="type">char</span>   *p3   =   <span class="string">&quot;123456&quot;</span>;   <span class="number">123456</span>/<span class="number">0</span>在常量区，p3在栈上。    </span><br><span class="line">  <span class="type">static</span>   <span class="type">int</span>   c   =<span class="number">0</span>；   全局（静态）初始化区    </span><br><span class="line">  p1   =   (<span class="type">char</span>   *)<span class="built_in">malloc</span>(<span class="number">10</span>);    </span><br><span class="line">  p2   =   (<span class="type">char</span>   *)<span class="built_in">malloc</span>(<span class="number">20</span>);    </span><br><span class="line">  分配得来得<span class="number">10</span>和<span class="number">20</span>字节的区域就在堆区。    </span><br><span class="line">  <span class="built_in">strcpy</span>(p1,   <span class="string">&quot;123456&quot;</span>);   <span class="number">123456</span>/<span class="number">0</span>放在常量区，编译器可能会将它与p3所指向的<span class="string">&quot;123456&quot;</span>  </span><br><span class="line">  优化成一个地方。    </span><br><span class="line">  &#125;    </span><br></pre></td></tr></table></figure>

<p>二、堆和栈的理论知识<br>2.1申请方式<br><code>stack</code>:<br>由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空<br>间</p>
<p><code>heap</code>:<br>需要程序员自己申请，并指明大小，在c中<code>malloc</code>函数<br>如<code>p1 = (char *)malloc(10);</code><br>在C++中用<code>new</code>运算符<br>如<code>p2 = new char[10];</code><br>但是注意<code>p1、p2</code>本身是在栈中的。</p>
<p>2.2 申请后系统的响应<br>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢<br>出。</p>
<p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，<br>会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表<br>中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的<br>首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。<br>另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部<br>分重新放入空闲链表中。</p>
<p>2.3申请大小的限制<br>栈：在<code>Windows</code>下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意<br>思是栈顶的地址和栈的最大容量是系统预先规定好的，在<code>WINDOWS</code>下，栈的大小是2M（也有的说是<code>1M</code>，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示<code>overflow</code>。因此，能从栈获得的空间较小。</p>
<p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储<br>的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小<br>受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p>
<p>2.4申请效率的比较：<br>栈由系统自动分配，速度较快。但程序员是无法控制的。<br>堆是由<code>new</code>分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.<br>另外，在<code>WINDOWS</code>下，最好的方式是用<code>VirtualAlloc</code>分配内存，他不是在堆，也不是在栈是<br>直接在进程的地址空间中保留一块内存，虽然用起来最不方便。但是速度快，也最灵活。</p>
<p>2.5堆和栈中的存储内容<br>栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可<br>执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈<br>的，然后是函数中的局部变量。注意静态变量是不入栈的。<br>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地<br>址，也就是主函数中的下一条指令，程序由该点继续运行。<br>堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。</p>
<p>2.6存取效率的比较</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">  <span class="type">char</span>   s1[]   =   <span class="string">&quot;aaaaaaaaaaaaaaa&quot;</span>;    </span><br><span class="line">  <span class="type">char</span>   *s2   =   <span class="string">&quot;bbbbbbbbbbbbbbbbb&quot;</span>;    </span><br><span class="line">  aaaaaaaaaaa是在运行时刻赋值的；    </span><br><span class="line">  而bbbbbbbbbbb是在编译时就确定的；    </span><br><span class="line">  但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。    </span><br><span class="line">  比如：    </span><br><span class="line">  <span class="meta">#<span class="keyword">include</span>    </span></span><br><span class="line">  <span class="function"><span class="type">void</span>   <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">  </span>&#123;    </span><br><span class="line">  <span class="type">char</span>   a   =   <span class="number">1</span>;    </span><br><span class="line">  <span class="type">char</span>   c[]   =   <span class="string">&quot;1234567890&quot;</span>;    </span><br><span class="line">  <span class="type">char</span>   *p   =<span class="string">&quot;1234567890&quot;</span>;    </span><br><span class="line">  a   =   c[<span class="number">1</span>];    </span><br><span class="line">  a   =   p[<span class="number">1</span>];    </span><br><span class="line">  <span class="keyword">return</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">对应的汇编代码</span><br></pre></td></tr></table></figure>

<blockquote>
<p>10: a &#x3D; c[1];<br>00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]<br>0040106A 88 4D FC mov byte ptr [ebp-4],cl<br>11: a &#x3D; p[1];<br>0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]<br>00401070 8A 42 01 mov al,byte ptr [edx+1]<br>00401073 88 45 FC mov byte ptr [ebp-4],al</p>
</blockquote>
<p>第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到<br><code>edx</code>中，再根据<code>edx</code>读取字符，显然慢了。</p>
<p>2.7小结：<br>堆和栈的区别可以用如下的比喻来看出：<br>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就<br>走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自<br>由度小。<br>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由<br>度大。 (经典！)</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><p>并查集是一种树形的数据结构，支持两种操作，并：将两个不同的元素合并成一个集合；查：查找一个数据的所在集合</p>
<p>在模拟树状结构的时候，fa[x]存储的是节点的父节点，可以理解为特定集合的编号。这里的x和赋值给f[x]的值的关系，可以理解为<strong>节点和父节点连接</strong>的关系。初始化的时候，将每一个节点编号都初始化为自己(自己为一个集合)。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230503221426175.png" alt="并查集"></p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a><strong>查找</strong></h3><p>可以理解为顺着当前节点向上爬，找到我们当前集合的根节点。但实际上，我们并不是这样做，我们可以将这个操作进行优化，我们在找根节点的过程，可以顺便将每一个经过的节点的<strong>“父节点”都改为我们的“根节点”</strong>，一个查找循环下来，整一个集合的值都是我们的，根节点（也就是我们当前集合编号），下面是代码解释。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230503222836310.png" alt="路径压缩"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//未用路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果当前这个节点指向的是根节点，说明我们找到了目标集合，返回就行。</span></span><br><span class="line"> 	<span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="comment">//如果不是，那就递归查找，直到找到我们的目标集合（一定找得到）。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(fa[x]); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用路径压缩</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(f[a]); <span class="comment">//这里就是给路过的节点赋值 - 用的是递归</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a><strong>合并</strong></h3><p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230503224008918.png" alt="合并"></p>
<p>合并操作，可以理解为两个集合的根节点指向即可。这里举个例子，A集合和B集合，那么B集合序号指向A集合序号即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并代码</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unionset</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="comment">//将x的集合编号，赋值成y的集合编号</span></span><br><span class="line">    <span class="comment">//如果再次路径压缩，那么所有x集合的编号都会变成y的编号</span></span><br><span class="line">    fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，这样合并可以进行优化，我们可以这样想，如果我们合并两个集合的数量级不在一个级别上，比如一个集合元素个数为2，一个集合元素个数为<code>2e^10</code>，这样将集合元素为2的集合作为新集合的标号，确实不太合适。所以说，我们可以直接给每一个集合标记他们的元素数量，然后对其进行合并即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">siz</span><span class="params">(N,<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">unioset</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    x = <span class="built_in">find</span>(x),y = <span class="built_in">find</span>(y); <span class="comment">//找到各自的集合编号</span></span><br><span class="line">    <span class="keyword">if</span>(x == y) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(siz[x]&gt;siz[y]) <span class="built_in">swap</span>(x,y);<span class="comment">//判断哪个集合更大</span></span><br><span class="line">    fa[x] = y;<span class="comment">//小集合指向大集合</span></span><br><span class="line">    siz[y]+=siz[x]; <span class="comment">//合并一个大集合要加数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230503230130914.png" alt="并查集的变化"></p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p>
<p>Trie的核心思想是空间换时间。利用字符串的<strong>公共前缀</strong>来降低查询时间的开销以达到提高效率的目的。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230504131211298.png" alt="字典树"></p>
<h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p>Trie树，就是利用字符串的相同前缀，来节省我们查找的时间。这个树的根没有意义，只是为了构造这个树存在。可以说，根衔接的都是一个独立的单词（子树）。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230504132336132.png" alt="字典树"></p>
<p>我们可以想象一下，在一个根下面链接一个一个单词会是什么样子，是不是像一个拂尘一样。我们可以在这个基础之上，对这些单词进行处理：单词是由26个字母排列组合成的，所以说不管单词怎么变，肯定有些单词的前缀是相等的。例如：appear 和 apple。这两个前缀相同，那么我们就可以让”app”为同一支，从p分出两个枝e和p。（当然分支最多26个）以此类推构建字典树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字典树构造</span></span><br><span class="line"><span class="type">char</span> s[N]</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> ch[N][<span class="number">26</span>];<span class="comment">//儿子数组：存储从节点p沿着j这条路走到的子节点。26是26个字母的映射值（就是1代表a，2代表b以此类推）</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> cnt[N];<span class="comment">//存储以节点p结尾的单词的插入次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> idx;<span class="comment">//用来节点编号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历全部字符串的字符</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;s[i];i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = s[i]-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//字母映射 - 变为0-25的编号</span></span><br><span class="line">        <span class="keyword">if</span>(!ch[p][j]) ch[p][j]=++idx;<span class="comment">//不存在这个值（就是树中无这个子树）</span></span><br><span class="line">        p = ch[p][j];</span><br><span class="line">    &#125;</span><br><span class="line">    cnt[p]++;<span class="comment">//插入次数 - 表示当前节点子树个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>和插入的操作差不多，只要找到我们插入的时候做的标记就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;s[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> j = s[i]-<span class="string">&#x27;a&#x27;</span>;<span class="comment">//映射</span></span><br><span class="line">        <span class="keyword">if</span>(!ch[p][j]) <span class="keyword">return</span> <span class="number">0</span>;;</span><br><span class="line">        p = ch[p][j]; <span class="comment">//查找符合，直到子串末尾。都符合则成立</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230504140704449.png" alt="总结"></p>
<h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="BF算法"><a href="#BF算法" class="headerlink" title="BF算法"></a><a href="https://juejin.cn/post/6854573219106521101">BF算法</a></h3><p>BF算法(Brute-Force，最基本的字符串匹配算法)，BF算法的实现思想很简单：我们可以定义两个索引值i和j，分别指示主串Tag和子串Ptn当前正待比较的字符位置，从主串Tag的第pos个字符起和子串Ptn的第一个字符比较，若相等，则继续逐个比较后续字符，否则从主串Tag的下一个字符起再重新和子串Ptn的字符进行比较，重复执行，直到子串Ptn中的每个字符依次和主串Tag中的一个连续字符串相等，则匹配成功，函数返回该连续字符串的第一个字符在主串Tag中的位置，否则匹配不成功，函数返回-1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Brute-Force算法实现字符串匹配</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bruteForceSearch</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text[i + j] != pattern[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) <span class="comment">// 找到完全匹配</span></span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text, pattern;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入文本串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getline</span>(cin, text);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入模式串：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getline</span>(cin, pattern);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> position = <span class="built_in">bruteForceSearch</span>(text, pattern);</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;在位置 &quot;</span> &lt;&lt; position &lt;&lt; <span class="string">&quot; 处找到匹配。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到匹配。&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法*"></a><a href="https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">KMP算法</a>*</h3><p><a href="https://segmentfault.com/a/1190000022642180">演示</a></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1460000022642186.gif" alt="KMP算法拟人化演示"></p>
<p>在BF算法的基础之上，我们为了不让匹配完成的信息浪费，在回溯的基础之上，我们做了一下调整。在kmp算法中，不回溯i只回溯j的位置。这两个指针，i是指向我们的模式串，j指向我们的匹配串。说人话就是，i指针不断往前，j指针要执行回溯。在演示的过程中，我们可以看到j指针指向的串是在前进的，但是在代码中是回溯的。而匹配串移动的格子数则依照部分匹配。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806133747340-1693379134677-22.png" alt="image-20230806133747340"></p>
<p>首先要了解什么是<a href="https://www.bilibili.com/video/BV1234y1y7pm/?spm_id_from=333.788.recommend_more_video.1&vd_source=731595967596af37618c926a191e7811">字符串的前后缀</a>：</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806133314129.png" alt="image-20230806133314129"></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806133324374.png" alt="image-20230806133324374"></p>
<p>然后我们再谈部分匹配表，在我们匹配的时候，观察我们的匹配串，对于一个较长的字符串，我们可以发现一些特点，前缀集合和后缀集合中，很容易找到相同的元素，我们可以对于每一个[1-i]的子串片段，来计算它们相等的最大长度，保存我们匹配的信息。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806134138611.png" alt="image-20230806134138611"></p>
<p>所以说，我们要实现kmp算法，就需要打一个表，这个表的原理是”部分匹配值”，也就是”前缀”和”后缀”的最长的共有元素的长度。知道了这个长度，我们就可以将我们的匹配串移动我们已经完成的匹配信息的位置。这个表的打法如下</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230805234926666-1693379134677-23.png" alt="image-20230805234926666"></p>
<p>在之前的笔记中，我们用next数组构造了这个表，可能不是很全面，这里就举一个模版的例子吧。（[演示](<a href="https://cmps-people.ok.ubc.ca/ylucet/DS/KnuthMorrisPratt.html">Knuth-Morris-Pratt String Search Visualization (ubc.ca)</a>)）next 数组（也称为部分匹配表）是在模式串中与模式串本身进行匹配来构建的。在 KMP 算法中，next 数组记录了模式串中每个位置的最长相等前后缀长度。这个信息可以帮助我们在文本串中快速查找模式串的出现位置。具体来说，当在文本串中匹配模式串时，如果发生不匹配，我们可以利用 next 数组中的信息来确定下一次匹配的起始位置，从而避免重新检查已经匹配过的字符。对于next数组，有一个最通俗易懂的说法，可以理解为当前位置的P串向前移动next[j]的位置。</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806141023908-1693379134677-24.png" alt="image-20230806141023908"></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806141005083-1693379134677-25.png" alt="image-20230806141005083"></p>
<p>我们可以使用递推的思路来求解我们的next数组，下面是具体的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码 - 双指针算法</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buN</span><span class="params">(<span class="type">const</span> string&amp; patt)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next; <span class="comment">//最长前后缀</span></span><br><span class="line">    <span class="type">int</span> prefix_len = <span class="number">0</span>; <span class="comment">//用于赋值，每一个字符串片段的最长前后缀</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; <span class="comment">//遍历整个字符串的变量 - 起始位置为1</span></span><br><span class="line">    next.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 第一个位置的最长前后缀为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历整个模式串</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;patt.<span class="built_in">length</span>())&#123;</span><br><span class="line">        <span class="comment">//新加入的数据可以构成更长的前后缀长度</span></span><br><span class="line">        <span class="keyword">if</span>(patt[prefix_len] == patt[i])&#123;</span><br><span class="line">            prefix_len++;</span><br><span class="line">            <span class="comment">//这个位置的前后缀长度+1</span></span><br><span class="line">            next.<span class="built_in">push_back</span>(prefix_len);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(prefix_len == <span class="number">0</span>)&#123;</span><br><span class="line">                next.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//回溯 - 利用已知信息</span></span><br><span class="line">                prefix_len = next[prefix_len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之前的简洁代码（不好理解）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//子串和next数组都是从1开始的</span></span><br><span class="line"><span class="comment">//打表 - 部分匹配 - 伪代码</span></span><br><span class="line">ne[<span class="number">1</span>] = <span class="number">0</span>; <span class="comment">//第一个位置 - 前后缀相等长度为0</span></span><br><span class="line"><span class="comment">//遍历我们的匹配串</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>,j = <span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(j&amp;&amp;P[i]!=P[j+<span class="number">1</span>]) j = ne[j]; <span class="comment">//新字符匹配失败 - 回退</span></span><br><span class="line">    <span class="comment">// j ---- i</span></span><br><span class="line">    <span class="keyword">if</span>(P[i] == P[j+<span class="number">1</span>]) j++; <span class="comment">//增加的数据构成更长的前后缀  长度就+1 （注意，这里的j是上一次匹配的时候的最长前后缀的长度）</span></span><br><span class="line">    ne[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到的<a href="https://www.bilibili.com/video/BV1AY4y157yL/?spm_id_from=333.999.0.0">视频讲解</a>：6 : 07</p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806012033790-1693379134677-26.png" alt="image-20230806012033790"></p>
<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806001954712-1693379134677-27.png" alt="image-20230806001954712"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造部分匹配表（Next数组）</span></span><br><span class="line"><span class="comment">// 像是两个相等的数组来匹配</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildNext</span><span class="params">(<span class="type">const</span> string&amp; pattern, vector&lt;<span class="type">int</span>&gt;&amp; next)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//匹配串的长度</span></span><br><span class="line">    <span class="type">int</span> n = pattern.<span class="built_in">length</span>();</span><br><span class="line">    <span class="comment">//初始化数据</span></span><br><span class="line">    next.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; pattern[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];<span class="comment">// 回溯j的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[i] == pattern[j]) &#123;</span><br><span class="line">            j++;<span class="comment">// 匹配成功，j增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;<span class="comment">// 存储当前i位置的部分匹配值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// KMP算法实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kmpSearch</span><span class="params">(<span class="type">const</span> string&amp; text, <span class="type">const</span> string&amp; pattern)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = text.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> m = pattern.<span class="built_in">length</span>();</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">    <span class="built_in">buildNext</span>(pattern, next);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">// 当前已匹配的字符数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; text[i] != pattern[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];<span class="comment">// 回溯j的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (text[i] == pattern[j]) &#123;</span><br><span class="line">            j++;<span class="comment">// 匹配成功，j增加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j + <span class="number">1</span>; <span class="comment">// 匹配成功，返回在文本串中的起始位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 未匹配成功，返回-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string text = <span class="string">&quot;ABABABCABABABCABABABC&quot;</span>;</span><br><span class="line">    string pattern = <span class="string">&quot;ABABC&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> position = <span class="built_in">kmpSearch</span>(text, pattern);</span><br><span class="line">    <span class="keyword">if</span> (position != <span class="number">-1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;匹配位置在: &quot;</span> &lt;&lt; position &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;无法匹配.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20230806151418114-1693379134677-28.png" alt="image-20230806151418114"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>c#</title>
    <url>/2023/05/29/c/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C#基础"></a>C#基础</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>简单介绍一下c#“简单操作”，基本上学过其他语言的都是通用的，简单看看就行。如果在序号之前看到了*，说明这个知识点比较抽象（或者没啥用），建议多查👋</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _001_第一个程序</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是一个简单的C#程序框架示例，它包含了一些常见的命名空间和一个包含<code>Main</code>方法的类。</p>
<ol>
<li><p><code>using</code>语句：在代码的开头，使用了一系列的<code>using</code>语句来引入不同的命名空间。这些命名空间包括<code>System</code>、<code>System.Collections.Generic</code>、<code>System.Linq</code>、<code>System.Text</code>和<code>System.Threading.Tasks</code>等。通过引入这些命名空间，我们可以在代码中直接使用这些命名空间中定义的类型和成员，而无需使用完全限定名。</p>
<blockquote>
<p>命名空间</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br></pre></td></tr></table></figure>

<p>C#中的命名空间（Namespace）用于组织和管理代码，它具有以下作用：</p>
<ol>
<li>避免命名冲突：命名空间可以防止不同代码元素（类、结构、接口、枚举等）之间的命名冲突。通过将相关的代码元素放置在同一个命名空间中，可以确保它们的名称在该命名空间内是唯一的。</li>
<li>提供代码组织结构：命名空间提供了一种逻辑上组织和划分代码的方式。你可以根据功能、模块或其他逻辑关系将相关的类型放置在同一个命名空间中，以便更好地组织和管理代码。</li>
<li>支持代码重用和模块化：通过使用命名空间，可以将代码分割成多个逻辑模块，使得这些模块可以在不同的项目或文件中进行重用。通过引用适当的命名空间，可以在代码中访问和使用其他命名空间中定义的类型和成员。</li>
<li>提供代码可见性控制：命名空间也可以用于控制类型和成员的可见性。在C#中，命名空间可以被限定为特定的访问修饰符（例如<code>public</code>、<code>internal</code>等），从而决定其内部的类型和成员是否可以被其他代码访问。</li>
<li>与类库和命名空间的组织结构对应：C#标准类库和第三方类库通常使用命名空间来组织和命名其提供的类型和功能。通过使用相应的命名空间，你可以引用并使用这些类库中的类型和成员。</li>
</ol>
<p>总之，C#中的命名空间提供了一种组织、管理和访问代码的机制，能够避免命名冲突，提供代码重用和模块化，控制代码可见性，并与类库和模块的组织结构对应。它是代码组织和协作的重要工具。</p>
</blockquote>
</li>
<li><p>命名空间：代码中定义了一个名为<code>_001_第一个程序</code>的命名空间。命名空间用于组织和管理代码，它可以包含类、结构、接口、枚举等代码元素。在这个示例中，命名空间内部只包含一个类<code>Program</code>。</p>
<blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _001_第一个程序</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在C#中，自定义命名空间时需要遵循以下规则：</p>
<ol>
<li>命名空间名称必须是有效的标识符：命名空间的名称必须符合C#中有效标识符的规则。它可以包含字母、数字和下划线，并且必须以字母或下划线开头。</li>
<li>命名空间可以使用层次结构：命名空间可以包含多个层次，使用<code>.</code>进行分隔。例如，命名空间可以是<code>MyNamespace</code>、<code>MyNamespace.SubNamespace</code>、<code>MyNamespace.SubNamespace.SubSubNamespace</code>等。</li>
<li>命名空间应具有描述性：命名空间的名称应该具有描述性，能够清楚地表达其所包含代码的目的或功能。例如，如果你正在创建一个与日志记录相关的代码，可以选择一个描述性的命名空间名称，如<code>MyCompany.Logging</code>。</li>
<li>避免与现有命名空间冲突：在自定义命名空间时，应避免与已有的系统命名空间或其他第三方库的命名空间发生冲突。可以通过选择唯一的命名空间名称、使用公司名或项目名作为前缀等方式来避免冲突。</li>
<li>命名空间与目录结构可以对应：在组织项目文件时，可以将命名空间与文件的物理目录结构相对应。这有助于在代码文件的组织和查找方面更加直观和一致。</li>
<li>命名空间的规范化：根据一般的命名约定，命名空间的首字母应大写，采用帕斯卡命名法（PascalCase）。例如，<code>MyNamespace</code>、<code>MyNamespace.SubNamespace</code>。</li>
</ol>
<p>总之，自定义命名空间时需要确保名称符合C#中有效标识符的规则，具有描述性，避免与现有命名空间冲突，可以与文件的目录结构对应，符合命名约定。这些规则有助于编写清晰、可维护的代码，并提供一致性和可读性。</p>
</blockquote>
</li>
<li><p>类：在命名空间中定义了一个名为<code>Program</code>的类。这是程序的入口点，其中包含一个静态的<code>Main</code>方法。<code>Main</code>方法是C#程序的起始执行点，它是程序开始运行的地方。在这个示例中，<code>Main</code>方法没有任何具体的代码</p>
</li>
</ol>
<h4 id="变量标识符"><a href="#变量标识符" class="headerlink" title="变量标识符"></a>变量标识符</h4><p>变量标识符是用来命名变量的名称，它具有以下特点：</p>
<ol>
<li><p>标识符必须是有效的标识符：变量标识符必须符合C#中有效标识符的规则。它可以包含字母、数字和下划线，并且必须以字母或下划线开头。标识符区分大小写，因此大小写敏感。</p>
</li>
<li><p>标识符应具有描述性：变量标识符应该具有描述性，能够清晰地表达所代表的变量的含义和用途。良好的标识符命名有助于提高代码的可读性和可维护性。</p>
</li>
<li><p>遵循命名约定：在C#中，通常采用驼峰命名法（camelCase）来命名变量。这意味着标识符的第一个单词以小写字母开头，后续的每个单词的首字母大写。例如，<code>myVariable</code>、<code>firstName</code>。</p>
<blockquote>
<p>驼峰命名法（CamelCase）是一种命名约定，用于命名标识符（如变量、函数、属性、类等）。它的命名规则如下：</p>
<ol>
<li>第一个单词以小写字母开头：首字母小写，后续单词的首字母大写。</li>
<li>单词之间没有空格或其他分隔符：所有单词连续写在一起，没有空格或其他分隔符。</li>
</ol>
<p>驼峰命名法分为两种形式：</p>
<ol>
<li>小驼峰命名法（lowerCamelCase）：第一个单词的首字母小写，后续单词的首字母大写。例如：<code>myVariable</code>、<code>firstName</code>。</li>
<li>大驼峰命名法（PascalCase）：每个单词的首字母都大写。例如：<code>MyVariable</code>、<code>FirstName</code>。</li>
</ol>
<p>驼峰命名法的目的是使标识符具有更好的可读性和一致性，并提供一种清晰的命名约定。它在C#编程中被广泛使用，并且也是许多其他编程语言中常见的命名约定之一。</p>
<p>以下是一些使用驼峰命名法的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeint myVariable = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">myMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 方法体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，驼峰命名法是一种命名约定，根据首字母的大小写来区分单词，并且没有空格或其他分隔符。它有助于提高代码的可读性和一致性。</p>
</blockquote>
</li>
<li><p>不使用保留字：标识符不能是C#的保留字（关键字），因为保留字具有特殊的意义和用途，用于编程语言本身的语法和功能。</p>
</li>
<li><p>尽量简洁明确：标识符应该尽量简洁明确，避免过长或过于复杂的命名。一个好的标识符能够准确地表达变量的用途，同时也便于代码的编写和阅读。</p>
</li>
<li><p>语义正确：标识符应该与变量的含义和类型相符。它们应该能够清晰地表达变量所代表的数据或对象。</p>
</li>
<li><p>遵循命名约定和项目规范：在特定的项目或团队中，可能会有特定的命名约定或规范。遵循这些规范可以保持代码风格的一致性，并使不同开发者之间更容易理解和协作。</p>
</li>
</ol>
<p>总的来说，变量标识符是用于命名变量的名称，应符合C#中有效标识符的规则，具有描述性，遵循命名约定，不使用保留字，简洁明确，并与变量的含义和类型相符。良好的标识符命名有助于编写易读、易维护的代码。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>在 C# 中，变量具有以下规则：</p>
<ol>
<li><p>命名规则：</p>
<ul>
<li>变量名称必须以字母或下划线 <code>_</code> 开头。</li>
<li>变量名称可以包含字母、数字和下划线。</li>
<li>变量名称区分大小写。</li>
</ul>
</li>
<li><p>关键字保留：</p>
<ul>
<li>不可以使用 C# 中的关键字作为变量名称。例如，<code>int</code>、<code>string</code>、<code>if</code> 等都是关键字，不能用作变量名。</li>
</ul>
</li>
<li><p>类型声明：</p>
<ul>
<li>变量必须先声明后使用。在声明变量时，需要指定变量的类型。</li>
</ul>
</li>
<li><p>类型安全：</p>
<ul>
<li><p>C# 是一种静态类型语言，变量在声明时需要指定其类型，且变量的类型在编译时就确定了。类型安全意味着变量在使用过程中必须与其声明的类型匹配，不允许类型之间的隐式转换（除非使用显式类型转换）。</p>
<blockquote>
<p>当说到C#是一种静态类型语言时，意味着在编译时，每个变量都必须被显式地声明为某种类型。这意味着在声明变量时，必须指定变量的数据类型，例如整数 (<code>int</code>)、字符串 (<code>string</code>)、布尔值 (<code>bool</code>) 等。</p>
<p>一旦变量被声明为某种类型，它的类型就在编译时确定，无法在运行时更改。这为编译器提供了类型检查的机会，以确保变量在使用过程中与其声明的类型匹配。</p>
<p>类型安全的概念是指在使用变量时，变量的类型必须与其声明的类型相匹配，否则将产生编译时错误。这意味着在对变量进行操作、赋值或传递给函数时，需要保证类型的一致性。</p>
<p>举个例子，假设有以下代码片段：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeint num = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">string</span> text = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> result = num + text; <span class="comment">// 编译时错误：不能将 int 类型和 string 类型相加</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>num</code> 声明为整数类型 (<code>int</code>)，<code>text</code> 声明为字符串类型 (<code>string</code>)。由于整数和字符串是不兼容的类型，试图将它们相加会导致编译时错误。这是因为 C# 是类型安全的，不允许将不同类型的值混合使用。</p>
<p>然而，有时我们确实需要将一个类型的值转换为另一个类型。在这种情况下，可以使用显式类型转换来实现，例如使用 <code>(type)</code> 运算符。但是需要注意，显式类型转换可能会导致数据丢失或精度损失，所以需要谨慎使用。</p>
<p>总结起来，类型安全是指在 C# 中，变量在声明时需要指定其类型，并且在使用过程中必须与其声明的类型相匹配。这有助于在编译时捕捉类型错误，并提高代码的可靠性和可维护性。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>作用域：</p>
<ul>
<li>变量的作用域指的是其可见性和可访问性的范围。</li>
<li>变量可以在代码块内部声明，包括方法、循环、条件语句等。</li>
<li>变量的作用域通常是在声明它的代码块中，可以通过大括号 <code>&#123;&#125;</code> 来限定作用域。</li>
<li>局部变量的作用域在声明的代码块内有效，一旦超出作用域，变量就无法访问。</li>
</ul>
</li>
<li><p>生命周期：</p>
<ul>
<li>变量的生命周期是指变量存在的时间段。</li>
<li>局部变量的生命周期与其作用域一致，当超出作用域时，变量将被销毁。</li>
<li>类成员变量的生命周期与其所属的对象或类的生命周期相关。</li>
</ul>
</li>
<li><p>值赋值和修改：</p>
<ul>
<li>变量可以通过赋值运算符 <code>=</code> 来进行值的赋值。</li>
<li>变量可以在其生命周期内被修改，即可以重新赋予不同的值。</li>
</ul>
</li>
</ol>
<blockquote>
<p>变量的简单类型</p>
<p>在C#中，有许多简单的数据类型可以用来声明变量。以下是一些常见的简单类型：</p>
<ol>
<li>整数类型：<ul>
<li><code>int</code>: 表示整数，范围为约 -2,147,483,648 到 2,147,483,647。</li>
<li><code>long</code>: 表示长整数，范围更大，约 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807。</li>
<li><code>short</code>: 表示短整数，范围约为 -32,768 到 32,767。</li>
<li><code>byte</code>: 表示无符号字节，范围为 0 到 255。</li>
</ul>
</li>
<li>浮点类型：<ul>
<li><code>float</code>: 表示单精度浮点数，范围为约 ±1.5 x 10^(-45) 到 ±3.4 x 10^(38)，精度约为 7 位小数。</li>
<li><code>double</code>: 表示双精度浮点数，范围更大，约 ±5.0 x 10^(-324) 到 ±1.7 x 10^(308)，精度约为 15 位小数。</li>
</ul>
</li>
<li>字符类型：<ul>
<li><code>char</code>: 表示单个字符，用单引号括起来，例如 ‘A’、’b’。</li>
</ul>
</li>
<li>布尔类型：<ul>
<li><code>bool</code>: 表示布尔值，只有两个可能的值：<code>true</code> 或 <code>false</code>。</li>
</ul>
</li>
<li>字符串类型：<ul>
<li><code>string</code>: 表示文本字符串，用双引号括起来，例如 “Hello”、”World”。</li>
</ul>
</li>
<li>其他简单类型：<ul>
<li><code>decimal</code>: 表示高精度小数，适用于金融和货币计算，精度约为 28-29 位小数。</li>
<li><code>DateTime</code>: 表示日期和时间值。</li>
<li><code>enum</code>: 表示枚举类型，用于定义一组具名的常量值。</li>
</ul>
</li>
</ol>
<p>这些是C#中一些常见的简单数据类型，你可以根据需要选择适当的类型来声明变量。每种类型都有其特定的用途和取值范围。</p>
</blockquote>
<h4 id="块"><a href="#块" class="headerlink" title="块"></a>块</h4><p>在C#中，块（block）是由一组语句（statements）组成的代码段。块可以用来将多个语句组合在一起，以便按照一定的逻辑顺序执行。常见的使用块的情况是在条件语句（if、else if、else）和循环语句（for、while、do while）中。</p>
<p>一个块由一对花括号（{}）括起来，其中包含了一系列的语句。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code&#123;</span><br><span class="line">    <span class="comment">// 这是一个块</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;语句1&quot;</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;语句2&quot;</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;语句n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，花括号内的部分就是一个块，它包含了多个语句。当程序执行到这个块时，其中的语句将按照编写的顺序依次执行。</p>
<p>块的作用不仅仅是为了组织代码，还可以用来限制变量的作用域。在一个块内部声明的变量只在该块内有效，在块外部是不可见的。这种方式可以提供更好的代码封装和变量管理。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code&#123;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">10</span>; <span class="comment">// 在块内部声明变量x</span></span><br><span class="line">    Console.WriteLine(x); <span class="comment">// 输出：10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(x); <span class="comment">// 编译错误，x 在此处不可见</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，变量 <code>x</code> 在块内部声明，并在该块内部可见。在块外部的代码中，变量 <code>x</code> 是不可见的，因此会导致编译错误。</p>
<p>总之，块在C#中是一种用于组织语句和限制变量作用域的重要结构。</p>
<h4 id="字面值"><a href="#字面值" class="headerlink" title="*字面值"></a>*字面值</h4><p>在C#中，字面值（Literal）是指直接表示特定值的固定文本或符号。字面值可以用于声明和初始化变量，或者直接用于表达式中。</p>
<p>以下是C#中常见的字面值类型：</p>
<ol>
<li>整数字面值：<ul>
<li>十进制整数：例如 <code>123</code>。</li>
<li>二进制整数：以 <code>0b</code> 或 <code>0B</code> 开头，后跟一串二进制数字。例如 <code>0b1010</code> 表示十进制的 10。</li>
<li>八进制整数：以 <code>0</code> 开头，后跟一串八进制数字。例如 <code>0123</code> 表示十进制的 83。</li>
<li>十六进制整数：以 <code>0x</code> 或 <code>0X</code> 开头，后跟一串十六进制数字。例如 <code>0xFF</code> 表示十进制的 255。</li>
</ul>
</li>
<li>浮点数字面值：<ul>
<li>十进制浮点数：例如 <code>3.14</code>。</li>
<li>指数表示法：使用 <code>E</code> 或 <code>e</code> 表示指数部分。例如 <code>1.23e-4</code> 表示十进制的 0.000123。</li>
</ul>
</li>
<li>字符字面值：<ul>
<li>字符字面值用单引号括起来，表示单个字符。例如 <code>&#39;A&#39;</code>、<code>&#39;7&#39;</code>、<code>&#39;!&#39;</code>。</li>
</ul>
</li>
<li>字符串字面值：<ul>
<li>字符串字面值用双引号括起来，表示文本字符串。例如 <code>&quot;Hello&quot;</code>、<code>&quot;World&quot;</code>。</li>
</ul>
</li>
<li>布尔字面值：<ul>
<li>布尔字面值表示逻辑值，只有两个可能的值：<code>true</code> 和 <code>false</code>。</li>
</ul>
</li>
</ol>
<p>除了上述基本类型的字面值，C#还支持其他类型的字面值，如日期时间字面值、空值字面值等。</p>
<p>以下是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeint num = <span class="number">42</span>;           <span class="comment">// 整数字面值</span></span><br><span class="line"><span class="built_in">double</span> pi = <span class="number">3.14159</span>;    <span class="comment">// 浮点数字面值</span></span><br><span class="line"><span class="built_in">char</span> ch = <span class="string">&#x27;A&#x27;</span>;          <span class="comment">// 字符字面值</span></span><br><span class="line"><span class="built_in">string</span> message = <span class="string">&quot;Hello, World!&quot;</span>;   <span class="comment">// 字符串字面值</span></span><br><span class="line"><span class="built_in">bool</span> isTrue = <span class="literal">true</span>;     <span class="comment">// 布尔字面值</span></span><br><span class="line">DateTime now = DateTime.Now;   <span class="comment">// 日期时间字面值</span></span><br></pre></td></tr></table></figure>

<p>这些字面值在代码中直接表示相应的值，无需其他转换或操作。</p>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>C#中有多种运算符，用于执行各种算术、逻辑和位运算。以下是C#中常用的运算符的分类和示例：</p>
<ol>
<li><p>算术运算符：</p>
<ul>
<li><code>+</code>：加法</li>
<li><code>-</code>：减法</li>
<li><code>*</code>：乘法</li>
<li><code>/</code>：除法</li>
<li><code>%</code>：取模（取余数）</li>
</ul>
</li>
<li><p>关系运算符：</p>
<ul>
<li><code>==</code>：等于</li>
<li><code>!=</code>：不等于</li>
<li><code>&gt;</code>：大于</li>
<li><code>&lt;</code>：小于</li>
<li><code>&gt;=</code>：大于等于</li>
<li><code>&lt;=</code>：小于等于</li>
</ul>
</li>
<li><p>逻辑运算符：</p>
<ul>
<li><code>&amp;&amp;</code>：逻辑与（and）</li>
<li><code>||</code>：逻辑或（or）</li>
<li><code>!</code>：逻辑非（not）</li>
</ul>
</li>
<li><p>赋值运算符：</p>
<ul>
<li><code>=</code>：简单赋值</li>
<li><code>+=</code>：加法赋值</li>
<li><code>-=</code>：减法赋值</li>
<li><code>*=</code>：乘法赋值</li>
<li><code>/=</code>：除法赋值</li>
<li><code>%=</code>：取模赋值</li>
</ul>
</li>
<li><p>位运算符：</p>
<ul>
<li><code>&amp;</code>：按位与</li>
<li><code>|</code>：按位或</li>
<li><code>^</code>：按位异或</li>
<li><code>&lt;&lt;</code>：左移</li>
<li><code>&gt;&gt;</code>：右移</li>
<li><code>~</code>：按位取反</li>
</ul>
</li>
<li><p>条件运算符：</p>
<ul>
<li><p><code>? :</code>：条件运算符（三元运算符），用于简化条件语句</p>
<blockquote>
<p>在C#中，三元运算符（Conditional Operator）是一种简洁的条件表达式，它允许根据条件的真假选择不同的值。三元运算符的语法形式为 <code>condition ? trueValue : falseValue</code>，其中 <code>condition</code> 是一个条件表达式，<code>trueValue</code> 是在条件为真时返回的值，<code>falseValue</code> 是在条件为假时返回的值。</p>
<p>以下是一个使用三元运算符的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">int</span> num = (x &gt; y) ? x : y;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，根据条件 <code>(x &gt; y)</code> 的真假，如果条件为真，则将 <code>x</code> 的值赋给 <code>num</code>；如果条件为假，则将 <code>y</code> 的值赋给 <code>num</code>。这样就可以根据条件动态地选择不同的值进行赋值。</p>
<p>三元运算符的优点是简洁、易读，并且可以在单行中完成条件判断和赋值操作。但是，需要注意避免过度使用，以免降低代码的可读性和可维护性。在某些情况下，使用 <code>if-else</code> 语句可能更易于理解和维护，特别是当需要执行更复杂的逻辑时。因此，在选择使用三元运算符还是 <code>if-else</code> 语句时，可以根据具体情况和代码的可读性来进行判断。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>其他运算符：</p>
<ul>
<li><code>()</code>：括号，用于分组和优先级控制</li>
<li><code>[]</code>：方括号，用于访问数组元素和索引器</li>
<li><code>.</code>：点运算符，用于访问成员和方法</li>
</ul>
</li>
</ol>
<blockquote>
<p>布尔运算符:</p>
<p>C# 中的布尔运算符用于执行逻辑运算，操作布尔类型的值（true 或 false）。以下是常用的布尔运算符：</p>
<p>逻辑与运算符（&amp;&amp;）：当且仅当两个操作数都为 true 时，结果才为 true。否则，结果为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">bool</span> result = condition1 &amp;&amp; condition2;</span><br></pre></td></tr></table></figure>

<p>逻辑或运算符（||）：当至少一个操作数为 true 时，结果为 true。只有两个操作数都为 false 时，结果才为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">bool</span> result = condition1 || condition2;</span><br></pre></td></tr></table></figure>

<p>逻辑非运算符（!）：对单个操作数进行取反操作，如果操作数为 true，则结果为 false；如果操作数为 false，则结果为 true。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">bool</span> result = !condition;</span><br></pre></td></tr></table></figure>

<p>除了上述三个基本的布尔运算符，C# 还提供了其他一些用于布尔运算的运算符，如：</p>
<p>相等运算符（&#x3D;&#x3D;）：用于比较两个操作数是否相等，如果相等则结果为 true，否则为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">bool</span> result = value1 == value2;</span><br></pre></td></tr></table></figure>

<p>不等运算符（!&#x3D;）：用于比较两个操作数是否不相等，如果不相等则结果为 true，否则为 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">bool</span> result = value1 != value2;</span><br></pre></td></tr></table></figure>

<p>大于运算符（&gt;）、小于运算符（&lt;）、大于等于运算符（&gt;&#x3D;）、小于等于运算符（&lt;&#x3D;）：用于比较两个操作数的大小关系，返回结果为 true 或 false。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codebool result = value1 &gt; value2;</span><br><span class="line"><span class="built_in">bool</span> result = value1 &lt; value2;</span><br><span class="line"><span class="built_in">bool</span> result = value1 &gt;= value2;</span><br><span class="line"><span class="built_in">bool</span> result = value1 &lt;= value2;</span><br></pre></td></tr></table></figure>

<p>这些布尔运算符可用于控制流程、条件判断、循环控制等情况下，以便根据条件的真假进行相应的操作。</p>
</blockquote>
<h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><p>在C#中，转义字符（Escape Character）是用于表示一些特殊字符的特殊序列。转义字符以反斜杠 <code>\</code> 开头，后面跟着一个或多个字符，用于表示特定的含义。</p>
<p>以下是C#中常见的转义字符及其含义：</p>
<ul>
<li><code>\&#39;</code>：表示单引号字符。</li>
<li><code>\&quot;</code>：表示双引号字符。</li>
<li><code>\\</code>：表示反斜杠字符。</li>
<li><code>\n</code>：表示换行符（ASCII 值为 10）。</li>
<li><code>\r</code>：表示回车符（ASCII 值为 13）。</li>
<li><code>\t</code>：表示制表符。</li>
<li><code>\b</code>：表示退格符。</li>
<li><code>\f</code>：表示换页符。</li>
<li><code>\uXXXX</code>：表示一个 Unicode 字符，其中 <code>XXXX</code> 是四个十六进制数字。</li>
</ul>
<p>以下是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codestring singleQuote = <span class="string">&#x27;\&#x27;&#x27;</span>;     <span class="comment">// 单引号字符</span></span><br><span class="line"><span class="built_in">string</span> doubleQuote = <span class="string">&#x27;\&quot;&#x27;</span>;     <span class="comment">// 双引号字符</span></span><br><span class="line"><span class="built_in">string</span> backslash = <span class="string">&#x27;\\&#x27;</span>;       <span class="comment">// 反斜杠字符</span></span><br><span class="line"><span class="built_in">string</span> newLine = <span class="string">&quot;\n&quot;</span>;         <span class="comment">// 换行符</span></span><br><span class="line"><span class="built_in">string</span> tab = <span class="string">&quot;\t&quot;</span>;             <span class="comment">// 制表符</span></span><br><span class="line"><span class="built_in">string</span> unicodeChar = <span class="string">&quot;\u03A9&quot;</span>; <span class="comment">// 表示希腊字母大写Omega（Ω）</span></span><br></pre></td></tr></table></figure>

<p>在字符串中使用转义字符时，反斜杠后的字符将被解释为其特殊含义，而不是字面字符。</p>
<p>需要注意的是，如果你希望在字符串中显示实际的反斜杠字符而非转义字符，你可以使用两个连续的反斜杠 <code>\\</code> 来表示。</p>
<blockquote>
<p>在C#中，转义字符是一种特殊字符序列，用于表示一些特殊的字符或控制字符。如果你想禁用转义字符，你可以使用字符串前缀 <code>@</code> 来创建一个原始字符串（raw string），这样其中的转义字符就会被当作普通字符对待。</p>
<p>下面是一个示例，展示如何在C#中禁用转义字符：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codestring normalString = <span class="string">&quot;Hello\tWorld&quot;</span>; <span class="comment">// 使用转义字符的普通字符串</span></span><br><span class="line"><span class="built_in">string</span> rawString = <span class="string">@&quot;Hello\tWorld&quot;</span>; <span class="comment">// 使用原始字符串禁用转义字符</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(normalString); <span class="comment">// 输出：Hello   World</span></span><br><span class="line">Console.WriteLine(rawString); <span class="comment">// 输出：Hello\tWorld</span></span><br></pre></td></tr></table></figure>

<p>在 <code>rawString</code> 中，<code>\t</code> 不再表示制表符，而是被当作普通的两个字符：反斜杠和字母 ‘t’。</p>
</blockquote>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>在C#中，条件语句用于根据条件的真假来执行不同的代码块。C#提供了几种条件语句的形式，包括以下常见的：</p>
<ol>
<li><p><code>if</code> 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codeif</span> (<span class="params">condition</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当条件为真时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当条件为假时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>else if</code> 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codeif</span> (<span class="params">condition1</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当条件1为真时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (condition2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当条件1为假而条件2为真时执行的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 当前面条件都为假时执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>switch</code> 语句：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codeswitch</span> (<span class="params">variable</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 当变量等于value1时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 当变量等于value2时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        <span class="comment">// 当变量不匹配任何case时执行的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些条件语句根据条件的真假来选择执行不同的代码块。<code>if</code> 语句根据单个条件的真假执行不同的代码块，而 <code>else if</code> 语句可以用于检查多个条件并选择执行对应的代码块。<code>switch</code> 语句根据变量的值进行匹配，并执行与值匹配的代码块。</p>
<p>这些条件语句使程序能够根据不同的情况采取不同的行动，从而实现灵活的控制流程和逻辑。您可以根据具体的需求选择适当的条件语句来控制程序的行为。</p>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p>在C#中，循环语句用于重复执行一段代码块，直到满足指定的条件。C#提供了几种常用的循环语句，包括以下：</p>
<ol>
<li><p><code>for</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codefor</span> (<span class="params">initialization; condition; iteration</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>while</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codewhile</span> (<span class="params">condition</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>do-while</code> 循环：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codedo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环执行的代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>foreach</code> 循环（用于遍历集合）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codeforeach</span> (<span class="params"><span class="keyword">var</span> item <span class="keyword">in</span> collection</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环执行的代码，item 代表集合中的每个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这些循环语句允许您根据需要重复执行一段代码块，直到满足指定的条件。<code>for</code> 循环在执行循环之前进行初始化，并在每次迭代后进行迭代操作。<code>while</code> 循环在每次循环开始之前检查条件。<code>do-while</code> 循环首先执行一次循环体，然后在每次循环结束后检查条件。</p>
<p><code>foreach</code> 循环用于遍历集合中的元素，无需手动追踪索引或迭代器。它适用于数组、列表、字典等集合类型。</p>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>在C#中，枚举（Enum）是一种特殊的数据类型，用于定义一组具名的常量值。枚举类型允许我们为特定概念创建有意义的命名常量，使代码更加可读和可维护。</p>
<p>以下是一个枚举的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeenum DayOfWeek</span><br><span class="line">&#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 <code>DayOfWeek</code> 的枚举类型，它包含了一周中的每一天。枚举中的每个值都是一个常量，并用逗号分隔。默认情况下，第一个枚举成员的值为0，然后依次递增。</p>
<p>我们可以使用枚举类型来声明变量，并将其限制为枚举中的某个特定值，例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line">DayOfWeek today = DayOfWeek.Monday;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们将 <code>today</code> 声明为 <code>DayOfWeek</code> 枚举类型的变量，并将其赋值为 <code>DayOfWeek.Monday</code>。这样，我们可以使用 <code>today</code> 变量来表示今天是星期几。</p>
<p>枚举还可以使用 <code>switch</code> 语句进行处理，方便地处理不同枚举值的情况：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy <span class="title">codeswitch</span> (<span class="params">today</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> DayOfWeek.Monday:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;今天是星期一&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DayOfWeek.Tuesday:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;今天是星期二&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="literal">default</span>:</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;未知的星期&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们根据 <code>today</code> 变量的值，通过 <code>switch</code> 语句判断今天是星期几，并输出相应的信息。</p>
<p>枚举提供了一种方便的方式来定义和使用一组相关的常量值，以增加代码的可读性和可维护性。它在许多情况下都是非常有用的，例如表示日期、状态、选项等。</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>在C#中，结构体（Struct）是一种用户定义的值类型，用于封装一组相关的数据字段。结构体是值类型，意味着它们在赋值或传递给方法时会被复制，而不是引用。</p>
<p>以下是一个结构体的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codestruct Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了一个名为 <code>Point</code> 的结构体，它包含两个整型字段 <code>X</code> 和 <code>Y</code>。这个结构体表示二维平面上的一个点。</p>
<p>我们可以创建结构体的实例，并访问其字段，例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codePoint p;</span><br><span class="line">p.X = <span class="number">10</span>;</span><br><span class="line">p.Y = <span class="number">5</span>;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;X: <span class="subst">&#123;p.X&#125;</span>, Y: <span class="subst">&#123;p.Y&#125;</span>&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个名为 <code>p</code> 的 <code>Point</code> 结构体的实例，并设置了其 <code>X</code> 和 <code>Y</code> 字段的值。然后，我们使用插值字符串将字段的值输出到控制台。</p>
<p>结构体可以具有构造函数、方法和属性，以提供更丰富的功能。此外，结构体还可以实现接口，从而使其具备更多的行为和特性。</p>
<p>与类相比，结构体通常更适合用于简单的数据封装，特别是对于小型、轻量级的对象。由于结构体是值类型，它们在内存上的存储方式和复制行为也与类不同，这些特性使得结构体在某些场景下具有性能优势。</p>
<p>需要注意的是，结构体是值类型，因此在将结构体实例传递给方法时，传递的是结构体的副本而不是引用。这可能会导致性能开销，尤其在结构体较大或复杂时。在这种情况下，可以考虑使用类来代替结构体。</p>
<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>在C#中，数组（Array）是一种用于存储相同类型的元素的数据结构。数组提供了一个连续的内存块来存储多个元素，并使用索引来访问和操作这些元素。</p>
<p>以下是一个数组的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们声明了一个名为 <code>numbers</code> 的整型数组，它可以存储5个整数。使用 <code>new int[5]</code> 创建了一个长度为5的整型数组，并将其赋值给 <code>numbers</code> 变量。</p>
<p>我们可以使用索引来访问数组中的元素。数组的索引从0开始，因此可以使用 <code>[index]</code> 访问特定位置的元素，例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codenumbers[<span class="number">0</span>] = <span class="number">10</span>;</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">20</span>;</span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">Console.WriteLine(numbers[<span class="number">1</span>]);  <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用索引操作符 <code>[index]</code> 将值分配给数组的特定位置，并使用索引访问特定位置的元素。</p>
<p>除了使用固定大小的数组，C#还提供了动态数组，称为 <code>List&lt;T&gt;</code>，它具有更灵活的大小调整和功能。使用 <code>List&lt;T&gt;</code> 类型可以动态添加、删除和修改元素。</p>
<p>以下是一个使用 <code>List&lt;int&gt;</code> 的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeList&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">numbers.Add(<span class="number">10</span>);</span><br><span class="line">numbers.Add(<span class="number">20</span>);</span><br><span class="line">numbers.Add(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(numbers[<span class="number">1</span>]);  <span class="comment">// 输出: 20</span></span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了一个 <code>List&lt;int&gt;</code> 类型的对象，并使用 <code>Add</code> 方法向列表中添加整数。然后，使用索引访问特定位置的元素。</p>
<p>数组在许多编程场景中都是非常有用的，可以用于存储和处理大量数据，以及实现诸如集合、矩阵、图像等数据结构和算法。</p>
<blockquote>
<p>在C#中，<code>new</code> 操作符用于创建一个对象的实例或初始化一个数组。它在内存中分配了足够的空间来存储对象或数组，并调用适当的构造函数来初始化对象的状态。</p>
<p><code>new</code> 操作符的用法有以下几个常见的情况：</p>
<ol>
<li><p>创建对象实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line">ClassName obj = <span class="keyword">new</span> ClassName();</span><br></pre></td></tr></table></figure>

<p>这种用法创建了一个类的实例，并调用了该类的默认构造函数来初始化对象的初始状态。可以通过 <code>obj</code> 变量来访问和操作该对象的成员。</p>
</li>
<li><p>创建对象实例并传递参数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line">ClassName obj = <span class="keyword">new</span> ClassName(arg1, arg2, ...);</span><br></pre></td></tr></table></figure>

<p>这种用法创建了一个类的实例，并调用了带有指定参数的构造函数来初始化对象的状态。构造函数根据参数的类型和顺序来确定调用哪个构造函数重载。</p>
</li>
<li><p>初始化数组：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>

<p>这种用法创建了一个指定长度的数组，并使用默认值对数组的元素进行初始化。在上面的示例中，数组的长度为5，所有元素都被初始化为 <code>int</code> 类型的默认值 0。</p>
</li>
</ol>
<p>在C#中，<code>new</code> 操作符是用于动态创建对象和数组的关键操作符之一。它使我们能够在运行时创建和初始化新的实例，以满足程序的需求。同时，<code>new</code> 操作符也触发了相应类型的构造函数，允许我们在对象创建的过程中执行必要的初始化操作。</p>
</blockquote>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>在C#中，函数具有以下特点：</p>
<ol>
<li>封装性（Encapsulation）：函数允许将相关代码块封装成一个独立的单元，使代码更加模块化和可复用。函数可以隐藏内部实现细节，并提供一个公共接口供其他部分使用。</li>
<li>参数传递（Parameter Passing）：函数可以接受零个或多个参数，这些参数用于向函数传递数据。在C#中，参数可以是值类型、引用类型或输出参数，允许函数对传入的参数进行读取和修改。</li>
<li>返回值（Return Value）：函数可以返回一个值，用于向调用方提供计算结果或其他需要的信息。返回值可以是任何有效的数据类型，包括基本类型、自定义类型和引用类型。</li>
<li>可访问性（Accessibility）：函数可以具有不同的访问修饰符，如<code>public</code>、<code>private</code>、<code>protected</code>等，用于控制函数的可见性和访问权限。这决定了哪些部分可以调用函数和访问函数内部。</li>
<li>方法重载（Method Overloading）：在C#中，可以定义具有相同名称但参数列表不同的多个函数，称为方法重载。通过方法重载，可以根据不同的参数类型和数量来选择调用合适的函数。</li>
<li>递归（Recursion）：函数可以调用自身，这称为递归。递归在解决某些问题时非常有用，可以简化代码逻辑，但需要注意递归终止条件，以避免无限递归。</li>
<li>异常处理（Exception Handling）：函数可以抛出异常（<code>throw</code>语句），并在调用方处于适当的位置进行异常处理（<code>try-catch</code>语句）。异常处理可以捕获和处理在函数执行过程中可能发生的错误或异常情况。</li>
<li>匿名函数和Lambda表达式（Anonymous Functions and Lambda Expressions）：C#支持定义匿名函数和使用Lambda表达式，这使得在需要时可以更方便地编写简单的函数代码块。</li>
</ol>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h4><p>在C#中，可以使用标准输入和输出流进行输入和输出操作。下面是一些常用的输入和输出方法：</p>
<p>Console.ReadLine()：从标准输入流读取一行用户输入，并以字符串的形式返回。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line"><span class="built_in">string</span> input = Console.ReadLine();</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529202723287.png" alt="image-20230529202723287"></p>
<p>Console.Read()：从标准输入流读取下一个字符的 ASCII 值，并以整数形式返回。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code</span><br><span class="line">    <span class="comment">//只能读一个是吗？</span></span><br><span class="line"><span class="built_in">int</span> input = Console.Read();</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529203000925.png" alt="image-20230529203000925"></p>
<p>*Console.ReadKey()：从标准输入流读取下一个键入的字符，并返回一个表示该键入的 ConsoleKeyInfo 对象。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeConsoleKeyInfo keyInfo = Console.ReadKey();</span><br><span class="line"><span class="built_in">char</span> input = keyInfo.KeyChar;</span><br></pre></td></tr></table></figure>

<blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _001_第一个程序</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//结构体：接受输入的值</span></span><br><span class="line">            ConsoleKeyInfo keyInfo = Console.ReadKey();</span><br><span class="line"></span><br><span class="line">            <span class="built_in">char</span> inputChar = keyInfo.KeyChar;         <span class="comment">// 获取按下的字符值</span></span><br><span class="line">            ConsoleKey key = keyInfo.Key;             <span class="comment">// 获取按下的键的枚举值</span></span><br><span class="line">            ConsoleModifiers modifiers = keyInfo.Modifiers;  <span class="comment">// 获取修饰键的状态</span></span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输入的字符值: &quot;</span> + inputChar);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输入的键: &quot;</span> + key);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;修饰键的状态: &quot;</span> + modifiers);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ConsoleKeyInfo</code> 是在 <code>System</code> 命名空间下定义的结构，用于表示从标准输入流读取的键入信息。该结构包含了按下的键、键的字符值和修饰键的状态。</p>
<p>以下是一些 <code>ConsoleKeyInfo</code> 结构的属性：</p>
<ul>
<li><code>KeyChar</code>：按下的键对应的字符值。如果按下的是特殊键或无法映射到字符的键，则该属性的值为 <code>\0</code>。</li>
<li><code>Key</code>：按下的键的枚举值，类型为 <code>ConsoleKey</code>。可以使用 <code>Key</code> 属性来判断按下的是哪个特殊键，如方向键、功能键等。</li>
<li><code>Modifiers</code>：按下键时同时按下的修饰键（如 Shift、Ctrl 等）。该属性的类型为 <code>ConsoleModifiers</code> 枚举，可以使用按位运算符来判断是否同时按下了某个修饰键。</li>
</ul>
<p>以下是一个示例，演示如何使用 <code>ConsoleKeyInfo</code> 结构：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeConsoleKeyInfo keyInfo = Console.ReadKey();</span><br><span class="line"></span><br><span class="line"><span class="built_in">char</span> inputChar = keyInfo.KeyChar;         <span class="comment">// 获取按下的字符值</span></span><br><span class="line">ConsoleKey key = keyInfo.Key;             <span class="comment">// 获取按下的键的枚举值</span></span><br><span class="line">ConsoleModifiers modifiers = keyInfo.Modifiers;  <span class="comment">// 获取修饰键的状态</span></span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;输入的字符值: &quot;</span> + inputChar);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;输入的键: &quot;</span> + key);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;修饰键的状态: &quot;</span> + modifiers);</span><br></pre></td></tr></table></figure>

<p>通过上述代码，你可以获取按下的字符值、键和修饰键的状态，并根据需要进行进一步的处理和判断。</p>
</blockquote>
<p>Console.Write()：将指定的数据写入标准输出流，不附加换行符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Console.Write(<span class="string">&quot;The number is: &quot;</span>);</span><br><span class="line">Console.Write(number);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529210259411.png" alt="image-20230529210259411"></p>
<p>Console.WriteLine()：将指定的数据写入标准输出流，并附加换行符。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529210347145.png" alt="image-20230529210347145"></p>
<p>Console.WriteFormat()：将格式化的字符串写入标准输出流。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">25</span>;</span><br><span class="line">Console.WriteFormat(<span class="string">&quot;My name is &#123;0&#125; and I am &#123;1&#125; years old.&quot;</span>, name, age);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529210603766.png" alt="image-20230529210603766"></p>
<blockquote>
<p>这里用到了占位符，就简单的讲一下：</p>
<p>占位符的使用特点如下：</p>
<ol>
<li>顺序替换：占位符按照在格式化字符串中的顺序进行替换。第一个占位符 <code>&#123;0&#125;</code> 对应第一个参数，第二个占位符 <code>&#123;1&#125;</code> 对应第二个参数，依此类推。确保提供的参数数量与占位符的数量匹配，否则会引发异常。</li>
<li>参数类型灵活：占位符可以接受任意类型的参数。在替换过程中，会自动将参数转换为字符串形式。这允许你在格式化字符串中插入各种类型的数据，包括字符串、数字、日期等。</li>
<li>重复使用：占位符可以在格式化字符串中多次重复使用。这意味着你可以多次插入同一个参数值，或者在不同位置插入相同或不同的参数值。</li>
<li>格式化选项：占位符还可以使用格式化选项来指定参数的显示格式。格式化选项可以用于数字、日期、时间等类型的参数，以控制其显示方式。例如：<code>&#123;0:C&#125;</code> 表示将第一个参数作为货币值进行格式化显示。</li>
</ol>
<p>下面是一个示例，展示了占位符的使用特点：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codestring name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> age = <span class="number">25</span>;</span><br><span class="line"><span class="built_in">double</span> salary = <span class="number">2500.50</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> result = String.Format(<span class="string">&quot;My name is &#123;0&#125;, I am &#123;1&#125; years old, and my salary is &#123;2:C&#125;.&quot;</span>, name, age, salary);</span><br><span class="line">Console.WriteLine(result);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">swiftCopy code</span><br><span class="line">My name <span class="keyword">is</span> Alice, I am <span class="number">25</span> years old, <span class="keyword">and</span> my salary <span class="keyword">is</span> $<span class="number">2</span>,<span class="number">500.50</span>.</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>&#123;0&#125;</code> 对应变量 <code>name</code>，<code>&#123;1&#125;</code> 对应变量 <code>age</code>，<code>&#123;2:C&#125;</code> 对应变量 <code>salary</code>。参数按照顺序替换占位符，并使用相应的格式化选项。</p>
<p>通过占位符的使用特点，你可以方便地构建格式化的字符串，插入适当的参数，并根据需要进行格式化控制。</p>
</blockquote>
<p>这些方法可以用于控制台应用程序中的输入和输出操作。你可以根据需要使用适当的方法来读取用户输入或向控制台输出数据。</p>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><p>在 C# 中，有多种方法可以进行字符串拼接。下面是一些常见的字符串拼接规则和方法：</p>
<p>使用 <code>+</code> 运算符：可以使用 <code>+</code> 运算符将多个字符串连接在一起。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> lastName = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> fullName = firstName + <span class="string">&quot; &quot;</span> + lastName;</span><br><span class="line">Consolo.Write(fullName);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212308991.png" alt="image-20230529212308991"></p>
<p>*使用字符串插值（String Interpolation）：可以使用 <code>$</code> 符号和花括号 <code>&#123;&#125;</code> 来将变量插入到字符串中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> lastName = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> fullName = <span class="string">$&quot;<span class="subst">&#123;firstName&#125;</span> <span class="subst">&#123;lastName&#125;</span>&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212411765.png" alt="image-20230529212411765"></p>
<p>使用 <code>String.Format</code> 方法：可以使用 <code>String.Format</code> 方法来格式化字符串，并将参数插入到占位符中。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> firstName = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> lastName = <span class="string">&quot;Doe&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> fullName = String.Format(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, firstName, lastName);</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212513492.png" alt="image-20230529212513492"></p>
<p><strong>使用 <code>StringBuilder</code> 类：如果需要高效地拼接大量字符串或在循环中进行拼接操作，可以使用 <code>StringBuilder</code> 类。</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.Append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.Append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">sb.Append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> result = sb.ToString();</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230529212821511.png" alt="image-20230529212821511"></p>
<p>需要注意的是，字符串是不可变的（immutable），这意味着每次对字符串进行修改时，实际上会创建一个新的字符串对象。因此，在需要进行大量字符串拼接的情况下，使用 <code>StringBuilder</code> 类可以避免不必要的内存分配和性能损失。</p>
<blockquote>
<p>在C#中，有许多常用的字符串操作方法可用于处理和操作字符串。以下是一些常见的字符串操作示例：</p>
<ol>
<li><p>字符串连接：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cCopy codestring str1 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> result = str1 + <span class="string">&quot; &quot;</span> + str2;  <span class="comment">// 结果为 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串长度：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cCopy codestring str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> length = str.Length;  <span class="comment">// 结果为 11</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串截取：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cCopy codestring str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> substring = str.Substring(<span class="number">6</span>);  <span class="comment">// 结果为 &quot;World&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串分割：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">luaCopy codestring str = <span class="string">&quot;apple,banana,orange&quot;</span>;</span><br><span class="line"><span class="built_in">string</span>[] fruits = str.Split(<span class="string">&#x27;,&#x27;</span>);  <span class="comment">// 结果为 [&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串替换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cCopy codestring str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> replaced = str.Replace(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Universe&quot;</span>);  <span class="comment">// 结果为 &quot;Hello Universe&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串大小写转换：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cCopy codestring str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> uppercase = str.ToUpper();  <span class="comment">// 结果为 &quot;HELLO WORLD&quot;</span></span><br><span class="line"><span class="built_in">string</span> lowercase = str.ToLower();  <span class="comment">// 结果为 &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串去除空格：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">cCopy codestring str = <span class="string">&quot;  Hello World  &quot;</span>;</span><br><span class="line"><span class="built_in">string</span> trimmed = str.Trim();  <span class="comment">// 结果为 &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串查找：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">rustCopy codestring str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="built_in">bool</span> containsHello = str.Contains(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 结果为 true</span></span><br><span class="line"><span class="built_in">int</span> index = str.IndexOf(<span class="string">&quot;World&quot;</span>);  <span class="comment">// 结果为 6</span></span><br></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<h4 id="变量的类型转换"><a href="#变量的类型转换" class="headerlink" title="变量的类型转换"></a>变量的类型转换</h4><p>在C#中，可以使用类型转换操作符或转换方法来进行变量类型转换。以下是几种常见的类型转换方法：</p>
<ol>
<li><p>显式类型转换（Explicit Casting）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code<span class="comment">// 使用类型转换操作符</span></span><br><span class="line"><span class="built_in">int</span> intValue = (<span class="built_in">int</span>)doubleValue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Convert类的转换方法</span></span><br><span class="line"><span class="built_in">int</span> intValue = Convert.ToInt32(doubleValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>隐式类型转换（Implicit Casting）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code<span class="comment">// 隐式类型转换只适用于可安全地转换的情况</span></span><br><span class="line"><span class="built_in">int</span> intValue = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">double</span> doubleValue = intValue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Parse方法和TryParse方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code<span class="comment">// Parse方法将字符串转换为特定类型的值</span></span><br><span class="line"><span class="built_in">int</span> intValue = <span class="built_in">int</span>.Parse(<span class="string">&quot;10&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// TryParse方法尝试将字符串转换为特定类型的值，并返回转换是否成功的布尔值</span></span><br><span class="line"><span class="built_in">bool</span> success = <span class="built_in">int</span>.TryParse(<span class="string">&quot;10&quot;</span>, <span class="keyword">out</span> <span class="built_in">int</span> intValue);</span><br></pre></td></tr></table></figure>
</li>
<li><p>Convert类的转换方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code<span class="comment">// 使用Convert类的转换方法进行类型转换</span></span><br><span class="line"><span class="built_in">int</span> intValue = Convert.ToInt32(doubleValue);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h2><p>用几个简单的实例，来让我们熟系c#代码的功能吧。</p>
<h3 id="交换两个数据的值"><a href="#交换两个数据的值" class="headerlink" title="交换两个数据的值"></a>交换两个数据的值</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _002_练习</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//声明两个变量交换他们的值</span></span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">            <span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;打印交换之前的数据&quot;</span>);</span><br><span class="line">            Console.WriteLine(a);</span><br><span class="line">            Console.WriteLine(b);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 等待用户按下一个键</span></span><br><span class="line">            Console.ReadKey(); </span><br><span class="line"></span><br><span class="line">            temp = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = temp;</span><br><span class="line">            <span class="comment">//打印</span></span><br><span class="line">            Console.WriteLine(a);</span><br><span class="line">            Console.WriteLine(b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算梯形和圆形的值"><a href="#计算梯形和圆形的值" class="headerlink" title="计算梯形和圆形的值"></a>计算梯形和圆形的值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _002_练习</span><br><span class="line">&#123;</span><br><span class="line">    internal <span class="keyword">class</span> <span class="title class_">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">m</span><span class="params">(<span class="type">double</span> up, <span class="type">double</span> down, <span class="type">double</span> h)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (up + down) * h / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;计算梯形的面积&quot;</span>);</span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;请输入上底：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> up = Convert.<span class="built_in">ToDouble</span>(Console.<span class="built_in">ReadLine</span>());</span><br><span class="line"></span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;请输入下底：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> down = Convert.<span class="built_in">ToDouble</span>(Console.<span class="built_in">ReadLine</span>());</span><br><span class="line"></span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;请输入高度：&quot;</span>);</span><br><span class="line">            <span class="type">double</span> h = Convert.<span class="built_in">ToDouble</span>(Console.<span class="built_in">ReadLine</span>());</span><br><span class="line"></span><br><span class="line">            <span class="type">double</span> result = <span class="built_in">m</span>(up, down, h);</span><br><span class="line"></span><br><span class="line">            Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;计算结果为：&quot;</span> + result);</span><br><span class="line">            Console.<span class="built_in">ReadKey</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>ToDouble</code> 是一个用于将其他数据类型转换为 <code>double</code> 类型的方法。它是.NET Framework 中的一个内置方法，可用于在C#中进行数据类型转换。</p>
<p>在C#中，数据类型转换是将一个数据类型的值转换为另一个数据类型的过程。当您需要在不同的数据类型之间进行转换时，可以使用适当的类型转换方法。</p>
<p><code>ToDouble</code> 方法用于将其他数据类型的值转换为 <code>double</code> 类型的值。它是静态方法，可以通过调用相应数据类型的实例来使用。</p>
<p>例如，如果要将一个字符串转换为 <code>double</code> 类型，可以使用以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codestring numberString = <span class="string">&quot;3.14&quot;</span>;</span><br><span class="line"><span class="built_in">double</span> number = Convert.ToDouble(numberString);</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们将字符串变量 <code>numberString</code> 的值转换为 <code>double</code> 类型，并将结果存储在 <code>number</code> 变量中。<code>Convert.ToDouble()</code> 方法根据字符串的内容将其转换为相应的 <code>double</code> 类型值。</p>
<p>请注意，如果无法成功进行转换（例如，字符串不是有效的数字表示），则会抛出 <code>FormatException</code> 异常。因此，在进行数据类型转换时，需要确保输入的数据与目标数据类型兼容，否则可能会导致运行时错误。</p>
<blockquote>
<p><code>Convert</code> 是一个在 .NET Framework 中提供的类，用于执行数据类型之间的转换操作。它包含了各种静态方法，用于在不同的数据类型之间进行转换。</p>
<p><code>Convert</code> 类提供了一系列的静态方法，用于将一个数据类型的值转换为另一个数据类型。它支持各种常见的数据类型，例如整数、浮点数、字符串、日期等。通过调用相应的 <code>Convert</code> 方法，您可以将一个数据类型的值转换为另一个数据类型，前提是转换是合法和有效的。</p>
<p>以下是一些常用的 <code>Convert</code> 方法的示例：</p>
<ol>
<li><code>Convert.ToInt32()</code>：将其他数据类型的值转换为 32 位整数类型（<code>int</code>）。</li>
<li><code>Convert.ToDouble()</code>：将其他数据类型的值转换为双精度浮点数类型（<code>double</code>）。</li>
<li><code>Convert.ToString()</code>：将其他数据类型的值转换为字符串类型（<code>string</code>）。</li>
<li><code>Convert.ToDateTime()</code>：将其他数据类型的值转换为日期和时间类型（<code>DateTime</code>）。</li>
</ol>
<p>这些方法使用方法类似于 <code>Convert.ToDouble(value)</code>，其中 <code>value</code> 是要转换的值。方法将返回转换后的值，并根据需要进行合理的舍入、截断或格式化操作。</p>
<p>需要注意的是，在进行转换之前，需要确保源数据类型可以被转换为目标数据类型，否则可能会引发异常。例如，如果尝试将一个非数字字符串转换为整数类型，则会引发 <code>FormatException</code> 异常。</p>
<p><code>Convert</code> 类提供了一种方便且安全的方法来执行数据类型转换，使开发人员能够轻松地在不同的数据类型之间进行转换操作。</p>
</blockquote>
</blockquote>
<p>为什么要在函数体前加static？</p>
<blockquote>
<p>在C#中，<code>static</code> 关键字用于声明静态成员（方法、字段、属性等）。当在函数体前加上 <code>static</code> 关键字时，表示该方法是一个静态方法。</p>
<p>静态方法与实例方法有一些不同之处：</p>
<ol>
<li>静态方法属于类本身，而不是类的实例。可以通过类名直接调用静态方法，而无需创建类的实例。</li>
<li>静态方法可以在不创建类的实例的情况下访问和操作类的静态成员（静态字段、静态属性等）。</li>
<li>静态方法不能直接访问实例成员（实例字段、实例属性等），因为它们没有与特定实例关联。</li>
</ol>
<p>在将方法声明为静态时，有几个常见的原因和用途：</p>
<ol>
<li>共享性：静态方法是类的共享成员，所有类的实例都可以共享相同的静态方法。这使得静态方法可以用于实现与类相关的功能，而无需每次创建实例。</li>
<li>实用性：某些方法不需要访问实例状态或实例成员，只需要执行一些独立于实例的操作。将这些方法声明为静态方法可以更清晰地表达其意图和用途。</li>
<li>工具类方法：静态方法经常用于实现工具类或辅助类中的通用功能。这些方法不需要访问实例状态，可以通过类名直接调用。</li>
</ol>
<p>需要注意的是，静态方法只能访问静态成员，无法直接访问实例成员。如果在静态方法中需要访问实例成员，可以通过传递实例参数或创建实例对象来间接访问。</p>
<p>总而言之，将函数体前加上 <code>static</code> 关键字表示该方法是一个静态方法，具有与实例方法不同的特性和用途。</p>
</blockquote>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> _002_练习</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">o</span>(<span class="params"><span class="built_in">double</span> r</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">3.14</span> * r * r);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入圆的半径&quot;</span>);</span><br><span class="line">            <span class="built_in">double</span> r = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">           Console.WriteLine(o(r));</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="条件语句练习"><a href="#条件语句练习" class="headerlink" title="条件语句练习"></a>条件语句练习</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ConditionalStatementExercise</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">            <span class="built_in">int</span> number = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断输入的数值是否为正数、负数或零，并输出相应的消息</span></span><br><span class="line">            <span class="keyword">if</span> (number &gt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;输入的数值是正数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (number &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;输入的数值是负数&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;输入的数值是零&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">  <span class="comment">//暂停</span></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="兔子增速问题"><a href="#兔子增速问题" class="headerlink" title="兔子增速问题"></a>兔子增速问题</h3><p>兔子繁育问题。设有一对新生的兔子，从第三个月开始他们每个月都生一对兔子，新生的兔子从第三个月开始又每个月生一对兔子。技此规律，并假定象子没有死亡，20个月后共有多少个兔子? 要求编编写为控制台程序。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RabbitReproduction</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> totalMonths = <span class="number">20</span>; <span class="comment">// 总月数</span></span><br><span class="line">            <span class="built_in">int</span> adultPairs = <span class="number">1</span>; <span class="comment">// 成年兔对数（初始为1对）</span></span><br><span class="line">            <span class="built_in">int</span> childPairs = <span class="number">0</span>; <span class="comment">// 幼兔对数（初始为0对）</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= totalMonths; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> newPairs = adultPairs; <span class="comment">// 新生的兔对数等于成年兔对数</span></span><br><span class="line">                adultPairs += childPairs; <span class="comment">// 成年兔对数增加幼兔对数</span></span><br><span class="line">                childPairs = newPairs; <span class="comment">// 幼兔对数更新为新生的兔对数</span></span><br><span class="line">                </span><br><span class="line">   <span class="comment">//$符号是C#语言中的字符串插值符号。它允许你在字符串中嵌入表达式</span></span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;第<span class="subst">&#123;i&#125;</span>个月：成年兔对数：<span class="subst">&#123;adultPairs&#125;</span>，幼兔对数：<span class="subst">&#123;childPairs&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">int</span> totalPairs = adultPairs + childPairs; <span class="comment">// 总兔对数</span></span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;总共有<span class="subst">&#123;totalMonths&#125;</span>个月后，共有<span class="subst">&#123;totalPairs&#125;</span>对兔子。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随机数版本</span></span><br><span class="line"><span class="keyword">namespace</span> _02_兔子增速</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//开始兔子数量给他一个随机数</span></span><br><span class="line">            <span class="built_in">int</span> starting_number = <span class="keyword">new</span> Random().Next(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//一共生二十个月</span></span><br><span class="line">            <span class="built_in">int</span> totalMouths = <span class="number">20</span>;</span><br><span class="line">            <span class="built_in">int</span> adultPairs = starting_number;</span><br><span class="line">            <span class="comment">//生下来幼小的兔子开始为0对</span></span><br><span class="line">            <span class="built_in">int</span> childPairs = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; totalMouths; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> newPair = adultPairs; <span class="comment">//新生的兔子对数等于成年兔对数</span></span><br><span class="line">                adultPairs += childPairs; <span class="comment">//成年兔对数增加幼兔对数</span></span><br><span class="line">                childPairs = newPair; <span class="comment">//幼兔出现</span></span><br><span class="line"></span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;第<span class="subst">&#123;i&#125;</span>个月：成年兔对数：<span class="subst">&#123;adultPairs&#125;</span>，幼兔对数：<span class="subst">&#123;childPairs&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//总数 ： 幼+成</span></span><br><span class="line">            <span class="built_in">int</span> totalPairs = adultPairs+childPairs;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;总共有<span class="subst">&#123;totalMouths&#125;</span>个月后，共有<span class="subst">&#123;totalPairs&#125;</span>对兔子。&quot;</span>);</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制输出"><a href="#控制输出" class="headerlink" title="控制输出"></a>控制输出</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">NumberList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line">                <span class="built_in">int</span> n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.Write(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//打印个空格 换行</span></span><br><span class="line">                    Console.WriteLine();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>; <span class="comment">// 退出程序</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// 转到下一次循环，接收下一个整数</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="求解1000以内的所有完数"><a href="#求解1000以内的所有完数" class="headerlink" title="求解1000以内的所有完数"></a>求解1000以内的所有完数</h3><p>完数（Perfect Number）是指一个正整数，它恰好等于它的所有因子（除了自身）之和。换句话说，一个完数的所有真因子之和等于它本身。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PerfectNumbers</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> number = <span class="number">1</span>; number &lt;= <span class="number">1000</span>; number++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 寻找因子并求和</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; number; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (number % i == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        sum += i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否为完数</span></span><br><span class="line">                <span class="keyword">if</span> (sum == number)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="投掷骰子"><a href="#投掷骰子" class="headerlink" title="投掷骰子"></a>投掷骰子</h3><p>编写一个掷筛子100次的程序，并打印出各种点数的出现次数。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DiceRoll</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//随机数</span></span><br><span class="line">            Random random = <span class="keyword">new</span> Random();</span><br><span class="line">            <span class="built_in">int</span>[] count = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">6</span>]; <span class="comment">// 用于记录每个点数的出现次数</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> diceValue = random.Next(<span class="number">1</span>, <span class="number">7</span>); <span class="comment">// 随机生成1到6的整数，模拟筛子的点数</span></span><br><span class="line">                count[diceValue - <span class="number">1</span>]++; <span class="comment">// 对应点数的出现次数加1</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 打印各种点数的出现次数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">$&quot;点数 <span class="subst">&#123;i + <span class="number">1</span>&#125;</span> 出现的次数：<span class="subst">&#123;count[i]&#125;</span>&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>生成随机数：</p>
<p>在 C# 中，可以使用 <code>Random</code> 类来生成随机数。<code>Random</code> 类提供了一些方法来生成不同范围和类型的随机数。</p>
<p>下面是一些常见的随机数生成示例：</p>
<p>生成一个介于0和最大整数之间的随机整数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeRandom random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="built_in">int</span> randomNumber = random.Next();</span><br></pre></td></tr></table></figure>

<p>生成一个指定范围内的随机整数（包括最小值但不包括最大值）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeRandom random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="built_in">int</span> randomNumber = random.Next(minValue, maxValue);</span><br></pre></td></tr></table></figure>

<p>生成一个随机双精度浮点数（介于0.0和1.0之间）：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeRandom random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="built_in">double</span> randomDouble = random.NextDouble();</span><br></pre></td></tr></table></figure>

<p>生成一个指定范围内的随机双精度浮点数：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeRandom random = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="built_in">double</span> randomDouble = minValue + (random.NextDouble() * (maxValue - minValue));</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Random</code> 类的实例被创建，并使用 <code>Next()</code> 或 <code>NextDouble()</code> 方法来生成随机数。对于整数，<code>Next()</code> 方法生成一个非负整数；对于浮点数，<code>NextDouble()</code> 方法生成一个介于0.0和1.0之间的浮点数。</p>
<p>需要注意的是，在某些情况下，如果在循环中连续创建 <code>Random</code> 对象并立即使用 <code>Next()</code> 方法，可能会得到相同的随机数序列。为了避免这种情况，建议将 <code>Random</code> 对象的创建移到循环外部，以便重复使用同一个对象。</p>
</blockquote>
<h3 id="99乘法表"><a href="#99乘法表" class="headerlink" title="99乘法表"></a>99乘法表</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MultiplicationTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//j&lt;=i是个细节</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Write(<span class="string">$&quot;<span class="subst">&#123;j&#125;</span> × <span class="subst">&#123;i&#125;</span> = <span class="subst">&#123;i * j&#125;</span>\t&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                Console.WriteLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Console.Write($&quot;&#123;j&#125; × &#123;i&#125; = &#123;i * j&#125;\t&quot;);</code></p>
<p>字符串插值（String interpolation）的语法。<code>$&#123;j&#125; × &#123;i&#125; = &#123;i * j&#125;\t</code> 是一个包含格式占位符的字符串，其中 <code>&#123;&#125;</code> 用于包含表达式，而 <code>$</code> 前缀表示字符串是一个插值字符串。在这个字符串中，<code>&#123;j&#125;</code> 表示将变量 <code>j</code> 的值插入到字符串中，<code>&#123;i&#125;</code> 表示将变量 <code>i</code> 的值插入到字符串中，<code>&#123;i * j&#125;</code> 表示将变量 <code>i * j</code> 的结果插入到字符串中。<code>\t</code> 是一个制表符，用于在输出中创建水平制表。</p>
<p>综上所述，<code>Console.Write($&quot;&#123;j&#125; × &#123;i&#125; = &#123;i * j&#125;\t&quot;)</code> 的作用是将一条形如 “j × i &#x3D; (i * j)” 的带有制表符的字符串输出到控制台。</p>
</blockquote>
<h3 id="计算素数个数"><a href="#计算素数个数" class="headerlink" title="计算素数个数"></a>计算素数个数</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Prime numbers up to 1000:&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">1000</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> isPrime = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">2</span>; j &lt;= Math.Sqrt(i); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    isPrime = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (isPrime)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="要求用户输入5个大写字母"><a href="#要求用户输入5个大写字母" class="headerlink" title="要求用户输入5个大写字母"></a>要求用户输入5个大写字母</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> input;</span><br><span class="line">        <span class="built_in">bool</span> isValid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!isValid)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入5个大写字母：&quot;</span>);</span><br><span class="line">            input = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (input.Length == <span class="number">5</span> &amp;&amp; IsAllUpperCaseLetters(input))</span><br><span class="line">            &#123;</span><br><span class="line">                isValid = <span class="literal">true</span>;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;输入有效！&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这里可以继续处理输入的逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;输入无效，请确保输入5个大写字母。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsAllUpperCaseLetters</span>(<span class="params"><span class="built_in">string</span> input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">char</span> c <span class="keyword">in</span> input)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//检查c是否为大写字母</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">char</span>.IsUpper(c))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>char.IsUpper(c)</code> 是一个方法调用，用于判断给定的字符是否为大写字母。<code>char.IsUpper</code> 方法返回一个布尔值，如果字符是大写字母，则返回 <code>true</code>，否则返回 <code>false</code>。</p>
</blockquote>
<h2 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h2><h3 id="猜数字"><a href="#猜数字" class="headerlink" title="猜数字"></a>猜数字</h3><p>猜数字游戏，我有一个数请您猜猜是多少?请忽输入一个0-50之问的数:20( 用户输入数字)您猜小了，这个数字比20大:30.您猜大了，这个数字比30小:25.恭喜您猜对了，这个数字为:25</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MultiplicationTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">bool</span> is_read = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">int</span> counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!is_read)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//让这个语句只执行一次</span></span><br><span class="line">                <span class="keyword">if</span>(counter == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;请你猜猜我这个数据是多少涅？&quot;</span>);</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;不对捏，再猜&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//读入一个int类型数据</span></span><br><span class="line">                <span class="built_in">int</span> readS = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">                <span class="comment">//猜的数据</span></span><br><span class="line">                <span class="built_in">int</span> guess = <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (readS == guess)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;你猜对了&quot;</span>);</span><br><span class="line">                    is_read = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(readS &gt; guess) &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;输入的数据比目标数据大&#123;0&#125;&quot;</span>, Math.Abs(guess - readS));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;输入的数据比目标数据小&#123;0&#125;&quot;</span>, Math.Abs(guess - readS));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//随机数版本</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MultiplicationTable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">bool</span> isGuessed = <span class="literal">false</span>;</span><br><span class="line">            <span class="built_in">int</span> guess = <span class="keyword">new</span> Random().Next(<span class="number">1</span>, <span class="number">101</span>); <span class="comment">// 生成1到100之间的随机数作为目标数据</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!isGuessed)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">int</span> readS;</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;请你猜猜我这个数据是多少涅？&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">int</span>.TryParse(Console.ReadLine(), <span class="keyword">out</span> readS)) <span class="comment">// 输入验证</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (readS == guess)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;你猜对了&quot;</span>);</span><br><span class="line">                        isGuessed = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (readS &gt; guess)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;输入的数据比目标数据大&#123;0&#125;&quot;</span>, readS - guess);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.WriteLine(<span class="string">&quot;输入的数据比目标数据小&#123;0&#125;&quot;</span>, guess - readS);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    Console.WriteLine(<span class="string">&quot;输入的不是有效的整数，请重新输入&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>编写一个控制台程序，要求用户输入一组数字，对用户输入的数字从小到大输出。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入一组数字（以逗号分隔）：&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span>[] numbers = input.Split(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        <span class="built_in">int</span>[] arr = <span class="keyword">new</span> <span class="built_in">int</span>[numbers.Length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numbers.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span>.TryParse(numbers[i], <span class="keyword">out</span> arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Array.Sort(arr);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;从小到大排序后的数字为：&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> arr)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="猴子吃桃"><a href="#猴子吃桃" class="headerlink" title="猴子吃桃"></a>猴子吃桃</h3><p>每天的桃子数量是前一天桃子数量加1后乘以2的结果。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入天数 n 的值：&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> peachCount = CalculatePeaches(n);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;悟空第一天吃桃子的数量为：&quot;</span> + peachCount);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculatePeaches</span>(<span class="params"><span class="built_in">int</span> n</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> peachCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            peachCount = (peachCount + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> peachCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="找最小"><a href="#找最小" class="headerlink" title="找最小"></a>找最小</h3><p>输入n(n&lt;100)个数，找出其中最小的数，将它与最前面的数交换后输出这些数</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入要输入的数字个数 n（n &lt; 100）：&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> n = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span>[] numbers = <span class="keyword">new</span> <span class="built_in">int</span>[n];</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入这 &quot;</span> + n + <span class="string">&quot; 个数字：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            numbers[i] = Convert.ToInt32(Console.ReadLine());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> minIndex = FindMinimumIndex(numbers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIndex != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Swap(numbers, <span class="number">0</span>, minIndex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;交换后的数字为：&quot;</span>);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> num <span class="keyword">in</span> numbers)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.Write(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">FindMinimumIndex</span>(<span class="params"><span class="built_in">int</span>[] arr</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> minValue = arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; arr.Length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; minValue)</span><br><span class="line">            &#123;</span><br><span class="line">                minIndex = i;</span><br><span class="line">                minValue = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>(<span class="params"><span class="built_in">int</span>[] arr, <span class="built_in">int</span> index1, <span class="built_in">int</span> index2</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> temp = arr[index1];</span><br><span class="line">        arr[index1] = arr[index2];</span><br><span class="line">        arr[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发工资"><a href="#发工资" class="headerlink" title="发工资"></a>发工资</h3><p>作为泰课的老师，最盼望的日子就是每月的8号了，因为这一天是发工资的日子，养家糊口就它了，呵呵但是对子素则务处的工作人员来说，这一天是很忙品的天,对务处的小云最近就在考海一个同题:如果每个老所的工资额都和道，最少需要备多少张人民币，才能在治年位老师发工路的时候都不用老师战零呢这里假设老师的工资都是正整数，单位元，人民币一共有100元、50元、10元，5元、2元和1元六种</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入老师的人数：&quot;</span>);</span><br><span class="line">        <span class="built_in">int</span> teacherCount = Convert.ToInt32(Console.ReadLine());</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入每位老师的工资额（以空格分隔）：&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line">        <span class="built_in">string</span>[] salaryStrArray = input.Split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="built_in">int</span>[] salaries = <span class="keyword">new</span> <span class="built_in">int</span>[teacherCount];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; teacherCount; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            salaries[i] = Convert.ToInt32(salaryStrArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> minimumBills = CalculateMinimumBills(salaries);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;最少需要备 &quot;</span> + minimumBills + <span class="string">&quot; 张人民币。&quot;</span>);</span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">CalculateMinimumBills</span>(<span class="params"><span class="built_in">int</span>[] salaries</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] denominations = &#123; <span class="number">100</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span> &#125;;</span><br><span class="line">        <span class="built_in">int</span> minimumBills = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">int</span> salary <span class="keyword">in</span> salaries)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> remainingSalary = salary;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; denominations.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                minimumBills += remainingSalary / denominations[i];</span><br><span class="line">                remainingSalary %= denominations[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> minimumBills;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="判断是否合法"><a href="#判断是否合法" class="headerlink" title="判断是否合法"></a>判断是否合法</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 从用户输入中获取标识符</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;请输入一个标识符:&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> input = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用正则表达式检查标识符的合法性</span></span><br><span class="line">        <span class="built_in">bool</span> isValidIdentifier = Regex.IsMatch(input, <span class="string">@&quot;^[a-zA-Z_][a-zA-Z0-9_]*$&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (isValidIdentifier)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输入的字符串是一个合法的C#标识符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;输入的字符串不是一个合法的C#标识符&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>正则表达式：</p>
</blockquote>
<h2 id="c-面向对象"><a href="#c-面向对象" class="headerlink" title="c#面向对象"></a>c#面向对象</h2><p>面向对象编程（Object-Oriented Programming，简称OOP）是一种编程范式，它将程序设计问题划分为对象的集合，这些对象通过相互之间的交互来解决问题。在面向对象编程中，程序被组织成一组对象，每个对象都是类的实例，类定义了对象的属性（数据）和行为（方法）。</p>
<p>面向对象编程的核心思想是将真实世界中的事物抽象成为程序中的对象，每个对象都具有自己的状态和行为。对象可以通过发送消息（调用方法）来与其他对象进行交互，从而实现数据的封装、继承和多态性等特性。</p>
<p>面向对象编程具有以下特点：</p>
<ol>
<li>封装（Encapsulation）：将数据和操作封装在对象中，对象对外部提供有限的接口来访问和修改其内部状态，隐藏了实现细节，增强了安全性和模块化。</li>
<li>继承（Inheritance）：通过继承机制，一个类可以派生出子类，子类继承了父类的属性和方法，并可以在此基础上进行扩展或修改，实现代码的重用和扩展。</li>
<li>多态（Polymorphism）：多态性允许对象根据上下文的不同呈现不同的行为。通过多态，可以通过父类类型引用来引用子类对象，并根据实际对象类型来调用相应的方法。</li>
</ol>
<p>面向对象编程能够提供更加模块化、可扩展和可维护的代码，通过将问题分解成对象的方式来组织代码结构，使得代码更易于理解和重用。它被广泛应用于许多编程语言和软件开发领域。</p>
<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>在C#中，命名空间（Namespace）用于组织和管理代码，提供了一种避免命名冲突和代码组织的机制。命名空间可以包含类、结构、枚举、接口和其他命名空间等元素。</p>
<p>以下是一些命名空间的作用：</p>
<ol>
<li><strong>避免命名冲突</strong>：命名空间提供了一种将相关的类、结构和其他元素组织在一起的方式。不同命名空间中的同名类或成员不会发生冲突，可以在代码中使用完全限定名（包含命名空间）来区分它们。</li>
<li><strong>代码组织和模块化</strong>：命名空间可以按照逻辑关系将代码组织成模块，提高代码的可读性和可维护性。通过使用命名空间，可以将相关的类和功能放在一起，使代码更加结构化。</li>
<li><strong>访问控制和可见性</strong>：命名空间可以定义公共（public）和非公共（internal、private）的元素，从而控制代码的可见性和访问级别。通过将类和成员放置在适当的命名空间中，并使用适当的访问修饰符，可以限制对代码的访问。</li>
<li><strong>代码重用和组件化</strong>：命名空间可以用于组织和管理代码库中的各个组件。可以通过引用相应的命名空间来重用其他代码库中的类和功能，提高代码的重用性和可维护性。</li>
<li><strong>名称空间别名</strong>：命名空间还可以使用别名来简化代码中的引用。通过使用<code>using</code>关键字并提供一个别名，可以在代码中使用简短的名称来引用长命名空间，减少代码的冗余性和书写工作。</li>
</ol>
<p>例如，以下是一个使用命名空间的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeusing System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">MyApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>using System</code>语句引入了名为<code>System</code>的命名空间，其中包含了<code>Console</code>类。这样就可以直接使用<code>Console.WriteLine</code>方法而不需要使用完全限定名。</p>
<p>总而言之，命名空间在C#中提供了一种组织、管理和控制代码的机制，可以提高代码的可读性、可维护性和可重用性，并帮助避免命名冲突。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装（Encapsulation）是面向对象编程中的一个重要概念，它指的是将数据和操作封装在一个单元（如类）中，以实现信息隐藏和安全性。</p>
<p>封装通过将相关的数据和操作组合在一起形成一个单元，将其视为一个独立的实体，并对外部隐藏其内部实现细节。这意味着外部代码无法直接访问和修改封装单元的数据，而是通过定义的公共接口来与其进行交互。</p>
<p>类是实现封装的主要方式之一。在面向对象编程中，类是一个封装数据和方法的模板。它将数据（成员变量）和操作（成员方法）组合在一起，形成一个独立的实体。</p>
<p>通过使用访问修饰符（如<code>public</code>、<code>private</code>、<code>protected</code>等），类可以控制成员的可访问性。私有成员只能在类的内部访问，而公共成员可以被外部代码访问。这种访问控制机制实现了封装的一部分，通过隐藏内部实现细节，提高了代码的安全性和可维护性。</p>
<p>封装的优点包括：</p>
<ol>
<li>数据隐藏：封装可以隐藏类的内部数据，防止外部直接访问和修改，从而确保数据的一致性和完整性。</li>
<li>安全性：通过限制对类的访问权限，可以控制外部代码对类的操作，提高安全性。</li>
<li>简化接口：封装通过定义公共接口，隐藏内部实现细节，使外部代码只需要关注如何使用接口而不需要了解内部实现。</li>
<li>代码重用：封装可以将相关的数据和方法组合在一起，形成可重用的类，提高代码的可维护性和可重用性。</li>
<li>隔离变化：封装可以隔离类的内部实现细节，当需要修改内部实现时，只需修改类的内部，而不影响外部代码。</li>
</ol>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><p>在C#中，类（Class）是一种用户自定义的数据类型，它定义了对象的属性（数据成员）和行为（成员方法）。类是面向对象编程的核心概念之一，它允许开发人员将相关的数据和功能封装在一个单独的实体中。</p>
<p>类可以看作是对象的蓝图或模板，用于创建具体的对象实例。每个对象实例都基于类的定义，并拥有自己的一组属性和行为。</p>
<p>类的定义通常包含以下组成部分：</p>
<ol>
<li>类名：类的名称，用于标识和引用该类。</li>
<li>数据成员：用于存储对象的状态或属性的变量。这些成员可以是各种数据类型，如整数、浮点数、字符串等。</li>
<li>成员方法：用于定义对象的行为和功能的函数。成员方法可以访问和操作数据成员，并执行其他操作。</li>
</ol>
<p>以下是一个简单的C#类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Hello, my name is &quot;</span> + Name + <span class="string">&quot; and I am &quot;</span> + Age + <span class="string">&quot; years old.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，定义了一个名为”Person”的类，它具有两个数据成员：Name（姓名）和Age（年龄），以及一个成员方法SayHello（打招呼），用于输出一个简单的问候语。使用该类，可以创建多个Person对象的实例，并访问它们的属性和方法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codePerson person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.Name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">person1.Age = <span class="number">25</span>;</span><br><span class="line">person1.SayHello();</span><br><span class="line"></span><br><span class="line">Person person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.Name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">person2.Age = <span class="number">30</span>;</span><br><span class="line">person2.SayHello();</span><br></pre></td></tr></table></figure>

<p>上述代码创建了两个Person对象的实例，分别设置它们的姓名和年龄，并调用它们的SayHello方法输出问候语。</p>
<blockquote>
<p>类访问修饰符号：</p>
<p>在C#中，类的访问修饰符用于控制类的可见性和访问级别。C#提供了以下几种类的访问修饰符：</p>
<ol>
<li><strong>public</strong>：公共访问修饰符，表示该类对于所有代码都是可见的。可以从任何位置访问该类。</li>
<li><strong>private</strong>：私有访问修饰符，表示该类仅对于当前类内部可见。其他类无法直接访问私有类。</li>
<li><strong>protected</strong>：受保护访问修饰符，表示该类对于当前类及其派生类可见。其他类无法直接访问受保护类。</li>
<li><strong>internal</strong>：内部访问修饰符，表示该类对于当前程序集内的其他类可见。跨程序集时无法访问内部类。</li>
<li><strong>protected internal</strong>：受保护内部访问修饰符，表示该类对于当前程序集内的其他类及其派生类可见。跨程序集时无法访问受保护内部类。</li>
</ol>
<p>这些访问修饰符可以应用于类的定义，以控制类的可见性和访问级别。默认情况下，如果没有显式指定访问修饰符，类的访问级别为<code>internal</code>（内部）。</p>
<p>以下是一些示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">class</span> <span class="title">PublicClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 可以从任何位置访问PublicClass</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title">PrivateClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅对当前类内部可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">class</span> <span class="title">ProtectedClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅对当前类及其派生类可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">InternalClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 仅对当前程序集内的其他类可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">ProtectedInternalClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对当前程序集内的其他类及其派生类可见</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，类的访问修饰符还可以与其他修饰符（如静态修饰符<code>static</code>、抽象修饰符<code>abstract</code>等）一起使用，以提供更多的控制和灵活性。</p>
<p><strong>tip: 在类中如果声明的时候没有加访问修饰符，一般默认为private</strong></p>
</blockquote>
<h5 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h5><p>当提及C#语言时，类的构造函数是通过使用特定的构造函数语法来定义的。在C#中，构造函数与类的名称相同，并且可以包含参数。以下是一个简单的C#类和构造函数的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 无参数构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> age</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyClass</code>类具有两个构造函数。第一个构造函数是无参数的构造函数，它不接受任何参数。第二个构造函数是带有两个参数（<code>name</code>和<code>age</code>）的构造函数。</p>
<p>你可以根据实际需要在构造函数中执行各种初始化任务，例如设置对象的初始状态、分配内存、初始化成员变量等。</p>
<p>在使用C#时，你可以根据需要选择使用适当的构造函数，并在创建类的实例时自动调用相应的构造函数。</p>
<blockquote>
<p><strong>在C#中，有参构造函数不会直接代替无参构造函数。当一个类定义了有参构造函数时，如果没有显式定义无参构造函数，编译器将不会为类自动生成默认的无参构造函数。</strong></p>
<p>无参构造函数（也称为默认构造函数）是一个没有参数的构造函数，它在创建类的新实例时使用。如果没有显式定义无参构造函数，编译器会自动为类生成一个默认的无参构造函数。无参构造函数通常用于执行类的基本初始化操作，例如将成员变量设置为默认值。</p>
<p>有参构造函数是一个带有一个或多个参数的构造函数，它允许在创建对象时提供初始化所需的值。有参构造函数可以接受参数，并用这些参数对类的成员进行初始化。</p>
<p>如果一个类定义了有参构造函数，而没有显式定义无参构造函数，那么在创建类的实例时，必须使用有参构造函数并提供必要的参数。如果尝试使用无参构造函数创建对象，编译器将报错。</p>
<p>然而，如果需要在类中同时支持有参构造函数和无参构造函数，可以通过<strong>重载构造函数的方式实现。重载构造函数允许在一个类中定义多个构造函数，每个构造函数有不同的参数列表。在重载构造函数中，可以在参数列表不同的构造函数中实现不同的初始化逻辑。</strong></p>
<p>以下是一个示例，演示了有参构造函数和无参构造函数的使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeclass MyClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> myVariable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        myVariable = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        myVariable = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">DisplayVariable</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;变量的值为：&quot;</span> + myVariable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyClass myObject1 = <span class="keyword">new</span> MyClass(<span class="number">10</span>);</span><br><span class="line">        myObject1.DisplayVariable(); <span class="comment">// 输出：变量的值为：10</span></span><br><span class="line"></span><br><span class="line">        MyClass myObject2 = <span class="keyword">new</span> MyClass();</span><br><span class="line">        myObject2.DisplayVariable(); <span class="comment">// 输出：变量的值为：0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，**<code>MyClass</code> 类定义了一个有参构造函数和一个无参构造函数。有参构造函数接受一个整数参数，并将其用于初始化私有变量 <code>myVariable</code>。无参构造函数将 <code>myVariable</code> 设置为默认值 0。**</p>
<p>通过在创建对象时选择适当的构造函数，我们可以使用有参构造函数或无参构造函数来初始化类的实例，并执行相应的初始化操作。这样，无参构造函数和有参构造函数可以在不同的情况下使用。</p>
</blockquote>
<h5 id="类的析构函数"><a href="#类的析构函数" class="headerlink" title="类的析构函数"></a>类的析构函数</h5><p>在C#中，析构函数（Destructor）是一种特殊的方法，用于在对象被销毁之前执行清理操作。析构函数通常用于释放对象占用的资源，例如关闭文件、释放内存、关闭数据库连接等。</p>
<p>在C#中，析构函数使用特殊的语法进行定义，其名称与类的名称相同，但前面加上一个波浪线（~）。析构函数不能有参数，也不能被显式地调用，而是由垃圾回收器自动在对象被销毁时调用。</p>
<p>以下是一个简单的C#类和析构函数的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 构造函数的代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~MyClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 析构函数的代码逻辑，执行清理操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyClass</code>类具有一个构造函数和一个析构函数。当对象被销毁时，垃圾回收器会自动调用析构函数，以执行清理操作。</p>
<p>需要注意的是，<strong>C#的垃圾回收器会自动管理对象的内存，因此在大多数情况下，你不需要显式地定义和使用析构函数。析构函数通常用于释放非托管资源（如文件句柄或数据库连接），在使用这些资源时可能需要手动清理。</strong>对于托管资源，垃圾回收器会自动进行垃圾回收和内存释放。</p>
<p>但是，如果确实有需要使用析构函数进行清理操作的情况，可以通过析构函数来实现。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>在C#中，属性（Property）是一种特殊的成员，用于封装类的字段（Field）并提供对其读取和写入的访问方法。属性允许你定义类的外部代码如何访问和操作类的数据。</p>
<p>属性通过使用<code>get</code>和<code>set</code>访问器来定义读取和写入操作。<code>get</code>访问器用于获取属性的值，而<code>set</code>访问器用于设置属性的值。属性可以具有不同的访问修饰符，例如<code>public</code>、<code>private</code>、<code>protected</code>等，用于控制属性的可见性。</p>
<p>以下是一个简单的C#类和属性的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; name = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Person</code>类有一个名为<code>Name</code>的属性。属性的类型是<code>string</code>，并且使用了默认的访问修饰符<code>public</code>。属性对应的字段是<code>name</code>，它被<code>private</code>修饰，只能在类的内部访问。</p>
<p><strong>通过定义属性，可以通过以下方式读取和写入属性的值：</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.Name = <span class="string">&quot;John&quot;</span>; <span class="comment">// 设置属性的值</span></span><br><span class="line"><span class="built_in">string</span> name = person.Name; <span class="comment">// 获取属性的值</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用属性来设置和获取<code>Person</code>对象的<code>Name</code>属性的值。</p>
<p>属性提供了一种更加直观和易于使用的方式来访问类的字段，并且可以对字段的读取和写入进行额外的逻辑处理，例如数据验证、计算等。属性使得代码更具可读性、可维护性和安全性。</p>
<blockquote>
<p>get访问器：</p>
<p>当定义属性时，<code>get</code> 访问器用于获取属性的值。它指定了在访问属性时应该执行的代码逻辑。<code>get</code> 访问器没有参数，并且返回与属性类型相匹配的值。</p>
<p>以下是 <code>get</code> 访问器的基本语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;type&gt; PropertyName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回属性的值的代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>&lt;type&gt;</code> 中，你需要指定属性的类型。代码逻辑部分位于 <code>get</code> 访问器的花括号中，用于返回属性的值。</p>
<p>让我们看一个示例，假设我们有一个 <code>Person</code> 类，其中包含 <code>name</code> 字段和 <code>Name</code> 属性，我们使用 <code>get</code> 访问器获取 <code>Name</code> 属性的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Name</code> 属性的 <code>get</code> 访问器简单地返回 <code>name</code> 字段的值。</p>
<p>当我们创建 <code>Person</code> 对象时，我们可以通过调用 <code>Name</code> 属性来获取 <code>name</code> 字段的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.Name = <span class="string">&quot;John&quot;</span>; <span class="comment">// 这里是错误的，因为 Name 属性只定义了 get 访问器</span></span><br><span class="line"><span class="built_in">string</span> name = person.Name; <span class="comment">// 获取属性的值</span></span><br><span class="line">Console.WriteLine(name); <span class="comment">// 输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<p>请注意，由于属性只定义了 <code>get</code> 访问器，我们不能使用 <code>person.Name = &quot;John&quot;</code> 这样的语法为属性赋值，这将导致编译错误。只有当属性同时定义了 <code>get</code> 和 <code>set</code> 访问器时，我们才可以读取和写入属性的值。</p>
<p>通过使用 <code>get</code> 访问器，我们可以实现对属性的封装，并在需要时提供定制的获取逻辑，例如对属性进行计算、验证或其他处理。<br><code>set</code> 访问器:</p>
<p>当定义属性时，<code>set</code> 访问器用于设置属性的值。它指定了在给属性赋值时应该执行的代码逻辑。<code>set</code> 访问器接受一个参数，用于传递要设置的值。</p>
<p>以下是 <code>set</code> 访问器的基本语法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;type&gt; PropertyName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回属性的值的代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置属性的值的代码逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>&lt;type&gt;</code> 中，你需要指定属性的类型。<code>set</code> 访问器包含一个名为 <code>value</code> 的特殊参数，用于传递要设置的值。你可以在 <code>set</code> 访问器的代码逻辑中使用 <code>value</code> 参数来设置属性的值。</p>
<p>让我们看一个示例，假设我们有一个 <code>Person</code> 类，其中包含 <code>name</code> 字段和 <code>Name</code> 属性，我们使用 <code>get</code> 和 <code>set</code> 访问器来获取和设置 <code>Name</code> 属性的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            name = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Name</code> 属性定义了 <code>get</code> 和 <code>set</code> 访问器。<code>get</code> 访问器返回 <code>name</code> 字段的值，而 <code>set</code> 访问器将传递的值赋给 <code>name</code> 字段。</p>
<p>当我们创建 <code>Person</code> 对象时，我们可以通过调用 <code>Name</code> 属性来获取和设置 <code>name</code> 字段的值：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.Name = <span class="string">&quot;John&quot;</span>; <span class="comment">// 设置属性的值</span></span><br><span class="line"><span class="built_in">string</span> name = person.Name; <span class="comment">// 获取属性的值</span></span><br><span class="line">Console.WriteLine(name); <span class="comment">// 输出 &quot;John&quot;</span></span><br></pre></td></tr></table></figure>

<p>通过使用 <code>set</code> 访问器，我们可以在为属性赋值时执行验证、计算或其他逻辑。我们可以根据需要自定义 <code>set</code> 访问器的行为，例如检查传递的值是否满足某些条件，然后再决定是否设置属性的值。</p>
</blockquote>
<blockquote>
<p>属性（Property）和变量（Variable）在 C# 中有几个重要的区别：</p>
<ol>
<li>访问方式：属性提供了对类的字段的封装访问方式，通过使用 get 和 set 访问器来读取和修改属性的值。而变量可以直接读取和修改其存储的值。</li>
<li>封装性和控制：属性允许你在访问器中添加额外的逻辑，以对数据进行验证、处理或实施封装策略。这使得属性更加灵活和可控。而变量没有这种封装和控制的额外层面。</li>
<li>语法：属性使用特定的语法来定义，包含 get 和 set 访问器。变量则是通过简单的声明来定义。</li>
<li>外部可见性：属性可以具有不同的可见性修饰符，可以控制属性的访问级别。变量的可见性取决于其所在的作用域。</li>
<li>命名约定：属性通常使用 PascalCase 命名约定，以强调它们的行为和封装性。变量通常使用 camelCase 命名约定。</li>
</ol>
<p>总的来说，属性提供了更好的封装性、控制和灵活性，使得对类中的字段的访问和操作更加可控和一致。变量则是简单的数据存储容器，可以直接访问和修改其值。你可以根据具体的需求和设计目标选择使用属性或变量。</p>
</blockquote>
<h4 id="匿名类型"><a href="#匿名类型" class="headerlink" title="匿名类型"></a>匿名类型</h4><p>匿名类型是使用 <code>var</code> 关键字声明的一种特殊类型，它在编译时期由编译器自动推断出来。匿名类型是具有只读属性的类，它的属性名称和类型是根据初始化时提供的属性和值自动生成的。</p>
<p>匿名类型的语法如下所示：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codevar anonymousObject = <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    Property1 = value1,</span><br><span class="line">    Property2 = value2,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>anonymousObject</code> 是使用 <code>var</code> 声明的匿名类型变量。通过使用 <code>new</code> 关键字和对象初始化器的方式，我们可以创建一个匿名类型对象，并指定一组属性和对应的值。</p>
<p>匿名类型的属性是只读的，即不能在运行时修改其值。编译器为匿名类型生成一个类，并自动为每个属性创建一个只读的公共属性。匿名类型的属性名称和类型在编译时期确定，而不是在运行时。</p>
<p>匿名类型主要用于临时存储和传递一组相关的数据，通常与LINQ查询一起使用，以方便地处理查询结果。由于匿名类型没有显式的类定义，它们在编译时期是未知的，因此不能将匿名类型直接转换为其他类型。如果需要将匿名类型的数据转换为其他类型，可以使用显式类型转换或将其属性值逐个提取到新的对象中。</p>
<p>请注意，匿名类型的作用域通常被限制在定义它们的方法或代码块内部。超出作用域后，匿名类型将不再可用。</p>
<blockquote>
<p>匿名类型在C#中是通过 <code>new</code> 关键字创建的，它可以是结构体（struct）或类（class）的实例。实际上，编译器会根据匿名类型的属性数量和类型来决定生成结构体还是类。</p>
<p>当匿名类型的属性都是值类型（如整数、字符串等）时，编译器会生成一个结构体作为匿名类型的实例。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codevar anonymousObject = <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    Property1 = <span class="number">42</span>,</span><br><span class="line">    Property2 = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，由于 <code>Property1</code> 是整数类型，<code>Property2</code> 是字符串类型，编译器会生成一个结构体作为匿名类型的实例。</p>
<p>当匿名类型的属性包含引用类型（如自定义类、数组等）时，编译器会生成一个类作为匿名类型的实例。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codevar anonymousObject = <span class="keyword">new</span></span><br><span class="line">&#123;</span><br><span class="line">    Property1 = <span class="keyword">new</span> MyClass(),</span><br><span class="line">    Property2 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>Property1</code> 是一个自定义类的实例，<code>Property2</code> 是一个整数数组，因此编译器会生成一个类作为匿名类型的实例。</p>
<p>无论是结构体还是类，匿名类型都是只读的，不能在运行时修改其属性的值。匿名类型的属性名称和类型是在编译时期确定的。</p>
<p>需要注意的是，由于匿名类型是在编译时期生成的，所以它们的具体类型名称是不可知的，并且不能将匿名类型直接转换为其他类型。如果需要将匿名类型的数据转换为其他类型，可以使用显式类型转换或将其属性值逐个提取到新的对象中。</p>
</blockquote>
<h4 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h4><p>在C#中，堆（Heap）和栈（Stack）是两种用于存储和管理内存的重要概念。</p>
<p>栈（Stack）：</p>
<ul>
<li>栈是一种用于存储局部变量和方法调用的内存区域。</li>
<li>栈中的数据以“后进先出”（LIFO）的方式进行操作。</li>
<li>栈的操作非常高效，因为它使用简单的指针操作来管理内存。</li>
<li>当你调用一个方法时，该方法的局部变量和参数将被分配到栈上。当方法执行完毕，栈上的数据将被释放。</li>
</ul>
<p>堆（Heap）：</p>
<ul>
<li>堆是一种用于存储动态分配的对象的内存区域。</li>
<li>堆中的数据可以以任意顺序进行操作，没有特定的顺序要求。</li>
<li>堆的操作相对较慢，因为它需要进行内存分配和垃圾回收。</li>
<li>当你使用 <code>new</code> 关键字创建一个对象时，该对象将被分配到堆上。堆上的对象可以长时间存在，直到垃圾回收器将其标记为不再使用。</li>
</ul>
<p>在C#中，基本数据类型（如整数、浮点数、布尔值等）和引用类型（如类、接口、数组等）的存储位置有所不同：</p>
<ul>
<li>基本数据类型通常存储在栈上。当你声明一个基本数据类型的变量并为其赋值时，数据将直接存储在栈上。这些变量的生命周期在其作用域结束时就会结束。</li>
<li>引用类型的变量本身存储在栈上，但实际的对象存储在堆上。当你声明一个引用类型的变量并为其赋值时，变量本身存储在栈上，而对象存储在堆上。对象的生命周期由垃圾回收器来管理，垃圾回收器会自动检测不再使用的对象并进行回收。</li>
</ul>
<p>需要注意的是，通过传递引用类型变量作为参数或在方法中创建对象时，引用类型的对象可能存储在堆上或栈上。这取决于具体的情况和编译器的优化策略。</p>
<p>总结起来，栈用于存储局部变量和方法调用，它的操作效率高；堆用于存储动态分配的对象，它的操作相对较慢。在C#中，栈和堆都是用于管理内存的重要部分，理解它们的运行逻辑有助于编写高效和可靠的代码。</p>
<h4 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h4><p>在C#中，变量可以是值类型（Value Types）或引用类型（Reference Types）。这两种类型在内存中的存储方式和行为有所不同。</p>
<p>值类型（Value Types）：</p>
<ul>
<li>值类型的变量直接包含其数据的实际值。</li>
<li>值类型的变量在栈上分配内存。</li>
<li>值类型的赋值是通过将一个变量的值复制到另一个变量来完成的。</li>
<li>值类型的变量通常具有固定的大小，由编译时确定。</li>
<li>值类型包括整数类型（如int、float、double等）、布尔类型（bool）、字符类型（char）、结构体（struct）等。</li>
</ul>
<p>下面是一个值类型的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeint x = <span class="number">10</span>; <span class="comment">// 值类型变量 x，存储在栈上</span></span><br><span class="line"><span class="built_in">int</span> y = x; <span class="comment">// 将 x 的值复制给 y</span></span><br><span class="line">y = <span class="number">20</span>; <span class="comment">// 修改 y 不会影响 x 的值</span></span><br><span class="line">Console.WriteLine(x); <span class="comment">// 输出 10</span></span><br><span class="line">Console.WriteLine(y); <span class="comment">// 输出 20</span></span><br></pre></td></tr></table></figure>

<p>引用类型（Reference Types）：</p>
<ul>
<li>引用类型的变量存储的是对象的引用，而不是对象的实际数据。</li>
<li>引用类型的变量在栈上分配内存，但对象本身存储在堆上。</li>
<li>引用类型的赋值是通过将一个变量的引用复制到另一个变量来完成的，这样两个变量将引用同一个对象。</li>
<li>引用类型的大小是固定的，不受对象数据大小的影响，因为变量本身只是引用。</li>
<li>引用类型包括类（class）、接口（interface）、委托（delegate）、字符串（string）等。</li>
</ul>
<p>下面是一个引用类型的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] array1 = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">// 引用类型变量 array1，存储在栈上，对象存储在堆上</span></span><br><span class="line"><span class="built_in">int</span>[] array2 = array1; <span class="comment">// 将 array1 的引用复制给 array2</span></span><br><span class="line">array2[<span class="number">0</span>] = <span class="number">10</span>; <span class="comment">// 修改 array2 也会影响 array1 中的值</span></span><br><span class="line">Console.WriteLine(array1[<span class="number">0</span>]); <span class="comment">// 输出 10</span></span><br><span class="line">Console.WriteLine(array2[<span class="number">0</span>]); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，值类型的赋值是将值复制给另一个变量，而引用类型的赋值是复制引用。这意味着修改引用类型变量的值会影响到其他引用同一对象的变量，因为它们引用的是同一个对象。</p>
<p>在实际编程中，理解值类型和引用类型的区别很重要，因为它们的存储和传递方式不同，可能会对程序的行为产生影响。</p>
<blockquote>
<p><strong>值类型和引用类型在内存中的存储原理有所不同。</strong></p>
<p>值类型是指基本数据类型（如整数、浮点数、布尔值等）以及结构体（struct）等，它们的值直接存储在栈（stack）内存中。栈是一种后进先出（LIFO）的数据结构，用于存储局部变量和方法调用的上下文。当一个值类型的变量被声明时，系统会为其分配一块栈内存，并将值直接存储在这块内存中。当变量超出其作用域时，栈内存会被自动释放。</p>
<p>引用类型是指类（class）、接口（interface）、数组（array）以及字符串（string）等，它们的值存储在堆（heap）内存中。堆是一种动态分配的内存区域，用于存储对象和数据结构。当一个引用类型的变量被声明时，系统会为其分配一块堆内存，并将变量的引用（即指向该对象或数据结构的内存地址）存储在栈内存中。引用类型的变量实际上存储的是对象或数据结构在堆内存中的地址，通过这个地址可以找到实际存储的值。当变量超出其作用域时，只有栈内存中的引用被释放，而堆内存中的实际对象或数据结构需要等待垃圾回收器（garbage collector）进行回收。</p>
<p>这种区别在于内存的管理方式。值类型的存储是直接的，而引用类型的存储则是通过引用来访问实际的数据。这也意味着对于值类型的操作是在栈上进行的，而对于引用类型的操作需要通过引用来查找并操作堆内存中的数据。</p>
<p><strong>在C#中，值类型和引用类型在内存中的存储原理与前面描述的概念基本相同。</strong></p>
<p>对于值类型，在C#中包括基本数据类型（如整数、浮点数、布尔值等）以及结构体（struct）。这些值类型的实例直接存储在栈内存中，而不是堆内存。当值类型的变量被声明时，内存会分配在栈上，并将值直接存储在该栈内存中。当变量超出其作用域时，栈内存会自动释放。</p>
<p>引用类型在C#中包括类（class）、接口（interface）、数组（array）以及字符串（string）。这些引用类型的实例存储在堆内存中。当引用类型的变量被声明时，内存会分配在栈上，并将引用（即指向堆内存中对象的地址）存储在栈内存中。实际的对象或数据结构则存储在堆内存中。当变量超出其作用域时，栈内存中的引用会被释放，但堆内存中的对象或数据结构会等待垃圾回收器进行回收。</p>
<p>需要注意的是，<strong>C#中的引用类型还涉及到垃圾回收的机制</strong>。垃圾回收器会定期检查堆内存中的对象，释放不再被引用的对象，并回收其所占用的内存。这可以减轻开发者的内存管理负担，但也意味着无法精确控制对象的生命周期和内存释放的时机，因此在某些情况下可能会出现性能问题。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在C#中，类可以通过继承来扩展和重用现有的类。继承是面向对象编程中的一个重要概念，它允许你创建一个新类，从一个或多个现有的类中派生，继承其属性和方法。</p>
<p><strong>要在C#中实现类的继承，你可以使用冒号（:）符号来指定一个类派生自另一个类。派生类（子类）继承基类（父类）的成员，并可以添加自己的成员或覆盖基类的成员。</strong></p>
<p>下面是一个简单的示例，演示了如何在C#中实现类的继承：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Animal is eating.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Bark</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dog is barking.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用继承的示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.Eat();  <span class="comment">// 继承自基类 Animal</span></span><br><span class="line">        dog.Bark(); <span class="comment">// 派生类 Dog 自己的方法</span></span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code>类是基类，<code>Dog</code>类是派生类。<code>Dog</code>类继承了<code>Animal</code>类的<code>Eat()</code>方法，并添加了自己的<code>Bark()</code>方法。在<code>Main</code>方法中，我们创建了<code>Dog</code>的实例，并可以调用继承的方法和自己的方法。</p>
<p>继承的优点是可以实现代码的重用和层次化设计。派生类可以访问基类的非私有成员（公有、受保护或受内部可见性约束的成员），并且可以通过方法覆盖来修改或扩展基类的行为。</p>
<p>注意：在C#中，一个类只能直接继承自一个基类，即C#不支持多重继承。但是，你可以通过接口来实现类似多重继承的效果。</p>
<blockquote>
<p>在使用继承时，有一些需要注意的事项：</p>
<ol>
<li>类之间的逻辑关系：继承应该基于”是一个”的关系，即派生类是基类的一种特化或扩展。确保在建立继承关系时，派生类能够满足基类的行为和属性，遵循类之间的逻辑关系。</li>
<li>单一继承原则：C#中只支持单一继承，一个类只能直接继承自一个基类。这意味着你需要谨慎选择基类，以确保派生类能够获取所需的功能。</li>
<li>虚方法和方法重写：当使用继承时，如果你希望在派生类中重写基类的方法，可以将基类中的方法声明为<code>virtual</code>，然后在派生类中使用<code>override</code>来进行重写。这样可以实现多态性，确保在运行时根据对象的实际类型调用正确的方法。</li>
<li>访问修饰符的考虑：继承关系中，派生类对于基类的成员的访问权限取决于成员的访问修饰符。如果基类的成员是私有的（private），则派生类无法直接访问。如果基类的成员是受保护的（protected），则派生类可以直接访问。如果基类的成员是公共的（public），则派生类可以直接访问。</li>
<li>构造函数的继承：派生类默认会调用基类的无参构造函数，如果基类没有无参构造函数，则需要在派生类中显式调用基类的有参构造函数。</li>
<li>基类和派生类的生命周期管理：在继承关系中，需要注意基类和派生类对象的创建、销毁和生命周期管理。确保在适当的时候释放资源，避免内存泄漏等问题。</li>
<li>避免过度继承：过度的继承可能导致类之间的耦合性增加，难以维护和扩展。在设计类继承关系时，尽量遵循单一责任原则，保持继承关系的简洁和清晰。</li>
</ol>
</blockquote>
<h4 id="虚方法"><a href="#虚方法" class="headerlink" title="虚方法"></a>虚方法</h4><p>虚方法是C#中用于实现多态性的一种特殊类型的方法。通过将方法声明为虚方法，可以在派生类中重写该方法，实现基于对象的实际类型来调用相应的方法。</p>
<p>在C#中，使用<code>virtual</code>关键字来声明一个方法为虚方法。以下是一个示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The animal makes a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.MakeSound();  <span class="comment">// 输出：&quot;The animal makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.MakeSound();     <span class="comment">// 输出：&quot;The dog barks.&quot;</span></span><br><span class="line"></span><br><span class="line">        Cat cat = <span class="keyword">new</span> Cat();</span><br><span class="line">        cat.MakeSound();     <span class="comment">// 输出：&quot;The cat meows.&quot;</span></span><br><span class="line"></span><br><span class="line">        Animal polymorphicAnimal = <span class="keyword">new</span> Dog();</span><br><span class="line">        polymorphicAnimal.MakeSound();  <span class="comment">// 输出：&quot;The dog barks.&quot;</span></span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code>类中的<code>MakeSound()</code>方法被声明为虚方法，允许派生类进行方法的重写。<code>Dog</code>和<code>Cat</code>类分别重写了基类中的<code>MakeSound()</code>方法，提供了它们自己的实现。</p>
<p>在<code>Main</code>方法中，我们创建了<code>Animal</code>、<code>Dog</code>和<code>Cat</code>的实例，并分别调用它们的<code>MakeSound()</code>方法。此外，我们还创建了一个<code>Animal</code>类型的变量，但将其实际引用为<code>Dog</code>类的实例。这体现了多态性，当我们调用<code>MakeSound()</code>方法时，实际执行的是<code>Dog</code>类中重写的方法。</p>
<p>通过使用虚方法和方法重写，我们可以根据具体对象的类型来决定调用哪个方法，实现了运行时多态性的特性。这样的设计模式能够提高代码的灵活性和可扩展性，使得程序能够适应不同类型的对象，并根据对象的实际行为进行相应的处理。</p>
<h4 id="隐藏方法"><a href="#隐藏方法" class="headerlink" title="隐藏方法"></a>隐藏方法</h4><p>隐藏方法是继承中的一个相关概念，但它与方法重写（覆盖）有所不同。</p>
<p>在C#中，通过在派生类中使用<code>new</code>关键字，可以隐藏基类中的同名方法。这被称为方法隐藏（method hiding）。</p>
<p>方法隐藏是在派生类中定义一个与基类中同名的方法，而不是重写基类方法。当使用派生类的实例调用这个方法时，会调用派生类中定义的方法，而不是基类中的方法。</p>
<p>以下是一个示例，演示了方法隐藏的使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Animal makes a sound.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dog barks.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Animal animal = <span class="keyword">new</span> Animal();</span><br><span class="line">        animal.MakeSound();  <span class="comment">// 输出：&quot;Animal makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line">        Dog dog = <span class="keyword">new</span> Dog();</span><br><span class="line">        dog.MakeSound();     <span class="comment">// 输出：&quot;Dog barks.&quot;</span></span><br><span class="line"></span><br><span class="line">        Animal dogAnimal = <span class="keyword">new</span> Dog();</span><br><span class="line">        dogAnimal.MakeSound();   <span class="comment">// 输出：&quot;Animal makes a sound.&quot;</span></span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Animal</code>类中有一个<code>MakeSound()</code>方法，而<code>Dog</code>类中也定义了一个同名的方法。<code>Dog</code>类中的<code>MakeSound()</code>方法使用<code>new</code>关键字隐藏了基类中的方法。</p>
<p>当我们使用<code>Animal</code>类的实例调用<code>MakeSound()</code>方法时，执行的是基类中的方法。当我们使用<code>Dog</code>类的实例调用<code>MakeSound()</code>方法时，执行的是派生类中隐藏的方法。</p>
<p>注意，当将派生类的实例赋值给基类的变量时（如<code>Animal dogAnimal = new Dog()</code>），如果使用该变量调用<code>MakeSound()</code>方法，仍会执行基类中的方法。这是因为隐藏方法是通过编译时的静态类型来确定调用的方法，而不是基于运行时的实际对象类型。</p>
<h4 id="get和set关键字"><a href="#get和set关键字" class="headerlink" title="get和set关键字"></a>get和set关键字</h4><p><code>get</code> 和 <code>set</code> 是访问器标识符，用于定义属性的读取器和写入器。它们具有以下特点：</p>
<p><code>get</code> 标识符：用于定义属性的读取器。它指定了在访问属性时返回属性值的逻辑。<code>get</code> 方法必须返回与属性类型兼容的值。例如，对于一个名为 <code>MyProperty</code> 的属性，可以使用以下方式定义 <code>get</code> 访问器：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回属性值的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> someValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>set</code> 标识符：用于定义属性的写入器。它指定了在给属性赋值时设置属性值的逻辑。<code>set</code> 方法使用一个隐含的参数 <code>value</code>，表示将要分配给属性的值。例如，对于一个名为 <code>MyProperty</code> 的属性，可以使用以下方式定义 <code>set</code> 访问器：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置属性值的逻辑</span></span><br><span class="line">        someValue = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 和 <code>set</code> 访问器可以一起使用，用于定义可读写的属性。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="built_in">int</span> myField;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 返回属性值的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> myField;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置属性值的逻辑</span></span><br><span class="line">        myField = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>get</code> 和 <code>set</code> 访问器可以具有不同的访问修饰符，例如 <code>public</code>、<code>private</code> 等，用于控制属性的访问级别。</p>
<p>在 C# 6.0 之后，可以使用自动属性来简化属性的定义。自动属性使用简化的语法，编译器会自动生成私有字段和访问器的实现。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>通过使用 <code>get</code> 和 <code>set</code> 标识符，可以实现属性的读取和写入逻辑，并提供对属性的访问和修改。这种封装属性的方式使得代码更具可读性和可维护性，并提供了对属性访问的控制和验证。</p>
<h4 id="this和base关键字"><a href="#this和base关键字" class="headerlink" title="this和base关键字"></a>this和base关键字</h4><p>在C#中，<code>this</code>和<code>base</code>是两个关键字，用于引用当前对象和基类对象。它们在以下情况下使用：</p>
<p><code>this</code>关键字：</p>
<ul>
<li><p><code>this</code>关键字用于引用当前对象的成员（字段、属性、方法等）。它可以解决成员与局部变量之间的命名冲突。例如，如果一个方法的参数名与成员名相同，可以使用<code>this</code>关键字来指明要访问的是成员而不是参数。</p>
</li>
<li><p><code>this</code>关键字还可以在构造函数中调用其他构造函数，以实现构造函数的重载。通过使用<code>this</code>关键字，可以在一个构造函数中调用同一类的其他构造函数。</p>
</li>
<li><p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">class</span> <span class="title">MyClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span>() : <span class="title">this</span>(<span class="params"><span class="number">0</span></span>) <span class="comment">// 调用另一个构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>base</code>关键字：</p>
<ul>
<li><p><code>base</code>关键字用于引用基类对象的成员（字段、属性、方法等）。当派生类中定义了与基类同名的成员时，可以使用<code>base</code>关键字来访问基类的成员。</p>
</li>
<li><p><code>base</code>关键字还可以在派生类的构造函数中调用基类的构造函数。通过使用<code>base</code>关键字，可以在派生类的构造函数中调用基类的特定构造函数。</p>
</li>
<li><p>例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">class</span> <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> <span class="keyword">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyBaseClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyDerivedClass</span> : <span class="title">MyBaseClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDerivedClass</span>(<span class="params"><span class="built_in">int</span> <span class="keyword">value</span></span>) : <span class="title">base</span>(<span class="params"><span class="keyword">value</span></span>) <span class="comment">// 调用基类的构造函数</span></span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>总而言之，<code>this</code>关键字用于引用当前对象的成员，而<code>base</code>关键字用于引用基类对象的成员。它们在构造函数重载和解决成员命名冲突时非常有用。</p>
<h4 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h4><p>基类（Base Class）是面向对象编程中的一个概念，它是其他类的父类或超类。基类定义了一组通用的属性、方法和行为，可以被其他类继承和重用。</p>
<p>在继承关系中，子类可以从基类中继承（或派生）属性和方法。子类继承基类的成员后，可以直接使用这些成员，无需重新编写相同的代码。基类通过提供通用的结构和行为，可以为子类提供共享的功能和特征。</p>
<p>在C#中，使用关键字<code>class</code>定义一个类时，可以指定该类的基类。例如，如果要创建一个名为<code>Car</code>的子类，并使其继承一个名为<code>Vehicle</code>的基类，可以使用冒号（:）指定继承关系：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="comment">// 基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 基类的成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span> <span class="comment">// 子类，继承自基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 子类的成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>Vehicle</code>是<code>Car</code>的基类。<code>Car</code>类继承了<code>Vehicle</code>类的成员，并可以使用基类中定义的属性和方法。</p>
<p>基类可以包含构造函数、字段、属性、方法和事件等成员。子类可以直接访问基类的公共和受保护成员（根据访问修饰符的限制），并可以通过关键字<code>base</code>引用基类的成员。</p>
<p>基类的主要目的是促进代码的重用性和扩展性。通过继承基类，可以避免在每个子类中重复编写相同的代码，而是共享和继承基类的通用功能。基类也可以作为抽象基类或接口来定义规范和约束，以确保子类满足特定的行为要求。</p>
<h5 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h5><p>在C#中，抽象类（Abstract Class）是一种特殊的类，用于提供其他类的基类（父类）。抽象类本身不能被实例化，<strong>它主要用作其他类的蓝图或模板。</strong></p>
<p>抽象类通过在类的定义中使用 <code>abstract</code> 关键字来声明。它可以包含抽象方法、虚方法、实例字段和属性等成员。抽象方法是没有实现的方法，而是在派生类中被重写和实现。</p>
<p>下面是一个抽象类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>()</span>; <span class="comment">// 抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;This is a shape.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Shape</code> 类是一个抽象类，其中包含一个抽象方法 <code>CalculateArea()</code> 和一个非抽象方法 <code>Print()</code>。派生类必须实现抽象方法，但可以选择性地重写非抽象方法。</p>
<p>当你想要定义一个基类，提供一些通用行为，但又不希望直接实例化该基类时，抽象类非常有用。它允许你定义一些通用的方法和属性，并要求派生类提供实现细节。</p>
<p>需要注意的是，抽象类不能直接实例化，但可以被用作引用类型。你可以创建派生类的实例，然后将其赋值给抽象类类型的变量。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Shape shape = <span class="keyword">new</span> Circle();</span><br></pre></td></tr></table></figure>

<p>总而言之，抽象类是一种用于定义其他类的基类，并且它可以包含抽象方法和非抽象方法。派生类必须实现抽象方法，而非抽象方法可以选择性地被重写。</p>
<blockquote>
<p>抽象基类（Abstract Base Class）是面向对象编程中的一个概念，它是一种特殊的类，不能被直接实例化，而是被用作其他类的基类。</p>
<p>抽象基类本身是抽象的，它定义了一组抽象方法、虚方法或具体方法，这些方法可以在子类中进行重写或实现。抽象基类通常用于定义一组共享的特征、行为或接口，而不关心具体实现细节。</p>
<p>在C#中，可以使用<code>abstract</code>关键字将一个类声明为抽象基类。抽象基类可以包含以下类型的成员：</p>
<ol>
<li>抽象方法（Abstract Method）：这是一个没有实现体的方法，只有方法的声明，没有方法体。抽象方法必须在子类中进行实现（重写），用以提供具体的实现逻辑。</li>
<li>虚方法（Virtual Method）：这是一个具有默认实现的方法，但可以在子类中进行重写。子类可以选择重写虚方法以提供自定义的实现，也可以使用默认实现。</li>
<li>具体方法（Concrete Method）：这是一个具有完整实现的方法，没有关键字修饰。具体方法在抽象基类中提供默认实现，子类可以选择性地进行重写。</li>
</ol>
<p>抽象基类的主要目的是作为其他类的模板，通过继承它来共享通用行为和结构。它可以提供一种约束，要求子类必须实现某些方法或遵循特定的接口。抽象基类在设计和组织大型项目时非常有用，可以提高代码的可重用性、可扩展性和可维护性。</p>
</blockquote>
<h4 id="密封类"><a href="#密封类" class="headerlink" title="密封类"></a>密封类</h4><p>在C#中，密封类（Sealed Class）是一种特殊类型的类，它阻止其他类继承或派生自该密封类。使用 <code>sealed</code> 关键字可以将类声明为密封类。</p>
<p>当你声明一个类为密封类时，它将被标记为最终类，不允许其他类继承它或派生自它。换句话说，密封类不能作为基类用于其他类的继承。</p>
<p>下面是一个密封类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">MySealedClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>密封类的主要目的是限制类的继承，以确保其行为和状态不会被修改或扩展。密封类常用于具有固定功能的类，它们通常被设计为不可修改和不可继承的。</p>
<p>需要注意的是，密封类本身可以继承自其他类，但不能被其他类继承。例如，一个密封类可以继承自非密封的基类。</p>
<p>总结一下，密封类是通过使用 <code>sealed</code> 关键字声明的一种特殊类。它阻止其他类继承或派生自该类，主要用于限制类的继承，确保类的行为和状态不被修改或扩展。</p>
<blockquote>
<p>密封类不能被用作基类。在 C# 中，使用 <code>sealed</code> 关键字可以将一个类声明为密封类。密封类是为了防止其他类继承它。</p>
<p>当你将一个类声明为密封类时，它将不能被其他类继承。这意味着密封类不能作为其他类的基类，因为它不允许其他类派生自它。</p>
<p>以下是一个示例，展示了如何声明和使用密封类：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SealedClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Class implementation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DerivedClass</span> : <span class="title">SealedClass</span>  <span class="comment">// 错误！密封类不能作为基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Class implementation</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>SealedClass</code> 被声明为密封类，使用 <code>sealed</code> 关键字进行标识。然后，我们尝试从 <code>SealedClass</code> 派生一个名为 <code>DerivedClass</code> 的类，但这是错误的，因为密封类不能作为基类。</p>
<p>密封类的主要目的是为了限制继承，以确保某个类的特定实现不会被子类修改或扩展。密封类通常用于不希望被继承或修改的情况，例如某些框架类或工具类。</p>
<p>需要注意的是，密封类本身可以继承自其他类。只是它不能作为基类供其他类继承。</p>
</blockquote>
<h4 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h4><p>派生类（Derived Class）是指在面向对象编程中，通过继承从一个基类（父类）派生出新的类。派生类可以继承基类的成员（字段、属性、方法等），并且可以添加新的成员或修改继承的成员的行为。</p>
<p>在C#中，可以使用关键字 <code>class</code> 和冒号 <code>:</code> 来定义派生类，并指定基类。派生类在定义时可以扩展基类的功能，重写基类的虚方法，并可以添加自己的成员。</p>
<p>下面是一个派生类的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Vehicle</span> <span class="comment">// 基类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Brand &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Year &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The vehicle starts.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span> : <span class="title">Vehicle</span> <span class="comment">// 派生类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The car accelerates.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Start</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;The car starts.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Vehicle</code> 是一个基类，<code>Car</code> 是派生类。<code>Car</code> 类继承了基类 <code>Vehicle</code> 的属性和方法，并添加了自己的方法 <code>Accelerate()</code>。此外，派生类还可以重写基类中的虚方法，例如在 <code>Car</code> 类中重写了 <code>Start()</code> 方法。</p>
<p>使用派生类的好处是可以通过继承和扩展现有的类来创建新的类，从而实现代码的重用和组织。派生类可以使用基类的成员，并且可以根据需要修改或添加功能。</p>
<p>需要注意的是，C#不支持多重继承，即一个类不能直接继承自多个基类。但是，C#支持通过接口实现多重继承的特性。</p>
<p>总结一下，派生类是通过继承基类创建的新类。它可以继承基类的成员，可以添加新的成员或重写继承的成员的行为。通过派生类，可以实现代码的重用、组织和扩展。</p>
<h4 id="访问修饰符"><a href="#访问修饰符" class="headerlink" title="访问修饰符"></a>访问修饰符</h4><p>在C#中，有多种访问修饰符（Access Modifiers）用于控制类、成员（字段、属性、方法等）以及其他元素的访问级别。以下是C#中常用的访问修饰符：</p>
<ol>
<li><strong>public</strong>：公共访问修饰符，表示成员可以从任何地方都可以访问，没有访问限制。</li>
<li><strong>private</strong>：私有访问修饰符，表示成员只能在定义它的类内部被访问。私有成员对于类的外部是不可见的。</li>
<li><strong>protected</strong>：受保护访问修饰符，表示成员可以在定义它的类及其派生类中被访问，但对于类的外部是不可见的。</li>
<li><strong>internal</strong>：内部访问修饰符，表示成员可以在当前程序集内的任何类中访问，但对于程序集之外的类是不可见的。如果没有显式指定访问修饰符，默认情况下成员的访问级别就是 internal。</li>
<li><strong>protected internal</strong>：受保护内部访问修饰符，表示成员可以在当前程序集内的任何类及其派生类中访问，以及在其他程序集中通过派生类访问。</li>
</ol>
<p>这些访问修饰符可以用于类的定义、类的成员（字段、属性、方法等）的定义，以及命名空间的定义。它们用于控制对不同成员和元素的访问权限，帮助实现封装性、继承性和抽象性等面向对象编程的概念。</p>
<p>需要注意的是，访问修饰符的使用要根据具体的需求和设计决策。选择适当的访问修饰符可以确保代码的安全性和可维护性。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在C#中，多态（Polymorphism）是面向对象编程中的一个重要概念。它允许使用相同的接口来处理不同类型的对象，从而实现代码的灵活性和可重用性。</p>
<p>多态性有两种形式：静态多态性（静态绑定）和动态多态性（动态绑定）。</p>
<p>静态多态性（静态绑定）： 在编译时，通过方法的重载和运算符重载，可以根据参数的类型来决定要调用的具体方法或操作符。这称为静态多态性，因为它在编译时期已经确定了具体的方法或操作符。</p>
<p>例如，假设有一个基类<code>Shape</code>和两个派生类<code>Circle</code>和<code>Rectangle</code>。如果在基类和派生类中定义了名为<code>Draw</code>的方法，那么可以根据调用对象的类型来决定具体调用哪个类的<code>Draw</code>方法。这就是静态多态性的体现。</p>
<p>动态多态性（动态绑定）： 动态多态性是通过继承和方法重写（override）实现的。它在运行时根据对象的实际类型来确定要调用的方法。当基类引用指向派生类的对象时，可以通过基类引用调用派生类中重写的方法。</p>
<p>例如，假设有一个基类<code>Animal</code>和两个派生类<code>Dog</code>和<code>Cat</code>。如果在基类中定义了一个名为<code>MakeSound</code>的虚方法，并在派生类中重写该方法，那么可以通过基类引用指向派生类的对象，并调用<code>MakeSound</code>方法时，实际执行的是派生类中重写的方法。这就是动态多态性的体现。</p>
<p>多态性的好处在于可以编写通用的代码，能够处理不同类型的对象，而无需为每种对象编写独立的代码。它提高了代码的可维护性和可扩展性，并促进了面向对象编程的核心概念之一：封装、继承和多态。</p>
<blockquote>
<p>多态性在面向对象编程中具有多种常用功能。以下是一些常见的多态性功能：</p>
<ol>
<li>方法重写（Method Overriding）：多态性通过方法重写实现。子类可以重写基类的方法，并在运行时根据实际对象类型调用相应的方法。这允许不同的对象以不同的方式响应相同的方法调用。</li>
<li>动态绑定（Dynamic Binding）：多态性通过动态绑定实现。在运行时，系统根据对象的实际类型决定要调用的方法。这使得代码能够在运行时适应不同的对象类型，实现灵活性和可扩展性。</li>
<li>抽象类和接口（Abstract Class and Interface）：抽象类和接口是多态性的重要概念。它们定义了一组共享的行为或功能，并允许不同的类实现这些行为或功能。通过基于抽象类或接口编程，可以编写通用的代码，处理多个具体的类对象。</li>
<li>泛型编程（Generic Programming）：多态性在泛型编程中起着关键作用。通过泛型类型参数，可以编写与具体类型无关的通用代码。这样的代码可以在不同类型的对象上进行操作，提高了代码的可重用性和类型安全性。</li>
<li>集合和容器类的多态性：在面向对象的集合和容器类中，多态性允许将不同类型的对象存储在同一个集合或容器中，并可以通过统一的接口来访问和处理这些对象。这提供了更灵活的数据结构和算法设计。</li>
<li>虚方法和抽象方法的多态性：通过在基类中定义虚方法（Virtual Method）或抽象方法（Abstract Method），子类可以重写这些方法，并根据自身的需求提供不同的实现。这种多态性允许通过基类的引用调用子类的方法。</li>
</ol>
<p>这些功能使得多态性成为面向对象编程中的重要概念之一。它提供了灵活性、可扩展性和可维护性，使得代码能够更好地适应变化和复杂性。</p>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>在C#中，接口（Interface）是一种定义了一组方法、属性和事件的合同（Contract），用于描述类或结构体应具有的行为。接口定义了一组公共的成员，但没有提供具体的实现。类或结构体可以实现一个或多个接口，并通过实现接口中的成员来达到接口所描述的行为。</p>
<p>接口在C#中使用 <code>interface</code> 关键字进行声明。下面是一个简单的接口示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title">IShape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">double</span> <span class="title">CalculateArea</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>IShape</code> 接口定义了两个方法：<code>CalculateArea()</code> 和 <code>Draw()</code>。任何类实现了这个接口都必须提供这两个方法的具体实现。</p>
<p>类可以通过使用 <code>:</code> 符号来实现一个或多个接口。例如：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Circle</span> : <span class="title">IShape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> Radius &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">CalculateArea</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.PI * Radius * Radius;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a circle.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>Circle</code> 类实现了 <code>IShape</code> 接口，并提供了 <code>CalculateArea()</code> 和 <code>Draw()</code> 方法的具体实现。</p>
<p>通过接口，可以实现多态性，即一个对象可以被视为属于多个类型。类可以实现多个接口，从而具备不同接口所定义的行为，这提供了更大的灵活性和可重用性。</p>
<p>接口还可以用于定义事件和属性的规范，类在实现接口时必须提供这些事件和属性的实现。</p>
<p>总结一下，接口是一种定义行为规范的合同，它描述了类或结构体应该具有的一组方法、属性和事件。接口本身没有提供具体的实现，而是由类或结构体实现接口并提供具体的实现。通过实现接口，类可以达到多态性，并具备不同接口所定义的行为。</p>
<blockquote>
<p><strong>接口和类的区别：</strong></p>
<p>相似之处：</p>
<ol>
<li>都可以定义抽象成员（未实现的方法、属性、事件等）。</li>
<li>都不能被直接实例化，需要其他类来实现或继承。</li>
</ol>
<p>区别之处：</p>
<ol>
<li>接口可以多重继承，而类只能单继承。一个类可以实现多个接口，但只能继承一个抽象类。</li>
<li>接口只能定义抽象成员，不包含实现，而抽象类可以包含具体实现的成员。</li>
<li>接口中的成员默认是公共的（public），而抽象类中的成员可以有不同的访问修饰符。</li>
<li>接口不能包含字段（字段是类的状态），而抽象类可以包含字段。</li>
<li>接口不能提供代码的实现，而抽象类可以提供部分实现。</li>
</ol>
<p>接口通常用于描述对象应该具备的行为，定义了一套合约，供实现接口的类来遵循。通过实现接口，类可以在不同的层次结构中共享相同的行为规范，实现了一种多态性。</p>
<p>抽象类则更多地用于定义一种通用的基类，可以包含具体的实现代码，以及一些子类通用的属性和方法。抽象类可以作为其他类的基类被继承，子类可以继承抽象类的实现代码，并覆盖其中的抽象成员。</p>
<p>总之，接口主要关注行为的规范和多态性，而抽象类则更关注代码的复用和继承。选择使用接口还是抽象类，取决于设计的目标和需求。</p>
</blockquote>
<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>方法重写（Method overriding）是面向对象编程中的一个概念，它允许子类重新定义并实现从父类继承的方法。</p>
<p>当一个类继承自另一个类时，子类可以继承父类的方法。但有时子类可能需要修改继承的方法的实现，以满足自己的特定需求。方法重写提供了这样的机制，允许子类提供一个新的实现来替代父类的方法。</p>
<p>要实现方法重写，需要满足以下条件：</p>
<ol>
<li><strong>子类必须继承自父类。</strong></li>
<li><strong>父类中的方法必须被标记为<code>virtual</code>，表示它可以被子类重写。</strong></li>
<li><strong>子类中需要使用<code>override</code>关键字来重写父类中的方法，并提供新的实现。</strong></li>
</ol>
<p>子类中重写的方法必须具有与父类中被重写的方法相同的名称、参数列表和返回类型。通过重写方法，子类可以改变或扩展父类方法的行为，以适应子类的需求。</p>
<p>当使用父类的引用指向子类的对象时，如果调用被重写的方法，实际上会执行子类中重写的方法，而不是父类中的原始方法。这种行为称为动态绑定，因为在运行时决定要调用的具体方法。</p>
<p>方法重写是实现多态性的一种方式，它允许以统一的方式处理不同类型的对象，并根据对象的实际类型来调用相应的方法。这提高了代码的灵活性、可维护性和可扩展性。</p>
<h4 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h4><p>动态绑定（Dynamic Binding）是多态性的一个重要概念，它是指在运行时根据对象的实际类型来决定要调用的方法或执行的操作。通过动态绑定，程序能够根据对象的实际类型选择正确的方法实现，实现灵活性和可扩展性。</p>
<p>在编译时，编译器通常根据变量的声明类型来确定要调用的方法。但是，当使用多态性的特性时，对象的实际类型可能与声明类型不同。在这种情况下，动态绑定允许在运行时根据对象的实际类型来解析方法调用。</p>
<p>具体而言，当通过基类的引用指向子类的对象时，编译器会根据基类的声明类型确定要调用的方法。但在运行时，实际执行的是子类中重写的方法，而不是基类中的原始方法。这是因为在运行时，系统会根据对象的实际类型动态选择正确的方法实现。</p>
<p>例如，考虑以下代码片段：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Animal makes a sound&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Dog barks&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.MakeSound(); <span class="comment">// 动态绑定，实际调用的是Dog类的MakeSound方法</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>animal</code>是一个基类<code>Animal</code>的引用，但它实际上指向一个子类<code>Dog</code>的对象。当调用<code>MakeSound</code>方法时，通过动态绑定，实际执行的是<code>Dog</code>类中重写的<code>MakeSound</code>方法，输出”Dog barks”。</p>
<p>通过动态绑定，程序能够根据对象的实际类型来决定要调用的方法，实现了多态性的灵活性和可扩展性。这对于处理不同类型的对象和实现运行时多态行为非常重要。</p>
<blockquote>
</blockquote>
<h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型（Generics）是一种在编程语言中使用类型参数来创建可重用代码的机制。它允许在编写类或方法时延迟指定具体的数据类型，使代码能够适用于多种不同类型的数据。</p>
<p>泛型的主要目的是提供类型安全和代码重用。通过使用泛型，可以编写与数据类型无关的通用代码，避免重复编写相似的代码，提高代码的可维护性和可扩展性。</p>
<p>在C#中，泛型可以应用于类、结构体、接口和方法。它使用尖括号（&lt;&gt;）来指定类型参数，并在需要使用具体类型时进行替换。</p>
<p>以下是一个使用泛型的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeclass MyGenericClass&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T genericField;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyGenericClass</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        genericField = <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">GetGenericField</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> genericField;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用泛型类</span></span><br><span class="line">MyGenericClass&lt;<span class="built_in">int</span>&gt; myIntObject = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">int</span> <span class="keyword">value</span> = myIntObject.GetGenericField(); <span class="comment">// 返回42</span></span><br><span class="line"></span><br><span class="line">MyGenericClass&lt;<span class="built_in">string</span>&gt; myStringObject = <span class="keyword">new</span> MyGenericClass&lt;<span class="built_in">string</span>&gt;(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> text = myStringObject.GetGenericField(); <span class="comment">// 返回&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>MyGenericClass&lt;T&gt;</code>是一个泛型类，其中的<code>T</code>是一个类型参数。通过在创建对象时指定具体类型，可以创建<code>MyGenericClass</code>的实例。这样，<code>genericField</code>字段和<code>GetGenericField</code>方法的类型将根据实际指定的类型进行实例化。</p>
<p>泛型提供了许多优势，包括：</p>
<ol>
<li>类型安全：泛型在编译时提供类型检查，防止类型不匹配的错误。</li>
<li>代码重用：可以编写通用的算法和数据结构，适用于多种类型的数据。</li>
<li>性能提升：泛型可以避免装箱和拆箱操作，提高性能。</li>
<li>可读性和维护性：泛型代码通常更具可读性和可维护性，因为它们是与类型无关的通用代码。</li>
</ol>
<p>总而言之，泛型是一种强大的编程机制，它允许在编写代码时推迟具体类型的指定，从而提供更灵活、类型安全和可重用的代码。</p>
<h2 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h2><p>这个练习是为了熟系所有的面向对象的内容，我们将从头开始创建一个类，用于实现所有的面向对象特性。</p>
<h3 id="练习封装"><a href="#练习封装" class="headerlink" title="练习封装"></a>练习封装</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Object_oriented_testing</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个类用来练习封装</span></span><br><span class="line">    <span class="comment">//tip - 在类中，对方法和变量如果不加访问修饰符一般都是私有的（private）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IT</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//1.生成一个类中最基础的东西</span></span><br><span class="line">        <span class="comment">// - 成员变量</span></span><br><span class="line">        <span class="comment">//公有变量可以在类外中改变  - 用.操作符即可</span></span><br><span class="line">        <span class="comment">//私有变量只能在类中调用 - 在类外就不能调用</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> myVariable;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> myPublic;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.构造函数</span></span><br><span class="line">        <span class="comment">// - 构造函数 - 用来初始化变量</span></span><br><span class="line">        <span class="comment">//在创建对象的时候自动运行</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IT</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是构造函数&quot;</span>);</span><br><span class="line">            myVariable = <span class="number">1</span>;</span><br><span class="line">            myPublic = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.有参构造函数</span></span><br><span class="line">        <span class="comment">//用于用户自己指定所需要的私有变量的值</span></span><br><span class="line">        <span class="comment">//私有变量只能在类中改变值 - 但是我们可以通过构造函数来初始化我们想要的值</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">IT</span>(<span class="params"><span class="built_in">int</span> variable</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            myVariable = variable;</span><br><span class="line">            myPublic = variable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.构造我们的类方法</span></span><br><span class="line">        <span class="comment">//类方法完成某种方式 - 这里我们就简单一点</span></span><br><span class="line">        <span class="comment">//用方法打印一些字段</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;你好我是test这个方法&quot;</span>);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;我打印变量&#123;1&#125;和&#123;2&#125;&quot;</span>, myVariable, myPublic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//5.析构函数</span></span><br><span class="line">        <span class="comment">//在程序结束的时候自动运行</span></span><br><span class="line">        ~IT() &#123;</span><br><span class="line">            myPublic = <span class="number">1</span>;</span><br><span class="line">            myVariable = <span class="number">1</span>;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;我是析构函数&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> Object_oriented_testing;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Object_oriented_testing</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            IT a = <span class="keyword">new</span> IT();</span><br><span class="line">            <span class="comment">//1.对公共变量赋值</span></span><br><span class="line">            a.myPublic = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//2.调用对象方法</span></span><br><span class="line">            a.test();</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230604202621214.png" alt="image-20230604202621214"></p>
<h3 id="练习继承"><a href="#练习继承" class="headerlink" title="练习继承"></a>练习继承</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> 练习继承</span><br><span class="line">&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//创建Car作为基类 - 一般基类被创建为抽象类</span></span><br><span class="line">        <span class="comment">//抽象类不能实例化——只是我们子类的蓝图</span></span><br><span class="line">        <span class="comment">//创建两个变量 - 来传值给我们的属性</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> id = <span class="string">&quot;并没有设定默认id&quot;</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> name = <span class="string">&quot;并没有表明该车辆的名字&quot;</span>;</span><br><span class="line">        <span class="comment">//创建Car类来模拟继承</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.创建两个属性</span></span><br><span class="line">        <span class="comment">//属性的概念其实无处不在，我们的名字和性别就是一种属性</span></span><br><span class="line">        <span class="comment">//我们可以赋予属性功能来实现我们的目的</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Id</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> id;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//赋值的时候由value传递值给name</span></span><br><span class="line">                id = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span></span><br><span class="line">            &#123;</span><br><span class="line">                name = <span class="keyword">value</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.创建Car的虚方法 - 用于子类重写</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MyCars</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这辆车是什么&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里可以用属性代替</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Price</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这辆车的价钱是多少&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Balance</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;测试一下未重写是怎么样的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Wuling_Hongguang</span> : <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//3.重写父类的虚方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MyCars</span>()</span></span><br><span class="line">        &#123; </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这辆车是五菱宏光&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Price</span>()</span> &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;这辆车很便宜&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Wuling_Hongguang</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//在构造函数可用 - 用于调用父类的属性</span></span><br><span class="line">            <span class="keyword">base</span>.Id =<span class="string">&quot;001&quot;</span>;</span><br><span class="line">            <span class="keyword">base</span>.Name = <span class="string">&quot;五菱宏光&quot;</span>;</span><br><span class="line">            <span class="comment">//打印一下对应的属性</span></span><br><span class="line">            Console.WriteLine(Id);</span><br><span class="line">            Console.WriteLine(Name);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//创建一个五菱宏光的对象</span></span><br><span class="line">            Wuling_Hongguang a = <span class="keyword">new</span> Wuling_Hongguang();</span><br><span class="line">            <span class="comment">//更改一下五菱宏光的属性</span></span><br><span class="line">            a.Id = <span class="string">&quot;002&quot;</span>;</span><br><span class="line">            a.Name = <span class="string">&quot;小绵羊&quot;</span>;</span><br><span class="line">            a.Price();</span><br><span class="line">            a.MyCars();</span><br><span class="line">            a.Balance();</span><br><span class="line">            <span class="comment">//打印自定义属性</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;&#123;0&#125;,&#123;1&#125;&quot;</span>,a.Id,a.Name);</span><br><span class="line">            <span class="comment">//打印对象就出现对象对应的命名空间</span></span><br><span class="line">            Console.WriteLine(a);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230605130627976.png" alt="image-20230605130627976"></p>
<blockquote>
<p>当你打印一个对象时，它的默认打印行为是输出对象的完全限定类型名称。这是通过调用对象的 <code>ToString()</code> 方法实现的。</p>
<p>在 C# 中，所有类都继承自 <code>System.Object</code>，而 <code>System.Object</code> 类定义了默认的 <code>ToString()</code> 方法。默认情况下，<code>ToString()</code> 方法会返回对象的完全限定类型名称。</p>
<p>例如，假设你声明了一个名为 <code>myCar</code> 的对象，类型为 <code>Car</code>：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeCar myCar = <span class="keyword">new</span> Car();</span><br><span class="line">Console.WriteLine(myCar);</span><br></pre></td></tr></table></figure>

<p>输出将会是类似以下的结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">vbnetCopy code</span><br><span class="line">Namespace.Car</span><br></pre></td></tr></table></figure>

<p><code>Namespace</code> 是 <code>Car</code> 类所在的命名空间，而 <code>Car</code> 是类的名称。</p>
<p>如果你想在输出中显示自定义的信息，你可以重写基类 <code>System.Object</code> 中的 <code>ToString()</code> 方法，以便返回你想要的字符串表示形式。例如，你可以在 <code>Car</code> 类中重写 <code>ToString()</code> 方法，以返回车辆的特定信息：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy codepublic <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Car: &quot;</span> + Name + <span class="string">&quot;, ID: &quot;</span> + Id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，当你打印 <code>myCar</code> 对象时，将会输出你自定义的字符串表示形式，而不是默认的完全限定类型名称。</p>
</blockquote>
<h3 id="练习多态"><a href="#练习多态" class="headerlink" title="练习多态"></a>练习多态</h3><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> _03_练习多态</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1.定义了一个接口</span></span><br><span class="line">    <span class="comment">//接口可以实现多继承——来调用我们频繁使用的方法</span></span><br><span class="line">    <span class="keyword">interface</span> <span class="title">IMyInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">MyMethod</span>()</span>;</span><br><span class="line">        <span class="built_in">int</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Name</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">string</span> a;</span><br><span class="line">        <span class="comment">//创建属性对a操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> A</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span> &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line">            <span class="keyword">set</span> &#123; a = <span class="keyword">value</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//抽象类无法声明主题，需要继承来重写</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">Call</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span>;</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.创建一个类用来调用我们的接口方法</span></span><br><span class="line">    <span class="comment">//顺便继承父类 - 记住继承抽象类一定要重写它的抽象方法</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">MyClass</span> : <span class="title">Name</span>, <span class="title">IMyInterface</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MyMethod</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 实现接口中定义的方法</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> MyProperty &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">Call</span>(<span class="params"><span class="built_in">double</span> <span class="keyword">value</span></span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 提供具体的实现</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">value</span> * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//例子2</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The animal makes a sound.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Dog</span> : <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The dog barks.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Cat</span> : <span class="title">Animal</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">MakeSound</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;The cat meows.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Animal animal1 = <span class="keyword">new</span> Dog();</span><br><span class="line">            Animal animal2 = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line">            animal1.MakeSound(); <span class="comment">// 输出：The dog barks.</span></span><br><span class="line">            animal2.MakeSound(); <span class="comment">// 输出：The cat meows.</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/05/29/c/image-20230605194425539.png" alt="image-20230605194425539"></p>
<h2 id="c-功能类"><a href="#c-功能类" class="headerlink" title="c#功能类*"></a>c#功能类*</h2><h3 id="泛型-1"><a href="#泛型-1" class="headerlink" title="泛型"></a>泛型</h3><p>泛型（Generics）是一种在编程语言中实现参数化类型的机制。它允许我们编写可重用的代码，可以在不同的数据类型上进行操作，而无需为每种类型编写重复的代码。</p>
<p>使用泛型，我们可以定义类、接口、方法等具有参数化类型的实体。参数化类型允许我们在使用时指定具体的类型，从而使代码更加灵活和可重用。</p>
<p>泛型的主要好处如下：</p>
<ol>
<li>类型安全：通过使用泛型，我们可以在编译时捕获类型错误。编译器会在编译时检查泛型代码的类型，并提供类型安全保证。</li>
<li>代码重用：泛型使我们能够编写通用的代码，可以在不同类型上进行操作。这样可以避免重复编写类似的代码，提高代码的重用性和可维护性。</li>
<li>性能优化：使用泛型可以提高代码的性能。由于泛型代码在编译时生成特定类型的代码，因此避免了装箱和拆箱操作，并提供了更好的性能。</li>
</ol>
<p>以下是一个使用泛型的简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> T[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> top;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span>(<span class="params"><span class="built_in">int</span> capacity</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items = <span class="keyword">new</span> T[capacity];</span><br><span class="line">        top = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Push</span>(<span class="params">T item</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        items[++top] = item;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">Pop</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> items[top--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Stack&lt;<span class="built_in">int</span>&gt; intStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">int</span>&gt;(<span class="number">5</span>);</span><br><span class="line">        intStack.Push(<span class="number">1</span>);</span><br><span class="line">        intStack.Push(<span class="number">2</span>);</span><br><span class="line">        intStack.Push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> <span class="keyword">value</span> = intStack.Pop();</span><br><span class="line">        Console.WriteLine(<span class="keyword">value</span>); <span class="comment">// 输出：3</span></span><br><span class="line"></span><br><span class="line">        Stack&lt;<span class="built_in">string</span>&gt; stringStack = <span class="keyword">new</span> Stack&lt;<span class="built_in">string</span>&gt;(<span class="number">5</span>);</span><br><span class="line">        stringStack.Push(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        stringStack.Push(<span class="string">&quot;World&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">string</span> str = stringStack.Pop();</span><br><span class="line">        Console.WriteLine(str); <span class="comment">// 输出：World</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个泛型类 <code>Stack&lt;T&gt;</code>，它表示一个栈数据结构。通过在类定义中使用泛型参数 <code>T</code>，我们可以在创建对象时指定栈中存储的元素类型。</p>
<p>在 <code>Main</code> 方法中，我们创建了一个 <code>Stack&lt;int&gt;</code> 对象 <code>intStack</code>，用于存储整数类型的元素，并进行了入栈和出栈操作。然后，我们创建了一个 <code>Stack&lt;string&gt;</code> 对象 <code>stringStack</code>，用于存储字符串类型的元素，并进行了相应的操作。</p>
<p>通过使用泛型，我们可以在不同类型上重复使用相同的栈类，并在编译时获得类型安全和性能优化的好处。</p>
<h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p>在 C# 中，<code>List&lt;T&gt;</code> 类是泛型集合类之一，用于表示动态大小的可变数组。<code>List&lt;T&gt;</code> 提供了一组强大的方法和属性，用于操作和管理元素列表。</p>
<p><code>List&lt;T&gt;</code> 类位于 <code>System.Collections.Generic</code> 命名空间中，是 .NET Framework 中最常用的集合类型之一。它提供了类似数组的功能，但具有更大的灵活性和功能。</p>
<p>以下是 <code>List&lt;T&gt;</code> 类的一些主要特点和功能：</p>
<ol>
<li>动态大小：<code>List&lt;T&gt;</code> 允许根据需要自动调整容量，以容纳不同数量的元素。可以随时向列表中添加或删除元素。</li>
<li>泛型：<code>List&lt;T&gt;</code> 是一个泛型类，可以在创建时指定元素的类型。泛型提供了类型安全和性能优化的好处。</li>
<li>索引访问：可以通过索引访问列表中的元素。使用索引可以读取或修改列表中特定位置的元素。</li>
<li>增删改查：<code>List&lt;T&gt;</code> 提供了一系列的方法用于添加、删除、修改和搜索列表中的元素。例如，<code>Add</code> 方法用于添加元素，<code>Remove</code> 方法用于删除元素，<code>Find</code> 方法用于搜索元素等等。</li>
<li>排序和排序搜索：<code>List&lt;T&gt;</code> 提供了排序方法（<code>Sort</code>）和排序搜索方法（<code>BinarySearch</code>），方便对列表中的元素进行排序和搜索。</li>
<li>遍历：可以使用 <code>foreach</code> 循环或迭代器来遍历 <code>List&lt;T&gt;</code> 中的元素。</li>
</ol>
<p>下面是一个使用 <code>List&lt;T&gt;</code> 的简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeusing System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;<span class="built_in">string</span>&gt; fruits = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加元素</span></span><br><span class="line">        fruits.Add(<span class="string">&quot;Apple&quot;</span>);</span><br><span class="line">        fruits.Add(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        fruits.Add(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 访问元素</span></span><br><span class="line">        Console.WriteLine(fruits[<span class="number">0</span>]); <span class="comment">// 输出：Apple</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历元素</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="built_in">string</span> fruit <span class="keyword">in</span> fruits)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(fruit);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 删除元素</span></span><br><span class="line">        fruits.Remove(<span class="string">&quot;Banana&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 判断元素是否存在</span></span><br><span class="line">        <span class="built_in">bool</span> containsOrange = fruits.Contains(<span class="string">&quot;Orange&quot;</span>);</span><br><span class="line">        Console.WriteLine(containsOrange); <span class="comment">// 输出：True</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们创建了一个 <code>List&lt;string&gt;</code> 对象 <code>fruits</code>，并使用 <code>Add</code> 方法向其中添加了几个水果。然后，我们可以使用索引访问元素，使用 <code>foreach</code> 循环遍历元素，使用 <code>Remove</code> 方法删除元素，并使用 <code>Contains</code> 方法判断元素是否存在。</p>
<p>总之，<code>List&lt;T&gt;</code> 类是 C# 中用于表示动态大小的可变数组的泛型集合类，提供了丰富的方法和属性，方便对元素列表进行操作和管理。</p>
<h2 id="c-高级"><a href="#c-高级" class="headerlink" title="c#高级"></a>c#高级</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式（Regular Expression），简称为正则或正则表达式，是一种用于描述和匹配字符串模式的工具。它是由一系列字符和特殊字符组成的表达式，可以用来进行字符串的搜索、匹配、替换和提取等操作。</p>
<p>正则表达式由普通字符（例如字母、数字和标点符号）和特殊字符组成，特殊字符具有特定的含义和功能。通过组合和使用这些字符，可以构建出具有复杂匹配规则的模式。</p>
<p>正则表达式常用于以下场景：</p>
<ol>
<li>搜索和匹配：可以用来搜索和匹配符合特定模式的字符串。例如，可以使用正则表达式来检查一个字符串是否符合某种格式，如邮箱地址、电话号码等。</li>
<li>替换和修改：可以用来替换字符串中符合某个模式的部分。例如，可以使用正则表达式将一个文本中的所有日期格式改为另一种格式。</li>
<li>提取和分割：可以用来提取字符串中符合某个模式的部分。例如，可以使用正则表达式从一个网页的 HTML 代码中提取出所有链接。</li>
<li>格式验证：可以用来验证用户输入的数据是否符合特定的格式要求。例如，可以使用正则表达式来验证用户输入的密码是否包含特定的字符和长度。</li>
</ol>
<p>正则表达式是跨平台的，几乎所有现代编程语言都支持正则表达式的操作。在 C# 中，可以使用 <code>System.Text.RegularExpressions</code> 命名空间提供的正则表达式类来处理和操作正则表达式。</p>
<p>以下是一个简单的示例，演示了使用正则表达式来搜索和匹配字符串：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeusing System;</span><br><span class="line"><span class="keyword">using</span> System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> input = <span class="string">&quot;Hello, 12345!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义匹配模式</span></span><br><span class="line">        <span class="built_in">string</span> pattern = <span class="string">@&quot;\d+&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建正则表达式对象</span></span><br><span class="line">        Regex regex = <span class="keyword">new</span> Regex(pattern);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 搜索匹配项</span></span><br><span class="line">        Match match = regex.Match(input);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否找到匹配项</span></span><br><span class="line">        <span class="keyword">if</span> (match.Success)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;找到匹配项：&#123;0&#125;&quot;</span>, match.Value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;未找到匹配项&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个匹配模式 <code>@&quot;\d+&quot;</code>，表示一个或多个连续的数字。然后，我们使用 <code>Regex</code> 类创建一个正则表达式对象，并使用 <code>Match</code> 方法在输入字符串中搜索匹配项。</p>
<p>如果找到了匹配项，我们可以通过 <code>Match</code> 对象的属性来获取匹配结果。在此示例中，我们输出找到的匹配项。</p>
<p>总结来说，正则表达式是一种用于描述和匹配字符串模式的工具。它具有广泛使用的语法和特殊字符，可以用来进行字符串的搜索、匹配、替换和提取等操作。在不同编程语言中，正则表达式的具体语法和使用方式可能有所不同，但基本的概念和功能是相通的。</p>
<p>以下是一些常用的正则表达式特殊字符和符号的示例：</p>
<ul>
<li><code>.</code>: 匹配任意单个字符，除了换行符。</li>
<li><code>*</code>: 匹配前一个元素零次或多次。</li>
<li><code>+</code>: 匹配前一个元素一次或多次。</li>
<li><code>?</code>: 匹配前一个元素零次或一次。</li>
<li><code>[]</code>: 匹配括号内的任意一个字符。例如，<code>[abc]</code> 匹配字符 ‘a’、’b’ 或 ‘c’。</li>
<li><code>[^]</code>: 匹配不在括号内的任意一个字符。例如，<code>[^abc]</code> 匹配除了 ‘a’、’b’ 和 ‘c’ 之外的任意字符。</li>
<li><code>\d</code>: 匹配任意一个数字字符。等价于 <code>[0-9]</code>。</li>
<li><code>\w</code>: 匹配任意一个字母、数字或下划线字符。等价于 <code>[A-Za-z0-9_]</code>。</li>
<li><code>\s</code>: 匹配任意一个空白字符，包括空格、制表符、换行符等。</li>
<li><code>^</code>: 匹配字符串的开头位置。</li>
<li><code>$</code>: 匹配字符串的结尾位置。</li>
<li><code>|</code>: 在模式中使用逻辑或，匹配两个或多个模式之一。</li>
</ul>
<p>除了上述特殊字符外，正则表达式还支持使用括号进行分组、使用限定符指定匹配次数、使用转义字符来匹配特殊字符等。</p>
<p>正则表达式可以在不同的编程语言中使用，例如 C#、Java、Python、JavaScript 等。每种编程语言可能有自己的正则表达式类或函数，用于进行正则操作。在 C# 中，可以使用 <code>System.Text.RegularExpressions</code> 命名空间提供的类来处理和操作正则表达式。</p>
<h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><p>在 C# 中，委托（Delegate）是一种类型，用于表示对一个或多个方法的引用。委托可以将方法视为对象，并将其赋值给委托变量，以便在需要时调用这些方法。</p>
<p>委托提供了一种将方法作为参数传递、将方法存储在数据结构中和通过委托调用方法的机制。它可以帮助实现事件处理、回调函数和多播委托等功能。</p>
<p>以下是委托的主要特点和使用方法：</p>
<ol>
<li>类型安全：委托是类型安全的，它在编译时会进行类型检查，以确保委托变量与其引用的方法具有相同的签名（参数和返回类型）。</li>
<li>方法引用：委托可以引用一个或多个具有相同签名的方法。通过将方法赋值给委托变量，可以将方法作为对象来操作。</li>
<li>事件处理：委托经常用于实现事件处理机制。当事件发生时，相关的委托将被调用，并执行相应的方法。</li>
<li>回调函数：委托可以用作回调函数的机制，允许将一个方法传递给另一个方法，在需要时进行回调调用。</li>
<li>多播委托：委托可以合并多个方法，形成一个多播委托。调用多播委托时，所有合并的方法都会被依次调用。</li>
</ol>
<p>以下是一个简单的委托示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegate myDelegate = DisplayMessage;</span><br><span class="line">        myDelegate(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        myDelegate += DisplayUpperCaseMessage;</span><br><span class="line">        myDelegate(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayUpperCaseMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message in uppercase: &quot;</span> + message.ToUpper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个委托类型 <code>MyDelegate</code>，它可以引用具有 <code>void</code> 返回类型和一个 <code>string</code> 参数的方法。然后，我们创建了一个委托变量 <code>myDelegate</code>，并将其赋值为 <code>DisplayMessage</code> 方法。</p>
<p>通过调用委托变量 <code>myDelegate</code>，我们实际上调用了被委托引用的方法 <code>DisplayMessage</code>，并传递了一个字符串参数。</p>
<p>在后续操作中，我们将另一个方法 <code>DisplayUpperCaseMessage</code> 添加到委托变量 <code>myDelegate</code> 中。当调用委托变量时，两个方法都会被依次调用，从而实现多播委托的功能。</p>
<p>总而言之，委托是一个类，可以定义自己的委托类型，也可以使用.NET框架提供的预定义委托类型。预定义的委托类型包括<code>Action</code>、<code>Func</code>、<code>Predicate</code>等，它们具有不同的签名和功能，可以用于不同的场景。</p>
<p>下面是一些常用的预定义委托类型：</p>
<ul>
<li><code>Action</code>: 表示一个不返回值的委托。可以用于执行无返回值的操作。</li>
<li><code>Func</code>: 表示一个具有返回值的委托。可以用于执行带有返回值的操作。</li>
<li><code>Predicate</code>: 表示一个接受一个参数并返回布尔值的委托。通常用于进行条件判断。</li>
</ul>
<p>预定义委托类型的使用示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使用 Action 委托执行无返回值的操作</span></span><br><span class="line">        Action&lt;<span class="built_in">string</span>&gt; actionDelegate = DisplayMessage;</span><br><span class="line">        actionDelegate(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Func 委托执行带有返回值的操作</span></span><br><span class="line">        Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; funcDelegate = AddNumbers;</span><br><span class="line">        <span class="built_in">int</span> result = funcDelegate(<span class="number">10</span>, <span class="number">20</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Result: &quot;</span> + result);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 Predicate 委托进行条件判断</span></span><br><span class="line">        Predicate&lt;<span class="built_in">int</span>&gt; predicateDelegate = IsPositive;</span><br><span class="line">        <span class="built_in">bool</span> isPositive = predicateDelegate(<span class="number">5</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Is Positive: &quot;</span> + isPositive);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisplayMessage</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">AddNumbers</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">bool</span> <span class="title">IsPositive</span>(<span class="params"><span class="built_in">int</span> number</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> number &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用了不同的预定义委托类型来执行不同的操作。通过使用泛型，我们可以指定委托的参数类型和返回类型。</p>
<p>使用 <code>Action&lt;string&gt;</code> 委托执行了一个接受一个字符串参数并且没有返回值的方法 <code>DisplayMessage</code>。使用 <code>Func&lt;int, int, int&gt;</code> 委托执行了一个接受两个整数参数并返回整数结果的方法 <code>AddNumbers</code>。使用 <code>Predicate&lt;int&gt;</code> 委托进行了一个判断，判断一个整数是否为正数。</p>
<p>预定义委托类型使得使用委托更加方便和简洁，并且减少了自定义委托类型的需要。</p>
<p>总结来说，委托是一个类，用于表示对一个或多个方法的引用。它可以定义自己的委托类型，也可以使用预定义的委托类型。委托在C#中提供了一种灵活的机制，可以将方法作为参数传递、存储和调用。它在事件处理、回调函数和多播委托等场景中非常有用。</p>
<blockquote>
<p><code>Action</code> 委托是 C# 中预定义的一个委托类型，它用于表示一个不返回值的委托。<code>Action</code> 委托可以接受最多 16 个输入参数，但不返回任何值。</p>
<p><code>Action</code> 委托的定义如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy codepublic <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T</span>&gt;(<span class="params">T obj</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">Action</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>&gt;(<span class="params">T1 arg1, T2 arg2</span>)</span>;</span><br><span class="line"><span class="comment">// ... 其他重载 ...</span></span><br></pre></td></tr></table></figure>

<p><code>Action</code> 委托的命名规范为以 “Action” 开头，后面跟着输入参数的个数，最多可以有 16 个输入参数。</p>
<p>以下是一些使用 <code>Action</code> 委托的示例：</p>
<p>不带参数的 <code>Action</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeAction greet = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet(); <span class="comment">// 输出: Hello, World!</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个不带参数的 <code>Action</code> 委托变量 <code>greet</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>greet()</code>，实际上会执行 Lambda 表达式中定义的方法，输出 “Hello, World!”。</p>
<p>带有一个输入参数的 <code>Action</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeAction&lt;<span class="built_in">string</span>&gt; greet = (name) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;John&quot;</span>); <span class="comment">// 输出: Hello, John!</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有一个输入参数的 <code>Action</code> 委托变量 <code>greet</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>greet(&quot;John&quot;)</code>，Lambda 表达式中定义的方法会接收到参数 “John”，输出 “Hello, John!”。</p>
<p>带有多个输入参数的 <code>Action</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeAction&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> result = a + b;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Sum: &quot;</span> + result);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">add</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 输出: Sum: 8</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有两个输入参数的 <code>Action</code> 委托变量 <code>add</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>add(5, 3)</code>，Lambda 表达式中定义的方法会接收到参数 5 和 3，计算它们的和并输出结果 “Sum: 8”。</p>
<p><code>Action</code> 委托提供了一种方便的方式来定义和使用不返回值的委托。通过使用不同的重载，可以接受不同数量和类型的输入参数。这使得委托的使用更加灵活和简洁。</p>
</blockquote>
<blockquote>
<p><code>Func</code> 委托是 C# 中预定义的一个委托类型，它用于表示一个具有返回值的委托。<code>Func</code> 委托可以接受最多 16 个输入参数，并返回一个指定的结果类型。</p>
<p><code>Func</code> 委托的定义如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">csharpCopy codepublic <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">out</span> <span class="title">TResult</span>&gt;()</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T arg</span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> TResult <span class="title">Func</span>&lt;<span class="keyword">in</span> <span class="title">T1</span>, <span class="keyword">in</span> <span class="title">T2</span>, <span class="keyword">out</span> <span class="title">TResult</span>&gt;(<span class="params">T1 arg1, T2 arg2</span>)</span>;</span><br><span class="line"><span class="comment">// ... 其他重载 ...</span></span><br></pre></td></tr></table></figure>

<p><code>Func</code> 委托的命名规范为以 “Func” 开头，后面跟着输入参数的个数，最多可以有 16 个输入参数。最后一个类型参数表示返回值的类型。</p>
<p>以下是一些使用 <code>Func</code> 委托的示例：</p>
<p>不带参数的 <code>Func</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeFunc&lt;<span class="built_in">string</span>&gt; getGreeting = () =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> greeting = getGreeting(); <span class="comment">// greeting = &quot;Hello, World!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个不带参数的 <code>Func</code> 委托变量 <code>getGreeting</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>getGreeting()</code>，实际上会执行 Lambda 表达式中定义的方法，返回字符串 “Hello, World!”。</p>
<p>带有一个输入参数的 <code>Func</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeFunc&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; greet = (name) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> greeting = greet(<span class="string">&quot;John&quot;</span>); <span class="comment">// greeting = &quot;Hello, John!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有一个输入参数的 <code>Func</code> 委托变量 <code>greet</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>greet(&quot;John&quot;)</code>，Lambda 表达式中定义的方法会接收到参数 “John”，返回字符串 “Hello, John!”。</p>
<p>带有多个输入参数的 <code>Func</code> 委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeFunc&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> result = <span class="keyword">add</span>(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// result = 8</span></span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有两个输入参数的 <code>Func</code> 委托变量 <code>add</code>，并使用 Lambda 表达式来定义委托的方法体。通过调用委托变量 <code>add(5, 3)</code>，Lambda 表达式中定义的方法会接收到参数 5 和 3，计算它们的和并返回结果 8。</p>
<p><code>Func</code> 委托提供了一种方便的方式来定义和使用带有返回值的委托。通过使用不同的重载，可以接受不同数量和类型的输入参数，并指定返回值的类型。这使得委托的使用更加灵活和简洁。</p>
</blockquote>
<h4 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h4><p>多播委托（Multicast Delegate）是 C# 中的一种特殊委托类型，它可以持有一个或多个目标方法的引用，并且可以按顺序依次调用这些方法。</p>
<p>在 C# 中，多播委托是由 <code>System.MulticastDelegate</code> 类派生而来的委托类型。它具有以下特点：</p>
<ol>
<li>可以使用 <code>+</code> 运算符将多个委托合并为一个多播委托。</li>
<li>可以使用 <code>-</code> 运算符将一个委托从多播委托中移除。</li>
<li>调用多播委托时，会按照添加的顺序依次调用每个目标方法。</li>
</ol>
<p>下面是一个简单的示例，演示如何使用多播委托：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyDelegate</span>(<span class="params"><span class="built_in">string</span> message</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyDelegate myDelegate = MethodA;</span><br><span class="line">        myDelegate += MethodB;</span><br><span class="line">        myDelegate += MethodC;</span><br><span class="line"></span><br><span class="line">        myDelegate(<span class="string">&quot;Hello, World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MethodA: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MethodB: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MethodC</span>(<span class="params"><span class="built_in">string</span> message</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;MethodC: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">MethodA: Hello, World!</span><br><span class="line">MethodB: Hello, World!</span><br><span class="line">MethodC: Hello, World!</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 <code>MyDelegate</code> 的委托类型，它接受一个字符串参数并且没有返回值。然后，我们创建了一个多播委托 <code>myDelegate</code>，并使用 <code>+=</code> 运算符将三个方法 <code>MethodA</code>、<code>MethodB</code> 和 <code>MethodC</code> 添加到委托中。最后，我们通过调用委托 <code>myDelegate(&quot;Hello, World!&quot;)</code>，依次调用了每个方法，并传递相同的字符串参数。</p>
<p>需要注意的是，多播委托的调用顺序与添加方法的顺序有关。在示例中，我们按照添加的顺序依次调用了 <code>MethodA</code>、<code>MethodB</code> 和 <code>MethodC</code>。</p>
<p>另外，通过使用 <code>-</code> 运算符，我们可以从多播委托中移除一个方法。例如，使用 <code>myDelegate -= MethodB;</code> 可以从多播委托中移除 <code>MethodB</code> 方法。</p>
<p>多播委托在某些情况下非常有用，例如事件处理程序、回调函数等场景，它允许将多个方法组合在一起，并且能够方便地按顺序调用这些方法。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在 C# 中，事件（Event）是一种特殊的语言构造，用于实现发布-订阅模型（Publish-Subscribe Model）。事件允许一个对象（发布者）通知其他对象（订阅者）某个特定事件的发生，以便订阅者可以执行相应的操作。</p>
<p>事件由两个主要组成部分组成：事件声明和事件触发。事件声明定义了事件的名称、事件处理程序的委托类型以及可选的事件访问器。事件触发是在发布者对象中引发事件，以通知订阅者事件的发生。</p>
<p>以下是一个简单的示例，演示了如何在 C# 中声明和使用事件：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeusing System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 事件声明</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler MyEvent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Program program = <span class="keyword">new</span> Program();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 事件订阅（添加事件处理程序）</span></span><br><span class="line">        program.MyEvent += Program_MyEventHandler;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 触发事件</span></span><br><span class="line">        program.OnMyEvent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 事件触发的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnMyEvent</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        MyEvent?.Invoke(<span class="keyword">this</span>, EventArgs.Empty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 事件处理程序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Program_MyEventHandler</span>(<span class="params"><span class="built_in">object</span> sender, EventArgs e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Event handled!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们首先在 <code>Program</code> 类中声明了一个事件 <code>MyEvent</code>，它使用 <code>EventHandler</code> 委托作为事件处理程序的类型。然后，在 <code>Main</code> 方法中订阅了该事件，即将事件处理程序方法 <code>Program_MyEventHandler</code> 添加到事件的订阅列表中。最后，通过调用 <code>OnMyEvent</code> 方法触发了事件。</p>
<p>当事件触发时，订阅事件的事件处理程序方法 <code>Program_MyEventHandler</code> 将被执行，并在控制台输出 “Event handled!”。</p>
<p>需要注意的是，事件的访问器可以使用 <code>add</code> 和 <code>remove</code> 关键字进行自定义。这允许控制事件的订阅和取消订阅的行为。</p>
<p>事件是一种强大的机制，它可以实现对象间的松耦合通信，提供了一种简洁且可扩展的方式来处理对象间的交互。在 C# 中，事件被广泛用于处理用户界面的交互、异步操作的完成通知、消息传递和回调机制等各种场景。</p>
<h3 id="匿名方法"><a href="#匿名方法" class="headerlink" title="匿名方法"></a>匿名方法</h3><p>匿名方法（Anonymous Methods）是 C# 中一种特殊的方法，它允许我们在代码中定义一个没有显式命名的方法。匿名方法可以作为委托的实例或事件处理程序使用。</p>
<p>匿名方法的语法形式如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">delegate</span> (parameters)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在匿名方法中，我们可以定义方法体并传递参数，就像定义普通方法一样。匿名方法的参数列表和方法体放在一个委托类型的声明中，并且可以直接使用该委托类型的实例进行调用。</p>
<p>以下是一个使用匿名方法的示例，展示了如何将匿名方法作为委托的实例使用：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">GreetingDelegate</span>(<span class="params"><span class="built_in">string</span> name</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        GreetingDelegate greeting = <span class="built_in">delegate</span> (<span class="built_in">string</span> name)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        greeting(<span class="string">&quot;John&quot;</span>); <span class="comment">// 输出: Hello, John!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了一个名为 <code>GreetingDelegate</code> 的委托类型，它接受一个字符串参数并且没有返回值。然后，我们创建了一个匿名方法并将其赋值给委托变量 <code>greeting</code>。匿名方法的方法体是在 <code>delegate</code> 关键字后的大括号内定义的。最后，我们通过调用委托变量 <code>greeting(&quot;John&quot;)</code> 来调用匿名方法，并传递字符串参数 “John”。</p>
<p>匿名方法通常用于简单的委托场景，当我们只需要定义一个简短的方法体并且不想为其命名时，匿名方法提供了一种方便的方式。匿名方法可以与委托类型一起使用，允许我们以一种更简洁的方式定义委托实例。</p>
<h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><p>Lambda 表达式是 C# 中的一种语法特性，它提供了一种简洁的方式来定义匿名函数。Lambda 表达式可以用于创建委托实例、LINQ 查询、事件处理程序等场景。</p>
<p>Lambda 表达式的基本语法形式如下：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(parameters) =&gt; expression</span><br></pre></td></tr></table></figure>

<p>Lambda 表达式包括以下几个部分：</p>
<ul>
<li>参数列表：一对括号中包含零个或多个输入参数，可以指定参数的类型或使用隐式类型推断。</li>
<li>箭头运算符 <code>=&gt;</code>：表示从参数到表达式的映射。</li>
<li>表达式：定义 Lambda 表达式的方法体，可以是单个表达式或语句块。</li>
</ul>
<p>以下是一些使用 Lambda 表达式的示例：</p>
<p>无参数的 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">() =&gt; Console.WriteLine(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个 Lambda 表达式没有参数，表达式体是调用 <code>Console.WriteLine</code> 方法输出 “Hello, World!”。</p>
<p>带有一个参数的 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">name =&gt; Console.WriteLine(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这个 Lambda 表达式有一个参数 <code>name</code>，表达式体是调用 <code>Console.WriteLine</code> 方法输出 “Hello, “ 加上参数值。</p>
<p>带有多个参数的 Lambda 表达式：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">(a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure>

<p>这个 Lambda 表达式有两个参数 <code>a</code> 和 <code>b</code>，表达式体是将参数 <code>a</code> 和 <code>b</code> 相加并返回结果。</p>
<p>Lambda 表达式可以与委托类型一起使用，用于创建委托实例。例如，我们可以使用 Lambda 表达式创建 <code>Func</code> 委托的实例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Func&lt;<span class="built_in">int</span>, <span class="built_in">int</span>, <span class="built_in">int</span>&gt; <span class="keyword">add</span> = (a, b) =&gt; a + b;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个带有两个输入参数和一个返回值的 <code>Func</code> 委托实例 <code>add</code>，使用 Lambda 表达式 <code>(a, b) =&gt; a + b</code> 定义了方法体，实现了将两个参数相加并返回结果的逻辑。</p>
<p>Lambda 表达式的优势在于它的简洁性和灵活性。它可以减少编写冗余代码的需求，并且可以更直观地表达某些操作。Lambda 表达式在 LINQ 查询、集合操作、事件处理程序等场景中被广泛使用，提供了一种便捷的方式来编写简短而高效的代码。</p>
<h3 id="扩展方法"><a href="#扩展方法" class="headerlink" title="扩展方法"></a>扩展方法</h3><p>在C#中，扩展方法（Extension Methods）是一种特殊的静态方法，允许你向已存在的类型添加新的方法，而无需修改原始类型的定义或创建子类。</p>
<p>扩展方法提供了一种在不修改已有类型的情况下，为它们添加额外的功能的方式。这使得你可以向.NET框架中的类型添加自定义的方法，或者为自己定义的类型添加更便利的操作。</p>
<p>下面是扩展方法的一般写法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">ExtensionClass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ReturnType <span class="title">MethodName</span>(<span class="params"><span class="keyword">this</span> ExtendedType obj, parameters</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 扩展方法的实现逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码展示了一个扩展方法的示例，其中：</p>
<ul>
<li><code>ExtensionClass</code> 是定义扩展方法的静态类。类必须是静态的，并且在命名空间中。</li>
<li><code>MethodName</code> 是你给扩展方法起的名字。</li>
<li><code>ExtendedType</code> 是你要扩展的类型。</li>
<li><code>ReturnType</code> 是扩展方法的返回类型。</li>
<li><code>this ExtendedType obj</code> 表示将该扩展方法应用于 <code>ExtendedType</code> 类型的对象，通过 <code>this</code> 关键字进行标识。</li>
</ul>
<p>下面是一个示例，展示如何使用扩展方法为字符串类型添加一个自定义的方法：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringExtensions</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">ReverseString</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> input</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">char</span>[] chars = input.ToCharArray();</span><br><span class="line">        Array.Reverse(chars);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">string</span>(chars);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们为字符串类型添加了一个名为 <code>ReverseString</code> 的扩展方法，用于将字符串反转。</p>
<p>使用扩展方法时，需要注意以下几点：</p>
<ul>
<li>扩展方法必须定义在静态类中。</li>
<li>扩展方法必须是静态的。</li>
<li>扩展方法的第一个参数必须使用 <code>this</code> 关键字标识，并指定要扩展的类型。</li>
<li>调用扩展方法时，编译器会自动将调用者作为第一个参数传递给扩展方法。</li>
</ul>
<p>通过使用扩展方法，你可以在不修改已有类型的情况下，为其添加自定义的行为和功能。这对于扩展.NET框架中的类型或者自定义类型非常有用，可以使代码更加简洁、可读，并提供更便利的操作。</p>
<h3 id="Obsolete特性"><a href="#Obsolete特性" class="headerlink" title="Obsolete特性"></a>Obsolete特性</h3><p>在C#中，<code>Obsolete</code>特性用于标记已经过时（deprecated）的代码元素，例如类型、方法、属性或字段。通过将<code>Obsolete</code>特性应用于代码元素，可以向开发人员发出警告或错误，以指示该代码元素不再建议使用，并提供替代方案或建议。</p>
<p><code>Obsolete</code>特性具有以下特征：</p>
<ol>
<li>编译器警告：使用<code>Obsolete</code>特性标记的代码元素将导致编译器生成警告。这提醒开发人员在使用过时的代码元素时需要注意，并考虑替代方案。</li>
<li>自定义警告消息：<code>Obsolete</code>特性允许你提供自定义的警告消息，以解释为什么该代码元素被标记为过时，以及建议使用哪些替代方案。开发人员可以根据这些消息来了解如何迁移代码。</li>
<li>错误级别：你可以选择将<code>Obsolete</code>特性的错误级别设置为<code>Error</code>，这将导致编译器将过时的代码元素视为错误，阻止编译通过。这对于强制要求开发人员立即处理过时的代码非常有用。</li>
<li>版本控制：<code>Obsolete</code>特性还允许你指定过时的代码元素应该从哪个版本开始过时。这样，你可以明确说明从哪个版本开始推荐使用替代方案，并为使用较旧版本的代码的开发人员提供指导。</li>
</ol>
<p>使用<code>Obsolete</code>特性有助于提高代码的可维护性和可读性，确保开发人员及时了解不再建议使用的代码</p>
<h3 id="onditional特性"><a href="#onditional特性" class="headerlink" title="onditional特性"></a>onditional特性</h3><p>在C#中，<code>Conditional</code>特性用于在编译时根据条件决定是否包含或排除代码。它允许您根据条件选择性地编译和执行代码。</p>
<p><code>Conditional</code>特性有两个常见的用途：</p>
<ol>
<li><p>条件编译：通过使用条件预处理指令，您可以根据编译时定义的条件选择性地编译不同的代码块。<code>Conditional</code>特性可以与条件编译一起使用，以便在满足特定条件时才包含代码。这对于在不同的构建配置中包含或排除代码非常有用。</p>
<p>例如，考虑以下代码：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy code<span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DebugMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Debug method called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DebugMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>DebugMethod</code>方法带有<code>[Conditional(&quot;DEBUG&quot;)]</code>特性。这表示只有在定义了<code>DEBUG</code>预处理符号时，编译器才会将<code>DebugMethod</code>方法包含在生成的代码中。因此，只有当在代码的顶部定义了<code>#define DEBUG</code>时，<code>DebugMethod</code>方法才会在<code>Main</code>方法中调用。</p>
</li>
<li><p>方法调用条件性：使用<code>Conditional</code>特性还可以根据特定条件选择性地调用方法。在这种情况下，方法本身将始终包含在生成的代码中，但方法调用可能会根据条件被排除。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codepublic <span class="keyword">class</span> <span class="title">Example</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">Conditional(<span class="string">&quot;DEBUG&quot;</span>)</span>]</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DebugMethod</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Debug method called.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        DebugMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>DebugMethod</code>方法带有<code>[Conditional(&quot;DEBUG&quot;)]</code>特性。这意味着无论如何，<code>DebugMethod</code>方法都会被包含在生成的代码中，但是在调用<code>DebugMethod</code>方法时，它只会在定义了<code>DEBUG</code>预处理符号时执行。</p>
</li>
</ol>
<p>需要注意的是，<code>Conditional</code>特性只能应用于无返回值（<code>void</code>）的静态方法。这是因为在编译时，编译器会根据条件决定是否调用方法，而无法处理方法的返回值。</p>
<p>总结来说，<code>Conditional</code>特性允许您根据条件选择性地编译和执行代码，或选择性地调用方法。它在进行条件编译和调试期间非常有用。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射*"></a>反射*</h3><p>在C#中，反射（Reflection）是一种强大的机制，它允许你在运行时动态地探查、访问和操作程序集（assembly）、类型（type）和成员（member）的信息。通过反射，你可以在编译时不知道类型和成员的具体信息的情况下，通过名称来动态地获取并使用它们。</p>
<p>反射提供了一组类型（位于<code>System.Reflection</code>命名空间下）和方法，用于在运行时获取类型信息、创建对象实例、调用方法、获取和设置属性值等。下面是一些反射的常用用途：</p>
<ol>
<li>获取类型信息：你可以使用<code>Type</code>类来获取一个类型的信息，包括类型的名称、命名空间、基类、实现的接口、属性、方法等。你可以使用<code>typeof</code>运算符获取一个类型的<code>Type</code>对象，也可以使用<code>GetType()</code>方法获取一个对象的类型。</li>
<li>创建对象实例：通过反射，你可以使用<code>Activator</code>类来动态地创建对象实例。你可以指定类型的名称或<code>Type</code>对象，然后使用<code>Activator.CreateInstance</code>方法来创建对象。</li>
<li>调用方法和访问属性：反射允许你通过方法名称和参数信息来调用类型的方法，并获取方法的返回值。你可以使用<code>Type.InvokeMember</code>方法来实现。类似地，你也可以通过反射来获取和设置属性的值。</li>
<li>动态加载程序集：反射可以在运行时动态地加载程序集。通过<code>Assembly</code>类，你可以加载和探查程序集，获取其中的类型信息，并在需要时创建对象实例或调用方法。</li>
</ol>
<p>需要注意的是，反射是一个强大但复杂的机制，其使用可能会对性能产生一定的影响。在大多数情况下，建议优先考虑使用静态类型和编译时绑定，而将反射作为一种备选方案，用于处理那些在编译时无法确定的类型和成员。</p>
<h4 id="Assembly程序集合类"><a href="#Assembly程序集合类" class="headerlink" title="Assembly程序集合类"></a>Assembly程序集合类</h4><p>在C#中，<code>Assembly</code>类是一个用于加载、探索和操作程序集（assembly）的核心类。下面是<code>Assembly</code>类的一些主要特点和功能：</p>
<ol>
<li>加载程序集：<code>Assembly</code>类提供了多种方法来加载程序集，包括从文件、字节数组、流或已加载的程序集中加载。你可以使用<code>Assembly.Load</code>或<code>Assembly.LoadFrom</code>方法来加载程序集，并获取一个<code>Assembly</code>对象，以便后续的操作。</li>
<li>获取程序集信息：通过<code>Assembly</code>类，你可以获取程序集的各种信息，包括程序集的名称、版本号、公钥、特性、引用的程序集等。你可以使用<code>AssemblyName</code>类来访问这些信息，并通过<code>Assembly.GetCustomAttributes</code>方法获取程序集的自定义特性。</li>
<li>探索类型信息：<code>Assembly</code>类允许你在程序集中探索类型信息。你可以使用<code>Assembly.GetTypes</code>方法获取程序集中定义的所有类型，并使用<code>Type</code>类的相关方法来访问类型的成员、特性和基类信息。</li>
<li>创建对象实例：通过<code>Assembly</code>类，你可以在程序集中创建对象实例。使用<code>Assembly.CreateInstance</code>方法，你可以根据类型名称或<code>Type</code>对象创建对象实例。这对于实现插件系统或动态加载模块非常有用。</li>
<li>动态调用方法和访问属性：<code>Assembly</code>类允许你通过反射动态调用程序集中类型的方法和访问属性。你可以使用<code>Assembly.GetType</code>方法获取类型的<code>Type</code>对象，然后使用反射的方法来调用方法和访问属性。</li>
<li>扩展性和灵活性：<code>Assembly</code>类提供了一种扩展性和灵活性，使得在运行时动态加载和操作程序集成为可能。这对于实现插件系统、动态扩展功能或实现基于配置的行为非常有用。</li>
</ol>
<p>需要注意的是，<code>Assembly</code>类的使用需要谨慎考虑，并且在处理程序集时需要确保安全性和性能。反射和程序集操作可能具有一定的开销，因此在应用程序中要适度使用，并考虑使用更高效的技术来满足需求。</p>
<h2 id="LINQ"><a href="#LINQ" class="headerlink" title="LINQ"></a>LINQ</h2><p>在C#中，LINQ（Language Integrated Query）是一种强大的查询语言和查询操作符的集合，它被集成到语言和.NET框架中，用于对各种数据源进行统一的查询和操作。</p>
<p>LINQ提供了一种统一的语法和模型，用于查询和操作不同类型的数据，如集合、数组、数据库、XML等。使用LINQ，开发人员可以通过直观的查询表达式或方法调用的方式来执行各种数据查询和操作，而无需编写繁琐的迭代代码。</p>
<p>LINQ的核心思想是将查询看作是对数据源进行筛选、排序、分组和投影等操作的过程。它提供了一组标准的查询操作符，如Where、Select、OrderBy、GroupBy、Join等，以及强大的表达式树和延迟执行的机制。</p>
<p>以下是一个使用LINQ查询的简单示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> evenNumbers = <span class="keyword">from</span> num <span class="keyword">in</span> numbers</span><br><span class="line">                  <span class="keyword">where</span> num % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">                  <span class="keyword">select</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> evenNumbers)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们使用LINQ查询从一个整数数组中筛选出所有的偶数。使用<code>from</code>关键字指定查询的数据源（<code>numbers</code>数组），然后使用<code>where</code>关键字指定筛选条件，最后使用<code>select</code>关键字选择要返回的结果。</p>
<p>LINQ不仅可以用于集合的查询，还可以用于数据库查询（LINQ to SQL）、XML文档查询（LINQ to XML）、数据集查询（LINQ to DataSet）等。它提供了一种统一的编程模型，使得对不同类型数据源的查询具有一致的语法和风格。</p>
<p>通过LINQ，开发人员可以更加简洁、直观地编写查询代码，提高开发效率和代码可读性。同时，LINQ还具有编译时类型检查和优化查询的能力，使得查询更加安全和高效。</p>
<blockquote>
<p>LINQ 可以类比为在 C#（或其他支持 LINQ 的语言）中的 SQL 语句。LINQ 提供了一种类似于 SQL 的查询语法，使开发人员可以以一种直观和声明性的方式编写查询。</p>
<p>通过使用 LINQ 查询表达式，你可以使用类似于 SQL 的关键字和操作符（如<code>select</code>、<code>from</code>、<code>where</code>、<code>join</code>、<code>group by</code>、<code>order by</code>等）来编写查询逻辑。这样，你可以以一种熟悉且易于理解的方式来表示数据的筛选、排序、投影和聚合等操作。</p>
<p>这里是一个示例，展示了使用 LINQ 查询表达式来筛选和排序一个整数集合：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codeList&lt;<span class="built_in">int</span>&gt; numbers = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> query = <span class="keyword">from</span> number <span class="keyword">in</span> numbers</span><br><span class="line">            <span class="keyword">where</span> number &gt; <span class="number">5</span></span><br><span class="line">            <span class="keyword">orderby</span> number <span class="keyword">descending</span></span><br><span class="line">            <span class="keyword">select</span> number;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> result <span class="keyword">in</span> query)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们使用 LINQ 查询表达式从 <code>numbers</code> 列表中筛选出大于 5 的数，并按降序排序。然后，我们遍历查询结果并将每个结果打印到控制台。</p>
<p>虽然 LINQ 查询表达式的语法类似于 SQL，但它是在编译时进行类型检查的，因此可以提供更高的类型安全性和编译时错误检测。此外，LINQ 还提供了方法语法，可以通过使用 LINQ 扩展方法来编写查询，这种方式更接近于在代码中编写函数式操作。</p>
</blockquote>
<h4 id="LINQ集合联合查询"><a href="#LINQ集合联合查询" class="headerlink" title="LINQ集合联合查询"></a>LINQ集合联合查询</h4><p>在LINQ中，可以使用联合操作符进行集合的联合查询。联合查询允许你将多个集合合并为一个结果集，去除重复项并保持元素的顺序。</p>
<p>LINQ提供了两个常用的联合操作符：</p>
<ol>
<li><code>Union()</code>：将两个集合的元素合并为一个结果集，去除重复项。</li>
<li><code>Concat()</code>：将两个集合的元素按顺序合并为一个结果集，不去除重复项。</li>
</ol>
<p>下面是使用这两个联合操作符进行集合联合查询的示例：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">csharpCopy codevar numbers1 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> numbers2 = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Union() 进行联合查询</span></span><br><span class="line"><span class="keyword">var</span> unionQuery = numbers1.Union(numbers2);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Union Query:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> unionQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Concat() 进行联合查询</span></span><br><span class="line"><span class="keyword">var</span> concatQuery = numbers1.Concat(numbers2);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Concat Query:&quot;</span>);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> number <span class="keyword">in</span> concatQuery)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，我们定义了两个整数列表 <code>numbers1</code> 和 <code>numbers2</code>，然后使用 <code>Union()</code> 方法和 <code>Concat()</code> 方法进行联合查询。</p>
<p>在使用 <code>Union()</code> 方法时，结果集中的重复项会被去除，最终输出结果为：1, 2, 3, 4, 5, 6, 7, 8。</p>
<p>在使用 <code>Concat()</code> 方法时，结果集中保留了所有的元素，并按照它们在集合中的顺序进行合并，最终输出结果为：1, 2, 3, 4, 5, 4, 5, 6, 7, 8。</p>
<p>需要注意的是，联合查询的结果集是一个延迟执行的查询，只有在访问结果集时才会执行实际的查询操作。</p>
<p>除了 <code>Union()</code> 和 <code>Concat()</code>，LINQ还提供了其他的集合操作符，如交集查询（<code>Intersect()</code>）、差集查询（<code>Except()</code>）等，可以根据具体需求选择合适的操作符进行集合联合查询。</p>
<h4 id="join-on联合查询"><a href="#join-on联合查询" class="headerlink" title="join on联合查询"></a>join on联合查询</h4><p>在 C# 中，可以使用 LINQ（Language-Integrated Query）来执行联合查询和使用 <code>join on</code> 子句。LINQ 是一种强大的查询语言，可以与各种数据源（例如集合、数据库等）进行交互。</p>
<p>下面是一个示例，展示了如何在 C# 中使用 <code>join on</code> 来执行联合查询：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建示例数据源</span></span><br><span class="line">        List&lt;Order&gt; orders = <span class="keyword">new</span> List&lt;Order&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Order &#123; OrderId = <span class="number">1</span>, CustomerId = <span class="number">1</span>, OrderDate = <span class="keyword">new</span> DateTime(<span class="number">2023</span>, <span class="number">1</span>, <span class="number">1</span>) &#125;,</span><br><span class="line">            <span class="keyword">new</span> Order &#123; OrderId = <span class="number">2</span>, CustomerId = <span class="number">1</span>, OrderDate = <span class="keyword">new</span> DateTime(<span class="number">2023</span>, <span class="number">2</span>, <span class="number">1</span>) &#125;,</span><br><span class="line">            <span class="keyword">new</span> Order &#123; OrderId = <span class="number">3</span>, CustomerId = <span class="number">2</span>, OrderDate = <span class="keyword">new</span> DateTime(<span class="number">2023</span>, <span class="number">3</span>, <span class="number">1</span>) &#125;,</span><br><span class="line">            <span class="keyword">new</span> Order &#123; OrderId = <span class="number">4</span>, CustomerId = <span class="number">2</span>, OrderDate = <span class="keyword">new</span> DateTime(<span class="number">2023</span>, <span class="number">4</span>, <span class="number">1</span>) &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;Customer&gt; customers = <span class="keyword">new</span> List&lt;Customer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> Customer &#123; CustomerId = <span class="number">1</span>, Name = <span class="string">&quot;John&quot;</span> &#125;,</span><br><span class="line">            <span class="keyword">new</span> Customer &#123; CustomerId = <span class="number">2</span>, Name = <span class="string">&quot;Jane&quot;</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行联合查询</span></span><br><span class="line">        <span class="keyword">var</span> query = <span class="keyword">from</span> order <span class="keyword">in</span> orders</span><br><span class="line">                    <span class="keyword">join</span> customer <span class="keyword">in</span> customers <span class="keyword">on</span> order.CustomerId <span class="keyword">equals</span> customer.CustomerId</span><br><span class="line">                    <span class="keyword">where</span> customer.Name == <span class="string">&quot;John&quot;</span></span><br><span class="line">                    <span class="keyword">select</span> <span class="keyword">new</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        OrderId = order.OrderId,</span><br><span class="line">                        CustomerName = customer.Name,</span><br><span class="line">                        OrderDate = order.OrderDate</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出查询结果</span></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> result <span class="keyword">in</span> query)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">$&quot;OrderId: <span class="subst">&#123;result.OrderId&#125;</span>, CustomerName: <span class="subst">&#123;result.CustomerName&#125;</span>, OrderDate: <span class="subst">&#123;result.OrderDate&#125;</span>&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> OrderId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CustomerId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DateTime OrderDate &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> CustomerId &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了两个示例数据源：<code>orders</code>（订单）和 <code>customers</code>（客户）。然后，我们使用 LINQ 查询语法执行联合查询，使用 <code>join on</code> 将 <code>orders</code> 和 <code>customers</code> 根据 <code>CustomerId</code> 进行联接，并通过 <code>where</code> 子句筛选出 <code>Name</code> 为 “John” 的客户。最后，我们选择需要的字段，并将结果输出到控制台。</p>
<p>请注意，这只是一个简单的示例，你可以根据自己的实际需求进行调整和扩展。</p>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是一种被广泛接受和使用的解决特定软件设计问题的经验总结。它们提供了一套被认为是最佳实践的解决方案，可以帮助开发人员设计可维护、可扩展和可重用的代码。</p>
<p>以下是一些常见的设计模式：</p>
<ol>
<li>创建型模式（Creational Patterns）：<ul>
<li>工厂模式（Factory Pattern）</li>
<li>抽象工厂模式（Abstract Factory Pattern）</li>
<li>单例模式（Singleton Pattern）</li>
<li>建造者模式（Builder Pattern）</li>
<li>原型模式（Prototype Pattern）</li>
</ul>
</li>
<li>结构型模式（Structural Patterns）：<ul>
<li>适配器模式（Adapter Pattern）</li>
<li>桥接模式（Bridge Pattern）</li>
<li>组合模式（Composite Pattern）</li>
<li>装饰者模式（Decorator Pattern）</li>
<li>外观模式（Facade Pattern）</li>
<li>享元模式（Flyweight Pattern）</li>
<li>代理模式（Proxy Pattern）</li>
</ul>
</li>
<li>行为型模式（Behavioral Patterns）：<ul>
<li>责任链模式（Chain of Responsibility Pattern）</li>
<li>命令模式（Command Pattern）</li>
<li>解释器模式（Interpreter Pattern）</li>
<li>迭代器模式（Iterator Pattern）</li>
<li>中介者模式（Mediator Pattern）</li>
<li>备忘录模式（Memento Pattern）</li>
<li>观察者模式（Observer Pattern）</li>
<li>状态模式（State Pattern）</li>
<li>策略模式（Strategy Pattern）</li>
<li>模板方法模式（Template Method Pattern）</li>
<li>访问者模式（Visitor Pattern）</li>
</ul>
</li>
<li>并发模式（Concurrency Patterns）：<ul>
<li>生产者-消费者模式（Producer-Consumer Pattern）</li>
<li>读者-写者模式（Reader-Writer Pattern）</li>
<li>同步模式（Synchronization Pattern）</li>
</ul>
</li>
</ol>
<p>每种设计模式都有其特定的应用场景和解决问题的方式。选择适当的设计模式可以提高代码的可读性、可维护性和可扩展性，同时也有助于促进团队合作和共享设计经验。然而，设计模式并非万能的，使用时需要根据具体情况进行权衡和选择。</p>
<h3 id="观察者设计模式"><a href="#观察者设计模式" class="headerlink" title="观察者设计模式"></a>观察者设计模式</h3><p>观察者设计模式（Observer Design Pattern）是一种行为设计模式，它定义了对象之间的一对多依赖关系，使得当一个对象的状态发生变化时，其相关依赖对象都能够自动得到通知并更新。这种模式也被称为发布-订阅（Publish-Subscribe）模式。</p>
<p>在观察者设计模式中，有两个主要的角色：</p>
<ol>
<li>Subject（主题）：也称为被观察者或发布者，它维护一组观察者对象，并且提供了添加、删除和通知观察者的方法。当主题的状态发生变化时，它会通知所有注册的观察者。</li>
<li>Observer（观察者）：也称为订阅者，它定义了一个接口，用于接收主题的通知。当观察者接收到通知时，它可以执行相应的操作以更新自己的状态。</li>
</ol>
<p>观察者设计模式的工作原理如下：</p>
<ol>
<li>观察者通过订阅主题来注册自己，以便接收主题的通知。</li>
<li>主题维护一个观察者列表，用于记录所有注册的观察者。</li>
<li>当主题的状态发生变化时，它会遍历观察者列表，并调用每个观察者的通知方法。</li>
<li>观察者接收到通知后，可以根据需要进行相应的处理。</li>
</ol>
<p>观察者设计模式的优点包括：</p>
<ol>
<li>松耦合：主题和观察者之间是松耦合的关系，它们之间通过接口进行通信，主题不需要知道观察者的具体实现。</li>
<li>可扩展性：可以方便地添加新的观察者，主题和观察者之间的关系可以动态地建立和解除。</li>
<li>一致性：主题和观察者之间的一致性得到了保证，无论有多少观察者，它们都能够接收到相同的通知。</li>
</ol>
<p>然而，观察者设计模式也有一些潜在的缺点，包括：</p>
<ol>
<li>如果观察者过多或处理逻辑过于复杂，可能会导致性能问题。</li>
<li>观察者可能会收到不必要的通知，需要谨慎设计以避免这种情况。</li>
</ol>
<p>总之，观察者设计模式是一种常用的设计模式，它在许多应用场景中都有广泛的应用，例如事件处理、GUI 编程、消息队列等。通过使用观察者模式，可以实现对象之间的解耦和增加系统的灵活性。</p>
]]></content>
      <categories>
        <category>工程</category>
      </categories>
      <tags>
        <tag>工程</tag>
      </tags>
  </entry>
  <entry>
    <title>干爆算法竞赛</title>
    <url>/2023/08/29/%E5%B9%B2%E7%88%86%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h2><h3 id="简单模拟"><a href="#简单模拟" class="headerlink" title="简单模拟"></a>简单模拟</h3><h4 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h4><p>给你n根棍子，要求让你组合成一个周长最大的三角形</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_A = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,a[max_A];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//答案 </span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> k = j+<span class="number">1</span>;k&lt;n;k++)&#123;</span><br><span class="line">				<span class="comment">//周长 </span></span><br><span class="line">				<span class="type">int</span> len = a[i]+a[j]+a[k];</span><br><span class="line">				<span class="comment">//最长的边 </span></span><br><span class="line">				<span class="type">int</span> ma = <span class="built_in">max</span>(a[i],<span class="built_in">max</span>(a[j],a[k]));</span><br><span class="line">				<span class="comment">//可以组成三角形的规则 </span></span><br><span class="line">				<span class="type">int</span> rest = len-ma;				</span><br><span class="line">				<span class="comment">//所有子三角形的周长 </span></span><br><span class="line">				<span class="keyword">if</span>(ma&lt;rest)&#123;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans,len);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;		</span><br><span class="line">	&#125;		</span><br><span class="line">	<span class="comment">//输出结果 </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);		</span><br><span class="line">	</span><br><span class="line"> &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理就是：枚举三条边所能构造的三角形，然后比较找到周长最大的那个即可。</p>
</blockquote>
<h4 id="Ants"><a href="#Ants" class="headerlink" title="Ants"></a>Ants</h4><p><img src="/%E5%B9%B2%E7%88%86%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/4cbbb4f78a1f0901e29c33f7df81d5d.jpg" alt="4cbbb4f78a1f0901e29c33f7df81d5d"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l,n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_A = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> x[MAX_A]; </span><br><span class="line"></span><br><span class="line"><span class="comment">//每个蚂蚁都可以看做是同一个体</span></span><br><span class="line"><span class="comment">//两个碰完头 - 相当于穿过即可 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> minT = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="comment">//移动到端点的最短距离 </span></span><br><span class="line">		minT = <span class="built_in">max</span>(minT,<span class="built_in">min</span>(x[i],l-x[i]));		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//最长时间</span></span><br><span class="line">	<span class="type">int</span> maxT = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		maxT = <span class="built_in">max</span>(maxT,<span class="built_in">max</span>(x[i],l-x[i]));</span><br><span class="line">	&#125; </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,minT,maxT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	</span><br><span class="line">	cin&gt;&gt;l&gt;&gt;n;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;i++) cin&gt;&gt;x[i];</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">solve</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<h2 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h2><h2 id="困难题"><a href="#困难题" class="headerlink" title="困难题"></a>困难题</h2>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
  </entry>
  <entry>
    <title>md标注方法</title>
    <url>/2023/04/21/%E6%A0%BC%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="md的书写样式练习"><a href="#md的书写样式练习" class="headerlink" title="md的书写样式练习"></a><strong>md的书写样式练习</strong></h2><h3 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式"></a><strong>书写格式</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">代码框书写格式</span><br><span class="line">     <span class="string">&quot;``` bash(这里是代码的样式 - 看你输入的是什么语言)&quot;</span> </span><br><span class="line">        中间这里输入你的代码</span><br><span class="line">     <span class="string">&quot;```&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Front-matter修改"><a href="#Front-matter修改" class="headerlink" title="Front-matter修改"></a><strong>Front-matter修改</strong></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Page Front-matter 用于页面配置</span><br><span class="line">Post Front-matter 用于文章页配置</span><br><span class="line">    这两个就是你md文档的最顶部的两个 --- ---之间,用来配置hexo的网页功能</span><br><span class="line"></span><br><span class="line"><span class="comment"># 功能样式</span></span><br><span class="line"><span class="comment"># 当前文章题目</span></span><br><span class="line">title:  </span><br><span class="line"><span class="comment"># 当前文章创建日期</span></span><br><span class="line"><span class="built_in">date</span>:</span><br><span class="line"><span class="comment"># 当前文章更新日期</span></span><br><span class="line">updated:</span><br><span class="line"><span class="comment"># 标签、分类和友情链接三个页面需要配置 - 这个是啥暂时不知道</span></span><br><span class="line"><span class="built_in">type</span>:</span><br><span class="line"><span class="comment"># 显示评论模块(默认 true)</span></span><br><span class="line">comments:</span><br><span class="line"><span class="comment"># 页面描述</span></span><br><span class="line">description:</span><br><span class="line"><span class="comment"># 页面关键字</span></span><br><span class="line">keywords:</span><br><span class="line"><span class="comment"># 顶部图片 - 这里修改优先级最高</span></span><br><span class="line">top_img:</span><br><span class="line"><span class="comment"># 显示mathjax (当设置mathjax的per_page: false时，才需要配置，默认 false) - 不清楚</span></span><br><span class="line">mathjax:</span><br><span class="line"><span class="comment"># 【可选】显示katex (当设置katex的per_page: false时，才需要配置，默认 false) - 不清楚</span></span><br><span class="line">katex:</span><br><span class="line"><span class="comment"># 显示侧边栏 (默认 true)</span></span><br><span class="line">aside:</span><br><span class="line"><span class="comment"># 在需要的页面加载aplayer的js和css,请参考文章下面的音乐 配置</span></span><br><span class="line">aplayer:</span><br><span class="line"><span class="comment"># 配置代码框是否展开 (true/false) (默认为设置中highlight_shrink的配置)</span></span><br><span class="line">highlight_shrink:</span><br></pre></td></tr></table></figure>

<h3 id="md-表格创建"><a href="#md-表格创建" class="headerlink" title="md_表格创建"></a><strong>md_表格创建</strong></h3><p>要添加表，请使用三个或多个连字符（—）创建每列的标题，并使用管道（|）分隔每列.您可以选择在表的任一端添加管道</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">| Syntax    | Description |</span><br><span class="line">| --------- | ----------- |</span><br><span class="line">| Header    | Title       |</span><br><span class="line">| Paragraph | Text        |</span><br></pre></td></tr></table></figure>

<p>实现效果</p>
<table>
<thead>
<tr>
<th>Syntax</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Header</td>
<td>Title</td>
</tr>
<tr>
<td>Paragraph</td>
<td>Text</td>
</tr>
</tbody></table>
<p>创建表格可以使用：<a href="https://www.tablesgenerator.com/markdown_tables"><strong>label</strong></a>是一个创建md格式表格的好工具</p>
<h3 id="md基础语法"><a href="#md基础语法" class="headerlink" title="md基础语法"></a><strong>md基础语法</strong></h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>标题：</span><br><span class="line">    在头部用<span class="string">&quot;#&quot;</span>修饰即可，<span class="string">&quot;#&quot;</span>数量代表着标题的序数。还可以在文本下方添加任意数量的 == 号来标识一级标题，或者 -- 号来标识二级标题。</span><br><span class="line"><span class="number">2.</span>段落：</span><br><span class="line">    在需要分段的文字尾部，两个空格以上就是独立的段落了。（有个问题就是，上下空格数是否要相同）。注意的是，md语法中没有缩进段落的选项，所以说不能用缩进来操作段落。</span><br><span class="line"><span class="number">3.</span>换行：</span><br><span class="line">    建议用&lt;br&gt; - html中的语法。</span><br><span class="line"><span class="number">4.</span>强调</span><br><span class="line">    在两边加入两个*,就可以加粗我们选中的字体了。</span><br><span class="line"><span class="number">5.</span>斜体</span><br><span class="line">    添加一个*就可以实现斜体。</span><br><span class="line"><span class="number">6.</span>强调斜体</span><br><span class="line">    加三个***就可以了</span><br><span class="line"><span class="number">7.</span>引用</span><br><span class="line">    &gt;添加一个这个符号就可以实现引用框框了，如果多加一个&gt;就是嵌套环境,</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="comment">//上面就是初级引用</span></span><br><span class="line">&gt;&gt; <span class="comment">//这样子就算是嵌套了</span></span><br><span class="line"><span class="number">8.</span>无序列表</span><br><span class="line">    - 空格 加入输入的文字，这就算是一个无序列表了</span><br><span class="line"><span class="number">9.</span>列表</span><br><span class="line">    可以用html中的创建列表的语法，&lt;ol&gt; &gt; &lt;li&gt; *。或者直接在前面加上标题就可以</span><br></pre></td></tr></table></figure>

<h3 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a><strong>嵌套规则</strong></h3><h4 id="在列表中嵌套其他元素"><a href="#在列表中嵌套其他元素" class="headerlink" title="在列表中嵌套其他元素"></a><strong>在列表中嵌套其他元素</strong></h4><p>我们简单创建一个无序列表：</p>
<ul>
<li>三天打鱼两天晒网</li>
<li>六天打鱼四天晒网</li>
</ul>
<p>我们在其中插入一个引用数据，只需要用到&gt;即可</p>
<ul>
<li>三天打鱼两天晒网<blockquote>
<p>不能打鱼，我们要摆烂 ૮꒰ ˶• ༝ •˶꒱ა</p>
</blockquote>
</li>
<li>六天打鱼四天晒网<blockquote>
<p>不能打鱼，我们要摆烂 ૮꒰ ˶• ༝ •˶꒱ა</p>
</blockquote>
</li>
</ul>
<p>要是想要在列表中输入代码框,就直接用代码行格式就行（没必要用几个制表符或者空格来说明）。</p>
<ul>
<li>写一个简单代码</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>写两个简单代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>要创建分隔线，请在单独一行上使用三个或多个星号 (***)、破折号 (—) 或下划线 (___) ，并且不能包含其他内容。</p>
<hr>
<p>如果出现了其他内容，就会变成这样</p>
<p>——-你好,所以说不要在分割线上加东西</p>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[]() - 中括号中写入的是你要实现的超链接的名称</span><br><span class="line">     - 小括号中写入的是你要跳转的链接</span><br></pre></td></tr></table></figure>

<p>超链接格式和我们的图片格式是相似的 <a href="https://markdown.com.cn/basic-syntax/links.html"><strong>md语法</strong></a></p>
<hr>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">图片格式限定，![]()，[] - 是照片的名字，()是照片的文件地址</span><br><span class="line">和超链接比较就多了一个！</span><br><span class="line">存储文件的时候记得，新开一个文件夹，以防图片数据互相影响</span><br></pre></td></tr></table></figure>

<p>图片演示</p>
<p><img src="/../picture/format/Different%20from%20the%20usual%20of%20you.jpg" alt="与平常的你不同"></p>
<h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><p>使用尖括号可以很方便地把URL或者email地址变成可点击的链接。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&gt; - (这里面放的是网址信息，出现的链接这样就可以点击了)</span><br></pre></td></tr></table></figure>

<p><a href="https://markdown.com.cn/">https://markdown.com.cn</a></p>
<h4 id="带格式化的链接"><a href="#带格式化的链接" class="headerlink" title="带格式化的链接"></a>带格式化的链接</h4><p>强调链接, 在链接语法前后增加星号。 要将链接表示为代码，请在方括号中添加反引号。  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">就是在链接处加入我们的强调修饰符号：**[]()**</span><br></pre></td></tr></table></figure>

<p>渲染效果如下（还有其他链接方式暂时不学）：</p>
<!-- 这里是强调链接 链接不一定存在 -->
<p>I love supporting the <strong><a href="https://eff.org/">EFF</a></strong>.<br>This is the <em><a href="https://www.markdownguide.org/">Markdown Guide</a></em></p>
<hr>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><h4 id="可做转义的字符"><a href="#可做转义的字符" class="headerlink" title="可做转义的字符"></a>可做转义的字符</h4><p><img src="/../picture/format/turn.png" alt="转义字符"></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构 - 对数据的基本操作</title>
    <url>/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="对数据的常见操作"><a href="#对数据的常见操作" class="headerlink" title="对数据的常见操作"></a>对数据的常见操作</h2><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和</a></h3><p>前缀和，是一个序列的前n项和，可以理解为高中的数列的前n项和。</p>
<p><img src="/.png" alt="png"></p>
<p>如果给你一个数组，要求你求出这个数组中某段区间的和，我们可以用遍历区间的方式来求和，下面是求得区间和的朴素算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> a[N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">//记录和</span></span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输入两个区间</span></span><br><span class="line">    <span class="type">int</span> l,r;</span><br><span class="line">    cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="comment">//累加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l;i&lt;=r;i++) ans+=a[i];</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这样做，如果求多个区间和就要多次遍历，这样时间复杂度会很高，索性我们在输入数据的同时，构造前缀和数组<code>S[]</code>使得每一个<code>S[]</code>数组的下标表示一段从1开始(也可以从数组下标0开始)的连续的区间和，下面是代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[N],S[N];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造前缀和数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i] += s[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们需要求得一个区间的和的时候，可以利用前缀和的思想，例如给一个数组<code>a[5] = &#123;1,2,3,4,5&#125;</code>，要求区间<code>2-3</code>的和。由<code>S[]</code>数组的性质我们可以得到，<code>S[3]-S[1] = a[2]+a[3](展开就知道了)</code>，所以说对于任意的区间<code>[l,r]</code>,有<code>区间和 = S[r] - S[l-1]</code>,下面是根据推断得到的代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"> <span class="comment">//构造前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) s[i] = s[i - <span class="number">1</span>] + a[i]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]); <span class="comment">// 区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了前缀和算法。</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>一维前缀和是在一维数组构造的，二维前缀和是在二维数组构造的。一维前缀和求的是区间和，二位前缀和求的是矩阵和，在构造二维前缀和之前，我们先构造y一个简单的矩阵和来看看，下面是朴素算法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[N][N];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            cin&gt;&gt;a[i][j];</span><br><span class="line">    <span class="comment">//输入区间坐标</span></span><br><span class="line">    <span class="type">int</span> x1,y1;</span><br><span class="line">    <span class="type">int</span> x2,y2;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = x1;i&lt;=x2;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = x2;j&lt;=x2;j++)</span><br><span class="line">            ans+=a[i][j];</span><br><span class="line">    cout&lt;&lt;ans;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png" alt="二维前缀和"></p>
<p>我们只用图形来理解，如果我们需要求得红色区间的值应该怎么做。直接用最大的蓝色矩阵减去绿色和紫色小条就行。减去完发现多减了一个<code>a[i][j]</code>,加上即可，如下图所示。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C%E5%88%86%E8%A7%A3.png" alt="二维前缀和分解"></p>
<p>从上图的结论中我们很容易看出，整个外围蓝色矩形面积<code>s[i][j]</code> &#x3D; 绿色面积<code>s[i - 1][j]</code> + 紫色面积<code>s[i][j - 1]</code> - 重复加的红色的面积<code>s[i - 1][j - 1]</code> + 小方块的面积<code>a[i][j]</code>;</p>
<p><strong>因此得出二维前缀和预处理公式</strong>（求得从<code>11</code>开始的子矩阵的所有和）</p>
<p><code>s[i][j] = s[i - 1][j] + s[i][j - 1 ] + a[i] [j] - s[i - 1][j - 1]</code></p>
<p><strong>接下来回归问题</strong>(求子矩阵的和)去求以<code>(x1,y1)</code>为左上角和以<code>(x2,y2)</code>为右下角的矩阵的元素的和。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E6%B1%82%E8%B5%B7%E7%82%B9%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="求起点不同的子矩阵"></p>
<p><strong>紫色面积</strong>是指 <code>(1, 1)</code>左上角到<code>(x1 - 1, y2)</code>右下角的矩形面积 ，<strong>黄色面积</strong>是指<code>(1, 1)</code>左上角到<code>(x2, y1 - 1)</code>右下角的矩形面积；</p>
<p><strong>不难推出：</strong></p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%88%86%E8%A7%A3%E5%AD%90%E7%9F%A9%E9%98%B5.png" alt="分解子矩阵"></p>
<p>绿色矩形的面积 &#x3D; <code>整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]</code></p>
<p>因此二维前缀和的结论为：</p>
<p><strong><code>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为： s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]</code></strong></p>
<p>下面是例题代码</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/image-20230827153429879.png" alt="image-20230827153429879"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> n, m, q;</span><br><span class="line"><span class="type">int</span> s[N][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ )</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++ )</span><br><span class="line">            s[i][j] += s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (q -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">一维差分</a></p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%B7%AE%E5%88%86.png" alt="差分"></p>
<p>类似于数学中的求导和积分，差分可以看成前缀和的逆运算。</p>
<p>差分数组：</p>
<p>首先给定一个原数组<code>a：a[1], a[2], a[3],,,,,, a[n];</code></p>
<p>然后我们构造一个数组<code>b ： b[1], b[2], b[3],,,,,, b[i];</code></p>
<p>使得 <code>a[i] = b[1] + b[2] + b[3] + ,,,,,, + b[i]</code></p>
<p>也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个**<code>a[i]都是b数组中从头开始的一段区间和</code>**。</p>
<p>考虑如何构造差分b数组？</p>
<p>最为直接的方法</p>
<p>如下：</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%B7%AE%E5%88%861.png" alt="差分1"></p>
<p>我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到 a 数组 。</p>
<p>知道了差分数组有什么用呢？ 别着急，慢慢往下看。</p>
<p>话说有这么一个问题：</p>
<p>给定区间<code>[l, r ]，让我们把a数组中的[l, r] 区间中的每一个数都加上c,即 a[l] + c , a[l + 1] + c , a[l + 2] + c ,,,,,, a[r] + c;</code></p>
<p>暴力做法是<code>for循环l到r区间</code>，时间复杂度<code>O(n)</code>，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成<code>O(n * m)</code>。有没有更高效的做法吗? 考虑差分做法，(差分数组派上用场了)。</p>
<p>始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。</p>
<p>首先让差分b数组中的 <code>b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l + 1] + c,,,,,, a[n] + c</code>;</p>
<p>然后我们打个补丁，<code>b[r + 1] - c, 通过前缀和运算，a数组变成 a[r + 1] - c,a[r + 2] - c,,,,,,,a[n] - c</code>;</p>
<p>为啥还要打个补丁？</p>
<p>我们画个图理解一下这个公式的由来:</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%B7%AE%E5%88%86%E6%9E%84%E6%88%90.png" alt="差分构成"></p>
<p><code>b[l] + c</code>，效果使得a数组中<code>a[l]</code>及以后的数都加上了c(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 <code>b[r + 1] - c</code>,让a数组中<code>a[r + 1]</code>及往后的区间再减去c(绿色部分)，这样对于<code>a[r]</code> 以后区间的数相当于没有发生改变。</p>
<p>因此我们得出一维差分结论：给a数组中的<code>[ l, r]</code> 区间中的每一个数都加上c,只需对差分数组b做 <code>b[l] + = c, b[r+1] - = c</code>。时间复杂度为O(1), 大大提高了效率。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/20201217172005485.png" alt="在这里插入图片描述"></p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/image-20230827155704438.png" alt="image-20230827155704438"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模版代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N],b[N],c[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//构造差分数组的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l]+=c;</span><br><span class="line">    b[r+<span class="number">1</span>]-=c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="comment">//输入构造差分数组的原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">    <span class="comment">//构造差分序列 - b就是差分数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,i,a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r,c;</span><br><span class="line">        cin&gt;&gt;l&gt;&gt;r&gt;&gt;c;</span><br><span class="line">        <span class="comment">//插入更改的值</span></span><br><span class="line">        <span class="built_in">insert</span>(l,r,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是析出原数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) c[i] = c[i<span class="number">-1</span>]+b[i];</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;c[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。</p>
<p>a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组</p>
<p>原数组：<code>a[i][j]</code></p>
<p>我们去构造差分数组： <code>b[i][j]</code></p>
<p>使得a数组中<code>a[i][j]</code>是b数组左上角<code>(1,1)</code>到右下角<code>(i,j)</code>所包围矩形元素的和。</p>
<p>如何构造b数组呢？</p>
<p>其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。</p>
<p>同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由<code>O(n*n)</code>的时间复杂度优化成<code>O(1)</code></p>
<p>已知原数组a中被选中的子矩阵为 以<code>(x1,y1)</code>为左上角，以<code>(x2,y2)</code>为右下角所围成的矩形区域;</p>
<p>始终要记得，<strong>a数组是b数组的前缀和数组，比如对<code>b</code>数组的<code>b[i][j]</code>的修改，会影响到<code>a</code>数组中从<code>a[i][j]</code>及往后的每一个数。</strong></p>
<p>假定我们已经构造好了<code>b</code>数组，类比一维差分，我们执行以下操作<br>来使被选中的子矩阵中的每个元素的值加上<code>c</code></p>
<p><code>b[x1][y1] + = c ;</code></p>
<p><code>b[x1][y2+1] - = c;</code></p>
<p><code>b[x2+1][y1] - = c;</code></p>
<p><code>b[x2+1][y2+1] + = c;</code></p>
<p>每次对<code>b</code>数组执行以上操作，等价于：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x1;i &lt;= x2;i++)</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = y1;j &lt;= y2;j++)</span><br><span class="line">    a[i][j] += c;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86.png" alt="二维差分"></p>
<p><code>b[x1][y1] += c;</code> 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。<br><code>b[x1,][y2 + 1] -= c;</code> 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。<br><code>b[x2 + 1][y1] -= c;</code> 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。<br><code>b[x2 + 1][y2 + 1] += c;</code> 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E4%BA%8C%E7%BB%B4%E5%B7%AE%E5%88%86%E5%88%86%E8%A7%A3.png" alt="二维差分分解"></p>
<p><strong>我们将上述操作封装成一个插入函数:</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> y1,<span class="type">int</span> x2,<span class="type">int</span> y2,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;     <span class="comment">//对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c</span></span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以先假想<code>a</code>数组为空，那么<code>b</code>数组一开始也为空，但是实际上<code>a</code>数组并不为空，因此我们每次让以<code>(i,j)</code>为左上角到以<code>(i,j)</code>为右下角面积内元素(其实就是一个小方格的面积)去插入 <code>c = a[i][j]</code>，等价于原数组<code>a中(i,j) 到(i,j)</code>范围内 加上了 <code>a[i][j]</code>,因此执行<code>n*m</code>次插入操作，就成功构建了差分b数组.</p>
<p><strong>这叫做曲线救国。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= m;j++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">insert</span>(i, j, i, j, a[i][j]);    <span class="comment">//构建差分数组</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>当然关于二维差分操作也有直接的构造方法，<strong>公式如下：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b[i][j] = a[i][j] − a[i − <span class="number">1</span>][j] − a[i][j − <span class="number">1</span>] + a[i −<span class="number">1</span> ][j − <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>二维差分数组的构造同一维差分思维相同，因次在这里就不再展开叙述了。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/20201217172035975.png" alt="1"></p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/image-20230827161505699.png" alt="image-20230827161505699"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N][N], b[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);      <span class="comment">//构建差分数组</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">//二维前缀和</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><a href="https://www.cnblogs.com/huansky/p/13508533.html">双指针</a></h3><p>双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描，从而达到相应的目的。</p>
<p>换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。</p>
<h4 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h4><p>对撞指针是指在数组中，将指向最左侧的索引定义为<code>左指针(left)</code>，最右侧的定义为<code>右指针(right)</code>，然后从两头向中间进行数组遍历。</p>
<blockquote>
<p>对撞数组适用于连续数组和字符串，也就是说当你遇到题目给定连续数组和字符床时，应该第一时间想到用对撞指针解题。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line"><span class="function">function <span class="title">fn</span> <span class="params">(list)</span> </span>&#123;</span><br><span class="line">  var left = <span class="number">0</span>;</span><br><span class="line">  var right = list.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//遍历数组</span></span><br><span class="line">  <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">    left++;</span><br><span class="line">    <span class="comment">// 一些条件判断 和处理</span></span><br><span class="line">    ... ...</span><br><span class="line">    right--;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对撞指针能够解决：：1.二分查找 2.两数之和 II - 输入有序数组 3.反转字符串 4.反转字符串中的元音字母 5.回文字符串</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/image-20230828114701956.png" alt="image-20230828114701956"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reS</span><span class="params">(<span class="type">char</span> s[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">strlen</span>(s); <span class="comment">// 计算数组长度</span></span><br><span class="line">    <span class="keyword">if</span>(length == <span class="number">0</span> || length == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="comment">// 交换数据</span></span><br><span class="line">        <span class="type">char</span> temp = s[left];</span><br><span class="line">        s[left] = s[right];</span><br><span class="line">        s[right] = temp; </span><br><span class="line">        left++; </span><br><span class="line">        right--; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为<code>快指针（fast）</code>和<code>慢指针（slow）</code>，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。</p>
<blockquote>
<p>一般快慢指针用于维护区间</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">slow = head;</span><br><span class="line">fast = head;</span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    slow = slow-&gt;next;</span><br><span class="line">    fast = fast-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (slow == fast) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快慢指针能够解决：链表中倒数第k个节点  1.链表的中间节点 2.链表是否有环 3.链表环的长度 4.链表环的起点</span></span><br><span class="line"><span class="comment">//判断链表是否有环</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *slow = head; <span class="comment">// 慢指针</span></span><br><span class="line">    ListNode *fast = head-&gt;next; <span class="comment">// 快指针</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123; <span class="comment">// 当快慢指针不相遇时</span></span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 如果快指针到达链表尾部，说明链表没有环</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next; <span class="comment">// 慢指针走一步</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next; <span class="comment">// 快指针走两步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 如果快慢指针相遇，说明链表有环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快慢指针案例：**<a href="https://www.cnblogs.com/huansky/p/13488234.html">滑动窗口</a>**</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="哈希表的实现方法"><a href="#哈希表的实现方法" class="headerlink" title="哈希表的实现方法"></a><a href="https://zhuanlan.zhihu.com/p/496515259">哈希表的实现方法</a></h3><p><a href="https://www.cnblogs.com/lisen10/p/10876344.html">散列表</a>（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。</p>
<p>我们知道，数组的最大特点就是：寻址容易，插入和删除困难；而链表正好相反，寻址困难，而插入和删除操作容易。那么如果能够结合两者的优点，做出一种寻址、插入和删除操作同样快速容易的数据结构，那该有多好。这就是哈希表创建的基本思想，而实际上哈希表也实现了这样的一个“夙愿”，哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。</p>
<p>哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。</p>
<blockquote>
<p>map&lt;a,b&gt;: a经过哈希函数变为b，产生映射关系</p>
<p>hash表本质是数组，讲一个散列的数据集中到一个数组上，用最少资源按照一定的逻辑存储我们的数据</p>
<p>说人话就是大范围关键字存储改为小范围关键字存储</p>
</blockquote>
<p>哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。</p>
<blockquote>
<p>哈希函数相当于排列规则，我们可以依靠这个排列规则排列键的顺序，同时也可以用这个排列规则寻找我们的值.</p>
<p>如果用日常生活来举例的话，哈希表就像是我们的字典目录一样。</p>
</blockquote>
<p>哈希表和哈希函数的标准定义：若关键字为k，则其值存放在h(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为哈希函数，按这个思想建立的表为哈希表。</p>
<p>设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。<br>但是，一般散列函数都面临着冲突的问题。两个不同的关键字，由于散列函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该散列函数的同义词(Synonym)。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/v2-34a5a0d0cbff54649d0175f5126214cc_720w.webp" alt="散列表原理"></p>
<p>哈希表的实现就是映射函数构造，看某个元素具体属于哪一个类别。如何构造我们要考虑两个问题：</p>
<ul>
<li>n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小。</li>
<li>无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突。</li>
</ul>
<h4 id="直接定位法"><a href="#直接定位法" class="headerlink" title="直接定位法"></a><strong><a href="https://www.xiuxingstudio.com/computer/%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95/4195.html">直接定位法</a></strong></h4><p><code>Hash(key) = a·key + b (a、b为常数)</code></p>
<p><strong>优点</strong>：以关键码key的某个线性函数值为哈希地址，不会产生冲突.</p>
<p><strong>缺点</strong>：要占用连续地址空间，空间效率低。</p>
<p><strong>例：</strong>关键码集合为<code>&#123;100，300，500，700，800，900&#125;</code>， 选取哈希函数为<code>Hash(key)=key/100</code>， 则存储结构（哈希表）如下：</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1622171-20190525161418247-402666349.png" alt="img"></p>
<p>这种方法计算最简单，且<strong>不会产生冲突</strong>。<strong>适合于关键字分布基本连续的情况</strong>，<strong>如果关键字分布不连续，空位较多，则会造成存储空间的浪费</strong>。</p>
<p>举一个例子，假设有一个记录了从 1 岁到 100 岁的人口数字统计表。其中年龄为关键字，哈希函数取关键字自身，如下表所示。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/webp.png" alt="哈希函数（一）-直接定址法、除留余数法、平方取中法"></p>
<p>比如想要查询 25 岁的人有多少，则只要查询表中第 25 项即可。</p>
<blockquote>
<p>这种方法一般不使用，除非是我们查询的表比较简单的情况之下。</p>
</blockquote>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a><strong>除留余数法</strong></h4><p><code>Hash(key) = key mod p (p是一个整数)</code></p>
<p><strong>特点</strong>：以关键码除以p的余数作为哈希地址。</p>
<p><strong>关键</strong>：如何选取合适的p？</p>
<p><strong>技巧</strong>：若设计的哈希表长为m，则一般取p≤m且为质数 （也可以是不包含小于20质因子的合数）。</p>
<blockquote>
<p>取p≤m且为质数是为了少开区间，mod质数是为了输出不同区间的值，让数据更加散乱。</p>
<p>这种方法是最常见构造散列表的方法</p>
</blockquote>
<h4 id="乘余取整法"><a href="#乘余取整法" class="headerlink" title="乘余取整法"></a>乘余取整法</h4><p><code>Hash(key) = [B*( A*key mod 1 ) ]</code>下取整 <code>(A、B均为常数，且0&lt;A&lt;1，B为整数)</code></p>
<p><strong>特点：</strong>以关键码key乘以A，取其小数部分，然后再放大B倍并取整，作为哈希地址。</p>
<p><strong>例：</strong>欲以学号最后两位作为地址，则哈希函数应为： <code>H(k)=100*(0.01*k % 1 )</code>其实也可以用法2实现：<code>H(k)=k % 100</code></p>
<p>这也是一种简单且常用的哈希函数方法。其关键点在于<code>p</code> 的选择。<strong>根据经验而言，一般 <code>p</code> 取素数或者 <code>m</code>，这样可以尽可能的减少冲突。</strong></p>
<p>比如我们需要将 7 个数 [432, 5, 128, 193, 92, 111, 88] 存储在 11 个区块中（长度为 11 的数组），通过除留余数法将这 7 个数应分别位于如下地址：</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/webp-1693208563347-31.png" alt="哈希函数（一）-直接定址法、除留余数法、平方取中法"></p>
<p>比如432，对11取余数，余数为3，放在03位置</p>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a><strong>数字分析法</strong></h4><p><strong>特点：</strong>某关键字的某几位组合成哈希地址。所选的位应当是：各种符号在该位上出现的频率大致相同。</p>
<p>例：有一组（例如80个）关键码，其样式如下：</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1622171-20190525162109183-1593077689.png" alt="img"></p>
<h4 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a><strong>平方取中法</strong></h4><p><strong>特点：</strong>对关键码平方后，按哈希表大小，取中间的若干位作为哈希地址。</p>
<p><strong>理由</strong>：因为中间几位与数据的每一位都相关。</p>
<p><strong>例</strong>：2589的平方值为6702921，可以取中间的029为地址。</p>
<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a><strong>折叠法</strong></h4><p><strong>特点：</strong>将关键码自左到右分成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。</p>
<p><strong>适用于</strong>：每一位上各符号出现概率大致相同的情况。</p>
<p>法1：移位法 ── 将各部分的最后一位对齐相加。</p>
<p>法2：间界叠加法──从一端向另一端沿分割界来回折叠后，最后一位对齐相加。</p>
<p><strong>例：</strong>元素<code>42751896, 用法1： 427＋518＋96=1041   用法2： 427 518 96—&gt; 724+518+69 =1311</code></p>
<h3 id="哈希表优化冲突"><a href="#哈希表优化冲突" class="headerlink" title="哈希表优化冲突"></a>哈希表优化冲突</h3><p>Hash表解决冲突的方法主要有以下几种：</p>
<blockquote>
<p>开放定址法（开地址法）、 链地址法（拉链法）、 再哈希法（双哈希函数法）、 建立一个公共溢出区，而最常用的就是<strong>开发定址法</strong>和<strong>链地址法</strong>。</p>
</blockquote>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a><strong><a href="https://www.cnblogs.com/east7/p/12594894.html">开放寻址法</a></strong></h4><p> <strong>开放寻址法</strong>：又称开放定址法，当哈希碰撞发生时，从发生碰撞的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。这个空闲单元又称为开放单元或者空白单元。</p>
<blockquote>
<p>就是映射的位置有数了，就在这个位置的下一个位置存储，如果还有继续查找下一个位置以此类推。</p>
</blockquote>
<p> 查找时，如果探查到空白单元，即表中无待查的关键字，则查找失败。开放寻址法需要的表长度要大于等于所需要存放的元素数量，非常适用于装载因子较小（小于0.5）的散列表。</p>
<p> 开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记，直到有下个元素插入才能真正删除该元素。</p>
<p>​    可以把开放寻址法想象成一个停车问题。若当前车位已经有车，则继续往前开，直到找到一个空停车位。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1208468-20200329205724302-384212505.png" alt="img"></p>
<p><strong>设计思路：</strong>有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。</p>
<p><strong>含义：</strong>一旦冲突，就找附近（下一个）空地址存入。</p>
<p> 开放寻址法的基本函数是：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Hi</span>(key)=(<span class="built_in">H</span>(key) + <span class="built_in">f</span>(i)) MOD m, i=<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,…, <span class="built_in">k</span>(k&lt;=m<span class="number">-1</span>)，</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其中，<strong>m</strong> 为散列表长度，一般为素数；</p>
<p><strong>H(key)</strong> 为散列函数，用于计算索引，key为关键字值；</p>
<p><strong>f(i)</strong> 为增量序列，用于解决冲突，且<code>f(0) = 0</code>，i为已经尝试计算索引的次数。</p>
<p>当散列值<code>H0(key)</code>发生冲突时，再计算<code>H1(key)</code>……，直到不冲突为止。</p>
</blockquote>
<p>实现步骤</p>
<blockquote>
<p>得到给定的 <code>key</code>；</p>
<p>根据函数计算得 <code>hashValue</code>；</p>
<p>若不冲突，则把关键字值存入下标为<code>hashValue</code>的桶；</p>
<p>若冲突，则使 i++ ，也就是往后找，直到找到第一个空桶并填入当前key。若到了尾部则循环到前面。</p>
</blockquote>
<h5 id="线性探查法"><a href="#线性探查法" class="headerlink" title="线性探查法"></a><strong>线性探查法</strong></h5><p> 冲突函数：是<code>i</code>的一次多项式，典型取法为<code>f(i)=i</code>。</p>
<p>​    线行探查法(Linear Probing)是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p>
<p>​    对于一个散列表，在散列过程中，某些元素形成一些区块，这种现象称作<code>一次聚集（primary clustering）</code>。就是说，散列到区块中的任何关键字都需要多次探测才可以解决哈希碰撞，然后，把该关键字添加到相应区块的桶中。</p>
<p>下面是一道<a href="https://blog.csdn.net/ChenYiRan123456/article/details/128570110">例题</a>用线性探查实现开放寻址法</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/image-20230829145845885.png" alt="image-20230829145845885"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = (x % N + N) % N;</span><br><span class="line">    <span class="comment">//开放寻址法就是 挨个找，找不到就算，找到了就返回呗</span></span><br><span class="line">    <span class="keyword">while</span> (h[t] != null &amp;&amp; h[t] != x)<span class="comment">//没到尽头和不为我们的目标值</span></span><br><span class="line">    &#123;</span><br><span class="line">        t ++ ;</span><br><span class="line">        <span class="keyword">if</span> (t == N) t = <span class="number">0</span>;<span class="comment">//指针回位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n -- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[<span class="built_in">find</span>(x)] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[<span class="built_in">find</span>(x)] == null) <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a><a href="https://www.acwing.com/solution/content/30169/">拉链法</a></h4><p><strong>基本思想</strong>：将具有相同哈希地址的记录链成一个单链表，m个哈希地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。</p>
<p><strong>注：</strong>有冲突的元素可以插在表尾,也可以插在表头</p>
<p><strong>例</strong>：设<code>&#123; 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89 &#125;</code>的哈希函数为： <code>Hash(key)=key mod 11</code>， 用拉链法处理冲突，则建表如下图所示。</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/1622171-20190525164856289-1731976151.png" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*拉链法实现上诉题目*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">3</span>;  <span class="comment">// 取大于1e5的第一个质数，取质数冲突的概率最小 可以百度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//* 开一个槽 h</span></span><br><span class="line"><span class="type">int</span> h[N], e[N], ne[N], idx;  <span class="comment">//邻接表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = h[k];</span><br><span class="line">    h[k] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数</span></span><br><span class="line">    <span class="type">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[i] == x) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);  <span class="comment">//将槽先清空 空指针一般用 -1 来表示</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        string op;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; x;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&quot;I&quot;</span>) &#123;</span><br><span class="line">            <span class="built_in">insert</span>(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="双散列"><a href="#双散列" class="headerlink" title="双散列*"></a>双散列*</h4><p>​     冲突函数：<code>f(i) = i * hash2(key)</code>，典型取法是令<code>hash2(key)=PRIME – (key ％ PRIME)</code>，其中 PRIME 是小于散列表大小的质数。</p>
<p>​    双散列（<code>double hashing</code>）使用两个散列函数<code>H(key)和hash2(key)</code>。<code>hash2(key)</code>也以关键字为自变量，产生一个<code>l至m-1</code>之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)。</p>
<p>​    无论是线性探测还是二次探测，当装载因子过高时，哈希表能否动态增长？</p>
<p>​    要扩充哈希表，首先必须找下一个新的且够大(大约2倍)的质数，然后必须考虑重哈希的成本。我们不可能原封不动的拷贝，必须要检验旧表格中的每个元素，计算其在新表格中的位置，然后再插入到新表格中。</p>
<h4 id="平方探查法"><a href="#平方探查法" class="headerlink" title="平方探查法*"></a>平方探查法*</h4><p>​    冲突函数：是i的二次多项式，典型取法为f(i)&#x3D;i^2。</p>
<p>​    平方探测法（Quadratic Probing）即是发生冲突时，用发生冲突的单元H(key), 加上 1²、 2²等，即H(key) + 1²，H(key) + 2²，H(key) + 3²…直到找到空闲单元。f(i)也可以构造为：±i^2,i&#x3D;1,2,3,…,k。</p>
<p>​    在实际操作中，平方探测法不能探查到全部剩余的桶。不过在实际应用中，散列表如果大小是素数，并且至少有一半是空的，那么，总能够插入一个新的关键字。若探查到一半桶仍未找一个空闲的，表明此散列表太满，应该重哈希。平方探测法是解决线性探测中一次聚集问题的解决方法，但是，她引入了被称为二次聚集的问题——散列到同一个桶的那些元素将探测到相同的备选桶。下面的技术将会排除这个遗憾，不过要付出计算一个附加的哈希函数的代价。</p>
<h3 id="字符串哈希"><a href="#字符串哈希" class="headerlink" title="字符串哈希*"></a><a href="https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">字符串哈希</a>*</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串hash</span></span><br><span class="line"> 构造唯一数据表示字符串，可以理解为 <span class="built_in">f</span>(x) = y。就是通过某种方法转化，使得两个毫无相关的数据产生关系。但是为了将映射关系进行一一对应，也就是，一个字符串对应一个数字，那么一个数字也对应一个字符串。</span><br><span class="line"> 用字符串Hash的目的是，我们如果要比较一个字符串，我们不直接比较字符串，而是比较它对应映射的数字，这样子就知道两个“子串”是否相等。从而达到，子串的Hash值的时间为 <span class="built_in">O</span>(<span class="number">1</span>)，进而可以利用“空间换时间”来节省时间复杂的。</span><br><span class="line">    我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。不用担心，接下来的内容正要讲解。<span class="comment">//我们只需要用到数字来匹配数据，这样对数字操作就可以得到我们想要的操作了</span></span><br></pre></td></tr></table></figure>

<h4 id="构造字符串hash"><a href="#构造字符串hash" class="headerlink" title="构造字符串hash"></a>构造字符串hash</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单例子</span></span><br><span class="line"> 假如给你一个数字<span class="number">1166</span>，形式上你只知道它只是<span class="number">1</span>和<span class="number">6</span>的组合，但你知道它代表的实际大<span class="number">1</span>*<span class="number">10</span>^<span class="number">3</span>+<span class="number">1</span>*<span class="number">10</span>^<span class="number">2</span>+<span class="number">6</span>*<span class="number">10</span>^<span class="number">1</span>+<span class="number">6</span>*<span class="number">10</span>^<span class="number">0</span>。</span><br><span class="line"> 同理，给你一个字符串，要把它转换为数字，就可以先把每一个字符都先对应一个数字，然后把它们按照顺序乘以进制（Base）的幂进行相加，然后这个数可能很大，所以一般会取余数（MOD）。    </span><br><span class="line"><span class="comment">//具体操作</span></span><br><span class="line">    根据上面的理解，其实将字符串映射成数字，和我们平时的将一个 某Base进制数，变为一个十进制数，相类似。<span class="comment">//把字符串当成 某种进制的数据，把字符串拆成很多位，然后对每一个位置的字符都进行哈希操作，再用进制的乘法操作将他们拼接起来。</span></span><br><span class="line"> 我们先定义以下：</span><br><span class="line"> 给定一个字符串 S = s1s2s3...sn，对于每一个si就是一个字母，那么我们规定</span><br><span class="line">         <span class="built_in">idx</span>(si) = si-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span> （当然也可以直接用其ASCII值）</span><br><span class="line"> 构造字符串Hash总共有三种方法。每一种方法，主要都是用使用 Base 和 MOD（都要求是素数），一般都是 Base  &lt; MOD，同时将Base和MOD尽量取大即可，这种情况下，冲突（即不同字符串却有着相同的hash值）的概率是很低的</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.自然溢出方法 - 后面还有</span></span><br><span class="line"> 对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> 整数的自然溢出</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//怎么构建我们的字符串前缀</span></span><br><span class="line">  <span class="number">1.</span>将整个数组 当做是一个p进制的数。 通过这样的方式，将我们的字符串变成数字进行操作（本质上 字符串也是数字） - 但是我们这个数组转化完成可能会非常大 那么我们就mod一个大的数据 - 通过这样的方法映射到小区间中 <span class="comment">//取模会重复怎么办 还是说随机存储</span></span><br><span class="line">    <span class="number">2.</span>字符串哈希完全不考虑冲突的情况 </span><br><span class="line">    <span class="number">3.</span> p = <span class="number">131</span> <span class="keyword">or</span> <span class="number">13331</span> - Q = <span class="number">2e64</span> 这样可以忽略冲突 （溢出等价于 mod <span class="number">2e64</span>）</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%93%88%E5%B8%8C.png" alt="image-20230226201946750"></p>
<p>标准流程</p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%AD%97%E7%AC%A6%E4%B8%B2hash1.png" alt="原理"></p>
<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%AD%97%E7%AC%A6%E4%B8%B2hash2.png" alt="原理2"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//相当于将字符型映射为整型（本来就是 将字符串映射成一个p进制的数据 - p一般为质数）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> P = <span class="number">131</span>;</span><br><span class="line"><span class="comment">// p[i] = P^i, h[i] = s[1~i]的hash值</span></span><br><span class="line">ULL p[N],h[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//字符串长度就是对应的进制 p^n - 也可以说是长度是项数的个数</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>,h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        p[i] = p[i<span class="number">-1</span>]*P; <span class="comment">//P是进制</span></span><br><span class="line">        h[i] = h[i<span class="number">-1</span>]*P+s[i];<span class="comment">//s是对应字符的ASCII值是吧</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算s[l~r]的哈希值</span></span><br><span class="line"><span class="function">ULL <span class="title">get</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r]-h[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断两个子串是否相等</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">substr</span><span class="params">(<span class="type">int</span> l1,<span class="type">int</span> r1,<span class="type">int</span> l2,<span class="type">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>(l1,r1) == <span class="built_in">get</span>(l2,r2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总结：字符串哈希使用来解决字符串匹配，查找去重的问题的。</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/%E5%AD%97%E7%AC%A6%E4%B8%B2hash%E5%8E%9F%E7%90%863.png" alt="原理3"></p>
<h3 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h3><h4 id="高精度加法计算"><a href="#高精度加法计算" class="headerlink" title="高精度加法计算"></a><strong>高精度加法计算</strong></h4><blockquote>
<p>如果我们要将一个很大的数据与一个很小的数据相加应该怎么办，你可能会想，直接加就行了嘛，10000+1&#x3D;10001，很简单。但是，在计算机中，我们使用的数据类型在计算的时候，往往会将小的数据忽略掉，也就是<code>1e99+1 = 1e99</code>,而1就不见了。我们需要的是保持精度的情况下进行加法，这个时候我们可以利用我们的线性表，数组来实现这个保留精度的加法。A+B（这里的情况是一个大的数据加上另一个大的数据）。</p>
<p>依照上面的说法，我们就开辟两个字符串数组（比较好分离数据），一个a【】存A这个数据，一个b【】存B这个数据。但为了方便接下来的操作，我们还是开辟两个Vector(向量：是个容器)，然后将输入的a,b中的数据导入到我们的vector中，这个时候注意一个细节。</p>
<p>我们插入的数据是要倒着插入的，举个例子：123456789，这是一个大的数据，倒着插入意味着个位在数组（容器）的前面（之后的数据以此类推）。在数组中就变成了987654321，这样做的好处是进位不用移动数组中的元素，你看我们的目的是要计算这些大数据的加和，在加和的过程中免不了会产生进位，如果用123456789，进一位的话就要移动整个数组，就十分复杂。如果反过来，我们只需要在进的那位尾插一个数据就行。</p>
<p>同时，计算方法其实就和我们手工计算的差不多，对位计算加上进位即可，举个例子：1+9 &#x3D; 10，其实就是十位上面+进位 t&#x3D;1 &#x3D; 10,就是这样。</p>
</blockquote>
<p>代码实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C = A+B c是我们要实现的结果</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;<span class="comment">//这是结果</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span><span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||i&lt;B.<span class="built_in">size</span>();i++)<span class="comment">//只要没遍历完最长的就继续</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//下面实现的是 t在i这个位置的值，然后%10就是这个位置剩下的值，/10就是进位的值保留到i+1（下一位）</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i];</span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t+=B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t%<span class="number">10</span>);<span class="comment">//将对应位置的数据插入结果</span></span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t) C.<span class="built_in">push_back</span>(<span class="number">1</span>);<span class="comment">//进大位，出来t/10还有剩，那肯定进位了（我们是倒叙输入的嘛）</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒叙输入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;<span class="comment">//自己输入两个大的数据</span></span><br><span class="line">    <span class="comment">//为啥是size-1，就是0到i有i-1个数据嘛</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//倒着插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">//自动判断是啥类型</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A,B);<span class="comment">//调用模板</span></span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="高精度减法计算"><a href="#高精度减法计算" class="headerlink" title="高精度减法计算"></a><strong>高精度减法计算</strong></h4><p>  减法的计算其实和加法差不多，但是我们需要满足一些条件；<code>1.A&gt;=B</code> 不满足就要交换两个数据的值（加上负号）2.向前借位是<code>+10</code>（对于当前位数）所以说方向就很明确了，加上一个判断A,B大小的关系，对 t 改一下就行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(A.<span class="built_in">size</span>()!=B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>()&gt;B.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(A[i]!=B[i]) <span class="keyword">return</span> A[i]&gt;B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C = A-B c是我们要实现的结果</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,vector&lt;<span class="type">int</span>&gt; &amp;B)</span>/模板</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;<span class="comment">//这是结果</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,t = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||i&lt;B.<span class="built_in">size</span>();i++)<span class="comment">//只要没遍历完最长的就继续</span></span><br><span class="line">    &#123;</span><br><span class="line">  t = A[i] - t;<span class="comment">//t是借位的</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;B.<span class="built_in">size</span>()) t -= B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>((t+<span class="number">10</span>)%<span class="number">10</span>);<span class="comment">//这里的t有两种情况，一种减完之&lt;0，那就需要借位+10.一种是减完之后&gt;=0，不需要借位。这个时候，(t+10)%10这两种情况都满足，举个例子：1.你减完之后变成了-9，那就是要借一位，就是-9+10 = 1,1%10还是1.2.你减完之后，还剩下9，那么9%10还是9.</span></span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>() &gt; <span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>()== <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒叙输入</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a,b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A,B;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;<span class="comment">//自己输入两个大的数据</span></span><br><span class="line">    <span class="comment">//为啥是size-1，就是0到i有i-1个数据嘛</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//倒着插入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = b.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用上面的判断，计算A-B 或者 B-A</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">cmp</span>(A,B))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A,B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B,A);<span class="comment">//B&gt;A</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="高精度乘法计算"><a href="#高精度乘法计算" class="headerlink" title="高精度乘法计算"></a>高精度乘法计算</h4><p>大数据乘小数据</p>
<p> 在人工计算乘法的时候，我们一般是一位一位的计算，例如：<code>123乘12</code>，那么一般是2 <code>*123+10* 123</code>。但是这样其实比较繁琐，我们在计算高精度的时候，可以把这两个数据中的小数据，单独拿出来做一个整体，就上面那个来说，就变成了<code>1 *12* 100+2 *12* 10+3 *12* 1</code>，竖式就由两个变成一个了。</p>
<p> 同时，在计算的时候，每一个位的位数t也需要注意，举个例子：<code>123456789*12</code>，这里的 （第一位）a &#x3D; 9,进位就变成了 <code>t = 9* 12/10</code>，输入到结果C的就变成了 (第一位)<code>C = 9*12%10</code>，这样就定下来了。下面是代码演示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b)</span><span class="comment">//b比较小就直接用int表示（整体）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;A.<span class="built_in">size</span>()||t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>()) t+=A[i]*b;<span class="comment">//遍历位置乘完的数据</span></span><br><span class="line">        c.<span class="built_in">push_back</span>(t%<span class="number">10</span>);<span class="comment">//插进去计算完成之后这个位置的具体数</span></span><br><span class="line">        t/=<span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;<span class="comment">//数据大用字符串存储</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//这里是把字符串转化成具体的数，由ASCII决定的，在字符&#x27;0&#x27;代表的是48</span></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A,b);<span class="comment">//调用容器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高精度除法计算"><a href="#高精度除法计算" class="headerlink" title="高精度除法计算"></a>高精度除法计算</h4><p>大数据除小数据（一般用的不多）</p>
<p>在人工计算除法的时候，一般是从大到小位去除的。但是，一个题目难免会出现加减乘除多种运算，所以说我们还是尾插大数据把。具体做法和乘法差不多，就是把小的看成整体（平常我们算除法是这样）下面是代码演示。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A,<span class="type">int</span> b,<span class="type">int</span> &amp;r)</span><span class="comment">//b是小的</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> vector&lt;<span class="type">int</span>&gt; C;</span><br><span class="line">    r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = A.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r*<span class="number">10</span>+A[i];<span class="comment">//计算的时候，和我们把上一位除不了移下来算是一个样子的</span></span><br><span class="line">        C.<span class="built_in">push_back</span>(r/b);<span class="comment">//余数插入结果中</span></span><br><span class="line">        r%=b;<span class="comment">//除完之后的余数</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>());<span class="comment">//翻转</span></span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span>&amp;&amp;C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去除前端0</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;<span class="comment">//数据大用字符串存储</span></span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//这里是把字符串转化成具体的数，由ASCII决定的，在字符&#x27;0&#x27;代表的是48</span></span><br><span class="line">    <span class="type">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A,b,r);<span class="comment">//调用容器</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,C[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数论 - 简单讲解数论</title>
    <url>/2023/04/28/%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数论"><a href="#数论" class="headerlink" title="数论"></a><a href="https://oi-wiki.org/">数论</a></h1><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a><a href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95">欧几里得算法</a></h2><h3 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h3><p>欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g，意思是能够同时整除a和b的自然数中最大的一个。两个数的最大公约数通常写成<code>gcd(a,b)</code>，或者简写成<code>(a,b)</code>，但是第二种写法也被使用在其他数学概念，如二维向量的坐标。</p>
<blockquote>
<p> 特别的如果<code>gcd(a,b) = 1</code>则a和b互质，也就是说没有数能同时除以<code>a或者b</code>。</p>
</blockquote>
<p>令<code>g = gcd(a,b)</code>.由于a和b都是g的整数倍，所以可以写成<code>a = mg,b = ng</code>,并且不存在更大的整数<code>G&gt;g</code>使等式成立。为了使得g足够大，就要使得a和b中所有的公约数都提取出来归入g中，所以说自然数m，n一定互质（可以理解为互质导致两个数据距离足够大，一个极端小，一个极端大），并且a和b的最大公约数可以被a和b的所有其他公因数<code>c</code>整除(就是说，a和b的因素包含在<code>g</code>是吗)</p>
<p>前面讲述的是辗转相除法的特质，下面来讲辗转相除法的算法代码，顾名思义辗转相除法就是将两个数据不停相除，直到一方为0.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两个数据得是整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open_M</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b) result = <span class="built_in">gcd</span>(a,b);</span><br><span class="line">    <span class="keyword">else</span> result = <span class="built_in">gcd</span>(b,a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcd - 递归计算</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">//简单的记忆 - 只要传入的第二个参数为0 - 那么最大公约数就是第一个参数</span></span><br><span class="line">    <span class="keyword">if</span>(a%b == <span class="number">0</span>) <span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">gcd</span>(b,a%b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用上面的例子可能不好理解，下面用一个图形化实例来解释辗转相除法</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230907103114003.png" alt="image-20230907103114003"></p>
<blockquote>
<p>假设我们有一个长方形，其长度为a，宽度为b，我们的目标是找到一个能够完全覆盖这个长方形的最大长方形，而且没有部分超出原始长方形的边界。(试着理解，a和b是两个数据)</p>
<ol>
<li>首先，我们尝试将较大的长方形（a）分割成较小的长方形（b）和一些余下的部分（q），使得a &#x3D; b + q，其中q的长度小于b。我们将q看作是原始长方形中未被覆盖的部分。</li>
<li>然后，我们继续以同样的方式，尝试找到能够完全覆盖q的最大长方形，其长度为b’，同时q &#x3D; b’ + q’，其中q’的长度小于b’。</li>
<li>我们不断重复这个过程，直到找到一个长方形（b’’），它能够完全覆盖q’’，其中q’’ &#x3D; b’’ + 0。这时，q’’是一个没有余下部分的长方形。</li>
<li>这个最终的长方形（b’’）的长度就是原始长方形（a）和我们一路上找到的所有长方形（b、b’、…）的最大公约数。</li>
</ol>
<p>辗转相除法的核心思想是通过不断地将较大的长方形分割成较小的长方形，直到找到一个没有余下部分的长方形，来寻找两个数的最大公约数。这个过程反映了欧几里德算法的工作方式，其中我们一次又一次地计算余数，直到余数为0，此时除数就是最大公约数。</p>
</blockquote>
<p>对于两个整数a和b，假设a &gt; b。我们可以使用欧几里德算法来计算它们的最大公约数<code>(gcd)</code>。这个算法的基本思想是，用b去除a并计算余数，然后将b替换为a，将余数替换为b，然后继续这个过程，直到余数变为0。此时，b的值就是a和b的最大公约数。</p>
<p>现在，我们来看一下这个性质：假设a除以b的商和余数分别是p和q，即<code>a = b * p + q</code>。那么我们可以得出以下结论：</p>
<ol>
<li><code>gcd(b, q) </code>可以整除b和q，因为它是b和q的最大公约数。</li>
<li>根据欧几里德算法的步骤，q不断替换b，直到q变为0。此时，b的值就是a和b的最大公约数。</li>
</ol>
<p>因此，我们可以总结为：<code>gcd(b, q) </code>可以整除b和a，因为最终它就是a和b的最大公约数。</p>
<blockquote>
<p>为什么第一个参数要大于第二个参数呢，因为最后出现的0不能作为除数。</p>
<p>如果还是不能理解，就记住公式就行吧。</p>
</blockquote>
<h3 id="扩展欧几里得"><a href="#扩展欧几里得" class="headerlink" title="扩展欧几里得*"></a><a href="https://zhuanlan.zhihu.com/p/100567253">扩展欧几里得</a>*</h3><h4 id="求解线性同余方程"><a href="#求解线性同余方程" class="headerlink" title="求解线性同余方程"></a>求解线性同余方程</h4><p>形如</p>
<p><code>ax≡b (mod n)</code></p>
<p>这个就是线性同余方程，其中<code>a,b,n</code>都为常量，x是未知数，这个方程可以化为(取模n - 变为方程)</p>
<p><code>ax = kn+b</code></p>
<p>这里的k为任意常数，于是一般式为：</p>
<p><code>ax+by+c = 0</code></p>
<p>这个方程就是二维的直线方程，这个方程的解集是一些排列成直线的点。</p>
<p>拓展欧几里得可以用于求解线性同余方程<code>ax≡b (mod n)</code>,实际上拓展欧几里得是在求解最大公约数的时候对其加上一些限制，达到解决问题的目的。</p>
<p>下面是求解方程<code>ax≡b (mod n)</code>的具体步骤：</p>
<p>首先，确保a和n互质，即<code>gcd(a, n) = 1</code>。如果<code>gcd(a, n)</code>不等于1，那么线性同余方程没有整数解。</p>
<blockquote>
<p>特别的：当a和n不互质时，线性同余方程ax ≡ b (mod n)可能没有整数解或者只在特殊情况下有解。让我们来看两个例子：</p>
<p><strong>例子 a和n互质</strong></p>
<p>假设我们有线性同余方程：</p>
<p><code>3x ≡ 2 (mod 7)</code></p>
<p>在这个情况下，a &#x3D; 3，n &#x3D; 7。a和n是互质的，因为它们的最大公约数<code>gcd(3, 7) = 1</code>。因此，这个方程有整数解。解可以通过拓展欧几里得算法等方法找到。一个解是x &#x3D; 5，因为<code>3 * 5 ≡ 15 ≡ 2 (mod 7)</code>。</p>
<p><strong>例子 和n不互质</strong></p>
<p>现在，考虑线性同余方程：</p>
<p><code>4x ≡ 2 (mod 6)</code></p>
<p>在这个情况下，a &#x3D; 4，n &#x3D; 6。a和n不互质，因为它们的最大公约数<code>gcd(4, 6) = 2</code>。因此，这个方程可能没有整数解，因为<code>4x与2 (mod 6)</code>有一个共同的因子2。</p>
<p>如果我们尝试将<code>4x ≡ 2 (mod 6)</code>除以2，我们得到<code>2x ≡ 1 (mod 3)</code>，这个方程有整数解x &#x3D; 2。但是这不是原始方程<code>4x ≡ 2 (mod 6)</code>的解，因为我们只是在原方程的基础上除以了一个公因子2。</p>
<p>这个例子说明，当a和n不互质时，线性同余方程可能没有整数解，或者解可能存在于一个较小的模数下。</p>
</blockquote>
<p>使用拓展欧几里得算法来计算a和n的最大公约数<code>gcd(a, n)</code>，以及同时找到x和y，使得<code>ax + ny = gcd(a, n)</code>。这一步的目标是找到x的值。</p>
<p>如果<code>gcd(a, n)</code>等于1（表示a和n互质），则方程ax ≡ b (mod n)有唯一整数解。这个解可以通过将x乘以b并对n取模来获得，即x ≡ bx (mod n)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extended_gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        y = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x1, y1;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extended_gcd</span>(b % a, a, x1, y1);</span><br><span class="line">    </span><br><span class="line">    x = y1 - (b / a) * x1;</span><br><span class="line">    y = x1;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve_linear_congruence</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> n, <span class="type">int</span> &amp;x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x0, y0;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extended_gcd</span>(a, n, x0, y0);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (b % gcd != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//不存在整数解</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    x = (x0 * (b / gcd)) % n;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x += n; <span class="comment">// 确保x为正数</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">solve_linear_congruence</span>(a, b, n, x);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gcd == <span class="number">-1</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;没有整数解&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;方程整数解是： &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;x ≡ &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; (mod &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;) 是 x ≡ &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; (mod &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实现贝祖定理"><a href="#实现贝祖定理" class="headerlink" title="实现贝祖定理*"></a><a href="https://oi-wiki.org/math/number-theory/bezouts/">实现贝祖定理</a>*</h4><p>定义：</p>
<blockquote>
<p>给定两个整数a和b ，一定存在整数x和y ，使得<code>ax+by=gcd(a,b)</code></p>
<p>换句话说，若<code>ax + by = m </code>有整数解当且仅当m是<code>gcd(a,b)</code>的倍数。</p>
</blockquote>
<p>证明：</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230907141937287.png" alt="image-20230907141937287"></p>
<p>具体看<code>oi</code>网吧，我也没搞懂证明过程。</p>
<p>我们现在只需要证明：<code>对于任意整数a和b，存在整数x和y，使得ax + by = gcd(a, b)。</code>下面是一个简单的解决问题的步骤</p>
<p>首先，使用欧几里得算法计算a和b的最大公约数<code>（GCD）</code>。这可以通过反复取余数的方式来实现，直到余数为0为止。<code>GCD</code>就是最后一个非零余数。</p>
<p>在计算<code>GCD</code>的过程中，我们会得到一系列的等式，这些等式可以用来表示<code>GCD</code>为前两个数的线性组合。具体来说，如果我们得到了以下等式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原本的辗转相除法</span></span><br><span class="line"><span class="built_in">GCD</span>(a, b) = <span class="built_in">GCD</span>(b, a % b)</span><br></pre></td></tr></table></figure>

<p>那么根据贝祖定理，可以表示为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//贝祖定理</span></span><br><span class="line"><span class="built_in">GCD</span>(a, b) = x * a + y * (a % b)</span><br></pre></td></tr></table></figure>

<p>其中，x和y是与b和a % b相关的系数。</p>
<p>接下来，我们将递归地使用相同的过程，但是将b和a % b作为新的a和b，直到余数为0为止。此时，<code>GCD</code>就是最后一个非零余数，同时我们也得到了x和y的最终值，它们满足贝祖定理的要求。</p>
<p>最终，我们可以得到a和b的最大公约数<code>GCD(a, b)</code>，以及满足贝祖定理的整数x和y，使得<code>ax + by = GCD(a, b)</code>。</p>
<blockquote>
<p>上面的算式也没啥含金量，就是知道公式根据公式套模版，但是理解和证明贝祖定理是比较困难的。</p>
</blockquote>
<p>下面是实现的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数用于计算最大公约数（GCD）以及满足贝祖定理的x和y</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">extendedGCD</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x1, y1;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extendedGCD</span>(b, a % b, x1, y1);</span><br><span class="line"></span><br><span class="line">    x = y1;</span><br><span class="line">    y = x1 - (a / b) * y1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gcd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">48</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">18</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">extendedGCD</span>(a, b, x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;GCD(&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; gcd &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, y = &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="快速幂问题"><a href="#快速幂问题" class="headerlink" title="快速幂问题"></a><a href="https://zhuanlan.zhihu.com/p/95902286">快速幂问题</a></h2><p>顾名思义，这个算法实现的是快速求取高幂次的数据。在我们平常计算幂的数据的时候，通常会选择一个一个乘，举个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例如我要计算 7^10</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        a*=<span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样子确实能够实现我们的目的，但是由于循环次数过多导致算法效率太慢，我们就不使用这种算法，改为使用快速幂算法。</p>
<p>让我们先来思考一个问题：<strong>7的10次方，怎样算比较快？</strong></p>
<p><strong>方法1：</strong>最朴素的想法，<code>7*7=49，49*7=343</code>，… 一步一步算，共进行了<strong>9次</strong>乘法。</p>
<p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p>
<p><strong>方法2：</strong>先算7的5次方，即<code>7*7*7*7*7</code>，再算它的平方，共进行了<strong>5次</strong>乘法。</p>
<p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p>
<p><strong>方法3：</strong>先算7*7得49，则7的5次方为<code>49*49*7</code>，再算它的平方，共进行了<strong>4次</strong>乘法。</p>
<p>模仿这样的过程，我们得到一个在<code>O(log n)</code>时间内计算出幂的算法，也就是快速幂。</p>
<hr>
<p>那要怎么样才能实现这种效果呢，我们可以使用二进制来优化我们的乘法运算，使其更加高效的相乘。</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230907153701347.png" alt="image-20230907153701347"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘 - 提高次，就是和十进制的十位百位一样的</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位 - 位运算将十进制数据转换为二进制移动位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最初ans为1，然后我们一位一位算：</p>
<p>1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。</p>
<p>101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。</p>
<p>10的最后一位是0，跳过，右移，自乘。</p>
<p>然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/v2-e99e321dcff33699093cde2876424dbe_720w.webp" alt="img"></p>
<h3 id="快速幂扩展"><a href="#快速幂扩展" class="headerlink" title="快速幂扩展"></a>快速幂扩展</h3><p>上面所述的都是<strong>整数</strong>的快速幂，但其实，在算 a^n 时，只要a的数据类型支持<strong>乘法</strong>且<strong>满足结合律</strong>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//泛型的非递归快速幂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">qpow</span><span class="params">(T a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T ans = <span class="number">1</span>; <span class="comment">// 赋值为乘法单位元，可能要根据构造函数修改</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a; <span class="comment">// 这里就最好别用</span></span><br><span class="line">        自乘了，不然重载完*还要重载*=，有点麻烦。</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="乘法逆元"><a href="#乘法逆元" class="headerlink" title="乘法逆元"></a><a href="https://zhuanlan.zhihu.com/p/378728642">乘法逆元</a></h2><p>数学上的乘法逆元就是一个数的倒数，既a的逆元是<code>1/a</code>,也就是和a相乘得到1的数据。<code>ax = 1</code>,则x是a的乘法逆元。</p>
<blockquote>
<p>发明乘法逆元的目的是为了将除法变为乘法，因为计算除法很麻烦。</p>
</blockquote>
<p>这里讨论有关于取模运算的乘法逆元，既对于整数a,与a互质的数b作为模数，当整数x满足<code>ax mod b ≡ 1</code>时，称<code>x</code>为<code>a</code>关于模<code>b</code>的逆元，也就是<code>a * x % b == 1</code></p>
<p>在算法竞赛中，经常会遇到求解数据很大，则输出模 <code>10^9+7</code> 的解这类要求。加法、减法、乘法等操作，基于同余理论直接取模即可。但遇到除法时，某步中间结果不一定能完成整除，就无法求解了。</p>
<p>举个例子：求<code>3 * 6 / 3</code> 对 <code>7</code> 取模的结果。我们直接算出<code>3 * 6 / 3</code>的结果是<code>6</code>，对<code>7</code>取模得最终答案是 <code>6</code> 。</p>
<p>但我们通常面对的问题是中间结果超过<code>int</code>甚至<code>long long</code> 的范围，而不得不在每一步基于同余理论取模，我们用这个例子尝试一下：</p>
<p>还是求 <code>3 * 6 / 3 % 7</code></p>
<p>第一步：<code>3 * 6 == 18</code>，<code>18 % 7 == 4</code></p>
<p>第二步：<code>4</code> 这个中间结果再做 <code>4 / 3</code> 无法整除，就无法进行下去了。</p>
<p>**但我们可以求出除数 <code>3</code> 关于模数<code>7</code>的逆元 <code>5</code><strong>（根据逆元定义，<code>5</code> 符合 <code>3 * 5 % 7 == 1</code>），从而，</strong>用乘以<code>5</code>代替除以<code>3</code>**。</p>
<p>上述第二步除法变乘法： <code>4 * 5 == 20</code>，<code>20 % 7 == 6</code></p>
<p>从而也计算出了正确的结果 <strong><code>6</code></strong> 。</p>
<blockquote>
<p>也就是说，要找到一个乘法逆元满足，相乘 &#x3D; 1，然后替代掉我们的除法</p>
</blockquote>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230907163058460.png" alt="image-20230907163058460"></p>
<h3 id="拓展欧几里得实现逆元"><a href="#拓展欧几里得实现逆元" class="headerlink" title="拓展欧几里得实现逆元"></a><a href="https://zhuanlan.zhihu.com/p/378728642">拓展欧几里得实现逆元</a></h3><p>在上面我们了解过了，扩展欧几里得算法则是求<code>ax+by = gcd(a,b)</code>的一组可行解:</p>
<p>我们来看它和乘法逆元的关系：</p>
<ul>
<li>逆元： a关于模b的逆元 整数d满足<code>ad mod b ≡ 1</code></li>
<li>拓展欧几里得：求方程<code>ax+by = gcd(a,b)</code>的一组可行解</li>
</ul>
<p>逆元的<code>ad mod b ≡ 1</code>, 等价于 <code>ad - kb = 1</code>,其中k为未知整数。</p>
<p>设d为x，<code>-k为y</code>，则<code>ad-kb = 1</code>转为<code>ax+by=1</code> ，也就是求x就可以得到a关于模 b 的逆元。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩展欧几里得算法实现逆元</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> r = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - a / b * y;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inverse</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">int</span> gcd = <span class="built_in">exgcd</span>(a, m, x, y);</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : x + m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速幂实现乘法逆元"><a href="#快速幂实现乘法逆元" class="headerlink" title="快速幂实现乘法逆元"></a>快速幂实现乘法逆元</h3><p>本质上是使用费马小定理，下面简单介绍一下费马小定理：</p>
<p>费马小定理：对于整数 a 与质数 b ，若 a 与 b 互质，则有：<code>a^(b-1) mod b ≡ 1</code></p>
<p>拆一下也就变成了<code>a*a^(b-2) mod b ≡ 1</code> 也就将乘法逆元的公式拼凑成功了。然后就是进行幂的运算，这样使用快速幂即可。</p>
<p>求逆元，就用 <code>b-2</code> 和 b 代替 快速幂取模中的 <code>n</code> 和 <code>mod</code>：</p>
<p>时间复杂度：大约<code>O(log b)</code>。</p>
<p>适用范围：一般在模数 <code>b</code> 是质数的时候。</p>
<p>下面是实现的具体代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算a的幂次b模m的结果</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">fastModuloExponentiation</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    a %= m;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result = (result * a) % m;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % m;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算a关于模数m的乘法逆元</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">multiplicativeInverse</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用快速幂计算a^(m-2) % m</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fastModuloExponentiation</span>(a, m - <span class="number">2</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a, m;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入整数a：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入模数m：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> inverse = <span class="built_in">multiplicativeInverse</span>(a, m);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;整数 &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; 关于模数 &quot;</span> &lt;&lt; m &lt;&lt; <span class="string">&quot; 的乘法逆元是：&quot;</span> &lt;&lt; inverse &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a><a href="https://zhuanlan.zhihu.com/p/151756874">欧拉函数</a></h2><p>定义</p>
<p>在<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%95%B8%E8%AB%96">数论</a>中，对正<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8">整数</a><em>n</em>，<strong>欧拉函数φ(n)<strong>是小于或等于<em>n</em>的正整数中与<em>n</em><a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA">互质</a>的数的数目。此<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E6%95%B0%E5%AD%A6)">函数</a>以其首名研究者<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89">欧拉</a>命名，它又称为</strong>φ函数</strong>（由<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E5%8D%A1%E7%88%BE%C2%B7%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E9%AB%98%E6%96%AF">高斯</a>所命名）或是<strong>欧拉总计函数</strong>。</p>
<p>例如<code>φ(8) = 4</code>，因为<code>1,3,5,7</code>均和8互质。</p>
<p>也可以从简化剩余系的角度来解释，简化剩余系(reduced residue system)也称既约剩余系或缩系，是m的完全剩余系中与m<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E4%BA%92%E7%B4%A0/869678">互素</a>的数构成的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%AD%90%E9%9B%86/5017034">子集</a>，如果模m的一个剩余类里所有数都与m互素，就把它叫做与模m互素的<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%89%A9%E4%BD%99%E7%B1%BB/3712708">剩余类</a>。在与模m互素的全体剩余类中，从每一个类中各任取一个数作为代表组成的集合，叫做模m的一个简化剩余系。</p>
<p><code>（1，3，5，7）</code>就构成了8的一个简化剩余系。</p>
<blockquote>
<p>欧拉函数的定义是：<br>  <code>Φ(N) = (p1^k1)*(p2^k2)…*(pr^kr)</code><br>   其中<code>p1、p2…pr</code>是大于1的所有不相等的质数，而<code>k1、k2…kr</code>是正整数。<br>   <code>Φ(N)</code>表示小于等于<code>N</code>的正整数中，与<code>N</code>互质的数之积。欧拉函数的意义就是计算满足特定限制条件的正整数值</p>
<p>说人话就是，欧拉函数可以把一个数分解成质因数的乘积。</p>
</blockquote>
<p> 标准分解式</p>
<p>标准分解式：将质因数分解的结果，按照质因数大小，由小到大排列，并将相同质因数的连乘积，以指数形式表示，此种表示法称为标准分解式。</p>
<p>如2020的标准分解式是</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/v2-4305f9672e7bf9135245f0f4a9517a48_720w.png" alt="img"></p>
<blockquote>
<p>整数（除了0）都可被质因数分解，质因数分解是一个在理论上可行但在实际中对于大整数来说非常耗时的计算问题。</p>
</blockquote>
<p>欧拉函数计算方法</p>
<p>（1）先化为标准分解式形式</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/v2-7fff527aba93db7a2de6722d126b7720_720w.png" alt="img"></p>
<p>（2）再依照下式规则计算</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/v2-1b46934f0398099451934b434301000e_720w.png" alt="img"></p>
<p>例如：</p>
<p><img src="/v2-7944fd84b22ba208a1ecc4873ab1889b_720w.png" alt="img"></p>
<p>但是获得大整数的标准分解式却很困难</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/v2-f37804d83b944f0f8f87638a8ea5a897_720w.webp" alt="img"></p>
<p>下面是实现欧拉函数的一个代码：分解质因数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注意欧拉函数只适用于整数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算最大公约数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算欧拉函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">euler_phi</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">            result -= result / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">        result -= result / n;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个正整数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请输入一个大于0的正整数。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> phi = <span class="built_in">euler_phi</span>(n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;欧拉函数 φ(&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; phi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>欧拉函数简单理解就是，任何一个整数都可以将之质因数分解。</p>
</blockquote>
<h3 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h3><p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/v2-43c417f37ca53e2e888bc01a0333229e_720w.png" alt="img"></p>
<blockquote>
<p>对于任何正整数n和与n互质的正整数a（即，a和n没有共同的质因数），以下等式成立：</p>
<p><code>a^φ(n) ≡ 1 (mod n)</code></p>
<p>其中，^表示幂运算，<code>φ(n)</code>表示欧拉函数（<code>Euler&#39;s Totient Function</code>），≡ 表示模同余。<code>φ(n)</code>表示小于等于n且与n互质的正整数的个数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//欧拉定理的代码生成</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义欧拉函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">euler</span><span class="params">(<span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> ans=n,i,j;</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">2</span>;i*i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans=ans-ans/i;</span><br><span class="line">            <span class="keyword">while</span>(n%i==<span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                n/=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;<span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        ans=ans-ans/n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> n;</span><br><span class="line"> </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个正整数：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;此数的欧拉函数值为：&quot;</span>&lt;&lt; <span class="built_in">euler</span>(n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a><a href="https://www.cnblogs.com/RioTian/p/13938770.html">费马小定理</a></h3><p>对于费马小定理，可以理解为是欧拉函数的一种特殊状态，<code>a^φ(n) ≡ 1 (mod n)</code>.下面列出的是欧拉函数的公式</p>
<p><code>a^(p-1) ≡ 1 (mod p)</code> </p>
<p>这里举一个例子：</p>
<p><code>2^5-1 = 2^4 = 16 ≡ 1(mod 5)</code></p>
<p>可以看出，mod的这个质数之后会余下1，这个性质朴素存在，但是也有例外：<img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230907224817684.png" alt="image-20230907224817684"></p>
<p>对于定理的证明，可以观看这个<a href="https://www.youtube.com/watch?v=u2D3Fe41IC0">视频</a>,然后下面是实现费马小定理的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 (a^b) % mod，使用费马小定理</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mod_pow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    a %= mod;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            result = (result * a) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        a = (a * a) % mod;</span><br><span class="line">        b /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 a 在模 mod 下的逆元，使用费马小定理</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mod_inverse</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mod_pow</span>(a, mod - <span class="number">2</span>, mod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> a = <span class="number">7</span>; <span class="comment">// 你的底数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> mod = <span class="number">13</span>; <span class="comment">// 你的模数</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">mod_pow</span>(a, mod - <span class="number">2</span>, mod);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;逆元: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>费马小定理常用于实现别的算法，实现自己的就很少。</p>
<p>乘法逆元和组合性数学也可以使用这个来实现，了解即可</p>
</blockquote>
<h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a><a href="https://zhuanlan.zhihu.com/p/44591114">中国剩余定理</a></h2><p>中国剩余定理是为了解决一元线性同余方程组而存在的，</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230908143445893.png" alt="image-20230908143445893"></p>
<p>假设我们需要解决这样的方程组：</p>
<p><code>x = 2 (mod 5)</code></p>
<p><code>x = 3 (mod 7)</code></p>
<p>目的是要求出x的值，假设y是这个函数的解决方法，那么<code>y+35</code>也是一个解决方案，所以说只需要找到一个数据<code>mod 35</code>，通过暴力算法，可以得到一个数据 <code>x = 17(mod 35)</code>.</p>
<blockquote>
<p><code>x % 5 = 2</code>  <code>原理就是用for循环枚举就行</code></p>
<p><code>x % 7 = 3</code></p>
</blockquote>
<p>对于任何这样的方程组，中国剩余定理告诉我们在一定模数范围内总有唯一解，并描述了如何有效找到目标解。</p>
<p>定理：当<code>p,q</code>互质，那么方程组</p>
<p><code>x = a (mod p)</code></p>
<p><code>x = b (mod q)</code></p>
<p>有一个独特的解决方案<code>x</code>模数<code>pq</code></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230908150544523.png" alt="image-20230908150544523"></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230908151047563.png" alt="image-20230908151047563"></p>
<blockquote>
<p>具体的计算流程：</p>
<ol>
<li>确保所有的模数<code>n₁、n₂、...、nₖ</code>两两互素。如果它们不互素，你需要将它们分解成互素的模数并分别解决每个子组。</li>
<li>计算<code> M = n₁ * n₂ * ... * nₖ，</code>即所有模数的乘积。</li>
<li>对于每个 i，计算 <code>Mᵢ = M / nᵢ</code>，即去除掉 nᵢ 的乘积。</li>
<li>对于每个 i，计算 Mᵢ 的模反元素（即 Mᵢ 在模 nᵢ 下的乘法逆元），通常用记号 Mi⁻¹ 表示。这可以使用扩展欧几里得算法来计算。</li>
<li>最后，计算 <code>x = (a₁ * M₁ * M₁⁻¹ + a₂ * M₂ * M₂⁻¹ + ... + aₖ * Mₖ * Mₖ⁻¹) % M。</code></li>
</ol>
<p>这个 x 就是满足所有模同余方程的解。</p>
<p>下面是一个简单的示例，以帮助理解：</p>
<p>考虑以下方程组：</p>
<ol>
<li><code>x ≡ 2 (mod 3)</code></li>
<li><code>x ≡ 3 (mod 5)</code></li>
<li><code>x ≡ 2 (mod 7)</code></li>
</ol>
<p>首先，计算<code> M = 3 * 5 * 7 = 105。</code></p>
<p>然后，计算<code> M₁ = M / 3 = 35，M₂ = M / 5 = 21，M₃ = M / 7 = 15。</code></p>
<p>接下来，计算 M₁、M₂、M₃ 在模 n₁、n₂、n₃ 下的模反元素：</p>
<ul>
<li><code>M₁⁻¹ ≡ 35⁻¹ ≡ 2 (mod 3)</code></li>
<li><code>M₂⁻¹ ≡ 21⁻¹ ≡ 1 (mod 5)</code></li>
<li><code>M₃⁻¹ ≡ 15⁻¹ ≡ 1 (mod 7)</code></li>
</ul>
<p>最后，计算 x：</p>
<p><code>x = (2 * 35 * 2 + 3 * 21 * 1 + 2 * 15 * 1) % 105 x = (140 + 63 + 30) % 105 x = 233 % 105 x = 23</code></p>
<p>所以，方程组的解是 <code>x ≡ 23 (mod 105)。</code>这就是中国剩余定理的应用示例。</p>
</blockquote>
<p>下面是具体实现的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算模反元素的函数，使用扩展欧几里得算法</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">mod_inverse</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m0 = m, x0 = <span class="number">0</span>, x1 = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> q = a / m;</span><br><span class="line">        m = a % m;</span><br><span class="line">        a = m0;</span><br><span class="line">        m0 = m;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = x0 - q * x1;</span><br><span class="line">        x0 = x1;</span><br><span class="line">        x1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x1 &lt; <span class="number">0</span> ? x1 + m0 : x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现中国剩余定理的函数</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">chinese_remainder_theorem</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">long</span> <span class="type">long</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保输入的 a 和 n 有相同的长度</span></span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">size</span>() != n.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;The input vectors must have the same size.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> N = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> ni : n) &#123;</span><br><span class="line">        N *= ni;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> Ni = N / n[i];</span><br><span class="line">        result += a[i] * Ni * <span class="built_in">mod_inverse</span>(Ni, n[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 例子：解 x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)</span></span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; a = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; n = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> solution = <span class="built_in">chinese_remainder_theorem</span>(a, n);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;The solution is: &quot;</span> &lt;&lt; solution &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="高斯消元"><a href="#高斯消元" class="headerlink" title="高斯消元"></a><a href="https://cloud.tencent.com/developer/article/1087352">高斯消元</a></h2><p>高斯消元法，是线性代数中的一个<a href="https://cloud.tencent.com/developer/tools/blog-entry?target=http://lib.csdn.net/base/datastructure">算法</a>，可用来求解线性方程组，并可以求出矩阵的秩，以及求出可逆方阵的逆矩阵。 高斯消元法的原理是： 若用初等行变换将增广矩阵 化为 ，则<code>AX = B与CX = D</code>是同解方程组。</p>
<p>所以我们可以用初等行变换把增广矩阵转换为行阶梯阵，然后回代求出方程的解。</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/5bynwh32a2.png" alt="image"></p>
<p>构造增广矩阵，即系数矩阵A增加上常数向量b（A|b）  </p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/ahv19vepb0.png" alt="image"></p>
<p> 通过以交换行、某行乘以非负常数和两行相加这三种初等变化将原系统转化为更简单的三角形式（triangular form）    注：这里的初等变化可以通过系数矩阵A乘上初等矩阵E来实现  </p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/s7at02swx8.png" alt="image"></p>
<p> 从而得到简化的三角方阵组，注意它更容易解</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/9uo7gd9be7.png" alt="image"></p>
<p> 这时可以使用向后替换算法(也就是最后的方程向前带) 求解得  <code>z=-4/-4=1, y=4-2z=4-2=2, x= (1-y-z)/2=(1-2-1)/2=-1</code>  </p>
<p>总结上面过程，高斯消元法其实就是下面非常简单的过程</p>
<p><strong>原线性方程组    ——&gt;    高斯消元法   ——&gt;  下三角或上三角形式的线性方程组      ——&gt; 前向替换算法求解（对于上三角形式，采用后向替换算法）</strong></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/f17gajsz1a.png" alt="img"></p>
<p>下面是思路代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义矩阵类型，用于存储方程组的系数矩阵</span></span><br><span class="line"><span class="keyword">typedef</span> vector&lt;vector&lt;<span class="type">double</span>&gt;&gt; Matrix;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高斯消元函数，将方程组化为上三角矩阵</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">gaussian_elimination</span><span class="params">(Matrix&amp; A, vector&lt;<span class="type">double</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 寻找主元素</span></span><br><span class="line">        <span class="type">int</span> pivot_row = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(A[j][i]) &gt; <span class="built_in">abs</span>(A[pivot_row][i])) &#123;</span><br><span class="line">                pivot_row = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 交换当前行和主元素所在行</span></span><br><span class="line">        <span class="built_in">swap</span>(A[i], A[pivot_row]);</span><br><span class="line">        <span class="built_in">swap</span>(b[i], b[pivot_row]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果主元素接近于零，则无法继续计算</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(A[i][i]) &lt; <span class="number">1e-10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将当前行的主元素缩放为1</span></span><br><span class="line">        <span class="type">double</span> pivot = A[i][i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            A[i][j] /= pivot;</span><br><span class="line">        &#125;</span><br><span class="line">        b[i] /= pivot;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用当前行的主元素将下面的行消元</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">double</span> factor = A[j][i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i; k &lt; n; ++k) &#123;</span><br><span class="line">                A[j][k] -= factor * A[i][k];</span><br><span class="line">            &#125;</span><br><span class="line">            b[j] -= factor * b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回代函数，解出方程组的解</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">back_substitution</span><span class="params">(<span class="type">const</span> Matrix&amp; A, <span class="type">const</span> vector&lt;<span class="type">double</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = A.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">x</span><span class="params">(n)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        x[i] = b[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            x[i] -= A[i][j] * x[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例方程组的系数矩阵 A 和右侧常数向量 b</span></span><br><span class="line">    Matrix A = &#123;&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">-3</span>, <span class="number">-1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; b = &#123;<span class="number">8</span>, <span class="number">-11</span>, <span class="number">-3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解线性方程组</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">gaussian_elimination</span>(A, b)) &#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; solution = <span class="built_in">back_substitution</span>(A, b);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Solution:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; solution.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;x[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; solution[i] &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No unique solution exists.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="求质数"><a href="#求质数" class="headerlink" title="求质数"></a><a href="https://oi-wiki.org/math/number-theory/sieve/">求质数</a></h2><h3 id="试除法"><a href="#试除法" class="headerlink" title="试除法"></a>试除法</h3><p>如果我们想要知道小于等于n有多少个素数呢？</p>
<p>一个自然的想法是对于小于等于n每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算质数的代码(暴力根源)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> i, j, count;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; 它的2到100间的质数有: \n&quot;</span>;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">2</span>;i&lt;<span class="number">100</span>;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        count = <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;i;j++)<span class="comment">//判断i是否为质数，若count==0则为质数  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(i%j == <span class="number">0</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                count++;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)  </span><br><span class="line">        &#123;  </span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在前面的基础上，加上了合数优化：</p>
<ul>
<li><p>如果一个数是合数（不是素数），那么它可以被分解为两个或更多个正整数的乘积。</p>
</li>
<li><p>如果一个数 <code>n</code> 是合数，那么它的最小因子（除了1以外）一定不会大于它的平方根 <code>sqrt(n)</code>。</p>
</li>
</ul>
<blockquote>
<p>基于这两个观察，可以得出合数优化的原理：</p>
<ul>
<li><strong>在判断一个数是否为素数时，只需要检查从2到该数的平方根的整数范围内是否存在能整除该数的整数，而不必遍历整个范围直到该数本身。</strong></li>
</ul>
<p>这是因为如果一个数 <code>n</code> 是合数，那么它一定可以被表示为 <code>n = a * b</code>，其中 <code>a</code> 和 <code>b</code> 是两个大于1的整数。如果 <code>a</code> 大于 <code>sqrt(n)</code>，那么 <code>b</code> 必然小于 <code>sqrt(n)</code>，因为 <code>a * b = n</code>。因此，我们只需要检查从2到 <code>sqrt(n)</code> 的整数范围内是否存在能整除 <code>n</code> 的整数，如果存在，就可以确定 <code>n</code> 是合数。如果不存在，那么 <code>n</code> 就很可能是素数。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加上合数优化</span></span><br><span class="line"><span class="comment">//这里解决的是，判断这个数据是否为质数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">i_p</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//如果一个数是合数（不是素数），那么它的最小因数一定不会超过它的平方根</span></span><br><span class="line">    <span class="comment">//这个属性可以用反陈述来证明。设 a 和 b 是 n 的两个因子，使得 a*b = n。如果两者都大于 √n，则 a.b &gt; √n， * √n，这与表达式 “a * b = n” 相矛盾。（可以理解为 a 和 b 最大就 √n）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=x/i;i++)</span><br><span class="line">        <span class="keyword">if</span>(x%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">i_p</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="试除法求约数"><a href="#试除法求约数" class="headerlink" title="试除法求约数"></a>试除法求约数</h3><p>前面利用试除法判断一个数据是否为质数，现在求n这个数据内部有多少约数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">get_divisors</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=x/i;i++)</span><br><span class="line">    <span class="comment">//整除流入</span></span><br><span class="line">        <span class="keyword">if</span>(x%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果i是质因数 - 塞入res数组中</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i); </span><br><span class="line">            <span class="comment">//除数相等的情况 就只有i了嘛</span></span><br><span class="line">            <span class="keyword">if</span>(i!=x/i) res.<span class="built_in">push_back</span>(x/i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排个序 (可不可以用 set存储啊)</span></span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (n -- )&#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">get_divisors</span>(x);</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">auto</span> x:res) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码用于计算一组整数的最小公倍数的约数个数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; primes; <span class="comment">// 使用哈希表存储质因数及其指数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分解质因数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                x /= i;</span><br><span class="line">                primes[i]++; <span class="comment">// 记录每个质因数的指数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x &gt; <span class="number">1</span>)</span><br><span class="line">            primes[x]++; <span class="comment">// 如果剩余的数大于1，说明它本身是一个质数，记录其指数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p : primes) &#123;</span><br><span class="line">        res = res * (p.second + <span class="number">1</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif" alt="定义"></p>
<p>埃拉托色尼筛的原理是这样的：</p>
<ul>
<li>首先，把所有小于等于n的自然数都列出来，从2开始，把1排除掉。</li>
<li>然后，从2开始，把它的所有倍数都标记为合数，也就是不是素数的数。</li>
<li>接着，<strong>找到下一个没有被标记的数，它一定是素数</strong>，然后把它的所有倍数都标记为合数。重复这个过程，直到没有更多的没有被标记的数为止。</li>
<li>最后，所有没有被标记的数就是素数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N],cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(st[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//  primes[cnt++] = i;的作用是把i这个素数存入primes数组中</span></span><br><span class="line">        <span class="comment">//  并且把cnt加一，表示素数的个数增加了一个。</span></span><br><span class="line">        primes[cnt++] = i;</span><br><span class="line">        <span class="comment">//  这个循环的作用是把i的所有倍数都标记为合数，也就是非素数。</span></span><br><span class="line">        <span class="comment">//  这样，当i增加时，就可以跳过已经被标记为合数的数字，只考虑没有被标记的数字，因为它们可能是素数。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i+i;j&lt;=n;j+=i) st[j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线性筛法"><a href="#线性筛法" class="headerlink" title="线性筛法"></a><a href="https://www.jianshu.com/p/f16d318efe9b">线性筛法</a></h3><p>线性筛法的主要思想是，对于每个数x，只考虑它的最小质因数。初始时，将每个合数（非素数）标记为其最小质因数。然后，从小到大遍历2到n的整数，如果某个数x还没有被标记为合数，那么它就是素数，并且将它的倍数标记为x。</p>
<p>线性筛法的关键是避免多次标记。对于每个数x，它只会被其最小质因数标记一次，因此不会重复标记。这使得线性筛法的时间复杂度相对较低，比传统的埃拉托斯特尼筛法更高效，特别是在生成大量素数时。</p>
<blockquote>
<p>以下是线性筛法的基本步骤：</p>
<ol>
<li>初始化一个布尔数组（或标记数组）<code>is_prime</code>，用于标记每个整数是否为素数。初始时，所有数都标记为素数。</li>
<li>初始化一个数组<code>primes</code>，用于存储生成的素数。初始时，<code>primes</code>为空。</li>
<li>从2开始遍历到n的每个整数x：<ul>
<li>如果<code>is_prime[x]</code>为true，表示x是素数，将x添加到<code>primes</code>数组中。</li>
<li>对于x的每个质因数p（p从2开始，逐渐增加），将x * p标记为合数，并将最小质因数设置为p。</li>
<li>如果x被标记为合数后，跳出内层循环。</li>
</ul>
</li>
<li>当遍历完2到n的所有整数后，<code>primes</code>数组中就包含了所有小于等于n的素数。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.线性筛法（埃拉托色尼筛优化版）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N= <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> primes[N], cnt;</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">get_primes</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) primes[cnt ++ ] = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; primes[j] &lt;= n / i; j ++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//primes[j] * i这个数标记为合数</span></span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。</span></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">get_primes</span>(n);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="求组合数"><a href="#求组合数" class="headerlink" title="求组合数"></a><a href="https://segmentfault.com/a/1190000005072018">求组合数</a></h2><h3 id="组合计数"><a href="#组合计数" class="headerlink" title="组合计数"></a>组合计数</h3><p> 在中学数学中，我们其实已经学会了组合数的公式了，基础的公式是：</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/webp.webp" alt="img"></p>
<p>线性写法为：<code>c(m,n) = m!/((m-n)!*n!)</code></p>
<p>但是，如果按照公式计算，时间复杂度非常高，下面是一个原始组合数模版代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算组合数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">combination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">factorial</span>(n) / (<span class="built_in">factorial</span>(k) * <span class="built_in">factorial</span>(n - k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入总数n：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入要选择的元素数k：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">combination</span>(n, k);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;组合数 C(&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个代码使用的是递归的思想，来计算这个组合数，当然在这个模版的基础上，我们也可以将之优化.</p>
<hr>
<p>采用阶乘计算稍大数组合数是不合适的，而且效率不高，但是可以先对公式进行转换然后再进行计算：<br> <strong>1.对公式两边取自然对数</strong></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/2475558-a800e7d9bea07740.webp" alt="2475558-a800e7d9bea07740"></p>
<p><strong>2.根据对数性质进行转换</strong></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/2475558-576a246a59455baa.webp" alt="2475558-576a246a59455baa"></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/2475558-14dada8828552c4c.webp" alt="2475558-14dada8828552c4c"></p>
<ul>
<li><p>消除相同项<img src="/2023/04/28/%E6%95%B0%E8%AE%BA/2475558-cd4aabbfde8e8344.webp" alt="2475558-cd4aabbfde8e8344"></p>
</li>
<li><p>到这就已经将阶乘转换成对数连加，极大的降低了运算的复杂度。另外，依据组合数性质：<img src="/2023/04/28/%E6%95%B0%E8%AE%BA/2475558-5cf3a8040bf13892.webp" alt="2475558-5cf3a8040bf13892"></p>
</li>
</ul>
<p>当 <code>n &gt; m/2 </code>时，<code>n 相对于 m - n </code>是一个较大的数，此时可以取 <code>n = m - n</code>进行计算。</p>
<p><strong>3.进行计算</strong><br> 以第2步得到的公式计算出</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/2475558-b30e33e52cf70ad7.webp" alt="img"></p>
<p>的值，然后再取反对数就可以得到组合数结果了。</p>
<p>用这种方法计算组合数，如果只计算<code>ln(C(m,n))</code>的话，<code>n</code>可以取到整型数据的极限值<code>65535，ln(C(65535,32767)) = 45419.6</code></p>
<p>而计算时间可以达到毫秒级。当然，如果要取反对数得到最终的组合数的话，m的取值就不能达到这么大了，但是这种算法仍然可以保证m取到<code>1000</code>以上。</p>
<hr>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算组合数的自然对数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">logCombination</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> result = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        result += <span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(n - i + <span class="number">1</span>)) - <span class="built_in">log</span>(<span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入总数n：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入要选择的元素数k：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">exp</span>(<span class="built_in">logCombination</span>(n, k)); <span class="comment">// 恢复为普通数值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;组合数 C(&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; k &lt;&lt; <span class="string">&quot;) = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p>卢卡斯定理（Lucas’s Theorem）是一种与组合数和模运算相关的数学定理，它扩展了二项式定理的应用，特别适用于计算组合数模素数的情况。该定理以法国数学家Édouard Lucas的名字命名。</p>
<p>卢卡斯定理的主要内容是描述如何将组合数C(n, k) 模素数p 分解为更小的组合数的乘积，然后再模p运算。具体来说，定理陈述如下：</p>
<p>对于给定的正整数n、k 和素数p（p 必须大于n），可以将组合数C(n, k) 模p 分解为以下形式的乘积：</p>
<p>C(n, k) ≡ C(n mod p, k mod p) * C(n&#x2F;p, k&#x2F;p) (mod p)</p>
<p>其中，C(n mod p, k mod p) 表示将n 和k 分别模p 后的余数所对应的组合数，C(n&#x2F;p, k&#x2F;p) 表示将n 和k 分别除以p 后的商所对应的组合数。</p>
<p>卢卡斯定理在计算组合数模素数时非常有用，因为它可以将大的组合数分解成小的组合数，并通过模运算得到结果，从而避免大整数计算。</p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230317192018240.png" alt="image-20230317192018240"></p>
<p><img src="/2023/04/28/%E6%95%B0%E8%AE%BA/image-20230317192035378.png" alt="image-20230317192035378"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">20</span>][<span class="number">20</span>];<span class="comment">//定义二维数组，用来中间存储计算结果 </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">cmn</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;     </span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=m;++i)  <span class="comment">//循环m步，从0开始 </span></span><br><span class="line">       <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=n;++j)  <span class="comment">//循环n步，也是从0开始  </span></span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>||i==j)    <span class="comment">//当i等于0或者i等于j时，直接赋值为1 </span></span><br><span class="line">           f[i][j]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">           f[i][j]=f[i<span class="number">-1</span>][j<span class="number">-1</span>]+f[i<span class="number">-1</span>][j];<span class="comment">//其他的都是在上一步的计算结果上加+1，依次类推</span></span><br><span class="line">     <span class="keyword">return</span> f[m][n];  <span class="comment">//返回结果 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> m,n;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;请输入任意m.n来得到组合数：&quot;</span>;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> result=<span class="built_in">cmn</span>(m,n);</span><br><span class="line">    cout&lt;&lt;m&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;=&quot;</span>&lt;&lt;result&lt;&lt;endl; <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
