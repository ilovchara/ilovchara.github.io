<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构 - 图论 | Jane Station</title><meta name="author" content="chara"><meta name="copyright" content="chara"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="图论  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构 - 图论">
<meta property="og:url" content="https://www.wniee.cn/2023/04/28/%E5%9B%BE%E8%AE%BA/index.html">
<meta property="og:site_name" content="Jane Station">
<meta property="og:description" content="图论  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251544299.jpg">
<meta property="article:published_time" content="2023-04-28T01:05:38.000Z">
<meta property="article:modified_time" content="2023-09-05T14:55:46.523Z">
<meta property="article:author" content="chara">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251544299.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://www.wniee.cn/2023/04/28/%E5%9B%BE%E8%AE%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chara","link":"链接: ","source":"来源: Jane Station","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构 - 图论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-05 22:55:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/c/font_4222343_dr0clxta0zj.css"><link rel="stylesheet" href="/css/comment/Navigation_Bar.css"><link rel="stylesheet" href="/css/comment/self.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/picture/img/Vigus.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="icat_menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="icat_menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="icat_menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="icat_menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="icat_menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="icat_menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251544299.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Jane Station"><span class="site-name">Jane Station</span></a></span><div id="menus"></div><div class="menus_items"><div class="icat_menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="icat_menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="icat_menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="icat_menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="icat_menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="icat_menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构 - 图论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-28T01:05:38.000Z" title="发表于 2023-04-28 09:05:38">2023-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-09-05T14:55:46.523Z" title="更新于 2023-09-05 22:55:46">2023-09-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构 - 图论"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><p>  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学习。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>  要了解上述两个遍历模型，就要了解二叉树。二叉树是图的一种特殊造型，二叉树有两种主要形式：满二叉树和完全二叉树.满二叉树的深度和结点是有关系的，一个深度为k的满二叉树，它的节点数是2^k - 1（每一层是两个，减去我们的头结点就ok了）</p>
<h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>  完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数 都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h层，则该层包含 1~ 2^h -1 个节点。（就是叶子结点左边可以不满，其他必须满是这个意思是吗）。</p>
<p>​        <img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216131827500-16923746582101.png" alt="image-20230216131827500"></p>
<blockquote>
<p>二叉搜索树（建立在完全二叉树的基础之上）<br>有如下的规则（简单来说，左边的都是小于根节点，右边的都是大于根节点）<br> 若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；<br> 若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；<br> 它的左、右⼦树也分别为⼆叉排序树</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308312338279.png" alt="image-20230216133015856"></p>
<h4 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h4><p>平衡⼆叉搜索树：又被称为AVL<code>（Adelson-Velsky and Landis）</code>树，且具有以下性质：它是 ⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。（高度差 注意是高度差！！！！！）</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216133247245-16923744811933.png" alt="image-20230216133247245"></p>
<h4 id="用数组实现二叉树"><a href="#用数组实现二叉树" class="headerlink" title="用数组实现二叉树"></a>用数组实现二叉树</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216134441813-16923744802222.png" alt="image-20230216134441813"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">⽤数组来存储⼆叉树如何遍历的呢？ 如果⽗节点的数组下表是i，那么它的左孩⼦就是i * <span class="number">2</span> + <span class="number">1</span>，右孩⼦就是 i * <span class="number">2</span> + <span class="number">2</span>。 </span><br><span class="line">但是⽤链式表⽰的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。</span><br><span class="line">所以⼤家要了解，⽤数组依然可以表⽰⼆叉树</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的链式实现"><a href="#二叉树的链式实现" class="headerlink" title="二叉树的链式实现"></a>二叉树的链式实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;<span class="comment">//定义left指针 指向左子树</span></span><br><span class="line">  TreeNode *right;<span class="comment">//right指针 指向右子树</span></span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="用二叉树理解递归"><a href="#用二叉树理解递归" class="headerlink" title="用二叉树理解递归"></a>用二叉树理解递归</h4><p>实现递归的三要素：</p>
<blockquote>
<ol>
<li>确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。</li>
<li>确定终⽌条件： 写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者 终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果 递归没有终⽌，操作系统的内存栈必然就会溢出。</li>
<li>确定单层递归的逻辑：<br>确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程</li>
</ol>
</blockquote>
<p>为什么用二叉树可以实现递归，首先让我们回到二叉树中。如果我们搜索一个二叉树的随机节点的值，应该怎么办。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216134441813-16923744802222.png" alt="image-20230216134441813"></p>
<p>如果我们要查找e这个位置的数据，依靠上帝视角我们可以直接0-1-4即可查询。但是如果这个树十分庞大导致无法一眼看出，而且计算机也无法做到这么复杂的识别方式，那我们怎么做。</p>
<p>最简单的方法就是一条线查找下去（从左到右）或者说一层层查找（从上到下）。那这个和递归有什么关系呢。</p>
<p>我们现在是在一个二叉树内找数据，从一个节点到另一个节点只有两种方式，要么向左要么向右。而每个节点只有两种情况，要么有值要么没值。遍历的过程每一条线都是独立的，且每次遍历都高度相似（因为向下延伸只有两种方式）。终止条件就是找到我们需要的值。所以说这样的遍历方式符合使用递归的情况，一下是实现递归的具体步骤。</p>
<blockquote>
<p>下面用递归实现二叉树的遍历，二叉树的遍历有三种。前中后序遍历，但是基本上是差不多的，我们可以通过这三个遍历来看看改变递归函数的语句会产生什么变化。</p>
</blockquote>
<p>在遍历构造之前，我们先构造树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;<span class="comment">//定义left指针 指向左子树</span></span><br><span class="line">  TreeNode *right;<span class="comment">//right指针 指向右子树</span></span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数  </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h5><p>前序遍历（对于单独）的逻辑是，从根节点出发，找到左子树，再到右子树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">  <span class="type">int</span> val;</span><br><span class="line">  TreeNode *left;<span class="comment">//定义left指针 指向左子树</span></span><br><span class="line">  TreeNode *right;<span class="comment">//right指针 指向右子树</span></span><br><span class="line">  <span class="built_in">TreeNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">left</span>(<span class="literal">NULL</span>),<span class="built_in">right</span>(<span class="literal">NULL</span>)&#123;&#125;<span class="comment">//构造函数  </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PT</span><span class="params">(TreeNode root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果访问的节点没有子节点</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">nullptr</span> == root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印遍历的节点数据</span></span><br><span class="line">    cout&lt;&lt;root-&gt;data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历左子树</span></span><br><span class="line">    <span class="built_in">PT</span>(root -&gt; left);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历右子树</span></span><br><span class="line">    <span class="built_in">PT</span>(root -&gt; right);    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>中序遍历的逻辑是，从左子树出发，到根节点，再到右节点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//和上面相比，就改变了顺序</span></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的逻辑是通过<code>inorderTraversal(root-&gt;left);</code>这个语句到达我们的最下左节点，然后执行打印<code> cout &lt;&lt; root-&gt;data &lt;&lt; &quot; &quot;;</code>最后查询当前遍历到节点的右节点，直到最后没有节点为止。</p>
</blockquote>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>后序遍历的逻辑是左子树到右子树到根节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//一样的改变顺序</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们只针对于遍历到第一个节点来思考，如果我们需要打印这个节点就需要执行前面两个语句，<code>postorderTraversal(root-&gt;left);</code>和<code>postorderTraversal(root-&gt;right);</code>。我们<strong>执行完了第一个语句</strong>，这个时候就返回了<code>root -&gt; 树中最左的节点（执行的是一个函数嘛）</code>，然后执行第二个函数<code>postorderTraversal(root-&gt;right);</code>由于这个函数查询了当前这个节点<code>(root -&gt; 树中最左的节点（执行的是一个函数嘛）)-&gt;right</code> 这个结果，其实就是<code>null</code>。所以说当前这个递归的其中一个函数结束了，也就是打印了第一个值。</p>
<p>结束了递归中的第一个函数，不代表全部函数都结束了。由第一个函数引发的全部函数（大概是2的倍数差不多），还在继续运行以第一个函数举例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorderTraversal</span><span class="params">(TreeNode* root-&gt;left)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//当执行完这两个句子的时候，就会打印值</span></span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left-&gt;left);</span><br><span class="line">    <span class="built_in">postorderTraversal</span>(root-&gt;left-&gt;right);</span><br><span class="line">    cout &lt;&lt; root-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样你就能理解了吗，再说下去就会乱了。执行完全部子函数，就可以执行完这个递归函数了。</p>
</blockquote>
<h5 id="层序遍历（补充）"><a href="#层序遍历（补充）" class="headerlink" title="层序遍历（补充）"></a>层序遍历（补充）</h5><p>层序遍历，就是从根节点出发，一层一层的遍历我们的树。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一排一排的遍历 利用队列的特性哟，将根结点入队列 然后然后出入队列，出队列后将其左右孩子结点入队列</span></span><br><span class="line"><span class="comment">//直到队列为空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SeqTraverse</span><span class="params">(BiTree tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SeqQueue queue = <span class="built_in">Init_SeqQueue</span>();</span><br><span class="line">	<span class="built_in">Push_SeqQueue</span>(queue, tree);</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">IsEmpty_SeqQueue</span>(queue))</span><br><span class="line">	&#123;</span><br><span class="line">		BiTree root = <span class="built_in">Pop_SeqQueue</span>(queue);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, root-&gt;data);</span><br><span class="line">        <span class="comment">//遍历两个孩子就行 - 因为是二叉树嘛</span></span><br><span class="line">		<span class="keyword">if</span> (root-&gt;lchild)</span><br><span class="line">			<span class="built_in">Push_SeqQueue</span>(queue, root-&gt;lchild);</span><br><span class="line">		<span class="keyword">if</span>(root-&gt;rchild)</span><br><span class="line">			<span class="built_in">Push_SeqQueue</span>(queue, root-&gt;rchild);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图的介绍"><a href="#图的介绍" class="headerlink" title="图的介绍"></a>图的介绍</h3><p>图，是一种抽象的数据结构，在我们学习数学的时候，最早接触的图像就是三角形，三角形的属性有三个边，并且是封闭的。在数据结构中，图的理论也和我们的数学是一样的，在其基础之上，我们衍生出了节点，和边集关系。用这些属性，可以帮助我们快速的构造一个像样的图。</p>
<p>对于图，我们可以这样理解，就是节点与节点之间的关系，且关系成环（至少有一个环），如果没有环的话，其实是一种特殊的图像，也就是二叉树。节点彼此的关系，可以理解为边，毕竟声明一个图主要用途就是寻找路径和定位。在此基础上增加了几个定义。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809211226304.png" alt="image-20230809211226304"></p>
<p>相对比而言，图严格证明的定义是十分多的，如果要细究会十分抽象和麻烦。我们这边就记几个比较常用语算法中的概念，如果有需要可以去翻维基百科，里面有详细的定义和概念。</p>
<p>首先我们需要了解，组成一个图需要什么，你可能会说，找几个定点将之链接起来，围成一片区域，这样形成的图像不就是图吗。但是，严格来说，单个节点其实也是个图，这样的图被称之为<strong>独立节点</strong>-最简单的图像。这里就引出了图中的第一个概念，顶点。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809212302594.png" alt="image-20230809212302594"></p>
<p>在这一张图中，顶点其实没有属性，只有编号，但是顶点可以赋值属性。这就要具体题目具体分析*。类似于我们城市的路线图。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809212603095.png" alt="image-20230809212603095"></p>
<p>在这些图中，每个节点都有相应的关系，通过一个线来表示。这个被我们称之为<strong>边</strong>，边中可以赋值，上面的城市路线图，边就承接了两个城市之间的距离这个信息。对于边我们可以用邻接矩阵来承接边的信息，这个信息被称之为<strong>权</strong>。下面就举一个简单的例子。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码 - 二维数组表示邻接矩阵</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 每一个位置表示一个顶点</span></span><br><span class="line">f[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果我们有四个节点 1 2 3 4 那么</span></span><br><span class="line">f[<span class="number">1</span>][<span class="number">2</span>]; <span class="comment">//表示1链接2</span></span><br><span class="line">f[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>; <span class="comment">//表示1节点到2节点的边权为1</span></span><br></pre></td></tr></table></figure>

<p>在这里我们只举了单向的边来表示，只有单向的边的图叫做<strong>有向图</strong>，如果链接之间没有方向，那么被称之为<strong>无向图</strong>。前面说，二叉树是一种特殊的图，但是树有一个特点，就是不存在环，但是一般出现的图呢，很正常会出现<strong>环</strong>，那么环的概念是什么呢。</p>
<p><strong>图环</strong>（Cycle）是指图中的一条路径，它从一个顶点出发，经过一系列不同的顶点，最后回到起始顶点，形成一个闭合的回路。换句话说，图环是一个不包含重复顶点的路径，其起始顶点和终止顶点相同，并且至少包含3条边（或2个顶点）。</p>
<p>从这个概念，我们可以得到环的特殊变式，<strong>连通图</strong>和<strong>强连通图</strong>。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809214600123.png" alt="image-20230809214600123"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809214636189.png" alt="image-20230809214636189"></p>
<p>具体细节可以看这篇<a target="_blank" rel="noopener" href="http://data.biancheng.net/view/201.html">博客</a>,我的理解是，<strong>联通图是，从一个节点可以到达任意的节点。强连通图是在连通图的基础上，有两个方向都可通行。</strong>如果让你编写一个程序判断图是否是连通图你会写吗？其实很简单，只要将我们图中的每个节点遍历一遍即可，遍历到说明在图中，遍历不到说明在这之外。这就是我们之后会涉及到的，图的遍历的两种方法，深度优先遍历和广度优先遍历（不过图还是深度用的多）。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809220406017.png" alt="image-20230809220406017"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809220953852.png" alt="image-20230809220953852"></p>
<p>下一个概念是，<strong>子图</strong>，也被称之为图的子集。如果我们需要求得一个图有多少个子集，可以使用幂集的概念。一个包含n个元素的集合的幂集包含2^n个子集，其中包括空集和全集。对于图来说，子集的数量与图的顶点数量有关。假设图有n个顶点，那么图的所有可能子集数量为2^n。这是因为每个顶点都可以选择是否包含在子集中，有包含和不包含两种选择，所以总的可能性是2^n。具体到图的应用中，可以将每个顶点看作是一个元素，然后使用幂集的概念计算子集的数量。这在某些问题中可能是有用的，例如在某些组合问题中，需要考虑图中的顶点子集。需要注意的是，幂集包括空集和全集，所以实际有效的非空子集数量是2^n - 1。</p>
<p>子图对于我们将图转化为树或者说森林也有帮助，这里就不在赘述。在离散数学中也有对于的体型，感兴趣可以去看看离散数学。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809221018966.png" alt="image-20230809221018966"></p>
<p>完全图： 具有n个顶点的无向图，每一对不同的顶点之间都存在一条边。两点关系的一种特殊情况。知道概念就行。一般来说也不是很常见，和普通的图一样。</p>
<p>度数：和树的概念其实是一样的，这里就表示的是当前顶点连接了几个其他顶点。然后出度表示出去的边的数量，入度表示进来的边的数量。</p>
<p>邻接矩阵和邻接表等等讲，就是用来表示图的结构的一种数据结构。下面是总概念，可以简单看看，建议结合教材。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809221035439.png" alt="image-20230809221035439"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230809213919067.png" alt="image-20230809213919067"></p>
<h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><p>在讲遍历之前，我们先讲几个常见的存储图的方式。</p>
<h5 id="领接矩阵"><a href="#领接矩阵" class="headerlink" title="领接矩阵"></a>领接矩阵</h5><p>开一个二维数组，每一个数组位置相当于一个二维坐标，每个二位坐标存储图中的一个数据。图是二维的嘛，所以说用二维数组存储很好理解。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230305080127311.png" alt="image-20230305080127311"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//领接矩阵声明，开一个二维数组； 1.二维数组w[u][v],存储u - v的边权（就是这个连线多长）2.只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）</span></span><br><span class="line"><span class="comment">//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> w[N][N]; <span class="comment">//声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c</span></span><br><span class="line"><span class="type">int</span> vis[N];<span class="comment">//点集</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,u,v,w[u][v]);</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        w[a][b] = c; <span class="comment">//赋予权值（a点 和 b点）（算是连线）</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>但是如果矩阵的点很散，例如三个点<code>（1,1）,(10000,10000),(100000,100000)</code>,那么开的空间很多都会被浪费，所以说只适合用于稠密图。</p>
</blockquote>
<h5 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230305080154969.png" alt="image-20230305080154969"></p>
<p>声明了一个结构体，存储我们两个节点对应的边。好处就是不用按照数组下标开对应大的数组。其实很好理解，声明两个变量存储对应的节点序列，然后声明一个变量存储权即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边集数组</span></span><br><span class="line"><span class="comment">//结构体下标联系三者</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>()&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w; <span class="comment">//两点 和 权</span></span><br><span class="line">&#125;e[M]; <span class="comment">//边集合</span></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">//点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v,w = e[i].w; <span class="comment">//用结构体中对应的值</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>,u,v,w); <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>; <span class="comment">//这个点到过了</span></span><br><span class="line">        <span class="built_in">dfs</span>(e[i].v);<span class="comment">//下一个点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[i] = &#123;a,b,c&#125;;</span><br><span class="line">        <span class="comment">//e[i] = &#123;b,a,c&#125;; //无向图就要加上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="领接表"><a href="#领接表" class="headerlink" title="领接表"></a>领接表</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302110544398.png" alt="image-20230302110544398"></p>
<p>对于每个节点，领接表创建的结构体数组，存储的是当前节点的所有出边（和图的出度是一个概念），结构体中声明两个变量，一个存储当前节点指向的节点，一个存储连接的边权。（不过我刚开始理解的时候，对于这个<code>vector&lt;edge&gt; e[N]</code>理解的有点抽象，感觉是数组的数组，但是确实是:joy:）</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230831223534628.png" alt="image-20230831223534628"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//领接表（将图用dfs序输出）</span></span><br><span class="line"><span class="comment">//出边数组e[u][i] 存储u点的所有出边&#123;终点 v ， 边权 w&#125;。</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edga</span>&#123;<span class="type">int</span> v,w;&#125;; <span class="comment">//声明结构体（代表每个点有的属性）</span></span><br><span class="line">vector&lt;edga&gt; e[N];<span class="comment">//存储的是每一个起点（有n个）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u]) <span class="comment">//遍历当前层的元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;<span class="comment">//判重（父节点记录父节点是否走过）（u和fa是交替使用的）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d，%d,%d\n&quot;</span>,u,v,w);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);<span class="comment">// （u,fa,v,u,v,u.......） //fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）</span></span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//无向图 两边都要连接</span></span><br><span class="line">        e[a].<span class="built_in">push_back</span>(&#123;b,c&#125;);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(&#123;c,b&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父节点是相互的，我们用领接表存储的时候，只要连接就是父和子的叠加态（这也解释了为什么可以回溯）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链式领接表"><a href="#链式领接表" class="headerlink" title="链式领接表"></a>链式领接表</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302111110291.png" alt="image-20230302111110291"></p>
<p>与前面的领接表不同，是按照输入循序给与节点编号，按照编号存储我们的出边的信息，并且用这些信息构造一个数组<code>h[N]</code>来存储。然后在一个桶数组，以编号的形式插入我们的数据，就构成了一个链式领接表（是尾插法，<code>vector</code>变长数组）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式领接表</span></span><br><span class="line"><span class="comment">/*两个变量：1.边集数组 2.表头数组</span></span><br><span class="line"><span class="comment">1.边集数组存储的是第几条边的属性：e[j]存储第j条边的&#123;起点u，终点v，边权w&#125;</span></span><br><span class="line"><span class="comment">2.表头数组存储的是u点的所有出边的编号：h[u][j](u表示的是当前的点)（j表示的是当前点连接的出边）*/</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> u,v,w&#125;;</span><br><span class="line">vector&lt;edge&gt; e; <span class="comment">//边集合（边的属性）</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; h[N]; <span class="comment">//点的所有出边</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e.<span class="built_in">push_back</span>(&#123;a,b,c&#125;); <span class="comment">// 对应边的属性压入</span></span><br><span class="line">    h[a].<span class="built_in">push_back</span>(e.<span class="built_in">szie</span>()<span class="number">-1</span>); <span class="comment">//当前边权数组的大小-1（这里的应该是桶数组）    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//u当前节点 fa-父节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;h[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="type">int</span> j = h[u][j];<span class="comment">//表示的是当前的点？</span></span><br><span class="line">        <span class="type">int</span> v = e[j].v,w = e[j].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//邻接表存储数据</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);<span class="comment">// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h5><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302112003101.png" alt="image-20230302112003101"></p>
<p>e数组表示的是每一个出边的编号，现在相当于是双向的了（<code>1-4</code>的同时也<code>4-1</code>）,h数组表示出边的编号，编号用节点的编号表示就行，反正每一个节点都是独一无二的。然后在桶数组中，以链表的形式存储就行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w,ne;&#125;;<span class="comment">//ne是链接点的编号 - 例如1-4</span></span><br><span class="line">edge e[M]; <span class="comment">// 存储的是所有的边</span></span><br><span class="line"><span class="type">int</span> idx,h[N]; <span class="comment">//点的第一条出边（每个点都有）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取第一个出边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = &#123;b,c,h[a]&#125;; <span class="comment">// e结构体存储的是这个边的信息</span></span><br><span class="line">    <span class="comment">//idx给每一个边都搞一个编号 - 独一无二的</span></span><br><span class="line">    h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//横向遍历是为了回溯</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u];~i;i=e[i].ne)&#123; <span class="comment">//~i表示i不等于-1</span></span><br><span class="line">        <span class="type">int</span> v = e[i].v,w = e[i].w;</span><br><span class="line">        <span class="keyword">if</span>(v == fa) <span class="keyword">continue</span>;<span class="comment">//判重 回溯</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);</span><br><span class="line">        <span class="built_in">dfs</span>(v,u);/深入</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);<span class="comment">//初始化表头</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="comment">//无向图构图</span></span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302112236202.png" alt="image-20230302112236202"></p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a><a target="_blank" rel="noopener" href="https://www.cxyxiaowu.com/9854.html">图的遍历</a></h3><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230216151302883.png" alt="遍历逻辑"></p>
<p>讲完了二叉树的遍历，我们来讲讲图的遍历，图和二叉树的逻辑其实也是一样的（因为二叉树也是图）。下面讲讲用深度优先遍历和程序遍历来遍历我们的图。</p>
<p>但是对于图来说，遍历不像二叉树一样简单了，二叉树每个节点最多两个选择，但是对于图来说，每个节点连接的节点数是不一样的，导致递归次数会比树多很多。</p>
<h4 id="dfs过程的实现"><a href="#dfs过程的实现" class="headerlink" title="dfs过程的实现"></a>dfs过程的实现</h4><p>深度优化遍历( <strong>Depth First Search</strong> )，也有称为 <strong>深度优化搜索</strong> ，简称为 <strong><code>DFS</code></strong> 。事实上，我们在树的遍历中早已涉及<code>DFS</code>，层序遍历、中序遍历和后序遍历都属于深度优先遍历的方式，因为这些遍历方式本质上都归结于<strong>栈</strong>。为了讲清楚<code>DFS</code>，我们先来看两个概念。</p>
<p><strong>右手原则：</strong> 在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。</p>
<p><strong>左手原则：</strong> 在没有碰到重复顶点的情况下，分叉路口始终是向左手边走，每路过一个顶点就做一个记号。</p>
<p>本文约定以<strong>右手原则</strong>进行深度优先遍历。废话不多说，我们以下图说明深度优先搜索。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850315-3ce63cac0c52019-1693495997261-22.png" alt="1589850315-3ce63cac0c52019"></p>
<p>原则上，我们可以从图中的任何一个顶点开始，进行深度优先遍历，假设我们从顶点A开始，遍历过程中的每一步如下：</p>
<p>第一步：从顶点A开始，将顶点A标记为已访问顶点。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850315-906ab179bb5b850-1693496008513-24.png" alt="1589850315-906ab179bb5b850"></p>
<p>第二步：根据约定的右手原则，访问顶点B，并将B标记为已访问顶点。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850315-906ab179bb5b850-1-1693496019174-26.png" alt="1589850315-906ab179bb5b850-1"></p>
<p>第三步：右手原则，访问顶点C</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850316-453854f971022e4-1693496121022-34.png" alt="1589850316-453854f971022e4"></p>
<p>第四步：右手原则，访问顶点D</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850316-6b252e146243857-1693496098000-30.png" alt="1589850316-6b252e146243857"></p>
<p>第五步：右手原则，访问顶点E</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850316-6600fddac3ef23a-1693496111738-32.png" alt="1589850316-6600fddac3ef23a"></p>
<p>第六步：右手原则，访问顶点F</p>
<p><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202309041521437.png" alt="第六步"></p>
<p>第七步：右手原则，应该先访问顶点F的邻接顶点A，但发现A已被访问，则访问除A之外的最右侧顶点G。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850317-1becc6e66c4855c-1693496129403-36.png" alt="1589850317-1becc6e66c4855c"></p>
<p>第八步：右手原则，先访问顶点B，顶点B已被访问；再访问顶点D，顶点D已经被访问；最后访问顶点H。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850317-9b188e21831899e-1693496146605-38.png" alt="1589850317-9b188e21831899e"></p>
<p>第九步：发现顶点H的邻接顶点均已被访问，则退回到顶点G;</p>
<p>第十步：顶点G的邻接顶点均已被访问，则退回到顶点F；</p>
<p>第十一步：顶点F的邻接顶点已被访问，则退回到顶点E；</p>
<p>第十二步：顶点E的邻接顶点均已被访问，则退回到顶点D；</p>
<p>第十三步：顶点D的邻接顶点I尚未被访问，则访问顶点I；</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1589850318-e17b709eef68580-1693496178677-42.png" alt="1589850318-e17b709eef68580"></p>
<p>第十四步：顶点I的邻接顶点均已被访问，则退回到顶点D;</p>
<p>顶点D的邻接顶点均已被访问，退回到顶点C；顶点C的邻接顶点均已被访问，则退回到顶点B；顶点B的邻接顶点均已被访问，则退回到顶点A，顶点A为<strong>起始顶点</strong>，深度优先搜索结束。</p>
<blockquote>
<p>上述步骤记录的递归遍历图的过程，可以发现，是从一个节点出发一直延伸到全部。</p>
<p>如果我们只看第一次遍历到的节点，只需要判断当前节点的下一个为位置是否为空，不为空打印，为空就返回<code>null</code>,然后每经过一个节点就记录该节点已经遍历过了。</p>
<p>而对于每一个节点来说，都可以利用这一个函数。所以说就构造递归函数实现遍历。</p>
</blockquote>
<p>下面是实现递归的模版：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition for a binary tree node.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">level</span>(root, <span class="number">0</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">level</span><span class="params">(TreeNode* root, <span class="type">int</span> level, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (result.<span class="built_in">size</span>() == level) result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">        result[level].<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left) <span class="built_in">level</span>(root-&gt;left, level + <span class="number">1</span>, result);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right) <span class="built_in">level</span>(root-&gt;right, level + <span class="number">1</span>, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个二叉树</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">1</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    Solution solution;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result = solution.<span class="built_in">levelOrder</span>(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出层次遍历结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; level : result) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : level) &#123;</span><br><span class="line">            cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> root-&gt;left-&gt;left;</span><br><span class="line">    <span class="keyword">delete</span> root-&gt;left-&gt;right;</span><br><span class="line">    <span class="keyword">delete</span> root-&gt;left;</span><br><span class="line">    <span class="keyword">delete</span> root-&gt;right;</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="dfs序列"><a href="#dfs序列" class="headerlink" title="dfs序列"></a>dfs序列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs模板（感觉是遍历 这个树hhh）</span></span><br><span class="line"><span class="type">int</span> g[N][N]; <span class="comment">//这个就是 表示树（宽度 和 深度）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span><span class="comment">//fa表示树的根结点（醍醐灌顶）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> sz = g[u].<span class="built_in">size</span>(); <span class="comment">// 整个树的节点个数</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++) <span class="comment">// 遍历每一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(g[u][i]!=fa) <span class="comment">// u（代表当前层的一个数据）的i(表示下一层的数据)没用过</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加一个辅助数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  dfs_[++len] = u; <span class="comment">//遍历的就是当前的父节点 记录一下 （每次走过的就当是根 - 父节点的就可以了）</span></span><br><span class="line">  <span class="type">int</span> sz = g[u].<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(g[u][i]!=fa)&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(g[u][i],u);<span class="comment">//根节点替换</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实例代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//一维数组 可以用作二维数组吗</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dfs_[<span class="number">200020</span>],len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfs_[++len]=u;  </span><br><span class="line">    <span class="type">int</span> sz=g[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//两个点 不同方向都有一条边</span></span><br><span class="line">        <span class="type">int</span> from,to;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);</span><br><span class="line">        g[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        g[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,dfs_[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="type">int</span> x = len+<span class="number">1</span>;<span class="comment">//数组拓展</span></span><br><span class="line">    s[++len] = ++time; </span><br><span class="line">   dfs_[len] = u;<span class="comment">//存储dfs序列</span></span><br><span class="line">   <span class="type">int</span> sz = g[u].<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(g[u][i] == fa)&#123;</span><br><span class="line">          <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   e[x] = time;<span class="comment">//存储对应 根节点到子节点的时间区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。（算导里称之为括号化定理）</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>dfs序列作用</strong></p>
<p>子树加权</p>
<p>​	在dfs序列中，一个结点的子树序列是连续的。 - 看下面的树： <code>abdegcfh </code>我们关注 b结点 发现b - deg 这一段是连续的，就可以利用差分的操作就行加权。然后我们可以发现B字树B-D-E-G，C子树C-F-H都在一段连续的区间中。那么这有什么好处呢？比如说现在有一道题：给你一颗树，给出m个x和w，意为将x子树中的所有点加上一个权值w，最后询问所有点的权值 - 既然dfs序中x和他的所有子节点都在连续的区间上，那么我们就可以将它简化成差分的问题。比如说给b节点加2，就可以简化为给b的差分数组+2，c的差分数组-2 。（又涉及到了差分数组了）怎么找第一个不在B子树中的点 引入时间戳</p>
<p>时间戳</p>
<p>作用：记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。（用数组记录时间）</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/1188068-20171027104122883-1380446385.png" alt="img"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230301212454581.png" alt="image-20230301212454581"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[<span class="number">100010</span>];</span><br><span class="line"><span class="type">int</span> dfs_[<span class="number">200020</span>],len,time,s[<span class="number">200020</span>],e[<span class="number">200020</span>],pos[<span class="number">200020</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=len+<span class="number">1</span>;</span><br><span class="line">    s[++len]=++time;<span class="comment">//当前点 时间起点</span></span><br><span class="line">    dfs_[len]=u;</span><br><span class="line">    pos[u]=len;</span><br><span class="line">    <span class="type">int</span> sz=g[u].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;sz;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g[u][i]!=fa)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(g[u][i],u);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    e[x]=time;<span class="comment">//时间终点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="comment">//输入我们的树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//用邻接表表示树</span></span><br><span class="line">        <span class="type">int</span> from,to;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);</span><br><span class="line">        g[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        g[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">        x=pos[x];</span><br><span class="line">        y=pos[y];</span><br><span class="line">        <span class="keyword">if</span>(s[x]&lt;=s[y]&amp;&amp;e[y]&lt;=e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;YES\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;NO\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/">层序遍历</a></h4><p>层序遍历是用队列构造的，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。</p>
<p><code>BFS</code>使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。<code>BFS</code>总共有两个模板：</p>
<p>1.如果不需要确定当前遍历到了哪一层，<code>BFS</code>模板如下。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的节点数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 节点的值</span></span><br><span class="line">    vector&lt;Node*&gt; neighbors;  <span class="comment">// 相邻节点列表</span></span><br><span class="line">    <span class="type">bool</span> visited;  <span class="comment">// 标记节点是否已经访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">visited</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(Node* start)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cur-&gt;visited) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;Visiting node with value: &quot;</span> &lt;&lt; cur-&gt;value &lt;&lt; endl;</span><br><span class="line">            cur-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Node* neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">                <span class="keyword">if</span> (neighbor &amp;&amp; !neighbor-&gt;visited) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建图节点</span></span><br><span class="line">    Node* node1 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    Node* node2 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* node3 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    Node* node4 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立节点之间的连接关系</span></span><br><span class="line">    node1-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line">    node2-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node3-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node4-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起始节点开始BFS遍历</span></span><br><span class="line">    <span class="built_in">bfs</span>(node1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> node1;</span><br><span class="line">    <span class="keyword">delete</span> node2;</span><br><span class="line">    <span class="keyword">delete</span> node3;</span><br><span class="line">    <span class="keyword">delete</span> node4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.如果要确定当前遍历到了哪一层，<code>BFS</code>模板如下。 这里增加了<code>level</code>表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。<code>size</code>表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义图的节点数据结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;  <span class="comment">// 节点的值</span></span><br><span class="line">    vector&lt;Node*&gt; neighbors;  <span class="comment">// 相邻节点列表</span></span><br><span class="line">    <span class="type">bool</span> visited;  <span class="comment">// 标记节点是否已经访问过</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val), <span class="built_in">visited</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BFS按层级遍历函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsByLevel</span><span class="params">(Node* start)</span> </span>&#123;</span><br><span class="line">    queue&lt;Node*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Level &quot;</span> &lt;&lt; level &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (size--) &#123;</span><br><span class="line">            Node* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cur-&gt;visited) &#123;</span><br><span class="line">                cout &lt;&lt; cur-&gt;value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                cur-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Node* neighbor : cur-&gt;neighbors) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (neighbor &amp;&amp; !neighbor-&gt;visited) &#123;</span><br><span class="line">                        q.<span class="built_in">push</span>(neighbor);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建图节点</span></span><br><span class="line">    Node* node1 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">1</span>);</span><br><span class="line">    Node* node2 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">2</span>);</span><br><span class="line">    Node* node3 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">3</span>);</span><br><span class="line">    Node* node4 = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立节点之间的连接关系</span></span><br><span class="line">    node1-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line">    node2-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node3-&gt;neighbors = &#123;node1, node4&#125;;</span><br><span class="line">    node4-&gt;neighbors = &#123;node2, node3&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起始节点开始按层级BFS遍历</span></span><br><span class="line">    <span class="built_in">bfsByLevel</span>(node1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点内存</span></span><br><span class="line">    <span class="keyword">delete</span> node1;</span><br><span class="line">    <span class="keyword">delete</span> node2;</span><br><span class="line">    <span class="keyword">delete</span> node3;</span><br><span class="line">    <span class="keyword">delete</span> node4;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面两个是通用模板，在任何题目中都可以用，是要记住的！</p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/135094687">拓扑排序</a></h3><p>拓扑排序只是针对特定的一类图,也就是有向无环图。</p>
<ul>
<li><p>这个图的边必须是有方向的；</p>
</li>
<li><p>图内无环。</p>
</li>
</ul>
<p>为什么必须要无环呢，如果有环，拓扑排序将会是一个无限的序列，将无限自指。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-1e72742f8cc825e716ab74f68a3d38f6_720w.webp" alt="img"></p>
<p>如果一个图里有环，比如上图，想执行1就要先执行3，想执行3就要先执行2，想执行2就要先执行1，这成了个死循环，无法找到正确的打开方式，所以找不到它的一个拓扑序。</p>
<blockquote>
<p>其实和缺氧的科技树很像，你必须要完成前置条件才能达到我们最终的条件。或者拿<code>moba</code>游戏，你只有把全部防御塔推了才能推掉对面的水晶。</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-49a86090444ba413a1d11e09715d1283_720w.webp" alt="img"></p>
<p>这种图叫 <code>AOV </code>(Activity On Vertex) 网络，在这种图里：</p>
<ul>
<li>顶点：表示活动；</li>
<li>边：表示活动间的先后关系</li>
</ul>
<p>在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。</p>
<p><strong>所以一个 AOV 网应该是一个 DAG，即有向无环图，否则某些活动会无法进行。</strong><br><strong>那么所有活动可以排成一个可行线性序列，这个序列就是<code>拓扑序列</code>。</strong></p>
<p>那么这个序列的<code>实际意义</code>是：<br><strong>按照这个顺序，在每个项目开始时，能够保证它的前驱活动都已完成，从而使整个工程顺利进行。</strong></p>
<blockquote>
<p>注意，有时候拓扑序并不是唯一的，比如在这个例子中，先学 <code>C1 再学 C2</code>，和先 <code>C2 后 C1</code> 都行，都是这个图的正确的拓扑序，但这是两个顺序了。</p>
</blockquote>
<p>在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。</p>
<blockquote>
<p>那么我们回想一下刚刚自己找拓扑序的过程，为什么我们先看上了 <code>C1, C2?</code></p>
</blockquote>
<p>因为它们没有依赖别人啊，<br>也就是它的<code>入度为 0</code>.</p>
<blockquote>
<p><strong>入度</strong>：顶点的入度是指「<strong>指向该顶点的边</strong>」的数量；<br><strong>出度</strong>：顶点的出度是指该顶点指向其他点的边的数量。</p>
</blockquote>
<p>所以我们先执行入度为 0 的那些点，<br>那也就是要记录每个顶点的入度。<br>因为<strong>只有当它的 <code>入度 = 0</code> 的时候，我们才能执行它。</strong></p>
<p>在刚才的例子里，最开始 <code>C1, C2 </code>的入度就是 0，所以我们可以先执行这两个。</p>
<p>那在这个算法里第一步就是得到每个顶点的入度。</p>
<h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>拿到了这个之后，就可以执行入度为<code>0</code>的这些点了，也就是 <code>C1, C2.</code></p>
<p>那我们把可以被执行的这些点，放入一个<code>待执行的容器</code>里，这样之后我们一个个的从这个容器里取顶点就好了。</p>
<p>至于这个<code>容器</code>究竟选哪种<code>数据结构</code>，这取决于我们需要做哪些<code>操作</code>，再看哪种数据结构可以为之服务。</p>
<p>那么首先可以把<code>[C1, C2]</code>放入<code>容器</code>中，</p>
<p>然后想想我们需要哪些操作吧！</p>
<p>我们最常做的操作无非就是<code>把点放进来</code>，<code>把点拿出去</code>执行了，也就是需要一个 <code>offer</code> 和 <code>poll</code> 操作比较高效的数据结构，那么 <code>queue</code> 就够用了。</p>
<p>（其他的也行，放进来这个容器里的顶点的地位都是一样的，都是可以执行的，和进来的顺序无关，但何必非得给自己找麻烦呢？一个常规顺序的简简单单的 <code>queue</code> 就够用了。）</p>
<blockquote>
<p>解析实现顺序可以去标题的博客看，下面是具体实现拓扑排序的代码</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302193314874.png" alt="image-20230302193314874"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302195721755.png" alt="image-20230302195721755"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302195739338.png" alt="image-20230302195739338"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302195757415.png" alt="image-20230302195757415"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*简单来说就是 按照 前面点最少的顺序排序（也就是入度从小到大）</span></span><br><span class="line"><span class="comment">1.Kahn算法</span></span><br><span class="line"><span class="comment">   起点是从入度为0的点开始的（这样才能入度从小到大），使用队列来维护我们的点；1.初始化：将所有入度为0的点压入我们的队列（顺序不重要）；2.每次从q中取出一个点x放入数组tp（存储最终序列）；3.将x的所有出边删除：这个时候的x是队头，边被删除那么对应的连接点的入度就变成0，就可以压入队列；4.重复23步骤。5.如果tp中的数据和我们的点的数量一样，那么就有拓扑序列，如果不一样，那就没有。（有向 无环图才有拓扑序列）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],tp;<span class="comment">//tp是我们最终输出的拓扑序列</span></span><br><span class="line"><span class="type">int</span> din[N]<span class="comment">//存储着点的入度（画图是不是要用领接表）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//让入度0的进入队伍</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(din[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i); <span class="comment">// din数组记录的是入度</span></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(); <span class="comment">//让队头出栈 并且删除对应的边</span></span><br><span class="line">        tp.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> y:e[N])&#123;</span><br><span class="line">            <span class="keyword">if</span>(--din[y]==<span class="number">0</span>) q.<span class="built_in">push</span>(y);<span class="comment">//删除对应的边 并且让对应的数据入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> tp.<span class="built_in">size</span>() = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        din[b]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">toposort</span>()) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>) ; <span class="comment">//如果数量不满足 则说明这个不是拓扑序列</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">auto</span> x:tp) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,x); <span class="comment">//将拓扑序列输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs求拓扑序列(变色法)</span></span><br><span class="line"><span class="comment">//不懂翻转序列 - 翻转序列是因为尾插法吧</span></span><br><span class="line"><span class="comment">/*1.染色法（yxc用的）</span></span><br><span class="line"><span class="comment">    每个点的颜色都会变化，从0 - -1 - 1，经历三次变色；1.初始状态，所有点染色为0；2.枚举每一个点，进入x点（是我们的指针），把x染色为-1，枚举x的儿子y，如果y的颜色为0，那么说明没碰过该点，进入y继续走（这里应该是检测有无环 - 会不会回到x）；3.如果枚举完x（当前数据 - 也算是队头）的儿子，将x压入tp数组；4.如果发现，有-1的出现（那么就是有环出现了），返回false，退出。*/</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N],tp;<span class="comment">//e[N] 应该是树，，或者是领接表画的图</span></span><br><span class="line"><span class="type">int</span> c[N]; <span class="comment">//染色数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    c[x] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y:e[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[y]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//有环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!c[y])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(y)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[x] = <span class="number">1</span>;</span><br><span class="line">    tp.<span class="built_in">push_back</span>(x); <span class="comment">//当前这个数据遍历完成 压入我们的tp数组</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">toposort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c)); <span class="comment">// 初始化 - 刚开始全部点的颜色为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>;x&lt;=n;x++)</span><br><span class="line">        <span class="keyword">if</span>(!c[x])</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(x)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="built_in">reverse</span>(tp.<span class="built_in">begin</span>(),tp.<span class="built_in">end</span>());<span class="comment">//翻转序列 为啥？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最短路算法"><a href="#最短路算法" class="headerlink" title="最短路算法"></a>最短路算法</h3><p>顾名思义，从任意顶点出发到另一顶点的最短距离。也就是权重最小。</p>
<h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/40338107?source_id=1003">Dijkstra</a></h4><blockquote>
<p>基于贪心思想，也就是每次选择的路径权重是最小的，达成局部最小变为全局最小。</p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230904102403004.png" alt="image-20230904102403004"></p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302202401928.png" alt="image-20230302202401928"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302204100958.png" alt="image-20230302204100958"></p>
<blockquote>
<p>简单来说：就是每次选择最短路线进行前进</p>
<p>三个数组：</p>
<p>​	e[u] 存储节点u的所有出边的终点和边权 </p>
<p>​	d[u] 存储u到源点的最小距离（源点就是当前连边的点）（d[u]需要遍历）</p>
<p>​	vis[u] 标记是否出圈<br>​    1.初始的时候，所有点都在圈中，vis &#x3D; 0,d[s] &#x3D; 0,d[其他点] &#x3D; 正无穷<br>​    2.从圈中选择一个距离最小的点，u，打标记出圈（贪心）<br>​    3.对u的所有出边执行松弛操作 - 尝试更新邻点v的最小距离<br>​    4.重复2,3操作，直到圈内为空</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>; <span class="comment">// 最大节点数量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>(); <span class="comment">// 无穷大表示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w; <span class="comment">// 边的目标节点和权值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; e[N]; <span class="comment">// 邻接表表示图</span></span><br><span class="line"><span class="type">int</span> d[N]; <span class="comment">// 存储最短距离</span></span><br><span class="line"><span class="type">int</span> vis[N]; <span class="comment">// 标记节点是否已经访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        d[i] = inf; <span class="comment">// 初始化距离为无穷大</span></span><br><span class="line">        vis[i] = <span class="number">0</span>; <span class="comment">// 初始化节点未访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">// 起点到自身距离为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择未访问节点中距离最小的节点 u</span></span><br><span class="line">        <span class="comment">//第一次更新找到哪个点都无所谓 - 后面for遍历全部会松弛一遍的</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!vis[j] &amp;&amp; d[j] &lt; d[u]) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vis[u] = <span class="number">1</span>; <span class="comment">// 标记节点 u 为已访问</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新从节点 u 出发的边的目标节点的距离</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">            <span class="comment">//松弛操作 - 将无穷大的值松弛为输入值</span></span><br><span class="line">            <span class="keyword">if</span> (!vis[v] &amp;&amp; d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                d[v] = d[u] + w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s; <span class="comment">// 输入节点数量、边数量和起点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; <span class="comment">// 输入边的起点、终点和权值</span></span><br><span class="line">        e[a].<span class="built_in">push_back</span>(&#123;b, c&#125;); <span class="comment">// 添加边到邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(s, n); <span class="comment">// 调用 Dijkstra 算法计算最短路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出从起点到每个节点的最短距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Shortest distance from &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; to &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; d[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302204110774.png" alt="image-20230302204110774"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302205328621.png" alt="image-20230302205328621"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里用的是小根堆 - 就不用加-号了</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆优化 - 用优先队列维护被更新点的集合</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 全部点的距离都是无穷大</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + N, inf);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建小根堆（最小堆） - pair的第一个元素是距离</span></span><br><span class="line">    priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, greater&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环迭代</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().second;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                d[v] = d[u] + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d[v], v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dijkstra</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[i] == inf) cout &lt;&lt; <span class="string">&quot;INF &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302205410861.png" alt="image-20230302205410861"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//就是两个模板 优化的地方就是枚举的时候用队列维护</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N],vis[N]; <span class="comment">//边 和 点</span></span><br><span class="line"><span class="comment">//s是起点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++) d[i] = <span class="number">0x3f3f3f</span>; <span class="comment">//无穷大的值</span></span><br><span class="line">    d[s] = <span class="number">0</span>; <span class="comment">//对于自己和自己的距离当然是0了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++)&#123;<span class="comment">//枚举次数</span></span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//优化 就是把这里优化了 取消了枚举全部点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++) <span class="comment">//枚举点</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123; <span class="comment">//ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）</span></span><br><span class="line">            <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w) &#123;</span><br><span class="line">                d[v] = d[u]+w;</span><br><span class="line">                q.<span class="built_in">push_back</span>(&#123;-d[v],v&#125;);<span class="comment">//插入到 大根堆上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;            </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230302205417632.png" alt="image-20230302205417632"></p>
<h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford*"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352724346">Bellman-Ford</a>*</h4><blockquote>
<p>贝尔曼-福特算法（Bellman-Ford）是由理查德·贝尔曼和莱斯特·福特创立的，求解<strong>单源最短路径问题</strong>的一种算法。它的原理是对图进行V-1次<strong>松弛操作</strong>，得到所有可能的最短路径。其优于Dijkstra算法的方面是边的权值可以为<strong>负数</strong>、实现简单，缺点是时间复杂度过高，高达<code>O(VE)</code></p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-3253617aa1280adbe911e9fae4133584_720w.webp" alt="img"></p>
<blockquote>
<p>然后迭代对于起点链接的节点进行松弛</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-b79ce7e33dcee4a3e915bd1d1d2866e7_720w.webp" alt="img"></p>
<blockquote>
<p>每一个节点的距离 - 起点的距离 &#x3D; 和起点的距离</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-f407fdcc6ac680d357f535258e3f12d8_720w.webp" alt="img"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/v2-0b8efc7f4fcf5d767fc7b678c1d08c8c_720w.webp" alt="img"></p>
<p><code>Bllman-Ford </code>算法是一种用于求解带权图中单源最短路径的算法，可以处理负权边，但不能处理负权环。<br> 它的时间复杂度为 <code>O(VE)</code>，其中 V 是顶点数，E是边数。Bellman-Ford 算法的基本思想是对所有的边进行 V-1 轮松弛操作，以求出所有可能的最短路径。如果在第 V轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。</p>
<blockquote>
<p>单源最短路<br>    单源最短路问题是图论中的一个基本问题，它指的是给定一张有权图，如何求某两点之间的最短路径1。解决这个问题的算法有很多，比如Dijkstra算法和Bellman-Ford算法等。</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212846831.png" alt="image-20230304212846831"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304210834724.png" alt="image-20230304210834724"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212028882.png" alt="image-20230304212028882"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e9</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1005</span>; <span class="comment">// 根据你的需求设置节点数量上限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bellmanFord</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d, d + n, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123; <span class="comment">// 最多执行 n-1 轮松弛操作</span></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[u] == INF) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">                <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">                <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                    d[v] = d[u] + w;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>; <span class="comment">// 如果本轮没有更新，提前退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否存在负权环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> u = <span class="number">1</span>; u &lt;= n; u++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (d[u] == INF) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v, w = ed.w;</span><br><span class="line">            <span class="keyword">if</span> (d[v] &gt; d[u] + w) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 存在负权环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 不存在负权环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="spfa-算法"><a href="#spfa-算法" class="headerlink" title="spfa 算法"></a><a target="_blank" rel="noopener" href="https://wat1r.github.io/2020/09/21/spfa-algorithm-master/">spfa 算法</a></h4><blockquote>
<p>何为<code>SPFA（Shortest Path Faster Algorithm）</code>算法:</p>
<p><strong>给定一个加权连通图，选取一个顶点，称为起点，求取起点到其它所有顶点之间的最短距离，其显著特点是可以求含负权图的单源最短路径，且效率较高。（</strong><code>spfa</code>是求单源<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">最短路径</a>的一种算法，它还有一个重要的功能是判负环（在差分约束系统中会得以体现），在<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/Bellman-ford">Bellman-ford</a>算法的基础上加上一个队列优化，减少了冗余的<a target="_blank" rel="noopener" href="http://baike.baidu.com/item/%E6%9D%BE%E5%BC%9B%E6%93%8D%E4%BD%9C">松弛操作</a>，是一种高效的最短路算法。）</p>
<p><strong><code>spfa算法思想</code>：</strong><code>spfa</code>就是<code>BellmanFord</code>的一种实现方式，其具体不同在于，对于处理松弛操作时，采用了队列（先进先出方式）操作，从而大大降低了时间复杂度</p>
<p>但是<code>spfa</code>容易被卡常数，所以说最差复杂度和BF算法差不多,而且<code>spfa</code>不适用负权环，只适用于负权边。还是推荐用<code>bf</code>算法</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20200921211548307.png" alt="image-20200921211548307.png"></p>
<blockquote>
<p><code>spfa</code>可以用来判断图中是否有环</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212218685.png" alt="image-20230304212218685"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212529352.png" alt="image-20230304212529352"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230304212738052.png" alt="image-20230304212738052"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆优化 bellman 算法 - spfa算法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];<span class="comment">//点集合</span></span><br><span class="line"><span class="type">int</span> d[N],cnt[N],vis[N]; <span class="comment">//边 边数 开关</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; <span class="comment">//队列</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,inf,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="comment">//开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集</span></span><br><span class="line">    d[s] = <span class="number">0</span>; vis[s] = <span class="number">1</span>; q.<span class="built_in">push</span>(s); </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//这里是将前面初始化的点操作的地方，每次都只操作一个点</span></span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>(); vis[u] = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v , w = ed.w;</span><br><span class="line">            <span class="comment">//比较枚举点和当前点 的长度 更新最短值</span></span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)&#123;</span><br><span class="line">                d[v] = d[u]+w;</span><br><span class="line">                cnt[v] = cnt[u]+<span class="number">1</span>; <span class="comment">//记录边数</span></span><br><span class="line">                <span class="keyword">if</span>(cnt[v]&gt;=n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v]) q.<span class="built_in">push</span>(v),vis[v] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法 "></a><a target="_blank" rel="noopener" href="https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd">Floyd算法 </a></h4><p>Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。</p>
<p>从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）</p>
<p>从任意节点i到任意节点j的最短路径不外乎2种可能，<strong>1是直接从i到j，2是从i经过若干个节点k到j。</strong>所以，我们假设Dis(i,j)为节点u到节点v的最短路径的距离，对于每一个节点k，我们检查**<code>Dis(i,k) + Dis(k,j) &lt; Dis(i,j)</code><strong>是否成立，如果成立，证明从i到k再到j的路径比i直接到j的路径短，我们便设置</strong><code>Dis(i,j) = Dis(i,k) + Dis(k,j)</code>**，这样一来，当我们遍历完所有节点k，Dis(i,j)中记录的便是i到j的最短路径的距离。</p>
<blockquote>
<p>可以用滚动数组，在动态规划会讲解</p>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307160057133.png" alt="image-20230307160057133"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307160205801.png" alt="image-20230307160205801"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307160839691.png" alt="image-20230307160839691"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）</span></span><br><span class="line"><span class="comment">// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k;k&lt;=n;k++) <span class="comment">//以k为桥(k枚举的是所有点)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">mid</span>(d[i][j],d[i][k]+d[k][j]); <span class="comment">//二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307161152125.png" alt="image-20230307161152125"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//路径记录原理不了解</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n,m,k;</span><br><span class="line"><span class="type">int</span> d[N][N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k &lt;= n;k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= n;j++)</span><br><span class="line">                d[i][j] = <span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="built_in">fill</span>(d[<span class="number">0</span>],d[<span class="number">0</span>]+N*N,<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++) d[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        d[a][b] = <span class="built_in">min</span>(d[a][b],c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(d[a][b] &gt; <span class="number">0x3f3f3f3f</span>/<span class="number">2</span>) cout &lt;&lt; <span class="string">&quot;impossible&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230307161434260.png" alt="image-20230307161434260"></p>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><h4 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308192754299.png" alt="image-20230308192754299"></p>
<blockquote>
<p>Prim算法的基本思路：</p>
<ol>
<li>选择一个起始节点（可以是任意节点），将其加入生成树中，初始化生成树为空。</li>
<li>在每一步中，从已经在生成树中的节点集合出发，选择一个距离生成树最近的节点（即与生成树中的某个节点相邻且权重最小的节点），将其加入生成树中。这个过程重复执行，直到生成树包含了图中的所有节点为止。</li>
<li>最终生成的树就是最小生成树。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//没有优化版本 - 基于贪心算法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;;</span><br><span class="line">vector&lt;edge&gt; e[N];</span><br><span class="line"><span class="type">int</span> d[N],vis[N];<span class="comment">//d是边的长度 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++) d[i] = inf;</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="comment">//排除选过的点 - 这里是选领点的（懂了）</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        ans+=d[u];<span class="comment">//边权和（最小生成树的边权和）</span></span><br><span class="line">        <span class="keyword">if</span>(d[u]!=inf) cnt++; <span class="comment">//判断是否联通</span></span><br><span class="line">        <span class="comment">//遍历到u这个点（u之前的也是一起的，算是连续的）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;w)&#123;</span><br><span class="line">                d[v] = w;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n; <span class="comment">//返回true就是有最小生成树的 返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308110618789.png" alt="image-20230308110618789"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。</span></span><br><span class="line"><span class="type">int</span> n,m,s,a,b,c,ans,cnt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,w;&#125;; <span class="comment">//构造一个结构体 内部有点和边的属性</span></span><br><span class="line">vector&lt;edge&gt; e[N];<span class="comment">//领点（也算是所有点？）</span></span><br><span class="line"><span class="type">int</span> d[N],vis[N];</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q; <span class="comment">//这里创一个优先队列（就是堆）</span></span><br><span class="line"><span class="comment">//s是起点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;=n;i++) d[i] = inf; <span class="comment">//先初始化全部的边 - 每个边都是无穷大</span></span><br><span class="line">    <span class="comment">//起点</span></span><br><span class="line">    d[s] = <span class="number">0</span>;q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="comment">//取出q队列的点？ - 后面有进入点？</span></span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">top</span>().second; q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>; </span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        ans+=d[u]; cnt++;</span><br><span class="line">        <span class="comment">//这里应该就是插入 领点的步骤</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])&#123;</span><br><span class="line">            <span class="type">int</span> v = ed.v,w = ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;w)&#123;</span><br><span class="line">                d[v] = w; <span class="comment">//对应点v边权最小的边</span></span><br><span class="line">                q.<span class="built_in">push</span>(&#123;-d[v],v&#125;);<span class="comment">//大根堆</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == n; <span class="comment">//这里判断的是啥？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308110724388.png" alt="image-20230308110724388"></p>
<h4 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h4><blockquote>
<p>Kruskal算法的基本思路如下：</p>
<ol>
<li>将图中的所有边按照权重从小到大进行排序。</li>
<li>初始化一个空的最小生成树。</li>
<li>从权重最小的边开始，依次考虑每条边，如果该边不会导致生成树中出现环路（即加入这条边后，两个节点已经在同一个连通分量中），就将这条边加入生成树中。</li>
<li>重复步骤3，直到生成树中包含了图中的所有节点，此时最小生成树构建完成。</li>
</ol>
</blockquote>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308125205044.png" alt="image-20230308125205044"></p>
<p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230308125225033.png" alt="image-20230308125225033"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>,M=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="comment">//结构体存储边的信息</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="comment">//比较函数 （用来作为排序算法的参数）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge x,edge y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.w&lt;y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);</span><br><span class="line">    <span class="comment">//排序边权（我们是用贪心来筛选的）</span></span><br><span class="line">    <span class="built_in">sort</span>(e+<span class="number">1</span>,e+m+<span class="number">1</span>,cmp);</span><br><span class="line">    <span class="comment">//初始化并查集</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="comment">//每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）</span></span><br><span class="line">        <span class="type">int</span> a=<span class="built_in">find</span>(e[i].a),b=<span class="built_in">find</span>(e[i].b),w=e[i].w;</span><br><span class="line">        <span class="comment">//查一下是否是连通块</span></span><br><span class="line">        <span class="keyword">if</span>(a!=b)&#123;</span><br><span class="line">            <span class="comment">//纳入后宫</span></span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==n<span class="number">-1</span>) <span class="keyword">break</span>;  <span class="comment">//成树</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);<span class="comment">//输出边权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二分图"><a href="#二分图" class="headerlink" title="二分图*"></a>二分图*</h3><h4 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230314143817025.png" alt="image-20230314143817025"></p>
<blockquote>
<p>以下是染色法的基本思路：</p>
<ol>
<li>选择一个起始节点，将其染成颜色A（可以用0和1表示两种颜色）。</li>
<li>从起始节点开始，对于与其相邻的节点，将其染成颜色B。</li>
<li>继续递归地对与颜色A节点相邻的节点染成颜色B，与颜色B节点相邻的节点染成颜色A。</li>
<li>如果在染色的过程中发现相邻的两个节点已经被染成了相同的颜色，那么图不是二分图。</li>
<li>如果成功染色完所有节点而没有发现相邻节点颜色相同的情况，那么图是二分图。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//染色法判断二分图</span></span><br><span class="line">首先随机选择一个未染色的顶点，将其染成红色或蓝色（或其他任意两种不同颜色）。</span><br><span class="line">然后将与该顶点相邻的所有顶点染成与其不同的颜色。</span><br><span class="line">重复上述过程，直到所有顶点都被染色或者发现某个顶点和它相邻的顶点已经被染成了相同的颜色。</span><br><span class="line">如果所有顶点都被染色，那么这个图就是二分图；如果发现有冲突，那么这个图就不是二分图。</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分图</span></span><br><span class="line">二分图是图论中的一种特殊模型，它的定义是<span class="number">1234</span>：如果一个无向图的顶点集可以分成两个互不相交的子集，使得每条边的两个端点分别属于这两个子集，那么这个无向图就是二分图。例如，下图就是一个二分图：</span><br><span class="line">    A   B   C</span><br><span class="line">    | / | / |</span><br><span class="line">    D   E   F</span><br><span class="line">就是映射是吧，两个不同的集合中有连边，相同集合的不连边</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断此图是否是二分图</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>,M = <span class="number">2e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N],e[N],ne[M],idx; <span class="comment">//e是点集 ne是边集</span></span><br><span class="line"><span class="type">int</span> color[N]; <span class="comment">//存储每一个点的状态 一共有三种 起始0 染色 1 - 2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a],h[a] = idx++; <span class="comment">//把h[a]理解为前面的桶形数组就好了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每次访问一个顶点u，就会先递归地访问它的所有邻接点，直到没有未访问的邻接点为止，</span></span><br><span class="line"><span class="comment">//然后再回溯到上一层。这样可以保证每个连通分量内的顶点都被染色。</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    color[u] = c; <span class="comment">//c是什么意思 - 是当前点的染色状态 （只有三种 0 1 2 用3减去就前后不一样了）</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; ~i;i = ne[i])&#123;</span><br><span class="line">        <span class="type">int</span> j = e[i]; <span class="comment">//邻点</span></span><br><span class="line">        <span class="keyword">if</span>(!color[j])&#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(j,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//这个是递归地调用dfs函数，给顶点j和它的邻接点染色，并判断是否有冲突。</span></span><br><span class="line">        <span class="comment">//如果返回false，就说明发现了不符合二分图的情况，就返回false。</span></span><br><span class="line">        <span class="comment">//冲突是指同一个子集内的顶点颜色相同，或者不同子集内的顶点颜色不同。</span></span><br><span class="line">        <span class="comment">//这些情况都不满足二分图的定义，所以要返回false。</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(color[j] == c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果顶点j已经被染色，并且与u的颜色相同，就说明同一个子集内有边相连，不符合二分图的定义，就返回false。</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b); <span class="built_in">add</span>(b,a); <span class="comment">//无向图</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(!<span class="built_in">dfs</span>(i,<span class="number">1</span>))</span><br><span class="line">           &#123;</span><br><span class="line">               flag = <span class="literal">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/image-20230314144148781.png" alt="image-20230314144148781"></p>
<p><img src="/image-20230314144232392.png" alt="image-20230314144232392"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>; <span class="comment">// 顶点数的最大值</span></span><br><span class="line"><span class="type">int</span> n1, n2; <span class="comment">// 二分图左右两边的顶点数</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[N]; <span class="comment">// 邻接表存储图</span></span><br><span class="line"><span class="type">int</span> match[N]; <span class="comment">// match[i]表示右边第i个点当前匹配的左边的点</span></span><br><span class="line"><span class="type">bool</span> st[N]; <span class="comment">// st[i]表示右边第i个点是否已经被遍历过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二分图中寻找增广路</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[x].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="type">int</span> j = g[x][i];</span><br><span class="line">        <span class="keyword">if</span> (!st[j]) &#123;</span><br><span class="line">            st[j] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (match[j] == <span class="number">0</span> || <span class="built_in">find</span>(match[j])) &#123;</span><br><span class="line">                match[j] = x;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求二分图最大匹配数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">    <span class="type">int</span> m; <span class="comment">// 边数</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        g[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 最大匹配数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="keyword">sizeof</span> st);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">find</span>(i)) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法*"></a>匈牙利算法*</h4><p><img src="/2023/04/28/%E5%9B%BE%E8%AE%BA/image-20230314205307317.png" alt="image-20230314205307317"></p>
<blockquote>
<p>匈牙利算法的基本思路：</p>
<ol>
<li>选择一个未匹配的左侧节点作为起始点，如果所有左侧节点都已经匹配，则说明找到了一个最大匹配。</li>
<li>对于选定的起始点，尝试将其与未匹配的右侧节点进行匹配。如果可以找到一个未匹配的右侧节点与起始点相连接，那么建立这个匹配，否则，尝试改变匹配路径。</li>
<li>如果可以改变匹配路径，就寻找一条增广路径（alternating path），这是一条交替经过匹配边和非匹配边的路径，以尽量多地增加匹配数目。增广路径的搜索通常使用深度优先搜索（DFS）或广度优先搜索（BFS）。</li>
<li>如果找到了增广路径，就根据这条路径来改变匹配，然后返回步骤1，继续查找下一个未匹配的左侧节点。</li>
<li>如果没有找到增广路径，说明已经找到了最大匹配，算法终止。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1.匈牙利算法 - 二分图的最大匹配</span></span><br><span class="line"><span class="comment"> 二分图，简单来说就是不同集合有联系；同一集合不可以有联系； - 边数最多的一组匹配被称之为最大匹配</span></span><br><span class="line"><span class="comment"> 在二分图的前提下： 1.交替路 2.增广路  - 交替路就是匹配和不匹配边交替出现 - 增光路就是匹配和不匹配交换身份，看有没有多路径，多了就是增广路*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">10</span>,M = <span class="number">2e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,a,b,ans,idx;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="type">int</span> v,ne;&#125;e[M]; <span class="comment">//点（对应位置的妹子） ne 另一集合的点是吗</span></span><br><span class="line"><span class="type">int</span> h[N],idx;</span><br><span class="line"><span class="type">int</span> vis[N],match[M]; <span class="comment">//标记 和 匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//链式前向星</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    e[++idx] = &#123;b,h[a]&#125;;</span><br><span class="line">    h[a] = idx++; <span class="comment">//横置数组向右移动</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//男女匹配问题 (boy and girl）</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="comment">//每一个都要匹配看看</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = h[u]; i;i = e[i].ne)&#123;</span><br><span class="line">        <span class="type">int</span> v = e[i].v; <span class="comment">//妹子</span></span><br><span class="line">        <span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[v] = <span class="number">1</span>; <span class="comment">//标记</span></span><br><span class="line">        <span class="keyword">if</span>(!match[v]||<span class="built_in">dfs</span>(match[v]))&#123; <span class="comment">//没有匹配 || 能不能换（dfs的功能就是判断能不能换）</span></span><br><span class="line">            match[v] = u;<span class="comment">//成对</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;k;i++) cin&gt;&gt;a&gt;&gt;b,<span class="built_in">add</span>(a,b); <span class="comment">//建图</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">最近公共祖先</a></h3><h4 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h4><p><img src="/image-20230319121246852.png" alt="image-20230319121246852"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; tree[MAXN]; <span class="comment">// 邻接表存储树</span></span><br><span class="line"><span class="type">int</span> depth[MAXN], parent[MAXN]; <span class="comment">// 深度和父亲节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 深度优先搜索遍历计算深度和父亲节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    depth[u] = depth[p] + <span class="number">1</span>;</span><br><span class="line">    parent[u] = p;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : tree[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v != p) <span class="built_in">dfs</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算两个节点的最近公共祖先</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (depth[u] &gt; depth[v]) u = parent[u];</span><br><span class="line">    <span class="keyword">while</span> (depth[v] &gt; depth[u]) v = parent[v];</span><br><span class="line">    <span class="keyword">while</span> (u != v) &#123;</span><br><span class="line">        u = parent[u];</span><br><span class="line">        v = parent[v];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; <span class="comment">// 读入节点数和查询数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 读入边</span></span><br><span class="line">        tree[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        tree[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>); <span class="comment">// 计算深度和父亲节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v; <span class="comment">// 读入查询</span></span><br><span class="line">        cout &lt;&lt; <span class="built_in">lca</span>(u, v) &lt;&lt; endl; <span class="comment">// 输出结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">这个模板中，n 是树的节点数，m 是查询数量。对于每组查询，它读入两个节点编号 u 和 v，然后调用函数 <span class="built_in">lca</span>(u,v) 来获取它们的最近公共祖先。</span><br></pre></td></tr></table></figure>

<h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p><img src="/image-20230314144355261.png" alt="image-20230314144355261"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Tarjan算法是由Robert Tarjan发明的一种图算法。它可以用于解决许多不同类型的问题，包括寻找强连通分量、双连通分量、割点和割边等。其中一种应用是在树中查找节点对的最近公共祖先（LCA）。Tarjan算法通过深度优先搜索和并查集数据结构来高效地解决这个问题。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tarjan算法 ： 利用并查集</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; query[N];</span><br><span class="line"><span class="type">int</span> fa[N],vis[N],ans[M];</span><br><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(u == fa[u]) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">return</span> fa[u] = <span class="built_in">find</span>(fa[u]);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">    fa[u] = u; <span class="comment">// 初始化父亲为自己</span></span><br><span class="line">    vis[u] = <span class="literal">true</span>; <span class="comment">// 标记</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> v:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">            tarjan[v];</span><br><span class="line">            fa[v] = u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q:query[u])&#123;</span><br><span class="line">        <span class="type">int</span> v = q.first,i = q.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[v]) ans[i] = <span class="built_in">find</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="树链剖分-不理解"><a href="#树链剖分-不理解" class="headerlink" title="树链剖分(不理解)"></a>树链剖分(不理解)</h4><p><img src="/image-20230315210121556.png" alt="image-20230315210121556"></p>
<p><img src="/image-20230315210610462.png" alt="image-20230315210610462"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; e[N];</span><br><span class="line"><span class="type">int</span> fa[N],dep[N],son[N],sz[N];</span><br><span class="line"><span class="type">int</span> top[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span>&#123;</span><br><span class="line">    fa[u] = father, dep[u] = dep[father]+<span class="number">1</span>,sz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(v,u);</span><br><span class="line">        sz[u] += sz[v];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u] = t;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:e[u])&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == fa[u] || v == son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(v,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        u = fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u]&lt;dep[v]?u:v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="倍增算法（不理解）"><a href="#倍增算法（不理解）" class="headerlink" title="倍增算法（不理解）"></a>倍增算法（不理解）</h4><p><img src="/image-20230315210919875.png" alt="image-20230315210919875"></p>
<p><img src="/image-20230315210938761.png" alt="image-20230315210938761"></p>
<p><img src="/image-20230315210958755.png" alt="image-20230315210958755"></p>
<p><img src="/image-20230315210622550.png" alt="image-20230315210622550"></p>
<h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树*"></a>线段树*</h3><p><img src="/image-20230401100823894.png" alt="image-20230401100823894"></p>
<p><img src="/image-20230401100840271.png" alt="image-20230401100840271"></p>
<p><img src="/image-20230401100850209.png" alt="image-20230401100850209"></p>
<p><img src="/image-20230401100859800.png" alt="image-20230401100859800"></p>
<p><img src="/image-20230401100913730.png" alt="image-20230401100913730"></p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组*"></a>树状数组*</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://www.wniee.cn">chara</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.wniee.cn/2023/04/28/%E5%9B%BE%E8%AE%BA/">https://www.wniee.cn/2023/04/28/%E5%9B%BE%E8%AE%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.wniee.cn" target="_blank">Jane Station</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251544299.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" title="动态规划 - dp介绍"><img class="cover" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251330938.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">动态规划 - dp介绍</div></div></a></div><div><a href="/2023/04/26/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D/" title="数据结构 - 基础算法介绍"><img class="cover" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251330938.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">数据结构 - 基础算法介绍</div></div></a></div><div><a href="/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构 - 简单数据结构"><img class="cover" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251543942.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-27</div><div class="title">数据结构 - 简单数据结构</div></div></a></div><div><a href="/2023/04/26/%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/" title="数据结构 - 对数据的基本操作"><img class="cover" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251330938.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">数据结构 - 对数据的基本操作</div></div></a></div><div><a href="/2023/04/28/%E6%95%B0%E8%AE%BA/" title="数论 - 简单讲解数论"><img class="cover" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251553183.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">数论 - 简单讲解数论</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/picture/img/Vigus.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chara</div><div class="author-info__description">一个菜鸟刚搭的网站</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">14</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ilovchara"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ilovchara" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">文章中如果有引用，会在段落标题中有超链接可以直达引用文章地址。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">平衡二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">用数组实现二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">二叉树的链式实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%A7%A3%E9%80%92%E5%BD%92"><span class="toc-number">1.1.5.</span> <span class="toc-text">用二叉树理解递归</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">层序遍历（补充）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.</span> <span class="toc-text">图的介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">领接矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">边集数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">领接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%A2%86%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">链式领接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">链式前向星</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">图的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">dfs过程的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dfs%E5%BA%8F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">dfs序列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">层序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">拓扑排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.4.1.</span> <span class="toc-text">预处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">最短路算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra"><span class="toc-number">1.5.1.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">1.5.2.</span> <span class="toc-text">Bellman-Ford*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spfa-%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.</span> <span class="toc-text">spfa 算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.4.</span> <span class="toc-text">Floyd算法 </span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.6.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.1.</span> <span class="toc-text">prim算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.2.</span> <span class="toc-text">克鲁斯卡尔算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.7.</span> <span class="toc-text">二分图*</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.7.1.</span> <span class="toc-text">染色法判断二分图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">1.7.2.</span> <span class="toc-text">匈牙利算法*</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.8.</span> <span class="toc-text">最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.8.1.</span> <span class="toc-text">朴素方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tarjan%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.2.</span> <span class="toc-text">Tarjan算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E4%B8%8D%E7%90%86%E8%A7%A3"><span class="toc-number">1.8.3.</span> <span class="toc-text">树链剖分(不理解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8D%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">1.8.4.</span> <span class="toc-text">倍增算法（不理解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.9.</span> <span class="toc-text">线段树*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.10.</span> <span class="toc-text">树状数组*</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/29/%E5%B9%B2%E7%88%86%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" title="干爆算法竞赛"><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251542846.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="干爆算法竞赛"/></a><div class="content"><a class="title" href="/2023/08/29/%E5%B9%B2%E7%88%86%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/" title="干爆算法竞赛">干爆算法竞赛</a><time datetime="2023-08-29T11:51:43.000Z" title="发表于 2023-08-29 19:51:43">2023-08-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/08/24/unity/" title="unity"><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251542846.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="unity"/></a><div class="content"><a class="title" href="/2023/08/24/unity/" title="unity">unity</a><time datetime="2023-08-24T03:11:19.000Z" title="发表于 2023-08-24 11:11:19">2023-08-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/c/" title="c#"><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251543942.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c#"/></a><div class="content"><a class="title" href="/2023/05/29/c/" title="c#">c#</a><time datetime="2023-05-29T07:39:15.000Z" title="发表于 2023-05-29 15:39:15">2023-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/English/" title="English"><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251553183.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English"/></a><div class="content"><a class="title" href="/2023/05/24/English/" title="English">English</a><time datetime="2023-05-24T13:01:04.000Z" title="发表于 2023-05-24 21:01:04">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/30/Web/" title="前端三件套 - 简单介绍"><img src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251330938.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端三件套 - 简单介绍"/></a><div class="content"><a class="title" href="/2023/04/30/Web/" title="前端三件套 - 简单介绍">前端三件套 - 简单介绍</a><time datetime="2023-04-30T14:39:00.000Z" title="发表于 2023-04-30 22:39:00">2023-04-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 By chara</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://chara-twwikoo.wniee.cn/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://chara-twwikoo.wniee.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="点啥,别点,QAQ" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251245072.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/工程/&quot;);" href="javascript:void(0);">工程</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">数据结构和算法</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251245417.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/随笔/&quot;);" href="javascript:void(0);">随笔</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr">工程结构</span></li><li class="categoryBar-list-item" style="background:url(https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251243743.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法/&quot;);" href="javascript:void(0);">算法</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr">随笔</span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题/&quot;);" href="javascript:void(0);">刷题</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/05/29/c/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251543942.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-05-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/05/29/c/&quot;);" href="javascript:void(0);" alt="">c#</a><div class="blog-slider__text">记录c#的基础知识</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/05/29/c/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/04/30/Linux/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251330938.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/04/30/Linux/&quot;);" href="javascript:void(0);" alt="">Linux</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/04/30/Linux/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/04/30/Web/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251330938.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-04-30</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/04/30/Web/&quot;);" href="javascript:void(0);" alt="">前端三件套 - 简单介绍</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/04/30/Web/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2023/08/24/unity/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308251542846.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-08-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2023/08/24/unity/&quot;);" href="javascript:void(0);" alt="">unity</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2023/08/24/unity/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar-www.wniee.cn/api?ilovchara",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'ilovchara')
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body></html>