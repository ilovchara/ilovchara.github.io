<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Four | Jane Station</title><meta name="author" content="chara"><meta name="copyright" content="chara"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="第四章 - 图论的拓展121.基础图论模型2.图论算法    图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍">
<meta property="og:type" content="article">
<meta property="og:title" content="Four">
<meta property="og:url" content="https://ilovchara.github.io/2023/04/28/Four/index.html">
<meta property="og:site_name" content="Jane Station">
<meta property="og:description" content="第四章 - 图论的拓展121.基础图论模型2.图论算法    图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ilovchara.github.io/picture/img/Girl%20of%20the%20Deep.jpg">
<meta property="article:published_time" content="2023-04-28T01:05:38.000Z">
<meta property="article:modified_time" content="2023-08-18T16:18:48.806Z">
<meta property="article:author" content="chara">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ilovchara.github.io/picture/img/Girl%20of%20the%20Deep.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ilovchara.github.io/2023/04/28/Four/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: chara","link":"链接: ","source":"来源: Jane Station","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Four',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-19 00:18:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="source/self_use/code_demo"><link rel="stylesheet" href="source/self_use/sosuo/icat.css><link rel="stylesheet" href="/css/chara1/flink.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = 'hidden';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}

preloader.initLoading()
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/picture/img/Vigus.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="icat_menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="icat_menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="icat_menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="icat_menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/playlist/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li></ul></div><div class="icat_menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="icat_menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/picture/img/Girl%20of%20the%20Deep.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Jane Station"><span class="site-name">Jane Station</span></a></span><div id="menus"></div><div class="menus_items"><div class="icat_menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="icat_menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="icat_menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="icat_menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/playlist/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影片</span></a></li></ul></div><div class="icat_menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="icat_menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="nav-right"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i></a></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Four</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-28T01:05:38.000Z" title="发表于 2023-04-28 09:05:38">2023-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-18T16:18:48.806Z" title="更新于 2023-08-19 00:18:48">2023-08-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">12.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>51分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Four"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第四章-图论的拓展"><a href="#第四章-图论的拓展" class="headerlink" title="第四章 - 图论的拓展"></a>第四章 - 图论的拓展</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>基础图论模型<br><span class="hljs-number">2.</span>图论算法<br></code></pre></td></tr></table></figure>

<p>  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学习。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>  要了解上述两个遍历模型，就要了解二叉树。二叉树是图的一种特殊造型，二叉树有两种主要形式：满二叉树和完全二叉树.满二叉树的深度和结点是有关系的，一个深度为k的满二叉树，它的节点数是2^k - 1（每一层是两个，减去我们的头结点就ok了）</p>
<h4 id="1-完全二叉树"><a href="#1-完全二叉树" class="headerlink" title="1.完全二叉树"></a>1.完全二叉树</h4><p>  完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数 都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h层，则该层包含 1~ 2^h -1 个节点。（就是叶子结点左边可以不满，其他必须满是这个意思是吗）。</p>
<p>​        <img src="/2023/04/28/Four/image-20230216131827500-16923746582101.png" alt="image-20230216131827500"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//二叉搜索树（建立在完全二叉树的基础之上吗）</span><br>有如下的规则（简单来说，左边的都是小于根节点，右边的都是大于根节点）<br> -若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； <br> -若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；<br> -它的左、右⼦树也分别为⼆叉排序树<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230216133015856-16923744832954.png" alt="image-20230216133015856"></p>
<h4 id="2-平衡二叉搜索树"><a href="#2-平衡二叉搜索树" class="headerlink" title="2.平衡二叉搜索树"></a>2.平衡二叉搜索树</h4><p>平衡⼆叉搜索树：又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是 ⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。（高度差 注意是高度差！！！！！）</p>
<p><img src="/image-20230216133247245-16923744811933.png" alt="image-20230216133247245"></p>
<h4 id="3-用数组实现二叉树"><a href="#3-用数组实现二叉树" class="headerlink" title="3.用数组实现二叉树"></a>3.用数组实现二叉树</h4><p><img src="/2023/04/28/Four/image-20230216134441813-16923744802222.png" alt="image-20230216134441813"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">⽤数组来存储⼆叉树如何遍历的呢？ 如果⽗节点的数组下表是i，那么它的左孩⼦就是i * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>，右孩⼦就是 i * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>。 <br>但是⽤链式表⽰的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。<br>所以⼤家要了解，⽤数组依然可以表⽰⼆叉树<br></code></pre></td></tr></table></figure>

<h4 id="4-二叉树的链式实现"><a href="#4-二叉树的链式实现" class="headerlink" title="4.二叉树的链式实现"></a>4.二叉树的链式实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>&#123;<br>  <span class="hljs-type">int</span> val;<br>  TreeNode *left;<span class="hljs-comment">//定义left指针 指向左子树</span><br>  TreeNode *right;<span class="hljs-comment">//right指针 指向右子树</span><br>  <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> x):<span class="hljs-built_in">val</span>(x),<span class="hljs-built_in">left</span>(<span class="hljs-literal">NULL</span>),<span class="hljs-built_in">right</span>(<span class="hljs-literal">NULL</span>)&#123;&#125;<span class="hljs-comment">//构造函数  </span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="5-二叉树的遍历步骤"><a href="#5-二叉树的遍历步骤" class="headerlink" title="5.二叉树的遍历步骤"></a>5.二叉树的遍历步骤</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//实现递归的三要素</span><br><span class="hljs-number">1.</span> 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。<br><span class="hljs-number">2.</span> 确定终⽌条件： 写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者 终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果 递归没有终⽌，操作系统的内存栈必然就会溢出。<br><span class="hljs-number">3.</span> 确定单层递归的逻辑：<br>确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程<br><span class="hljs-comment">//前序遍历（就是前中后）</span><br><span class="hljs-number">1.</span> 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，<span class="hljs-string">&#x27;所以参数⾥需 要传⼊vector在放节点的数值，除了这⼀点就不需要在处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</span><br><span class="hljs-string">void traversal(TreeNode* cur, vector&lt;int&gt;&amp; vec) //（一个存放的是结构体的指针，一个存放的是存储数据的容器）</span><br><span class="hljs-string">2.确定终⽌条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点 是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：</span><br><span class="hljs-string">if (cur == NULL) return;</span><br><span class="hljs-string">3.确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先 取中节点的数值，代码如下：</span><br><span class="hljs-string">vec.push_back(cur-&gt;val); // 中</span><br><span class="hljs-string">traversal(cur-&gt;left, vec); // 左</span><br><span class="hljs-string">traversal(cur-&gt;right, vec); // 右</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//前序遍历</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123; <br>  <span class="hljs-keyword">public</span>: <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <br>   vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中</span><br>   <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>   <span class="hljs-comment">// 左 </span><br>   <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <br>   <span class="hljs-comment">// 右</span><br>&#125;<br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">preorderTraversal</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123; <br>   vector&lt;<span class="hljs-type">int</span>&gt; result; <span class="hljs-built_in">traversal</span>(root, result); <span class="hljs-keyword">return</span> result;<br> &#125;<br>&#125;;<br><br><span class="hljs-comment">//中序遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>; <br>  <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>  <span class="hljs-comment">// 左 </span><br>  vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中 </span><br>  <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec);<br>  <span class="hljs-comment">// 右</span><br>&#125;<br><br><span class="hljs-comment">//后续遍历</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traversal</span><span class="hljs-params">(TreeNode* cur, vector&lt;<span class="hljs-type">int</span>&gt;&amp; vec)</span> </span>&#123; <br>  <span class="hljs-keyword">if</span> (cur == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-built_in">traversal</span>(cur-&gt;left, vec); <br>  <span class="hljs-comment">// 左 </span><br>  <span class="hljs-built_in">traversal</span>(cur-&gt;right, vec); <br>  <span class="hljs-comment">// 右</span><br>  vec.<span class="hljs-built_in">push_back</span>(cur-&gt;val);<br>  <span class="hljs-comment">// 中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230216135315873.png" alt="image-20230216135315873"></p>
<p><img src="/image-20230216135326265.png" alt="image-20230216135326265"></p>
<h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h4 id="0-前置知识-图的存储"><a href="#0-前置知识-图的存储" class="headerlink" title="0.前置知识 图的存储"></a>0.前置知识 图的存储</h4><p><img src="/image-20230305080127311.png" alt="image-20230305080127311"></p>
<h5 id="领接矩阵"><a href="#领接矩阵" class="headerlink" title="领接矩阵"></a>领接矩阵</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.领接矩阵</span><br> 领接矩阵声明，开一个二维数组； <span class="hljs-number">1.</span>二维数组w[u][v],存储u - v的边权（就是这个连线多长）<span class="hljs-number">2.</span>只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）<br>        <span class="hljs-comment">//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系</span><br><br><span class="hljs-type">int</span> w[N][N]; <span class="hljs-comment">//声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c</span><br><span class="hljs-type">int</span> vis[N];<span class="hljs-comment">//点集</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v = <span class="hljs-number">1</span>;v&lt;=n;v++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w[u][v]);<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs</span>(v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        w[a][b] = c; <span class="hljs-comment">//赋予权值（a点 和 b点）（算是连线）</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="边集数组"><a href="#边集数组" class="headerlink" title="边集数组"></a>边集数组</h5><p><img src="/image-20230305080154969.png" alt="image-20230305080154969"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//边集数组</span><br><span class="hljs-comment">//结构体下标联系三者</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>()&#123;<br>    <span class="hljs-type">int</span> u,v,w; <span class="hljs-comment">//两点 和 权</span><br>&#125;e[M]; <span class="hljs-comment">//边集合</span><br><span class="hljs-type">int</span> vis[N]; <span class="hljs-comment">//点</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    vis[u] = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-type">int</span> v = e[i].v,w = e[i].w; <span class="hljs-comment">//用结构体中对应的值</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d&quot;</span>,u,v,w); <span class="hljs-comment">//</span><br>        <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">//这个点到过了</span><br>        <span class="hljs-built_in">dfs</span>(e[i].v);<span class="hljs-comment">//下一个点</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        e[i] = &#123;a,b,c&#125;;<br>        <span class="hljs-comment">//e[i] = &#123;b,a,c&#125;; //无向图就要加上</span><br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="领接表（重点）"><a href="#领接表（重点）" class="headerlink" title="领接表（重点）"></a>领接表（重点）</h5><p><img src="/image-20230302110544398.png" alt="image-20230302110544398"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//领接表（将图用dfs序输出）</span><br>出边数组e[u][i] 存储u点的所有出边&#123;终点 v ， 边权 w&#125;。<br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edga</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//声明结构体（代表每个点有的属性）</span><br>vector&lt;edga&gt; e[N];<span class="hljs-comment">//存储的是每一个起点（有n个）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span>  <span class="hljs-comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u]) <span class="hljs-comment">//遍历当前层的元素</span><br>    &#123;<br>        <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>        <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重（父节点记录父节点是否走过）（u和fa是交替使用的）</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d，%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);<span class="hljs-comment">// （u,fa,v,u,v,u.......） //fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）</span><br>    &#125;   <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//无向图 两边都要连接</span><br>        e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<br>        e[b].<span class="hljs-built_in">push_back</span>(&#123;c,b&#125;);<br>    &#125;<br>    <span class="hljs-comment">//1.从哪一个点开始深搜  2.当前节点的父节点</span><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;   <br>    <br>&#125;<br><span class="hljs-comment">//父节点是相互的，我们用领接表存储的时候，只要连接就是父和子的叠加态（这也解释了为什么可以回溯）</span><br><br></code></pre></td></tr></table></figure>

<h5 id="链式领接表"><a href="#链式领接表" class="headerlink" title="链式领接表"></a>链式领接表</h5><p><img src="/image-20230302111110291.png" alt="image-20230302111110291"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式领接表</span><br>两个变量：<span class="hljs-number">1.</span>边集数组 <span class="hljs-number">2.</span>表头数组<br><span class="hljs-number">1.</span>边集数组存储的是第几条边的属性：e[j]存储第j条边的&#123;起点u，终点v，边权w&#125;<br><span class="hljs-number">2.</span>表头数组存储的是u点的所有出边的编号：h[u][j](u表示的是当前的点)（j表示的是当前点连接的出边）<br>    <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> u,v,w&#125;;<br>vector&lt;edge&gt; e; <span class="hljs-comment">//边集合（边的属性）</span><br>vector&lt;<span class="hljs-type">int</span>&gt; h[N]; <span class="hljs-comment">//点的所有出边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    e.<span class="hljs-built_in">push_back</span>(&#123;a,b,c&#125;); <span class="hljs-comment">// 对应边的属性压入</span><br>    h[a].<span class="hljs-built_in">push_back</span>(e.<span class="hljs-built_in">szie</span>()<span class="hljs-number">-1</span>); <span class="hljs-comment">//当前边权数组的大小-1（这里的应该是桶数组）    </span><br>&#125;<br><span class="hljs-comment">//u当前节点 fa-父节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;h[u].<span class="hljs-built_in">size</span>();i++)&#123;<br>        <span class="hljs-type">int</span> j = h[u][j];<span class="hljs-comment">//表示的是当前的点？</span><br>        <span class="hljs-type">int</span> v = e[j].v,w = e[j].w;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//邻接表存储数据</span><br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<span class="hljs-comment">// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="链式前向星（重点）"><a href="#链式前向星（重点）" class="headerlink" title="链式前向星（重点）"></a>链式前向星（重点）</h5><p><img src="/image-20230302112003101.png" alt="image-20230302112003101"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//链式前向星 - 用边集数组和领接表结合成的 - （还是不理解）</span><br>数组<span class="hljs-number">1</span>：边集数组 - e[i]存储第i条出边的&#123;终点v,边权w，下一条边ne&#125;<br>数组<span class="hljs-number">2</span>：表头数组 - h[u]存储的是u点的第一条出边的编号（理解为第一条边就可以了）<br>边的编号：由idx分配<br><br><span class="hljs-comment">//输入 变量 1.点的个数 2.边的个数</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w,ne;&#125;;<span class="hljs-comment">//ne是下一条边</span><br>edge e[M]; <span class="hljs-comment">// 存储的是所有的边</span><br><span class="hljs-type">int</span> idx,h[N]; <span class="hljs-comment">//点的第一条出边（每个点都有）</span><br><span class="hljs-comment">//表头数组相当于给我们一个起点，让我们访问到别的边</span><br><br><span class="hljs-comment">//获取第一个出边</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b,<span class="hljs-type">int</span> c)</span></span>&#123;<br>    e[idx] = &#123;b,c,h[a]&#125;; <span class="hljs-comment">// e结构体存储的是这个边的信息</span><br>    <span class="hljs-comment">//这样理解吗 b就是a的出边 - 每次进来的a都会标记 而且idx会变化 不用担心重复</span><br>    h[a] = idx++;<br>&#125;<br><br><span class="hljs-comment">//每次添加一条边，都会把这条边的ne指针指向上一次添加的边的编号，这样就形成了一个链表。例如，如果先添加了a到b的边，再添加了a到c的边，那么h[a]就会指向a到c的边的编号，而a到c的边的ne指针就会指向a到b的边的编号，这样就可以通过h[a]和e[i].ne访问到a点的所有出边。</span><br><span class="hljs-comment">//这个函数的最后一个参数是e[idx].ne，表示这条边的下一条边的编号。赋值的是h[a]，表示a点的第一条出边的编号。这样就把这条边和a点的原来的第一条出边连接起来了，形成了一个链表。表头数组只存储了每个点的第一条出边的编号，而不是所有的边。</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//横向遍历是为了回溯</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];~i;i=e[i].ne)&#123; <span class="hljs-comment">//~i表示i不等于-1</span><br>        <span class="hljs-type">int</span> v = e[i].v,w = e[i].w;<br>        <span class="hljs-keyword">if</span>(v == fa) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重 回溯</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d,%d,%d\n&quot;</span>,u,v,w);<br>        <span class="hljs-built_in">dfs</span>(v,u);/深入<br>    &#125;    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(h,<span class="hljs-number">-1</span>,<span class="hljs-keyword">sizeof</span> h);<span class="hljs-comment">//初始化表头</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//无向图构图</span><br>        <span class="hljs-built_in">add</span>(a,b,c);<br>        <span class="hljs-built_in">add</span>(b,a,c);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;     <br>&#125;<br><br><span class="hljs-comment">//说人话就是，输入一组数据 a b c。 可以将a点作为出边点 那么b就是出边。重复构建图就是这样</span><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//ai给的例子</span><br>好的，我可以给你举一个例子。假设有一个无向图，有三个点，分别是<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span>，有三条边，分别是<span class="hljs-number">1</span>到<span class="hljs-number">2</span>，<span class="hljs-number">2</span>到<span class="hljs-number">3</span>，<span class="hljs-number">1</span>到<span class="hljs-number">3</span>。那么输入数据的过程如下：<br><br>输入第一条边<span class="hljs-number">1</span>到<span class="hljs-number">2</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)来添加这条边。<br>此时e[<span class="hljs-number">0</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">1</span>到<span class="hljs-number">2</span>的边的信息，其中v=<span class="hljs-number">2</span>表示终点是<span class="hljs-number">2</span>，w=<span class="hljs-number">0</span>表示权值是<span class="hljs-number">0</span>（这里没有用到），ne=<span class="hljs-number">-1</span>表示没有下一条边。<br>同时h[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>，表示<span class="hljs-number">1</span>点的第一条出边的编号是<span class="hljs-number">0</span>。<br>e[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">2</span>到<span class="hljs-number">1</span>的边的信息。<br>h[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>，表示<span class="hljs-number">2</span>点的第一条出边的编号是<span class="hljs-number">1</span>。<br>输入第二条边<span class="hljs-number">2</span>到<span class="hljs-number">3</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>)来添加这条边。<br>此时e[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;，表示从<span class="hljs-number">2</span>到<span class="hljs-number">3</span>的边的信息，其中ne=<span class="hljs-number">1</span>表示下一条边的编号是<span class="hljs-number">1</span>（即从<span class="hljs-number">2</span>到<span class="hljs-number">1</span>的边）。<br>同时h[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>，表示<span class="hljs-number">2</span>点的第一条出边的编号是<span class="hljs-number">2</span>（即从<span class="hljs-number">2</span>到<span class="hljs-number">3</span>的边）。<br>e[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>&#125;，表示从<span class="hljs-number">3</span>到<span class="hljs-number">2</span>的边的信息。<br>h[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>，表示<span class="hljs-number">3</span>点的第一条出边的编号是<span class="hljs-number">3</span>。<br>输入第三条边<span class="hljs-number">1</span>到<span class="hljs-number">3</span>，调用<span class="hljs-built_in">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)和<span class="hljs-built_in">add</span>(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)来添加这条边。<br>此时e[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;，表示从<span class="hljs-number">1</span>到<span class="hljs-number">3</span>的边的信息，其中ne=<span class="hljs-number">0</span>表示下一条边的编号是<span class="hljs-number">0</span>（即从<span class="hljs-number">1</span>到<span class="hljs-number">2</span>的边）。<br>同时h[<span class="hljs-number">1</span>] = <span class="hljs-number">4</span>，表示<span class="hljs-number">1</span>点的第一条出边的编号是<span class="hljs-number">4</span>（即从<span class="hljs-number">1</span>到<span class="hljs-number">3</span>的边）。<br>e[<span class="hljs-number">5</span>] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">3</span>&#125;，表示从<span class="hljs-number">3</span>到<span class="hljs-number">1</span>的边的信息，其中ne=<span class="hljs-number">3</span>表示下一条边的编号是<span class="hljs-number">3</span>（即从<span class="hljs-number">3</span>到<span class="hljs-number">2</span>的边）。<br>同时h[<span class="hljs-number">3</span>] = <span class="hljs-number">5</span>，表示<span class="hljs-number">3</span>点的第一条出边的编号是<span class="hljs-number">5</span>（即从<span class="hljs-number">3</span>到<span class="hljs-number">1</span>的边）。<br>这样就完成了输入数据和构建链式前向星存储结构。你明白了吗？<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302112236202.png" alt="image-20230302112236202"></p>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><p>dfs算法是一种深度优先搜索算法，它的特点是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。它可以用来解决许多不同类型的问题，如寻找最短路径、搜索树、图等。dfs又被称之为递归，算是一种用暴力方法求解全部点的连通性。这种方法使用于树（树是图的一种，它具有没有环的性质），下面我们用一种简单的二叉树的图进行讨论。</p>
<p><img src="/image-20230216151302883.png" alt="image-20230216151302883"></p>
<h5 id="1-dfs过程的实现"><a href="#1-dfs过程的实现" class="headerlink" title="1.dfs过程的实现"></a>1.dfs过程的实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>深搜的过程<br>   从根进入，向下走 - 走到底。 无路可走，回溯向上走，绕树根兜圈子，最后从根退出。<br><span class="hljs-number">2.</span>深搜的实现<br>   用系统栈实现的。递归调用的过程，系统自动通过栈去维护函数的状态空间。系统栈记录函数的返回地址，局部变量，参数传递。 向下走 压栈； 向上走，弹栈。 <span class="hljs-comment">// 可以看做 用栈维护不同的序列 - 弹出栈作为新的栈</span><br><span class="hljs-number">3.</span>代码（模板）<br>vector&lt;<span class="hljs-type">int</span>&gt; e[N]; <span class="hljs-comment">// 表示一颗树（或者是图）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:e[N])&#123; <span class="hljs-comment">// v遍历我们的e数组（v变量维护我们的栈）</span><br>    <span class="hljs-keyword">if</span>(v==fa) <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 就相当于 在数组中构造树（有标记的数据我们不走?） - 这里才是回溯的重点 - 问ai</span><br>    <span class="hljs-built_in">dfs</span>(v,u);<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  cin&gt;&gt;n&gt;&gt;m;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span>  i = <span class="hljs-number">1</span>;i&lt;=m;i++)<br>  cin&gt;&gt;a&gt;&gt;b, e[a].<span class="hljs-built_in">push_back</span>(b),e[b] = <span class="hljs-built_in">push_back</span>(a); <span class="hljs-comment">//这个是啥意思</span><br>  <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-number">4.</span>深搜的计算（暂时不想看）<br></code></pre></td></tr></table></figure>

<h5 id="2-dfs序列"><a href="#2-dfs序列" class="headerlink" title="2.dfs序列"></a>2.dfs序列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>dfs模板（感觉是遍历 这个树hhh）<br><span class="hljs-type">int</span> g[N][N]; <span class="hljs-comment">//这个就是 表示树（宽度 和 深度）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span><span class="hljs-comment">//fa表示树的根结点（醍醐灌顶）</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 整个树的节点个数</span><br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++) <span class="hljs-comment">// 遍历每一个节点</span><br>    &#123;<br>       <span class="hljs-keyword">if</span>(g[u][i]!=fa) <span class="hljs-comment">// u（代表当前层的一个数据）的i(表示下一层的数据)没用过</span><br>        &#123;<br>           <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//加一个辅助数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span>&#123;<br>  dfs_[++len] = u; <span class="hljs-comment">//遍历的就是当前的父节点 记录一下 （每次走过的就当是根 - 父节点的就可以了）</span><br>  <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>  &#123;<br>     <span class="hljs-keyword">if</span>(g[u][i]!=fa)&#123;<br>        <span class="hljs-built_in">dfs</span>(g[u][i],u);<span class="hljs-comment">//根节点替换</span><br>      &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//实例代码</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//一维数组 可以用作二维数组吗</span><br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dfs_[<span class="hljs-number">200020</span>],len;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    dfs_[++len]=u;  <br>    <span class="hljs-type">int</span> sz=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(g[u][i]!=fa)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>    &#123;<br>      <span class="hljs-comment">//两个点 不同方向都有一条边</span><br>        <span class="hljs-type">int</span> from,to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);<br>        g[from].<span class="hljs-built_in">push_back</span>(to);<br>        g[to].<span class="hljs-built_in">push_back</span>(from);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=len;i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>,dfs_[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs序列作用</span><br><span class="hljs-number">1.</span>子树加权<br>   在dfs序列中，一个结点的子树序列是连续的。 - 看下面的树： abdegcfh 我们关注 b结点 发现b - deg 这一段是连续的，就可以利用差分的操作就行加权。然后我们可以发现B字树B-D-E-G，C子树C-F-H都在一段连续的区间中。那么这有什么好处呢？比如说现在有一道题：给你一颗树，给出m个x和w，意为将x子树中的所有点加上一个权值w，最后询问所有点的权值 - 既然dfs序中x和他的所有子节点都在连续的区间上，那么我们就可以将它简化成差分的问题。比如说给b节点加<span class="hljs-number">2</span>，就可以简化为给b的差分数组+<span class="hljs-number">2</span>，c的差分数组<span class="hljs-number">-2</span> 。（又涉及到了差分数组了）<br>   - 怎么找第一个不在B子树中的点 引入时间戳<br><span class="hljs-number">2.</span>时间戳<br>   作用：记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。（用数组记录时间）<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> x = len+<span class="hljs-number">1</span>;<span class="hljs-comment">//数组拓展</span><br>    s[++len] = ++time; <br>   dfs_[len] = u;<span class="hljs-comment">//存储dfs序列</span><br>   <span class="hljs-type">int</span> sz = g[u].<span class="hljs-built_in">size</span>();<br>   <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>       <span class="hljs-keyword">if</span>(g[u][i] == fa)&#123;<br>          <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>   e[x] = time;<span class="hljs-comment">//存储对应 根节点到子节点的时间区间</span><br>&#125;<br><span class="hljs-comment">//如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。（算导里称之为括号化定理）</span><br></code></pre></td></tr></table></figure>

<p><img src="/1188068-20171027104122883-1380446385.png" alt="img"></p>
<p><img src="/image-20230301212454581.png" alt="image-20230301212454581"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码 </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; g[<span class="hljs-number">100010</span>];<br><span class="hljs-type">int</span> dfs_[<span class="hljs-number">200020</span>],len,time,s[<span class="hljs-number">200020</span>],e[<span class="hljs-number">200020</span>],pos[<span class="hljs-number">200020</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> fa)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> x=len+<span class="hljs-number">1</span>;<br>    s[++len]=++time;<span class="hljs-comment">//当前点 时间起点</span><br>    dfs_[len]=u;<br>    pos[u]=len;<br>    <span class="hljs-type">int</span> sz=g[u].<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;sz;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(g[u][i]!=fa)<br>        &#123;<br>            <span class="hljs-built_in">dfs</span>(g[u][i],u);<br>        &#125;<br>    &#125;<br>    e[x]=time;<span class="hljs-comment">//时间终点</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);<br>  <span class="hljs-comment">//输入我们的树</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) <br>   <span class="hljs-comment">//这段代码读入树中的边并将它们存储在邻接表 g 中。对于每条边，它都读入两个整数 from 和 to，表示边的两个端点。然后，它将 to 添加到 g[from] 的末尾，并将 from 添加到 g[to] 的末尾。这样，对于每个节点，其邻接表中都存储了与其相连的所有节点。</span><br>    &#123;<br>      <span class="hljs-comment">//用邻接表表示树</span><br>        <span class="hljs-type">int</span> from,to;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;from,&amp;to);<br>        g[from].<span class="hljs-built_in">push_back</span>(to);<br>        g[to].<span class="hljs-built_in">push_back</span>(from);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>    &#123;<br>        <span class="hljs-type">int</span> x,y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);<br>        x=pos[x];<br>        y=pos[y];<br>        <span class="hljs-keyword">if</span>(s[x]&lt;=s[y]&amp;&amp;e[y]&lt;=e[x])<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//邻接表是一种常用的表示图的数据结构，它在存储稀疏图（即边数远小于节点数平方的图）时非常高效。邻接表通过为每个节点维护一个列表来存储与其相连的所有边，因此它只需要存储 2m 个整数（其中 m 是边数），空间复杂度为 O(m)。此外，使用邻接表可以快速访问与给定节点相连的所有边，时间复杂度为 O(度数)。当然，邻接表也有一些缺点。例如，它不适用于存储稠密图（即边数接近节点数平方的图），因为这样会浪费大量空间。此外，使用邻接表判断两个节点之间是否存在边需要遍历其中一个节点的邻接表，时间复杂度为 O(度数)，不如使用邻接矩阵来得快。</span><br></code></pre></td></tr></table></figure>

<h4 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h4><h5 id="0-前置知识：队列"><a href="#0-前置知识：队列" class="headerlink" title="0.前置知识：队列"></a>0.前置知识：队列</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//队列是一种先进先出的线性表，它只允许在一端插入元素，另一端删除元素1。队列可以用数组或者链表来实现23。队列的常见操作有入队（enqueue），出队（dequeue），获取队首元素（peek），判断队列是否为空（isEmpty）等</span><br><br><span class="hljs-comment">//在bfs中： 队列的作用是存储待访问的顶点，保证按照图的宽度优先的顺序进行遍历。队列可以帮助我们记录当前层的顶点和下一层的顶点，从而找到最短路径或者最优解。队列也可以避免重复访问已经遍历过的顶点，提高搜索效率。</span><br><br><span class="hljs-comment">//1.用数组模拟队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> q[N];<br><span class="hljs-type">int</span> hh,tt; <span class="hljs-comment">//定义队头和队尾的下标 初始化 hh = 0,tt = -1;</span><br><br><span class="hljs-comment">//向队尾插入一个元素 x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    q[++tt] = x; <span class="hljs-comment">//理解tt是向右边延伸的</span><br>&#125;<br><br><span class="hljs-comment">//从队头弹出一个数（） - 队列先进先出</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>&#123;<br>    hh++;<br>&#125;<br><br><span class="hljs-comment">//查询队头元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> q[hh];<br>&#125;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> hh &gt; tt;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//输入操作次数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        string op; <span class="hljs-comment">//输入操作类型</span><br>        cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">//输入操作参数</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;push&quot;</span>) &#123; <span class="hljs-comment">//如果是入队操作</span><br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;pop&quot;</span>) &#123; <span class="hljs-comment">//如果是出队操作</span><br>            <span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;empty&quot;</span>) &#123; <span class="hljs-comment">//如果是判断空操作</span><br>            cout &lt;&lt; (<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果是查询对头操作</span><br>            cout &lt;&lt; <span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br><br><span class="hljs-comment">//2.用stl实现队列</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">//引入STL中的queue头文件</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//定义一个int类型的队列q</span><br><br><span class="hljs-comment">//向队尾插入一个元素x</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    q.<span class="hljs-built_in">push</span>(x); <span class="hljs-comment">//调用STL中的push函数</span><br>&#125;<br><br><span class="hljs-comment">//从对头弹出一个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>    q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//调用STL中的pop函数</span><br>&#125;<br><br><span class="hljs-comment">//查询对头元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//调用STL中的front函数</span><br>&#125;<br><br><span class="hljs-comment">//判断队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> q.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">//调用STL中的empty函数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">//输入操作次数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        string op; <span class="hljs-comment">//输入操作类型</span><br>        cin &gt;&gt; op;<br>        <span class="hljs-type">int</span> x; <span class="hljs-comment">//输入操作参数</span><br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;push&quot;</span>) &#123; <span class="hljs-comment">//如果是入队操作</span><br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">push</span>(x);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;pop&quot;</span>) &#123; <span class="hljs-comment">//如果是出队操作</span><br>            <span class="hljs-built_in">pop</span>();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&quot;empty&quot;</span>) &#123; <span class="hljs-comment">//如果是判断空操作</span><br>            cout &lt;&lt; (<span class="hljs-built_in">empty</span>() ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">//如果是查询对头操作</span><br>            cout &lt;&lt; <span class="hljs-built_in">front</span>() &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="1-bfs算法模版"><a href="#1-bfs算法模版" class="headerlink" title="1.bfs算法模版"></a>1.bfs算法模版</h5><p><img src="/image-20230216163555284.png" alt="image-20230216163555284"></p>
<p><img src="/image-20230310225256235.png" alt="image-20230310225256235"></p>
<p><img src="/image-20230310225331114.png" alt="image-20230310225331114"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//代码模版</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<span class="hljs-comment">//存储的领接表 - 输入的时候的数据</span><br><span class="hljs-type">int</span> vis[N];<span class="hljs-comment">//标记该点是否遍历过</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">//起点标记 和 起点入队</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">// 这里可以打印 bfs 序列</span><br>        <span class="hljs-comment">//cout&lt;&lt;x&lt;&lt;endl;</span><br>        <br>        <span class="hljs-comment">//这一段是遍历e[x]中的所有相邻点y，如果y已经被访问过，就跳过，否则就标记为已访问，并把y入队，表示下一次要访问y的相邻点。</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y: e[x])&#123;<br>            <span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;<br>            vis[y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//入队 - 起点连接的下一层出队</span><br>            <span class="hljs-comment">//cout&lt;&lt;y&lt;&lt;endl;</span><br>            q.<span class="hljs-built_in">push</span>(y);<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="2-bfs序列（树与图的遍历）"><a href="#2-bfs序列（树与图的遍历）" class="headerlink" title="2. bfs序列（树与图的遍历）"></a>2. bfs序列（树与图的遍历）</h5><p><img src="/image-20230310225353381.png" alt="image-20230310225353381"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//bfs搜索树</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> vis[N];<br>queue&lt;<span class="hljs-type">int</span>&gt; q;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">()</span></span>&#123;<br>    vis[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//出队的元素 （这里输出就是bfs树）</span><br>        <span class="hljs-comment">//printf(&quot;%d\n&quot;,x);</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:e[x])&#123;<br>            <span class="hljs-keyword">if</span>(vis[y]) <span class="hljs-keyword">continue</span>;<br>            vis[y] = <span class="hljs-number">1</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d 入队 &quot;</span>，y); <span class="hljs-comment">//伪代码</span><br>            q.<span class="hljs-built_in">push</span>(y); <span class="hljs-comment">//搜索同层序的 入队吗</span><br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230310225411526.png" alt="image-20230310225411526"></p>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p><img src="/image-20230302193314874.png" alt="image-20230302193314874"></p>
<p><img src="/image-20230302195721755.png" alt="image-20230302195721755"></p>
<p><img src="/image-20230302195739338.png" alt="image-20230302195739338"></p>
<p><img src="/image-20230302195757415.png" alt="image-20230302195757415"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说就是 按照 前面点最少的顺序排序（也就是入度从小到大）</span><br><span class="hljs-number">1.</span>Kahn算法<br>   起点是从入度为<span class="hljs-number">0</span>的点开始的（这样才能入度从小到大），使用队列来维护我们的点；<span class="hljs-number">1.</span>初始化：将所有入度为<span class="hljs-number">0</span>的点压入我们的队列（顺序不重要）；<span class="hljs-number">2.</span>每次从q中取出一个点x放入数组tp（存储最终序列）；<span class="hljs-number">3.</span>将x的所有出边删除：这个时候的x是队头，边被删除那么对应的连接点的入度就变成<span class="hljs-number">0</span>，就可以压入队列；<span class="hljs-number">4.</span>重复<span class="hljs-number">23</span>步骤。<span class="hljs-number">5.</span>如果tp中的数据和我们的点的数量一样，那么就有拓扑序列，如果不一样，那就没有。（有向 无环图才有拓扑序列）<br><span class="hljs-comment">//***</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N],tp;<span class="hljs-comment">//tp是我们最终输出的拓扑序列</span><br><span class="hljs-type">int</span> din[N]<span class="hljs-comment">//存储着点的入度（画图是不是要用领接表）</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//让入度0的进入队伍</span><br> <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(din[i] == <span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(i); <span class="hljs-comment">// din数组记录的是入度</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-type">int</span> x = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//让队头出栈 并且删除对应的边</span><br>        tp.<span class="hljs-built_in">push_back</span>(x);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> y:e[N])&#123;<br>            <span class="hljs-keyword">if</span>(--din[y]==<span class="hljs-number">0</span>) q.<span class="hljs-built_in">push</span>(y);<span class="hljs-comment">//删除对应的边 并且让对应的数据入队</span><br>        &#125;<br>    &#125;    <br>    <span class="hljs-keyword">return</span> tp.<span class="hljs-built_in">size</span>() = n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        e[a].<span class="hljs-built_in">push_back</span>(b);<br>        din[b]++;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">toposort</span>()) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;-1&quot;</span>) ; <span class="hljs-comment">//如果数量不满足 则说明这个不是拓扑序列</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:tp) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,x); <span class="hljs-comment">//将拓扑序列输出</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//dfs求拓扑序列(变色法)</span><br><span class="hljs-comment">//不懂翻转序列</span><br><span class="hljs-number">1.</span>染色法（yxc用的）<br>    每个点的颜色都会变化，从<span class="hljs-number">0</span> - <span class="hljs-number">-1</span> - <span class="hljs-number">1</span>，经历三次变色；<span class="hljs-number">1.</span>初始状态，所有点染色为<span class="hljs-number">0</span>；<span class="hljs-number">2.</span>枚举每一个点，进入x点（是我们的指针），把x染色为<span class="hljs-number">-1</span>，枚举x的儿子y，如果y的颜色为<span class="hljs-number">0</span>，那么说明没碰过该点，进入y继续走（这里应该是检测有无环 - 会不会回到x）；<span class="hljs-number">3.</span>如果枚举完x（当前数据 - 也算是队头）的儿子，将x压入tp数组；<span class="hljs-number">4.</span>如果发现，有<span class="hljs-number">-1</span>的出现（那么就是有环出现了），返回<span class="hljs-literal">false</span>，退出。<br><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N],tp;<span class="hljs-comment">//e[N] 应该是树，，或者是领接表画的图</span><br><span class="hljs-type">int</span> c[N]; <span class="hljs-comment">//染色数组</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    c[x] = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y:e[x])&#123;<br>        <span class="hljs-keyword">if</span>(c[y]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//有环</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!c[y])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(y)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    c[x] = <span class="hljs-number">1</span>;<br>    tp.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">//当前这个数据遍历完成 压入我们的tp数组</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">toposort</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(c,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(c)); <span class="hljs-comment">// 初始化 - 刚开始全部点的颜色为0</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">1</span>;x&lt;=n;x++)<br>        <span class="hljs-keyword">if</span>(!c[x])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(x)) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> <span class="hljs-built_in">reverse</span>(tp.<span class="hljs-built_in">begin</span>(),tp.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//翻转序列 为啥？</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Dijkstra-最短路算法"><a href="#Dijkstra-最短路算法" class="headerlink" title="Dijkstra - 最短路算法"></a>Dijkstra - 最短路算法</h3><p><img src="/image-20230302202401928.png" alt="image-20230302202401928"></p>
<p><img src="/image-20230302204100958.png" alt="image-20230302204100958"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说：就是每次选择最短路线进行前进（画最小生成树）</span><br>三个数组： <span class="hljs-number">1.</span>e[u] 存储节点u的所有出边的终点和边权 <span class="hljs-number">2.</span>d[u] 存储u到源点的最小距离（源点就是当前连边的点）（d[u]需要遍历）<span class="hljs-number">3.</span>vis[u] 标记是否出圈<br>    <span class="hljs-number">1.</span>初始的时候，所有点都在圈中，vis = <span class="hljs-number">0</span>,d[s] = <span class="hljs-number">0</span>,d[其他点] = 正无穷<br>    <span class="hljs-number">2.</span>从圈中选择一个距离最小的点，u，打标记出圈（贪心）<br>    <span class="hljs-number">3.</span>对u的所有出边执行松弛操作 - 尝试更新邻点v的最小距离<br>    <span class="hljs-number">4.</span>重复<span class="hljs-number">2</span>,<span class="hljs-number">3</span>操作，直到圈内为空<br><span class="hljs-comment">//代码</span><br><span class="hljs-keyword">struct</span> edge&#123;<span class="hljs-type">int</span> v,w;&#125;;<span class="hljs-comment">//点 和 权</span><br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//边</span><br><span class="hljs-type">int</span> d[N],vis[N];<span class="hljs-comment">//d数组是存储当前点的最小距离 - vis标记当前集合中的点（有没有调用这个点）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<span class="hljs-comment">//初始化 全部点的距离都为无穷大</span><br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//枚举每个点 内部枚举全部的点比较他们的距离大小（选最小的边权） - 就是每个点都要比较它自身和其它点的距离关系  （图遍历就是两层 for的）</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<span class="hljs-comment">//枚举全部点（包括自身）</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="hljs-comment">//如果这个点没被测过 并且 当前边权小</span><br>        <br>        vis[u] = <span class="hljs-number">1</span>;<span class="hljs-comment">//标记u点（下次就选不到了）</span><br>        <span class="hljs-comment">//遍历全部的点 v点的距离更新为最短的点 ed是迭代器：用处是迭代全部的点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<span class="hljs-comment">//无穷大 &gt; 其他（这样来筛数据）</span><br>                d[v] = d[u]+w;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;<br>        <span class="hljs-comment">//领接表插入图</span><br>        e[a].<span class="hljs-built_in">push_back</span>(&#123;b,c&#125;);<span class="hljs-comment">//点 连接点 边权</span><br>    &#125;    <br>    <span class="hljs-built_in">dijkstra</span>(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302204110774.png" alt="image-20230302204110774"></p>
<p><img src="/image-20230302205328621.png" alt="image-20230302205328621"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆优化 - 用优先队列维护别更新点的集合。</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N];<br><span class="hljs-comment">//优先队列</span><br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q;<span class="hljs-comment">//大根堆（把距离取负值） - 距离最小的元素最大 - 一定在堆顶（懂了 距离从小到大优化）</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//1.全部点的距离都是无穷大</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>; q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<span class="hljs-comment">//自己和自己距离为0</span><br>    <span class="hljs-comment">//2.枚举进入队列中的数据</span><br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-keyword">auto</span> t = q.<span class="hljs-built_in">top</span>(); q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-comment">//u是点吗</span><br>        <span class="hljs-type">int</span> u = t.second;<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>;<span class="hljs-comment">//判重</span><br>        vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">//之前忘记标记出队了</span><br>        <span class="hljs-comment">//当前点 遍历全部点 出来的边权最小的数据</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                d[v] = d[u]+w;<br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v],v&#125;); <span class="hljs-comment">//大根堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302205410861.png" alt="image-20230302205410861"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//就是两个模板 优化的地方就是枚举的时候用队列维护</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N]; <span class="hljs-comment">//边 和 点</span><br><span class="hljs-comment">//s是起点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = <span class="hljs-number">0x3f3f3f</span>; <span class="hljs-comment">//无穷大的值</span><br>    d[s] = <span class="hljs-number">0</span>; <span class="hljs-comment">//对于自己和自己的距离当然是0了</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//枚举次数</span><br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//优化 就是把这里优化了 取消了枚举全部点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++) <span class="hljs-comment">//枚举点</span><br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j;<br>        vis[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123; <span class="hljs-comment">//ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）</span><br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w) &#123;<br>                d[v] = d[u]+w;<br>                q.<span class="hljs-built_in">push_back</span>(&#123;-d[v],v&#125;);<span class="hljs-comment">//插入到 大根堆上</span><br>            &#125;<br>        &#125;            <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230302205417632.png" alt="image-20230302205417632"></p>
<h3 id="Bellman-Ford-处理负权边的最短路算法"><a href="#Bellman-Ford-处理负权边的最短路算法" class="headerlink" title="Bellman-Ford  - 处理负权边的最短路算法"></a>Bellman-Ford  - 处理负权边的最短路算法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//llman-Ford 算法是一种用于求解带权图中单源最短路径的算法，可以处理负权边，但不能处理负权环。</span><br> 它的时间复杂度为 $<span class="hljs-built_in">O</span>(VE)$，其中 $V$ 是顶点数，$E$ 是边数。Bellman-Ford 算法的基本思想是对所有的边进行 $V<span class="hljs-number">-1</span>$ 轮松弛操作，以求出所有可能的最短路径。如果在第 $V$ 轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。<br>    <br><span class="hljs-comment">//Bellman-Ford算法是一种用于计算带权有向图中单源最短路径的算法。</span><br>    它由Richard Bellman和Lester Ford分别在<span class="hljs-number">1958</span>年和<span class="hljs-number">1956</span>年发表，而实际上Edward F. Moore也在<span class="hljs-number">1957</span>年发布了相同的算法，因此，此算法也常被称为Bellman-Ford-Moore算法<span class="hljs-number">1</span>。它比Dijkstra的算法慢，但更通用，因为它能够处理边权值为负数的图<span class="hljs-number">2</span>。<br><br><span class="hljs-comment">//单源最短路</span><br>    单源最短路问题是图论中的一个基本问题，它指的是给定一张有权图，如何求某两点之间的最短路径<span class="hljs-number">1</span>。解决这个问题的算法有很多，比如Dijkstra算法和Bellman-Ford算法等。<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230304212846831.png" alt="image-20230304212846831"></p>
<p><img src="/image-20230304210834724.png" alt="image-20230304210834724"></p>
<p><img src="/image-20230304212028882.png" alt="image-20230304212028882"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//目的是算出图中的最短路（单源最短路：是指在一个图中，给你一个起点（起点固定），然后终点不是固定的，求起点到任意终点的最短路径）</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//这里是 点 和 权</span><br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N];<br><br><span class="hljs-comment">//内部变量是起点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bellmanford</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//初始化边集</span><br>    <span class="hljs-built_in">memset</span>(d,inf,<span class="hljs-keyword">sizeof</span> d);<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//标记</span><br>    <span class="hljs-type">bool</span> flag;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<span class="hljs-comment">//n轮更新</span><br>        flag = <span class="hljs-literal">false</span>; <span class="hljs-comment">//标记（看有无更新）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> u = <span class="hljs-number">1</span>;u&lt;=n;u++)&#123; <span class="hljs-comment">//每个点枚举出边</span><br>            <span class="hljs-keyword">if</span>(d[u] == inf) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-comment">//枚举u的领点 就行松弛操作</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123; <span class="hljs-comment">//u的出边</span><br>                <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>                <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                    d[v] = d[u] + w;<br>                    flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">//更新完成 就变true</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!flag) <span class="hljs-keyword">break</span>; <span class="hljs-comment">//没有更新就退出</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> flag; <span class="hljs-comment">//第n轮 = true 那么说明就有环    </span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="spfa-算法-用bf就好了"><a href="#spfa-算法-用bf就好了" class="headerlink" title="spfa 算法 - 用bf就好了"></a>spfa 算法 - 用bf就好了</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">SPFA 算法是Bellman-Ford算法的队列优化算法的别称，通常用于求含负权边的单源最短路径，以及判负权环。SPFA 最坏情况下复杂度和朴素Bellman-Ford相同，为<span class="hljs-built_in">o</span>(VE).<br><span class="hljs-comment">//其实还不如直接用Bellman-ford</span><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230304212218685.png" alt="image-20230304212218685"></p>
<p><img src="/image-20230304212529352.png" alt="image-20230304212529352"></p>
<p><img src="/image-20230304212738052.png" alt="image-20230304212738052"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆优化 bellman 算法 - spfa算法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//点集合</span><br><span class="hljs-type">int</span> d[N],cnt[N],vis[N]; <span class="hljs-comment">//边 边数 开关</span><br>queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">//队列</span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">spfa</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(d,inf,<span class="hljs-keyword">sizeof</span> d);<br>    <span class="hljs-comment">//开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集</span><br>    d[s] = <span class="hljs-number">0</span>; vis[s] = <span class="hljs-number">1</span>; q.<span class="hljs-built_in">push</span>(s); <br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//这里是将前面初始化的点操作的地方，每次都只操作一个点</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">front</span>(); q.<span class="hljs-built_in">pop</span>(); vis[u] = <span class="hljs-number">0</span>;<br>     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v , w = ed.w;<br>            <span class="hljs-comment">//比较枚举点和当前点 的长度 更新最短值</span><br>            <span class="hljs-keyword">if</span>(d[v]&gt;d[u]+w)&#123;<br>                d[v] = d[u]+w;<br>                cnt[v] = cnt[u]+<span class="hljs-number">1</span>; <span class="hljs-comment">//记录边数</span><br>                <span class="hljs-keyword">if</span>(cnt[v]&gt;=n) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span>(!vis[v]) q.<span class="hljs-built_in">push</span>(v),vis[v] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Floyd算法-点到点的最短路"><a href="#Floyd算法-点到点的最短路" class="headerlink" title="Floyd算法 - 点到点的最短路"></a>Floyd算法 - 点到点的最短路</h3><p><img src="/image-20230307160057133.png" alt="image-20230307160057133"></p>
<p><img src="/image-20230307160205801.png" alt="image-20230307160205801"></p>
<p><img src="/image-20230307160839691.png" alt="image-20230307160839691"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）</span><br><span class="hljs-comment">// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）</span><br><br><span class="hljs-comment">//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k;k&lt;=n;k++) <span class="hljs-comment">//以k为桥(k枚举的是所有点)</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span> ;i&lt;=n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>                d[i][j] = <span class="hljs-built_in">mid</span>(d[i][j],d[i][k]+d[k][j]); <span class="hljs-comment">//二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230307161152125.png" alt="image-20230307161152125"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//路径记录原理不了解</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">210</span>;<br><span class="hljs-type">int</span> n,m,k;<br><span class="hljs-type">int</span> d[N][N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">floyd</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;k &lt;= n;k++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++)<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n;j++)<br>                d[i][j] = <span class="hljs-built_in">min</span>(d[i][j],d[i][k]+d[k][j]);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-built_in">fill</span>(d[<span class="hljs-number">0</span>],d[<span class="hljs-number">0</span>]+N*N,<span class="hljs-number">0x3f3f3f3f</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n;i++) d[i][i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b,c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>        d[a][b] = <span class="hljs-built_in">min</span>(d[a][b],c);<br>    &#125;<br>    <span class="hljs-built_in">floyd</span>();<br>    <span class="hljs-keyword">while</span>(k--)&#123;<br>        <span class="hljs-type">int</span> a,b; cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-keyword">if</span>(d[a][b] &gt; <span class="hljs-number">0x3f3f3f3f</span>/<span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-string">&quot;impossible&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span> cout &lt;&lt; d[a][b] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230307161434260.png" alt="image-20230307161434260"></p>
<h3 id="最小生成树-prim算法"><a href="#最小生成树-prim算法" class="headerlink" title="最小生成树 - prim算法"></a>最小生成树 - prim算法</h3><p><img src="/image-20230308192754299.png" alt="image-20230308192754299"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//没有优化版本 - 基于贪心算法</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;;<br>vector&lt;edge&gt; e[N];<br><span class="hljs-type">int</span> d[N],vis[N];<span class="hljs-comment">//d是边的长度 </span><br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf;<br>    d[s] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j&lt;=n;j++)<br>            <span class="hljs-keyword">if</span>(!vis[j]&amp;&amp;d[j]&lt;d[u]) u = j; <span class="hljs-comment">//排除选过的点 - 这里是选领点的（懂了）</span><br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans+=d[u];<span class="hljs-comment">//边权和（最小生成树的边权和）</span><br>        <span class="hljs-keyword">if</span>(d[u]!=inf) cnt++; <span class="hljs-comment">//判断是否联通</span><br>        <span class="hljs-comment">//遍历到u这个点（u之前的也是一起的，算是连续的）</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;w)&#123;<br>                d[v] = w;   <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n; <span class="hljs-comment">//返回true就是有最小生成树的 返回false</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230308110618789.png" alt="image-20230308110618789"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。</span><br><span class="hljs-type">int</span> n,m,s,a,b,c,ans,cnt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,w;&#125;; <span class="hljs-comment">//构造一个结构体 内部有点和边的属性</span><br>vector&lt;edge&gt; e[N];<span class="hljs-comment">//领点（也算是所有点？）</span><br><span class="hljs-type">int</span> d[N],vis[N];<br>priority_queue&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; q; <span class="hljs-comment">//这里创一个优先队列（就是堆）</span><br><span class="hljs-comment">//s是起点</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">prim</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;=n;i++) d[i] = inf; <span class="hljs-comment">//先初始化全部的边 - 每个边都是无穷大</span><br>    <span class="hljs-comment">//起点</span><br>    d[s] = <span class="hljs-number">0</span>;q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>,s&#125;);<br>    <span class="hljs-keyword">while</span>(q.<span class="hljs-built_in">size</span>())&#123;<br>        <span class="hljs-comment">//取出q队列的点？ - 后面有进入点？</span><br>        <span class="hljs-type">int</span> u = q.<span class="hljs-built_in">top</span>().second; q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span>(vis[u]) <span class="hljs-keyword">continue</span>; <br>        vis[u] = <span class="hljs-number">1</span>;<br>        ans+=d[u]; cnt++;<br>        <span class="hljs-comment">//这里应该就是插入 领点的步骤</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> ed:e[u])&#123;<br>            <span class="hljs-type">int</span> v = ed.v,w = ed.w;<br>            <span class="hljs-keyword">if</span>(d[v]&gt;w)&#123;<br>                d[v] = w; <span class="hljs-comment">//对应点v边权最小的边</span><br>                q.<span class="hljs-built_in">push</span>(&#123;-d[v],v&#125;);<span class="hljs-comment">//大根堆</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt == n; <span class="hljs-comment">//这里判断的是啥？</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure>

<p><img src="/image-20230308110724388.png" alt="image-20230308110724388"></p>
<h3 id="最小生成树-克鲁斯卡尔算法-并查集"><a href="#最小生成树-克鲁斯卡尔算法-并查集" class="headerlink" title="最小生成树 - 克鲁斯卡尔算法 - 并查集"></a>最小生成树 - 克鲁斯卡尔算法 - 并查集</h3><p><img src="/image-20230308125205044.png" alt="image-20230308125205044"></p>
<p><img src="/image-20230308125225033.png" alt="image-20230308125225033"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">克鲁斯卡尔算法（Kruskal）是一种使用贪婪方法的最小生成树算法。该算法初始将图视为森林，图中的每一个顶点视为一棵单独的树。一棵树只与它的邻接顶点中权值最小且不违反最小生成树属性（不构成环）的树之间建立连边。<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">100010</span>,M=<span class="hljs-number">200010</span>;<br><span class="hljs-type">int</span> n,m;<br><span class="hljs-comment">//结构体存储边的信息</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<br>    <span class="hljs-type">int</span> a,b,w;<br>&#125;e[M];<br><span class="hljs-comment">//比较函数 （用来作为排序算法的参数）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(edge x,edge y)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> x.w&lt;y.w;<br>&#125;<br><span class="hljs-comment">//并查集</span><br><span class="hljs-type">int</span> p[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(p[x]!=x) p[x]=<span class="hljs-built_in">find</span>(p[x]);<br>    <span class="hljs-keyword">return</span> p[x];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>,&amp;e[i].a,&amp;e[i].b,&amp;e[i].w);<br>    <span class="hljs-comment">//排序边权（我们是用贪心来筛选的）</span><br>    <span class="hljs-built_in">sort</span>(e+<span class="hljs-number">1</span>,e+m+<span class="hljs-number">1</span>,cmp);<br>    <span class="hljs-comment">//初始化并查集</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++) p[i]=i;<br>    <span class="hljs-type">int</span> res=<span class="hljs-number">0</span>,cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)&#123;<br>        <span class="hljs-comment">//每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）</span><br>        <span class="hljs-type">int</span> a=<span class="hljs-built_in">find</span>(e[i].a),b=<span class="hljs-built_in">find</span>(e[i].b),w=e[i].w;<br>        <span class="hljs-comment">//查一下是否是连通块</span><br>        <span class="hljs-keyword">if</span>(a!=b)&#123;<br>            <span class="hljs-comment">//纳入后宫</span><br>            p[a]=b;<br>            res+=w;<br>            cnt++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cnt==n<span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;  <span class="hljs-comment">//成树</span><br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,res);<span class="hljs-comment">//输出边权</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/image-20230308100226384.png" alt="image-20230308100226384"></p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="染色法判断二分图"><a href="#染色法判断二分图" class="headerlink" title="染色法判断二分图*"></a>染色法判断二分图*</h3><p><img src="/image-20230314143817025.png" alt="image-20230314143817025"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//染色法判断二分图</span><br>首先随机选择一个未染色的顶点，将其染成红色或蓝色（或其他任意两种不同颜色）。<br>然后将与该顶点相邻的所有顶点染成与其不同的颜色。<br>重复上述过程，直到所有顶点都被染色或者发现某个顶点和它相邻的顶点已经被染成了相同的颜色。<br>如果所有顶点都被染色，那么这个图就是二分图；如果发现有冲突，那么这个图就不是二分图。<br><br><span class="hljs-comment">//二分图</span><br>二分图是图论中的一种特殊模型，它的定义是<span class="hljs-number">1234</span>：如果一个无向图的顶点集可以分成两个互不相交的子集，使得每条边的两个端点分别属于这两个子集，那么这个无向图就是二分图。例如，下图就是一个二分图：<br>    A   B   C<br>    | / | / |<br>    D   E   F<br>就是映射是吧，两个不同的集合中有连边，相同集合的不连边<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//判断此图是否是二分图</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e6</span>+<span class="hljs-number">10</span>,M = <span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><br><span class="hljs-type">int</span> h[N],e[N],ne[M],idx; <span class="hljs-comment">//e是点集 ne是边集</span><br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">//存储每一个点的状态 一共有三种 起始0 染色 1 - 2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[idx] = b, ne[idx] = h[a],h[a] = idx++; <span class="hljs-comment">//把h[a]理解为前面的桶形数组就好了</span><br>&#125;<br><span class="hljs-comment">//每次访问一个顶点u，就会先递归地访问它的所有邻接点，直到没有未访问的邻接点为止，</span><br><span class="hljs-comment">//然后再回溯到上一层。这样可以保证每个连通分量内的顶点都被染色。</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c; <span class="hljs-comment">//c是什么意思 - 是当前点的染色状态 （只有三种 0 1 2 用3减去就前后不一样了）</span><br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; ~i;i = ne[i])&#123;<br>        <span class="hljs-type">int</span> j = e[i]; <span class="hljs-comment">//邻点</span><br>        <span class="hljs-keyword">if</span>(!color[j])&#123;<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(j,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//这个是递归地调用dfs函数，给顶点j和它的邻接点染色，并判断是否有冲突。</span><br>        <span class="hljs-comment">//如果返回false，就说明发现了不符合二分图的情况，就返回false。</span><br>        <span class="hljs-comment">//冲突是指同一个子集内的顶点颜色相同，或者不同子集内的顶点颜色不同。</span><br>        <span class="hljs-comment">//这些情况都不满足二分图的定义，所以要返回false。</span><br>            &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[j] == c) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//如果顶点j已经被染色，并且与u的颜色相同，就说明同一个子集内有边相连，不符合二分图的定义，就返回false。</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-built_in">memset</span>(h, <span class="hljs-number">-1</span>, <span class="hljs-keyword">sizeof</span> h);<br>    <br>    <span class="hljs-keyword">while</span>(m--)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b); <span class="hljs-built_in">add</span>(b,a); <span class="hljs-comment">//无向图</span><br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!color[i])<br>        &#123;<br>           <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))<br>           &#123;<br>               flag = <span class="hljs-literal">false</span>;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>        &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230314144148781.png" alt="image-20230314144148781"></p>
<p><img src="/image-20230314144232392.png" alt="image-20230314144232392"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">510</span>; <span class="hljs-comment">// 顶点数的最大值</span><br><span class="hljs-type">int</span> n1, n2; <span class="hljs-comment">// 二分图左右两边的顶点数</span><br>vector&lt;<span class="hljs-type">int</span>&gt; g[N]; <span class="hljs-comment">// 邻接表存储图</span><br><span class="hljs-type">int</span> match[N]; <span class="hljs-comment">// match[i]表示右边第i个点当前匹配的左边的点</span><br><span class="hljs-type">bool</span> st[N]; <span class="hljs-comment">// st[i]表示右边第i个点是否已经被遍历过</span><br><br><span class="hljs-comment">// 在二分图中寻找增广路</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; g[x].<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-type">int</span> j = g[x][i];<br>        <span class="hljs-keyword">if</span> (!st[j]) &#123;<br>            st[j] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[j] == <span class="hljs-number">0</span> || <span class="hljs-built_in">find</span>(match[j])) &#123;<br>                match[j] = x;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 求二分图最大匹配数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n1 &gt;&gt; n2;<br>    <span class="hljs-type">int</span> m; <span class="hljs-comment">// 边数</span><br>    cin &gt;&gt; m;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a].<span class="hljs-built_in">push_back</span>(b);<br>    &#125;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 最大匹配数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n1; i++) &#123;<br>        <span class="hljs-built_in">memset</span>(st, <span class="hljs-literal">false</span>, <span class="hljs-keyword">sizeof</span> st);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">find</span>(i)) res++;<br>    &#125;<br><br>    cout &lt;&lt; res &lt;&lt; endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="二分图的最大匹配"><a href="#二分图的最大匹配" class="headerlink" title="二分图的最大匹配"></a>二分图的最大匹配</h3><h4 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法*"></a>匈牙利算法*</h4><p><img src="/image-20230314205307317.png" alt="image-20230314205307317"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">1.</span>匈牙利算法 - 二分图的最大匹配<br> 二分图，简单来说就是不同集合有联系；同一集合不可以有联系； - 边数最多的一组匹配被称之为最大匹配<br> 在二分图的前提下： <span class="hljs-number">1.</span>交替路 <span class="hljs-number">2.</span>增广路  - 交替路就是匹配和不匹配边交替出现 - 增光路就是匹配和不匹配交换身份，看有没有多路径，多了就是增广路<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">1e5</span>+<span class="hljs-number">10</span>,M = <span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> n,m,k,a,b,ans,idx;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,ne;&#125;e[M]; <span class="hljs-comment">//点（对应位置的妹子） ne 另一集合的点是吗</span><br><span class="hljs-type">int</span> h[N],idx;<br><span class="hljs-type">int</span> vis[N],match[M]; <span class="hljs-comment">//标记 和 匹配</span><br><br><span class="hljs-comment">//链式前向星</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++idx] = &#123;b,h[a]&#125;;<br>    h[a] = idx++; <span class="hljs-comment">//横置数组向右移动</span><br>&#125;<br><span class="hljs-comment">//男女匹配问题 (boy and girl）</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    <span class="hljs-comment">//每一个都要匹配看看</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u]; i;i = e[i].ne)&#123;<br>        <span class="hljs-type">int</span> v = e[i].v; <span class="hljs-comment">//妹子</span><br>        <span class="hljs-keyword">if</span>(vis[v]) <span class="hljs-keyword">continue</span>;<br>        vis[v] = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记</span><br>        <span class="hljs-keyword">if</span>(!match[v]||<span class="hljs-built_in">dfs</span>(match[v]))&#123; <span class="hljs-comment">//没有匹配 || 能不能换（dfs的功能就是判断能不能换）</span><br>            match[v] = u;<span class="hljs-comment">//成对</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;k;i++) cin&gt;&gt;a&gt;&gt;b,<span class="hljs-built_in">add</span>(a,b); <span class="hljs-comment">//建图</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-built_in">memset</span>(vis,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span> vis);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(i)) ans++;<br>    &#125;<br>    cout&lt;&lt;ans;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>    <br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="染色法判断二分图-1"><a href="#染色法判断二分图-1" class="headerlink" title="染色法判断二分图"></a>染色法判断二分图</h4><p><img src="/image-20230315104701595.png" alt="image-20230315104701595"></p>
<p><img src="/image-20230315123714291.png" alt="image-20230315123714291"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//1.二分图的定义</span><br> 两个不同的集合，互相联通 - 相同集合不可能联通<br><span class="hljs-comment">//2.染色法</span><br>    可以用dfs和bfs来实现染色法，重点是怎么实现前后颜色不同。 我们运用两个标记来判断对应节点的状态： <span class="hljs-number">1</span> 表示这个节点是红 <span class="hljs-number">2</span>表示是黑 <span class="hljs-number">0</span>表示没选这个（加上个判重）<br>   <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">edge</span>&#123;<span class="hljs-type">int</span> v,ne;&#125;e[M];<br><span class="hljs-type">int</span> h[N];<br><span class="hljs-type">int</span> color[N]; <span class="hljs-comment">//颜色有三种 0 1 2</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span></span>&#123;<br>    e[++idx] = &#123;b,h[a]&#125;; <span class="hljs-comment">//用链式前向星存储的</span><br>    h[a] = idx++;<br>&#125;<br><span class="hljs-comment">//u点的颜色c </span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> c)</span></span><br><span class="hljs-function"></span>&#123;<br>    color[u] = c;<br>    <span class="hljs-comment">//枚举u的领边</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = h[u];i;e[i].ne)<br>    &#123;<br>        <span class="hljs-type">int</span> v = e[i].v;<br>        <span class="hljs-keyword">if</span>(!color[v])&#123; <span class="hljs-comment">//还没有被访问</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">dfs</span>(v,<span class="hljs-number">3</span>-c)) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">//改变不同层的颜色</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(color[v] == c) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;   <br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i&lt;m;i++)&#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin&gt;&gt;a&gt;&gt;b;<br>        <span class="hljs-built_in">add</span>(a,b);<br>        <span class="hljs-built_in">add</span>(b,a);<br>    &#125;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i&lt;=n;i++)<br>        <span class="hljs-keyword">if</span>(!color[i])<br>            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">dfs</span>(i,<span class="hljs-number">1</span>))&#123;<br>                flag = <span class="hljs-number">1</span>;<span class="hljs-comment">//有奇环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>    <span class="hljs-keyword">if</span>(flag) <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;No&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Yes&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/image-20230314142804998.png" alt="image-20230314142804998"></p>
<p><img src="/image-20230314143439093.png" alt="image-20230314143439093"></p>
<p><img src="/image-20230314143503237.png" alt="image-20230314143503237"></p>
<h3 id="最近公共祖先"><a href="#最近公共祖先" class="headerlink" title="最近公共祖先"></a><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811">最近公共祖先</a></h3><h4 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h4><p><img src="/image-20230319121246852.png" alt="image-20230319121246852"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">100005</span>;<br><span class="hljs-type">int</span> n, m;<br>vector&lt;<span class="hljs-type">int</span>&gt; tree[MAXN]; <span class="hljs-comment">// 邻接表存储树</span><br><span class="hljs-type">int</span> depth[MAXN], parent[MAXN]; <span class="hljs-comment">// 深度和父亲节点</span><br><br><span class="hljs-comment">// 深度优先搜索遍历计算深度和父亲节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    depth[u] = depth[p] + <span class="hljs-number">1</span>;<br>    parent[u] = p;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : tree[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v != p) <span class="hljs-built_in">dfs</span>(v, u);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算两个节点的最近公共祖先</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (depth[u] &gt; depth[v]) u = parent[u];<br>    <span class="hljs-keyword">while</span> (depth[v] &gt; depth[u]) v = parent[v];<br>    <span class="hljs-keyword">while</span> (u != v) &#123;<br>        u = parent[u];<br>        v = parent[v];<br>    &#125;<br>    <span class="hljs-keyword">return</span> u;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n &gt;&gt; m; <span class="hljs-comment">// 读入节点数和查询数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 读入边</span><br>        tree[u].<span class="hljs-built_in">push_back</span>(v);<br>        tree[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    <br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">// 计算深度和父亲节点</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v; <span class="hljs-comment">// 读入查询</span><br>        cout &lt;&lt; <span class="hljs-built_in">lca</span>(u, v) &lt;&lt; endl; <span class="hljs-comment">// 输出结果</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>这个模板中，n 是树的节点数，m 是查询数量。对于每组查询，它读入两个节点编号 u 和 v，然后调用函数 <span class="hljs-built_in">lca</span>(u,v) 来获取它们的最近公共祖先。<br></code></pre></td></tr></table></figure>

<h4 id="Tarjan算法"><a href="#Tarjan算法" class="headerlink" title="Tarjan算法"></a>Tarjan算法</h4><p><img src="/image-20230314144355261.png" alt="image-20230314144355261"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//Tarjan算法是由Robert Tarjan发明的一种图算法。它可以用于解决许多不同类型的问题，包括寻找强连通分量、双连通分量、割点和割边等。其中一种应用是在树中查找节点对的最近公共祖先（LCA）。Tarjan算法通过深度优先搜索和并查集数据结构来高效地解决这个问题。</span><br><br><span class="hljs-comment">//tarjan算法 ： 利用并查集</span><br>vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt;&gt; query[N];<br><span class="hljs-type">int</span> fa[N],vis[N],ans[M];<br><span class="hljs-comment">//并查集</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(u == fa[u]) <span class="hljs-keyword">return</span> u;<br>    <span class="hljs-keyword">return</span> fa[u] = <span class="hljs-built_in">find</span>(fa[u]);    <br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">tarjan</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span></span>&#123;<br>    fa[u] = u; <span class="hljs-comment">// 初始化父亲为自己</span><br>    vis[u] = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 标记</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> v:e[u])<br>    &#123;<br>        <span class="hljs-keyword">if</span>(!vis[v])&#123;<br>            tarjan[v];<br>            fa[v] = u;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> q:query[u])&#123;<br>        <span class="hljs-type">int</span> v = q.first,i = q.second;<br>        <span class="hljs-keyword">if</span>(vis[v]) ans[i] = <span class="hljs-built_in">find</span>(v);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="树链剖分-不理解"><a href="#树链剖分-不理解" class="headerlink" title="树链剖分(不理解)"></a>树链剖分(不理解)</h4><p><img src="/image-20230315210121556.png" alt="image-20230315210121556"></p>
<p><img src="/image-20230315210610462.png" alt="image-20230315210610462"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt; e[N];<br><span class="hljs-type">int</span> fa[N],dep[N],son[N],sz[N];<br><span class="hljs-type">int</span> top[N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> father)</span></span>&#123;<br>    fa[u] = father, dep[u] = dep[father]+<span class="hljs-number">1</span>,sz[u] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v==father) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(v,u);<br>        sz[u] += sz[v];<br>        <span class="hljs-keyword">if</span>(sz[son[u]]&lt;sz[v]) son[u] = v;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    top[u] = t;<br>    <span class="hljs-keyword">if</span>(!son[u]) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-built_in">dfs2</span>(son[u],t);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> v:e[u])&#123;<br>        <span class="hljs-keyword">if</span>(v == fa[u] || v == son[u]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs2</span>(v,v);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lca</span><span class="hljs-params">(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v)</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(top[u]!=top[v])&#123;<br>        <span class="hljs-keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="hljs-built_in">swap</span>(u,v);<br>        u = fa[top[u]];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dep[u]&lt;dep[v]?u:v;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="倍增算法（不理解）"><a href="#倍增算法（不理解）" class="headerlink" title="倍增算法（不理解）"></a>倍增算法（不理解）</h4><p><img src="/image-20230315210919875.png" alt="image-20230315210919875"></p>
<p><img src="/image-20230315210938761.png" alt="image-20230315210938761"></p>
<p><img src="/image-20230315210958755.png" alt="image-20230315210958755"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br></code></pre></td></tr></table></figure>

<h4 id="总"><a href="#总" class="headerlink" title="总"></a>总</h4><p><img src="/image-20230315210622550.png" alt="image-20230315210622550"></p>
<h2 id="补充2"><a href="#补充2" class="headerlink" title="补充2"></a>补充2</h2><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树*"></a>线段树*</h3><p><img src="/image-20230401100823894.png" alt="image-20230401100823894"></p>
<p><img src="/image-20230401100840271.png" alt="image-20230401100840271"></p>
<p><img src="/image-20230401100850209.png" alt="image-20230401100850209"></p>
<p><img src="/image-20230401100859800.png" alt="image-20230401100859800"></p>
<p><img src="/image-20230401100913730.png" alt="image-20230401100913730"></p>
<h3 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组*"></a>树状数组*</h3></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ilovchara.github.io">chara</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://ilovchara.github.io/2023/04/28/Four/">https://ilovchara.github.io/2023/04/28/Four/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ilovchara.github.io" target="_blank">Jane Station</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/picture/img/Girl%20of%20the%20Deep.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/04/28/Five/" title="Five"><img class="cover" src="/picture/img/Girl%20of%20the%20Deep.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">Five</div></div></a></div><div><a href="/2023/04/26/One/" title="One 基本算法"><img class="cover" src="/picture/img/Girl%20of%20the%20Deep.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">One 基本算法</div></div></a></div><div><a href="/2023/04/28/Six/" title="six"><img class="cover" src="/picture/img/Girl%20of%20the%20Deep.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-28</div><div class="title">six</div></div></a></div><div><a href="/2023/04/27/Three/" title="Three 基本数据结构"><img class="cover" src="/picture/img/Girl%20of%20the%20Deep.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-27</div><div class="title">Three 基本数据结构</div></div></a></div><div><a href="/2023/04/26/Two/" title="Two 对数据的基本操作"><img class="cover" src="/picture/img/Girl%20of%20the%20Deep.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-26</div><div class="title">Two 对数据的基本操作</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/picture/img/Vigus.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">chara</div><div class="author-info__description">一个菜鸟刚搭的网站</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">3</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ilovchara"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ilovchara" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这里我也不知道怎么写,先计划写完web吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9B%BE%E8%AE%BA%E7%9A%84%E6%8B%93%E5%B1%95"><span class="toc-number">1.</span> <span class="toc-text">第四章 - 图论的拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.完全二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.平衡二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.用数组实现二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.4.</span> <span class="toc-text">4.二叉树的链式实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.1.5.</span> <span class="toc-text">5.二叉树的遍历步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-number">1.2.</span> <span class="toc-text">深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86-%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">0.前置知识 图的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">领接矩阵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">边集数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%86%E6%8E%A5%E8%A1%A8%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">领接表（重点）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E9%A2%86%E6%8E%A5%E8%A1%A8"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">链式领接表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">链式前向星（重点）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS"><span class="toc-number">1.2.2.</span> <span class="toc-text">DFS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-dfs%E8%BF%87%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1.dfs过程的实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-dfs%E5%BA%8F%E5%88%97"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2.dfs序列</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFS"><span class="toc-number">1.2.3.</span> <span class="toc-text">BFS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#0-%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86%EF%BC%9A%E9%98%9F%E5%88%97"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">0.前置知识：队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-bfs%E7%AE%97%E6%B3%95%E6%A8%A1%E7%89%88"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">1.bfs算法模版</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-bfs%E5%BA%8F%E5%88%97%EF%BC%88%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">2. bfs序列（树与图的遍历）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra-%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">Dijkstra - 最短路算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bellman-Ford-%E5%A4%84%E7%90%86%E8%B4%9F%E6%9D%83%E8%BE%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.</span> <span class="toc-text">Bellman-Ford  - 处理负权边的最短路算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spfa-%E7%AE%97%E6%B3%95-%E7%94%A8bf%E5%B0%B1%E5%A5%BD%E4%BA%86"><span class="toc-number">1.6.</span> <span class="toc-text">spfa 算法 - 用bf就好了</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95-%E7%82%B9%E5%88%B0%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.7.</span> <span class="toc-text">Floyd算法 - 点到点的最短路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-prim%E7%AE%97%E6%B3%95"><span class="toc-number">1.8.</span> <span class="toc-text">最小生成树 - prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.9.</span> <span class="toc-text">最小生成树 - 克鲁斯卡尔算法 - 并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">2.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">2.1.</span> <span class="toc-text">染色法判断二分图*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.</span> <span class="toc-text">二分图的最大匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">匈牙利算法*</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%93%E8%89%B2%E6%B3%95%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">染色法判断二分图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">2.3.</span> <span class="toc-text">最近公共祖先</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%B4%E7%B4%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">朴素方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tarjan%E7%AE%97%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">Tarjan算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86-%E4%B8%8D%E7%90%86%E8%A7%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">树链剖分(不理解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%8D%E7%90%86%E8%A7%A3%EF%BC%89"><span class="toc-number">2.3.4.</span> <span class="toc-text">倍增算法（不理解）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB"><span class="toc-number">2.3.5.</span> <span class="toc-text">总</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%852"><span class="toc-number">3.</span> <span class="toc-text">补充2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">3.1.</span> <span class="toc-text">线段树*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">3.2.</span> <span class="toc-text">树状数组*</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/29/c/" title="c#"><img src="/picture/img/Girl%20of%20the%20Deep.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="c#"/></a><div class="content"><a class="title" href="/2023/05/29/c/" title="c#">c#</a><time datetime="2023-05-29T07:39:15.000Z" title="发表于 2023-05-29 15:39:15">2023-05-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/English/" title="English"><img src="/picture/img/Girl%20of%20the%20Deep.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="English"/></a><div class="content"><a class="title" href="/2023/05/24/English/" title="English">English</a><time datetime="2023-05-24T13:01:04.000Z" title="发表于 2023-05-24 21:01:04">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/30/Web/" title="Web"><img src="/picture/img/Girl%20of%20the%20Deep.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Web"/></a><div class="content"><a class="title" href="/2023/04/30/Web/" title="Web">Web</a><time datetime="2023-04-30T14:39:00.000Z" title="发表于 2023-04-30 22:39:00">2023-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/30/Linux/" title="Linux"><img src="/picture/img/Girl%20of%20the%20Deep.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux"/></a><div class="content"><a class="title" href="/2023/04/30/Linux/" title="Linux">Linux</a><time datetime="2023-04-30T14:29:58.000Z" title="发表于 2023-04-30 22:29:58">2023-04-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/28/Six/" title="six"><img src="/picture/img/Girl%20of%20the%20Deep.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="six"/></a><div class="content"><a class="title" href="/2023/04/28/Six/" title="six">six</a><time datetime="2023-04-28T01:09:57.000Z" title="发表于 2023-04-28 09:09:57">2023-04-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/picture/img/Girl%20of%20the%20Deep.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2023 By chara</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://butterfly.js.org/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (true){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"></div><script type="text/javascript" src="https://unpkg.zhimg.com/jquery@latest/dist/jquery.min.js"></script><script data - pjax type = "text/javascript" src = "/js/chara/flink.js" ></script ><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="点啥,别点,QAQ" data-fontsize="15px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>