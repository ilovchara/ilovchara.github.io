---
title: 数据结构 - 总结
date: 2024-04-16 15:06:52
tags: 算法
categories: 算法
typora-root-url: ./数据结构-总结
---

# 数据结构

> 对于我在大学中学习的数据结构做一个总结，之前走了太多的弯路。同时也记录一下考研数据结构的内容。用的教材是王道的。

## 第一章 - 绪论

### 数据基本概念

> 按照教材的原文，在其中补充我的理解，还有课后习题会写出相应的代码。

![image-20240416152423854](/image-20240416152423854.png)

![image-20240416152415165](/image-20240416152415165.png)

这两段需要记住的只有最后一句话，**算法的设计取决于选定的逻辑结构，算法的实现依赖于采用的存储结果.**

对于数据类型来说，抽象数据结构是由不同类来创建的。例如我有一个动物类，创建了一个抽象的类型，这个类型用于调用这个动物类的一些方法。

![image-20240416172232460](image-20240416172232460.png)

线性结构和非线性结构的区别就是：线性结构从开头走到结尾只有一条路。非线性可以有多条路。同时也可以用对应关系来理解。

![image-20240416172426064](image-20240416172426064.png)

![image-20240416172435984](image-20240416172435984.png)

![image-20240416172444116](image-20240416172444116.png)

需要记住的是这些存储的优点和缺点

- 顺序存储结构的有点是**实现随机存储**，缺点是声明存储单元时需要一整块内存区域

- 链式存储优点是**可以利用所有区域的存储资源**，缺点是使用了指针占用了其他的存储资源，而且储存逻辑也是线性的

- 索引存储的有点是查找速度快，类似于字典。缺点是附加了索引值`index`，增加值或者减去值都需要修改索引表

- 散列，通过映射的方法将数据压缩存储。优点是检索，可以理解为字典，缺点是设计散列函数麻烦，可能会引发哈希冲突。

  

![image-20240416172936957](image-20240416172936957.png)

![image-20240416173003841](image-20240416173003841.png)

第一题选D，数据结构可以理解为抽象数据类型声明的对象。这里可以简单理解为数据结构是抽象数据类型声明的实例

![image-20240416173626552](image-20240416173626552.png)

第二题选A，树可以由一个起点走不同的路到达终点，所以说它是非线性数据结构

![image-20240416173825424](image-20240416173825424.png)

逻辑结构指数据元素之间的相互关系，但是不考虑它们在计算机内存中的存储方式。这题选C.哈希表不是逻辑结构，是一种散列结构。**哈希表的核心思想是将数据元素存储在数组中，通过哈希函数将数据元素的关键字映射到数组的索引位置，从而实现快速的数据查找和访问。**

![image-20240416174333361](image-20240416174333361.png)

这题选D，栈是抽象数据结构也就是类。这里标注一下，在程序中我们声明一个变量需要标注其数据结构，所有可以声明的变量类似于(c语言内没有内置栈)

```c#
Stack<int> a = new Stack<int>();
```

![image-20240416213310338](image-20240416213310338.png)

选择A，这道题不是很懂

![image-20240416213540779](image-20240416213540779.png)

![image-20240416213604170](image-20240416213604170.png)

选择C，这个可以用链表的存储结构来解释。链表通常有两个属性来决定，一个是指向下一个值的地址，一个是当前地址的值。**所以说存储的不单单有值，而且也有两个数据之间的关系。**

![image-20240416213802402](image-20240416213802402.png)

选A，刚开始选的是C。后面发现错误了，每一个值的存储位置是连续的，不同值的存储位置可能不一样所以说就不连续。

![image-20240416214034174](image-20240416214034174.png)

- 对于数据结构来说，我们先搞清楚逻辑结构和物理结构是什么。逻辑结构是对于数据对象之间的关系，如果数据对象是一对一的关系，例如数组的索引与在数组中数据的排序对应。还有一对多图关系。还有数据的等级相同的集合关系，还有对应的层次类似于文件夹和文件的关系。物理结构是存储在内存中的位置关系，例如数组在内存是声明一块的内存用于存储数据，链表则是利用指针收集零散的位置来存储我们的数据。回到问题本身，对于两种不同的数据结构，他们的逻辑结构和物理结构可能相同，例如二叉树和二叉排序树，**但是在最终的输出和时间复杂度却不相同，原因是他们所赋予的逻辑结构和数据的运算任务不同。**

![image-20240416220127179](image-20240416220127179.png)

- 例如，线性表可以用顺序存储方式实现也就是数组，也可以用链式存储方式也就是链表。他们在插入和删除元素的时候，时间复杂度不一样。对于链表来说，插入和删除很困难，这是由于有地址的存在，需要让这个指针有意义就需要更改指向位置。这里我之前[写过](https://wniee.cn/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/?highlight=%E9%93%BE%E8%A1%A8)

![image-20240416220529051](image-20240416220529051.png)

### 算法评价

![image-20240416221100022](image-20240416221100022.png)

概念性的东西只能背了。简单过一遍就行

![image-20240416221144299](image-20240416221144299.png)

占时间复杂度最多的就是循环，更多的就是递归。

![image-20240416221237259](image-20240416221237259.png)

![image-20240416221551144](image-20240416221551144.png)

接下来的空间复杂度就要估算数据结构的大小了

![image-20240416221636077](image-20240416221636077.png)

开始做题：

![image-20240416221652875](image-20240416221652875.png)

选择B和C，第二题不用多说，时间复杂度是简单估算大概要花多少时间。第一题，**算法是解决问题或执行任务的明确、有序且有效的计算过程。也就是问题求解步骤的描述**

![image-20240416222126754](image-20240416222126754.png)

`i`会在每次循环的时候翻倍，直接看到最后一次循环，设最后一次循环的`i`的值为`K`，则退出循环的时候应该有`2^k > n` 也就是 `k > log n`

**所以说选择D，但是教材选择C我这里是觉得教材错了**

![image-20240416223324046](image-20240416223324046.png)

直接跳到最后一次循环，设最后一次循环的`i`的值是`K = i^3`。所以说退出循环需要，`i^3 <=n` 所以说选择C

![image-20240416223702501](image-20240416223702501.png)

不看最后的执行表达式，直接看两个循环的关系，也即是看`i和j`。对于`i`整个循环长度是 `n`。对于`j`来说，它的长度是`1+2+3+...+n`，这个等差数列我们学过，它趋向于`(n^2+n) / 2` 。最终执行语句的次数的等级就是`n^2`。

![image-20240416225213671](image-20240416225213671.png)

![image-20240416225851691](image-20240416225851691.png)

这道题不太懂（biaoji）

![image-20240416230028955](image-20240416230028955.png)

![image-20240416230432110](image-20240416230432110.png)

纯概念的东西。(biaoji)

![image-20240416230541741](image-20240416230541741.png)

![image-20240416230724092](image-20240416230724092.png)

设总执行次数为`t`，则有`2^(t+1)<n/2` 然后取对数就行。总算会算了。精髓就是用总执行次数替换循环条件位置的x

![image-20240416231106099](image-20240416231106099.png)

![image-20240417211755555](image-20240417211755555.png)

整数阶乘，执行了n次也就是n的时间复杂度选择B

![image-20240417213148292](image-20240417213148292.png)

选择D，循环判断，每次判断两个链表中的变量谁大谁小，然后放入到新的链表中，执行的次数与最大的链表长度相关。下面是简单的代码：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> mergeLists(const std::vector<int>& list1, const std::vector<int>& list2) {
    std::vector<int> mergedList;
    int i = 0, j = 0;

    // 从后往前遍历两个降序列表，将较大的元素依次插入到合并后的列表中
    while (i < list1.size() && j < list2.size()) {
        if (list1[i] > list2[j]) {
            mergedList.push_back(list1[i]);
            i++;
        } else {
            mergedList.push_back(list2[j]);
            j++;
        }
    }

    // 将剩余的元素依次插入到合并后的列表中
    while (i < list1.size()) {
        mergedList.push_back(list1[i]);
        i++;
    }
    while (j < list2.size()) {
        mergedList.push_back(list2[j]);
        j++;
    }

    // 将合并后的列表反转，得到升序列表
    std::reverse(mergedList.begin(), mergedList.end());

    return mergedList;
}

int main() {
    // 示例输入
    std::vector<int> list1 = {10, 8, 6, 4, 2};
    std::vector<int> list2 = {9, 7, 5, 3, 1};

    // 合并两个降序列表为一个升序列表
    std::vector<int> mergedList = mergeLists(list1, list2);

    // 输出合并后的列表
    std::cout << "合并完成的链表为: ";
    for (int num : mergedList) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

![image-20240417222328418](image-20240417222328418.png)

bu，内层循环变量与外层循环无关！首先计算外层的循环次数，设置循环次数为`t`，则`k = 2^t <= n`，所以说循环次数`t<=logn`。内层循环`n`，所以说二者相乘选择C

![image-20240417222539376](image-20240417222539376.png)

![image-20240417223400969](image-20240417223400969.png)

等价于`sum++`，设`t`为退出循环的次数，`sum`运行的次数是`n(n+1)/2`.循环次数满足`(1+t)*t/2<n`，所以说选择C。就像解方程，需要求得满足这个不等式，找出`Sum`这个值增大到退出循环时候的方程是什么即可。

![image-20240417224222547](image-20240417224222547.png)

buhui

![image-20240417224529491](image-20240417224529491.png)

![image-20240417224554251](image-20240417224554251.png)

![image-20240417224821670](image-20240417224821670.png)

明天找这个重点

![image-20240417224833946](image-20240417224833946.png)

我有点找不到重点，还是得总结规律

![image-20240417224908140](image-20240417224908140.png)

