---
title: 横版移动射击游戏-2
date: 2025-01-03 17:44:18
categories: unity
---

## 横版移动射击游戏(2)

### 项目流程(4) 限制视窗

在之前的项目流程(3)中，实现了主角的移动效果。但是出现玩家移动到镜头外面的情况，可以通过限制玩家的移动效果来达到。这里通过单例的方式，创建一个脚本用来控制`environment`

![image-20250106150753444](01-03-横版移动射击游戏-2/image-20250106150753444.png)

为了解耦和复用，创建一个类供给`viewport`来继承，通过这个类，可以在创建对象时自动生成一个 `instance` 对象。继承该类的子类，，在创建对象时也能拥有一个 `instance` 对象实现了单例的效果。使用**泛型单例**模式的最大优势之一就是，它**自动管理单例实例**，这样你就无需在主程序或其他地方手动创建 `Instance` 对象了。

![image-20250106151932731](01-03-横版移动射击游戏-2/image-20250106151932731.png)

```c#
using UnityEngine;

public class Singleton<T> : MonoBehaviour where T : Component
{
    // 声明属性
    public static T Instance { get; private set;}

    protected virtual void Awake()
    {
        Instance = this as T;
    }
}

```

然后在挂载的`environment`中编写程序，根据下面的模型图，编写了限制范围。

![image-20250106152025036](01-03-横版移动射击游戏-2/image-20250106152025036.png)

在 Unity 中，搭载了 **Transform** 组件的对象具有以下属性：

1. **Pivot（旋转中心点）**：

   `Pivot` 是 3D 模型旋转的中心点。在 `Unity `中，你可以设置模型的 `Pivot` 点，模型将围绕此点进行旋转。图中绿色线标出的是飞机模型的旋转中心。

2. **PaddingX**：

   `PaddingX `是指在 X 轴方向上增加的填充距离。在使用物理引擎或碰撞检测时，可能需要在模型边界之外增加一定的空间，以避免模型之间的穿透或提高物理交互的稳定性。图中用红色箭头表示了 X 轴方向的填充距离。

3. **PaddingY**：

   `PaddingY `是指在 Y 轴方向上增加的填充距离。与 `PaddingX `类似，它用于在 Y 轴方向上增加额外的空间，从而提高物理交互的稳定性。图中用绿色箭头表示了 Y 轴方向的填充距离。

```c#
using UnityEngine;
using UnityEngine.UIElements;

public class Viewport: Singleton<Viewport>
{
    // 定义限制窗口

    float minX;

    float maxX;

    float minY;

    float maxY;

    // 初始化限定世界位置
    void Start()
    {
        Camera mainCamera = Camera.main;

        Vector2 bottomLeft = mainCamera.ViewportToWorldPoint(new Vector3(0f,0f));
        Vector2 topRight = mainCamera.ViewportToWorldPoint(new Vector3(1f,1f));

        minX = bottomLeft.x;
        minY = bottomLeft.y;
        maxX = topRight.x;
        maxY = topRight.y;
    }

    public Vector3 PlayerMoveablePosition(Vector3 playerPosition, float paddingX, float paddingY)
    {
        Vector3 position = Vector3.zero;

        position.x = Mathf.Clamp(playerPosition.x, minX + paddingX, maxX - paddingX);
        position.y = Mathf.Clamp(playerPosition.y, minY + paddingY, maxY - paddingY);

        return position;
    }

}
```

在`player`中调用上面声明的对象，将设置好的变量带入到函数之中。这段代码通过使用协程实现了一个无限循环的过程，用于实时获取当前对象的位置并对其进行限制。具体来说，这个协程在每一帧更新物体的位置，以确保它始终位于允许的范围内。

协程的作用是在 Unity 中实现**延时操作**或**分步执行**，并且**不阻塞主线程**。它允许你在多个时间点之间暂停执行某些任务，并在合适的时候恢复执行。常用于处理时间相关的操作，如动画、等待、异步任务等。想象你在一个银行排队办理业务。排队的过程就像是协程的执行：

1. **排队（协程开始）**：你排队等待办理业务，但你不会一直站着不动。你可以在排队时做其他事，比如看看手机或和旁边的人聊天，这就类似于协程中“暂停”执行的状态。
2. **等待（暂停执行）**：假设有些事务需要时间，比如银行工作人员在为前一个客户办理业务，你只能站在那里等待。这时，虽然你在等待，但并没有浪费时间，其他事情（比如其他客户办理业务）仍在继续进行。协程也会在“等待”某些条件时暂停，并允许其他代码执行。
3. **被叫到窗口（继续执行）**：当轮到你办理业务时，银行工作人员叫你过去，你继续处理自己的事务。此时，你的操作就像是协程恢复执行，继续完成接下来的任务。
4. **业务完成（协程结束）**：一旦业务完成，你可以离开排队。协程也是如此，完成所有操作后自然结束。

```c#
using System.Collections;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.Scripting.APIUpdating;

[RequireComponent(typeof(Rigidbody2D))]
public class Player : MonoBehaviour
{
    [SerializeField] PlayerInput input;
    [SerializeField] float moveSpeed = 10f;
    // 声明的这几个来约束玩家移动的位置
    [SerializeField] float paddingX;
    [SerializeField] float paddingY;

    new Rigidbody2D rigidbody; 

    [System.Obsolete]
    void OnEnable()
    {   
        input.onMove += Move;
        input.onStopMove += StopMove;
    }

    [System.Obsolete]
    void OnDisable()
    {
        input.onMove -= Move;
        input.onStopMove -= StopMove;
    }


    void Start()
    {
        rigidbody = GetComponent<Rigidbody2D>(); 
        rigidbody.gravityScale = 0f;

        input.EnableGameplayInput();
    }

	// 调用协程
    [System.Obsolete]
    void Move(Vector2 moveInput)
    {
        rigidbody.velocity = moveInput * moveSpeed;
        StartCoroutine(MovePositionLimitCoroutine());
    }
	// 调用协程
    [System.Obsolete]
    void StopMove()
    {
        rigidbody.velocity = Vector2.zero;
        StopCoroutine(MovePositionLimitCoroutine());

    }
    
    IEnumerator MovePositionLimitCoroutine()
    {
        while(true)
        {
            transform.position = Viewport.Instance.PlayerMoveablePosition(transform.position, paddingX, paddingY);
            // 暂停执行当前方法
            yield return null;
        }
    }

}
```

