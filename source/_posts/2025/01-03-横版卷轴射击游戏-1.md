---
title: 横版卷轴射击游戏(1)
date: 2025-01-03 12:56:10
categories: unity
---

## 横版卷轴射击游戏(1)

> 在油管学做的游戏，记录一下以供以后学习

### 项目流程一 准备工作

项目中需要用到URP的组件，URP（Universal Render Pipeline）是Unity中的一种渲染管线，主要用于实现高效的渲染，包括光照、材质、阴影等视觉效果，以支持不同平台的性能优化。这里使用Unity6进行开发，当然你也可以使用油管主的版本。在Unity中选用核心模版(内置URP)，然后创建项目。

![image-20250103130521826](01-03-横版卷轴射击游戏-1/image-20250103130521826.png)

在开始学习之前，需要在Unity中配置一些组件用来帮助接下来的开发，点击`Package Manager`下载插件。

![image-20250103142107534](01-03-横版卷轴射击游戏-1/image-20250103142107534.png)

需要下载如下插件，这里因为`Unity6`已经自带就不过多操作

![image-20250103143230003](01-03-横版卷轴射击游戏-1/image-20250103143230003.png)

这里简单介绍一下`Packer Manager`常用的有三个窗，默认窗口中存储的是当前项目的所有插件。你可以在这个窗口中，删除或者添加你需要的插件来完成你的开发

![image-20250103143507256](01-03-横版卷轴射击游戏-1/image-20250103143507256.png)

在侧边栏中，第二个窗口的作用是包仓库，可以在这里搜索你需要的插件包然后下载添加到你的项目中

![image-20250103143559349](01-03-横版卷轴射击游戏-1/image-20250103143559349.png)

第三个窗口是你在unity商场中购买的素材资源，可以下载然后导入到项目之中

![image-20250103143700125](01-03-横版卷轴射击游戏-1/image-20250103143700125.png)

上述流程完成之后，我们导入油管主提供的素材包，将图片拖拽到`Assets`文件夹中

![image-20250103144457866](01-03-横版卷轴射击游戏-1/image-20250103144457866.png)

在`Hierarchy`中拖入图片，同时打开`2d`视角，在`3d`工程中制造`2d`效果

![image-20250103144659668](01-03-横版卷轴射击游戏-1/image-20250103144659668.png)

在预制体中，拿出制作好的模型，添加到阶层(`hierarchy`)中，修改主相机的设置，将其观察模式改为正交投影模式，这里摘取AI的解释

1. **Orthographic（正交投影）**:
   - 在正交投影中，物体的大小不会随着距离摄像机的远近而改变，即无论物体距离摄像机多远，它们在屏幕上的大小都保持一致。
   - 这种投影方式常用于`2D`游戏或者需要精确测量距离和大小的场景。
   - 正交投影的摄像机就像是一个无限远的观察者，看到的是一个平面上的图像。
2. **Perspective（透视投影）**:
   - 在透视投影中，物体的大小会随着距离摄像机的远近而改变，即物体越远在屏幕上看起来越小，越近则越大。
   - 这种投影方式模拟了人眼观察世界的方式，提供了深度感和立体感，常用于`3D`游戏和模拟现实世界的场景。
   - 透视投影的摄像机就像是一个有限距离的观察者，看到的是一个锥形区域内的图像。

![image-20250103145028194](01-03-横版卷轴射击游戏-1/image-20250103145028194.png)

创建多一个次光源，将光源颜色改为蓝色，类似于图片的颜色

![image-20250103150114636](01-03-横版卷轴射击游戏-1/image-20250103150114636.png)

整理一下阶层中的组件，我们建立几个空物体，将插入的组件整理一下，最终效果如下

![image-20250103150251687](01-03-横版卷轴射击游戏-1/image-20250103150251687.png)

### 项目流程二 制作简易背景卷动

如果单纯将图片堆叠制作地图，那么是非常耗费资源的。可以采用[视差背景系统](https://www.bilibili.com/video/BV1EK4y1r783/?spm_id_from=333.337.search-card.all.click&vd_source=731595967596af37618c926a191e7811)，视频中是使用简易操作实现图片卷轴移动。先将之前的背景图片删除，在阶层下创建一个`3d`的正方形，用于背景图片的承载

![image-20250103151002244](01-03-横版卷轴射击游戏-1/image-20250103151002244.png)

为了适应图片的比例，将新建好的正方形的比例调整，这里图片的比例是`2048*822`的，那么正方形的比例可以调整为`20.48*8.22`。

![image-20250103151609799](01-03-横版卷轴射击游戏-1/image-20250103151609799.png)

修改`Transform`属性，将它调到合适的比例

![image-20250103152123404](01-03-横版卷轴射击游戏-1/image-20250103152123404.png)

1. **Position（位置）**: 这部分定义了对象在三维空间中的位置。X、Y、Z分别代表沿三个轴（通常是水平、垂直和深度）的位置坐标。在这个例子中，位置坐标都是0，意味着对象位于原点。
2. **Rotation（旋转）**: 这部分定义了对象绕三个轴的旋转角度。同样，X、Y、Z分别代表绕三个轴的旋转。这里显示的旋转值都是0，意味着对象没有旋转。
3. **Scale（缩放）**: 这部分定义了对象在三个维度上的缩放比例。X、Y、Z分别代表沿三个轴的缩放因子。在这个例子中，缩放因子都是1，意味着对象的大小没有变化。

创建一个材质，使用图片制作一个材质球

![image-20250103152737301](01-03-横版卷轴射击游戏-1/image-20250103152737301.png)

重新打开图片，将其中的`Wrap Mode `修改为`repeat`，这里最好创建一个副本，标注图片的层级

![image-20250103152903333](01-03-横版卷轴射击游戏-1/image-20250103152903333.png)

**Wrap Mode**: 这个设置决定了当纹理坐标超出0到1的范围时，纹理如何被应用到`3D`模型上。

- **Repeat**: 纹理会无限重复。如果纹理坐标超出1，它会从纹理的开始重新应用，创建一个无缝的重复效果。这在需要纹理覆盖整个表面而不需要精确对齐时非常有用。
- **Clamp**: 当纹理坐标超出0到1的范围时，纹理会被“夹住”，即超出的部分会显示纹理的边缘颜色。这可以防止纹理重复，适用于需要纹理在边缘平滑过渡的情况。
- **Mirror**: 类似于Repeat，但每次重复时纹理会镜像。这可以创建一个无缝的反射效果，使得纹理在重复时看起来更加自然。
- **Mirror Once**: 与Mirror类似，但只镜像一次，然后重复。这可以用于在纹理的一侧创建镜像效果，而另一侧则正常重复。

在创建好的材质中，选择设置好的图片，然后将这个材质拖入到创建完成的四方体中，这样就创建好了一个材质球。通过材质球中的一个属性，可以控制附加在立方体上面流动的材质

![image-20250103154622455](01-03-横版卷轴射击游戏-1/image-20250103154622455.png)

接下来对于这个`offset`属性，创建一个脚本来控制它的增加，实现卷轴滚动的效果

![image-20250103172807567](01-03-横版卷轴射击游戏-1/image-20250103172807567.png)

具体的代码名称可以自己命名，这里显示一下主要的代码。需要注意的是`GetComponent<T>()`是一个泛型函数，因此我们需要观察我们调用的组件然后找到对于的类型，一般而言包含着它的名字

```c++
using UnityEngine;

public class New : MonoBehaviour
{
    // 速度变量 控制卷轴滚动速度
    [SerializeField] Vector2 scroVelocity;
	
    public Material material;
    // Start is called once before the first execution of Update after the MonoBehaviour is created
    void Start()
    {
        // 获取对应的材质
        material = GetComponent<Renderer>().material;
    }

    // Update is called once per frame
    void Update()
    {
        material.mainTextureOffset += scroVelocity * Time.deltaTime;
    }
}
```

此时运行就会有滚动效果了

![image-20250103173209930](01-03-横版卷轴射击游戏-1/image-20250103173209930.png)
