---
title: 数据结构 - 简单数据结构
date: 2023-04-27 14:48:19
description: 基本数据结构
typora-root-url: 基本数据结构
categories: 算法
---

# 数据结构

## 链表和数组的区别

**数组** 和 **链表** 之间的主要区别在于它们的结构。数组是基于索引的数据结构，其中每个元素与索引相关联。另一方面，链表 依赖于引用，其中每个节点由数据和对前一个和下一个元素的引用组成。

- 数组是数据结构，包含类似类型数据元素的集合，而链表被视为非基元数据结构，包含称为节点的无序链接元素的集合。

- 在数组中元素属于索引，即，如果要进入第四个元素，则必须在方括号内写入变量名称及其索引或位置。但是，在链接列表中，您必须从头开始并一直工作，直到达到第四个元素。

- 虽然访问元素数组很快，而链接列表需要线性时间，但速度要慢得多。

- 数组中插入和删除等操作会占用大量时间。另一方面，链接列表中这些操作的性能很快。

- 数组具有固定大小。相比之下，链接列表是动态和灵活的，可以扩展和缩小其大小。

- 在数组中，在编译期间分配内存，而在链接列表中，在执行或运行时分配内存。

- 元素连续存储在数组中，而它随机存储在链接列表中。

- 由于实际数据存储在数组中的索引中，因此对内存的要求较少。相反，由于存储了额外的下一个和前一个引用元素，因此链接列表中需要更多内存。

- 此外，阵列中的内存利用效率低下。相反，内存利用率在阵列中是有效的。    

  ![数组和链表的对比](./2019-07-20-difference-between-array-and-linked-list-1693299145961-8.jpg)

需要额外说明的是: **即便是排好序的数组，你用二分查找，时间复杂度也是 `O(logn)`。所以，正确的表述应该是，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)**。

**如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，触发语言本身的垃圾回收操作。**

![image-20230829170835292](image-20230829170835292.png)

![image-20230729150121694](image-20230729150121694.png)

## [单链表](https://blog.51cto.com/u_15018701/2616916)

> 定义：链表是一种递归的数据结构，他或者为空（null），或者是指向一个结点（node）的引用，该结点含有一个泛型的元素和一个指向另一条链表的引用。

我们来对其解读一下，链表是一种常见且基础的数据结构，是一种线性表，但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址。我们也可以这样理解，链表是通过指针串联在一起的线性结构，每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向null。也就是我们所说的空指针。

> 简单的理解（这里忽略计算机内存那些的引用）链表和数组不同的在于他们的索引，数组所用的索引是数组下标，而链表的索引是他们下一个数据的位置。每一个位置存储当前的值和下一个位置的地址

我们先来看一下链表的可视化表示方法，以便更好的对其理解。一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。我们通过上面说到的可视化表示方法，将单链表可视化，如图所示。

![链表看这一篇真的就够了！_java](resize,m_fixed,w_1184.webp)

下面是实现单链表模板代码：

```c++
#include<iostream>
using namespace std;

struct Node {
    int data;
    Node* next; // 下一个节点的指针，data 存储的位置

    // 初始构造函数
    Node(int value) : data(value), next(nullptr) {
    }
};

class LinkedList {
private:
    Node* head; // 头指针
public:
    // 头指针默认为nullptr - 刚开始没有数据嘛 - 注意头指针是可以存值的
    LinkedList() : head(nullptr) {
    }

    void insert(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }

    // 删除节点
    void remove(int value) {
        Node* current = head;
        Node* prev = nullptr; // 这里应该是 prev 而不是 prevNode

        // 遍历单链表的每一个节点
        while (current != nullptr) {
            // 判断当前节点是否为目标节点
            if (current->data == value) {
                // 删除的位置是头指针
                if (prev == nullptr) {
                    head = current->next;
                } else {
                    // 前一个指针指向删除 value 指针的后面
                    prev->next = current->next;
                }

                // 保存当前节点的下一个节点
                Node* nextNode = current->next;

                // 释放被删除节点的内存
                delete current;

                // 将 current 指针移动到下一个节点 - 为空
                current = nextNode;
            } else {
                // 如果当前节点不是目标节点，继续遍历下一个节点
                prev = current;
                current = current->next;
            }
        }
    }

    void display() {
        Node* current = head;

        while (current != nullptr) {
            // 打印 current 位置的值
            cout << current->data << endl;
            // 更新 current 的位置
            current = current->next;
        }
        cout << endl;
    }

};

int main() {
    LinkedList list;

    list.insert(3);
    list.insert(5);
    list.insert(7);

    list.display(); // 输出：7 5 3

    list.remove(5);

    list.display(); // 输出：7 3

    return 0;
}
```

> 不用[指针](https://www.zhihu.com/question/31022750)来实现:
>
> ```c++
> #include <iostream>
> using namespace std;
> 
> const int MAX_SIZE = 100; // 假设链表最大节点数为100
> 
> class LinkedList {
> private:
>  int data[MAX_SIZE]; // 存储节点的值
>  int next[MAX_SIZE]; // 存储节点之间的连接关系
>  int head; // 头指针，表示链表的头节点的索引
>  int size; // 链表的当前大小
> 
> public:
>  LinkedList() : head(-1), size(0) {
>      // 初始化连接关系数组，表示链表为空
>      for (int i = 0; i < MAX_SIZE; i++) {
>          next[i] = -1;
>      }
>  }
> 
>  void insert(int value) {
>      // 创建新节点，并将新节点的值存入数组
>      data[size] = value;
> 
>      if (head == -1) {
>          // 如果链表为空，将头指针指向新节点
>          head = size;
>      } else {
>          // 如果链表不为空，将新节点插入到链表的头部
>          next[size] = head;
>          head = size;
>      }
> 
>      size++; // 链表大小加1
>  }
> 
>  void remove(int value) {
>      int current = head;
>      int prev = -1;
> 
>      while (current != -1) {
>          if (data[current] == value) {
>              if (prev == -1) {
>                  head = next[current];
>              } else {
>                  next[prev] = next[current];
>              }
> 
>              // 将当前节点从链表中移除
>              // 此处可以根据实际情况进行资源回收，但为了简化示例，不做处理
>              data[current] = 0;
>              next[current] = -1;
>              return;
>          }
> 
>          prev = current;
>          current = next[current];
>      }
>  }
> 
>  void display() {
>      int current = head;
> 
>      while (current != -1) {
>          // 打印当前节点的值
>          cout << data[current] << endl;
> 
>          // 更新 current 指向下一个节点
>          current = next[current];
>      }
> 
>      cout << endl;
>  }
> };
> 
> int main() {
>  LinkedList list;
> 
>  list.insert(3);
>  list.insert(5);
>  list.insert(7);
> 
>  list.display(); // 输出：7 5 3
> 
>  list.remove(5);
> 
>  list.display(); // 输出：7 3
> 
>  return 0;
> }
> 
> ```

链表的存储方式
我们知道了如何构造链表，我们再来说一下链表的存储方式。

我们都知道数组在内存中是连续分布的，但是链表在内存不是连续分配的。链表是通过指针域的指针链接内存中的各个节点。

所以链表在内存中是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。我们可以根据下图来进行理解。

![链表看这一篇真的就够了！_java_03](resize,m_fixed,w_1184-1693299787406-13.webp)

> 链表的索引主要是以引用的方式存在，数据主要是在堆中存储。

下面我们用一道题来说明链表的功能

![image-20230718080352568](./image-20230718080352568.png)

```c++
#include<iostream>
using namespace std;

//用结构体 - 构造链表
struct ListNode{
	int val;
	ListNode* next; //这个指针
	//结构体的构造函数 - nullptr是空指针常量 就是value赋值val 和 next赋值 
	ListNode(int value) : val(value),next(nullptr){} 
	
}; 

// 翻转以链表头开始的 k 个节点
ListNode* reverseKGroup(ListNode* head, int k) {
    // 计算链表长度
    int length = 0;
    ListNode* current = head;
    while (current) {
        length++;
        current = current->next;
    }

    // 确保链表长度大于等于 k
    if (length < k) {
        return head;
    }

    ListNode* prev_tail = nullptr; // 上一组翻转后的尾节点
    ListNode* new_head = nullptr; // 新的链表头，用于返回结果

    while (head) {
        int count = k;
        ListNode* prev = nullptr; // 用于翻转链表的前一个节点
        ListNode* curr = head; // 用于翻转链表的当前节点

        // 翻转当前的 k 个节点
        while (count > 0 && curr) {
            ListNode* next_node = curr->next;
            curr->next = prev;
            prev = curr;
            curr = next_node;
            count--;
        }

        // 如果翻转后的尾节点为空，表示当前是第一组翻转，更新新的链表头
        if (!new_head) {
            new_head = prev;
        }

        // 如果上一组翻转后的尾节点不为空，将其连接到当前组的头节点
        if (prev_tail) {
            prev_tail->next = prev;
        }

        // 将上一组翻转后的尾节点更新为当前组的尾节点
        prev_tail = head;
        head = curr;
    }

    return new_head;
}
// 用于打印链表
void printList(ListNode* head) {
    ListNode* current = head;
    while (current) {
        cout << current->val << " -> ";
        current = current->next;
    }
    cout << "nullptr" << endl;
}

int main() {
    ListNode* head = new ListNode(1);
    head->next = new ListNode(2);
    head->next->next = new ListNode(3);
    head->next->next->next = new ListNode(4);
    head->next->next->next->next = new ListNode(5);

    cout << "原链表：" << endl;
    printList(head);

    int k = 2; // 或者其他合适的 k 值
    ListNode* reversedHead = reverseKGroup(head, k);

    cout << "翻转后的链表：" << endl;
    printList(reversedHead);

    // TODO: 释放链表内存，防止内存泄漏

    return 0;
}
```

## 双链表

![双向链表](./双向链表-1693298571267-3.png)

![image.png](./7c0d280244b244ae9d46d3e9843c9b1dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

在单链表的基础上，往回加一个指针，不说指针了也就是再加一个数组来记录我们的链接方式，这样我们就可以向后检索，两面检索。减少时间。在机制和性质上，和我们的单链表是一样的。

```c++
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int l[N], r[N], idx, e[N];

// 初始化，设置虚拟头节点
void init() {
    l[0] = -1;      // 虚拟头节点的左指针为-1，表示不存在左边节点
    r[0] = 0;       // 虚拟头节点的右指针指向自身，表示链表为空
    idx = 1;        // 当前可用的节点索引从1开始（0已被虚拟头节点占用）
}

// 在k的右边插入数据
void add_right(int k, int x) {
    e[idx] = x;     // 新节点的值为x
    r[idx] = r[k];  // 新节点的右指针指向k节点原来的右边节点
    l[idx] = k;     // 新节点的左指针指向k节点
    l[r[k]] = idx;  // k节点原来的右边节点的左指针指向新节点
    r[k] = idx;     // k节点的右指针指向新节点，完成插入
    idx++;          // 更新节点索引
}

// 往k的左边插入数据
void add_left(int k, int x) {
    e[idx] = x;     // 新节点的值为x
    if (l[k] != -1) {
        r[idx] = k;     // 新节点的右指针指向k节点
        l[idx] = l[k];  // 新节点的左指针指向k节点原来的左边节点
        r[l[k]] = idx;  // k节点原来的左边节点的右指针指向新节点
        l[k] = idx;     // k节点的左指针指向新节点，完成插入
    } else {
        r[idx] = k;     // 新节点的右指针指向k节点
        l[idx] = -1;    // 新节点的左指针指向虚拟头节点
        l[k] = idx;     // k节点的左指针指向新节点，完成插入
    }
    idx++;          // 更新节点索引
}

int main() {
    init();         // 初始化链表

    add_right(0, 1); // 在虚拟头节点右边插入1，链表变为：0 -> 1  0是虚拟节点 
    add_left(1, 2);  // 在节点1的左边插入2，链表变为：2 -> 1

    // 输出链表的值 
    for (int i = r[0]; i != 0; i = r[i]) {
        cout << e[i] << " ";
    }
    // 输出：2 1

    return 0;
}
```

## 循环链表

### [循环单链表](https://zhuanlan.zhihu.com/p/107808443)*

 就是在单链表的基础之上，将最后本指向null的改为指向链表头。

![循环单链表](循环单项链表.png)

 循环链表主要用于操作系统中的任务维护。有许多例子，循环链表用于计算机科学，包括浏览器，记录用户过去访问过的页面记录也可以以循环链表的形式保存，并且可以在点击前一个按钮时再次访问。

 对单向链表中任一个节点的访问都需要从头结点开始；而对单向循环链表从任意节点出发都能遍历整个列表**，**极大的增强了其灵活性。

```c++
//c++实现
//1.节点类，
class Node{
public:
 int data;
 Node *pointer=NULL;
};
//2.链表类
class SingleLinkedList {
public:
 SingleLinkedList();
 bool isEmpty();
 void add(int data);
 void traversal();

private:
     Node *head;
};
//3.构造函数
SingleLinkedList::SingleLinkedList() {
 head = new Node;
 head->data = 0;
 head->pointer = head;
}
//4.判断是否为空：isEmpty()
bool SingleLinkedList::isEmpty() {
 // 头结点不指向任何结点，为空
 if (head->pointer == head) {
  return true;
 }
 else {
  return false;
 }
}
//5.头插法：add()
void SingleLinkedList::add(int data) {
 // 当原列表仅有头结点时，直接插入新节点即可
 if (isEmpty()) {
  head->pointer = new Node;
  head->pointer->pointer = head;
  head->pointer->data = data;
 }
 // 列表非空时
 else {
  // 临时存储头结点的直接后继
  Node *temp = head->pointer;
  head->pointer = new Node;
  head->pointer->data = data;
  head->pointer->pointer = temp;
 }
}
//6.遍历：traversal()
void SingleLinkedList::traversal() {
 // 链表为空，结束函数
 if(isEmpty()) {
  return;
 }
 else {
  Node *current;
  // 指向头结点的直接后继
  current = head->pointer;
  int counter = 1;
  // 遍历链表，输出每个节点的值
  while (current != head)
  {
   printf("Element in %d is %d \n", counter, current->data);
   counter++;
   current = current->pointer;
  }
 }
}
```

### [循环双链表](https://blog.csdn.net/sum_TW/article/details/61624039?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8%3D)*

 和循环单链表一样，只是多了双链表的属性。

![img](Center.png)

双向循环链表初始化

```c++
//创建链表
void creatList(Node** h)
{
    Node* pn=NULL;//存储新的节点
    Node* p=NULL;//头节点的替身
    int d;
    printf("请输入数据\n");
    scanf("%d",&d);
    pn=creteNode(d);
    pn->next=NULL;//next指向空
    pn->pre=NULL;//pre指向空
    sum=1;
    *h=pn;
    p=*h;
    while(1)
    {
        printf("请输入数据\n");
        scanf("%d",&d);
        if(d==0)
        {
            //创建到最后一个节点时，最后一个节点next为头节点
            p->next=*h;
            (*h)->pre=p;//头节点的pre为最后一个节点
            break;
        }
        pn=creteNode(d);
        p->next=pn;
        pn->pre=p;
        p=p->next;
        sum++;//元素个数++
    }
}
```

插入操作

![双向循环链表插入](双向循环链表插入.png)

```c++
//头插法
int addFont(int d,Node** h)//修改头节点  传入二级指针
{
    int i,n=sum;
    Node* pn=NULL;
    pn=creteNode(d);
    Node* p=*h;
    for(i=0;i<n-1;i++)
    {
        p=p->next;
    }
    //p为最后一个节点
    pn->next=*h;//新节点成为头节点
    p->next=pn;//最后一个节点p的下一个节点为新节点pn
    pn->pre=p;//新的头节点的pre为p
 
    (*h)->pre=pn;//原头节点的前一个节点为新节点
 
    *h=pn;//新节点为头节点
 
    sum++;
}
 
//插入
int insertNode(int n,int d,Node** h)//在n位置插入d
{
    if((n<1)||(*h==NULL)||(n>sum))
    {
        printf("插入位置不合法||链表为空!\n");
        return 0;
    }
     Node* pn=creteNode(d);//创建新的节点
    //插入位置为1，即插入头节点的位置
    if(n==1)
    {
       addFont(d,h);//调用头插法
       return 0;
    }
    else if(n==sum)
    {
        addBack(d,*h);
        return 0;
    }
    else
    {
       Node* pf=findNode(*h,n-1); //找到要删除的节点的前一个节点
       pn->next=pf->next;//前一个节点的next等于新的节点的next
       pf->next->pre=pn;//pf的next节点的pre应该为pn
       pf->next=pn;//前一个节点的next等于新的节点
       pn->pre=pf;//新节点的前一个节点为找到的前一个节点pf
       sum++;
       return 1;
    }
}
```

删除操作

![img](双向循环链表删除.png)

```c++
//删除头节点
int DelectFont(Node** h)
{
 //DelectFont(h);
    int i, n1=sum;
    Node* p=*h;
    Node* pd=NULL;;
    for(i=0;i<n1-1;i++)
    {
        p=p->next;
    }
    
    //p为最后一个节点
    pd=*h;
    *h=pd->next;//头节点的下一个节点成头节点
    
    p->next=*h;//最后一个节点的next为头节点
    
    (*h)->pre=p;//pd节点成为了头节点，它的前驱为p
    sum--;//元素个数-1
  
    return 0;
}
 
//删除第n个位置的元素
int deleteNode(int n,Node** h)
{
    //int i;//循环变量
    //判断头节点是否为空，位置是不是合法
    if((*h==NULL)||(n<1)||(n>sum))
    {
        printf("删除的链表为空||删除的位置不合法！so 插入失败\n");
        return 0;
    }
    Node* pd=NULL;
    //删除头节点
    if(n==1)
    {
       DelectFont(h);
       return 0;
    }
 
    //删除
    //找到要删除的节点的前一个节点
    Node* pf=findNode(*h,n-1);
    pd=pf->next;//将要删除的节点的给pd
    pf->next=pd->next;//将删除元素的前一个的next指向删除元素的后一个元素
    pd->pre=NULL;//pd的pre指向空
   
    pd->next->pre=pf;//将删除元素的后一个元素的前驱给pf
    pd->next=NULL;//pdnext指向空
    sum--;
    return 1;
}

```

总

```c++
#include <stdio.h>
#include <stdlib.h>
 
struct node{
    int data;
    struct node* next;
    struct node* pre;
};
typedef struct node Node;
#define SIZE sizeof(Node)
int sum;//节点个数
 
Node* creteNode(int d);//创建节点
void creatList(Node** h)；//创建链表
Node* findNode(Node* h,int n)；//查找某个节点的位置
int addBack(int d,Node* h)；//末尾增加一个新的节点
int addFont(int d,Node** h)；//修改头节点  传入二级指针
int insertNode(int n,int d,Node** h)；//在n位置插入d
int DelectFont(Node** h);//删除头节点
int deleteNode(int n,Node** h);//删除第n个位置的元素
void print(Node* h);//打印链表
 
//创建节点
Node* creteNode(int d)
{
    Node* pn=(Node*)malloc(SIZE);
    pn->data=d;
    pn->next=NULL;
    pn->pre=NULL;
    return pn;
}
 
//创建链表
void creatList(Node** h)
{
    Node* pn=NULL;//存储新的节点
    Node* p=NULL;//头节点的替身
    int d;
    printf("请输入数据\n");
    scanf("%d",&d);
    pn=creteNode(d);
    pn->next=NULL;//next指向空
    pn->pre=NULL;//pre指向空
    sum=1;
    *h=pn;
    p=*h;
    while(1)
    {
        printf("请输入数据\n");
        scanf("%d",&d);
        if(d==0)
        {
            //创建到最后一个节点时，最后一个节点next为头节点
            p->next=*h;
            (*h)->pre=p;//头节点的pre为最后一个节点
            break;
        }
        pn=creteNode(d);
        p->next=pn;
        pn->pre=p;
        p=p->next;
        sum++;//元素个数++
    }
}
 
//查找某个节点的位置
Node* findNode(Node* h,int n)
{
    int i;
    if((h==NULL)||(n<0)||(n>sum))
    {
            printf("查找位置不合法||链表为空！\n");
            return NULL;
    }
    if(n==1)
    {
        return h;
    }
    for(i=1;i<n;i++)
    {
        h=h->next;
    }
    return h;
} 
 
//末尾增加一个新的节点
int addBack(int d,Node* h)
{
    int i,n=sum;
    Node *pn=NULL;
    pn=creteNode(d);
    Node* p=h;
    for(i=0;i<n-1;i++)
    {
        p=p->next;
    }
    //此时的p指向了最后一个元素
    p->next=pn;//最后一个节点p的next为新节点
    pn->pre=p;//新节点的前一个节点为p
    pn->next=h;//pn的最后一个节点为头节点
    h->pre=pn;//头节点的pre为新节点
    sum++;
}
 
//头插法
int addFont(int d,Node** h)//修改头节点  传入二级指针
{
    int i,n=sum;
    Node* pn=NULL;
    pn=creteNode(d);
    Node* p=*h;
    for(i=0;i<n-1;i++)
    {
        p=p->next;
    }
    //p为最后一个节点
    pn->next=*h;//新节点成为头节点
    p->next=pn;//最后一个节点p的下一个节点为新节点pn
    pn->pre=p;//新的头节点的pre为p
 
    (*h)->pre=pn;//原头节点的前一个节点为新节点
 
    *h=pn;//新节点为头节点
 
    sum++;
}
 
//插入
int insertNode(int n,int d,Node** h)//在n位置插入d
{
    if((n<1)||(*h==NULL)||(n>sum))
    {
        printf("插入位置不合法||链表为空!\n");
        return 0;
    }
     Node* pn=creteNode(d);//创建新的节点
    //插入位置为1，即插入头节点的位置
    if(n==1)
    {
       addFont(d,h);//调用头插法
       return 0;
    }
    else if(n==sum)
    {
        addBack(d,*h);
        return 0;
    }
    else
    {
       Node* pf=findNode(*h,n-1); //找到要删除的节点的前一个节点
       pn->next=pf->next;//前一个节点的next等于新的节点的next
       pf->next->pre=pn;//pf的next节点的pre应该为pn
       pf->next=pn;//前一个节点的next等于新的节点
       pn->pre=pf;//新节点的前一个节点为找到的前一个节点pf
       sum++;
       return 1;
    }
}
 
//删除头节点
int DelectFont(Node** h)
{
 //DelectFont(h);
    int i, n1=sum;
    Node* p=*h;
    Node* pd=NULL;;
    for(i=0;i<n1-1;i++)
    {
        p=p->next;
    }
    
    //p为最后一个节点
    pd=*h;
    *h=pd->next;//头节点的下一个节点成头节点
    
    p->next=*h;//最后一个节点的next为头节点
    
    (*h)->pre=p;//pd节点成为了头节点，它的前驱为p
    sum--;//元素个数-1
  
    return 0;
}
 
//删除第n个位置的元素
int deleteNode(int n,Node** h)
{
    //int i;//循环变量
    //判断头节点是否为空，位置是不是合法
    if((*h==NULL)||(n<1)||(n>sum))
    {
        printf("删除的链表为空||删除的位置不合法！so 插入失败\n");
        return 0;
    }
    Node* pd=NULL;
    //删除头节点
    if(n==1)
    {
       DelectFont(h);
       return 0;
    }
 
    //删除
    //找到要删除的节点的前一个节点
    Node* pf=findNode(*h,n-1);
    pd=pf->next;//将要删除的节点的给pd
    pf->next=pd->next;//将删除元素的前一个的next指向删除元素的后一个元素
    pd->pre=NULL;//pd的pre指向空
   
    pd->next->pre=pf;//将删除元素的后一个元素的前驱给pf
    pd->next=NULL;//pdnext指向空
    sum--;
    return 1;
}
 
//打印链表
void print(Node* h)
{
    int i,n=sum;
    printf("list:\n");
    Node* p=h;
    printf("正序遍历：\n");
    for(i=1;i<=n;i++)
    {
        printf("%d ",p->data);
        p=p->next;
    }
    //上面遍历到第一个节点
    printf("\n");
    printf("反序遍历：\n");
    for(i=1;i<=n;i++)
    {
        printf("%d ",p->pre->data);
        p=p->pre;
    }
    printf("\n");
}
 
int main()
{
    Node* head=NULL;
    creatList(&head);
    deleteNode(2,&head);
    print(head);
    return 0;
}
```



## [队列](https://zhuanlan.zhihu.com/p/45798936)

队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，允许删除的一端称为队头。它是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，而在表的后端进行插入操作，和栈一样，队列是一种操作受限制的线性表。

而且队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。

解决假溢出的办法就是后面满了，就再从头开始，也就是头尾相接的循环。我们把队列的这种头尾相接的顺序存储结构称为循环队列。

> 什么是[假溢出](https://www.dotcpp.com/course/107)？打一个比方：
>
> ![顺序队列](1564998238118812.png)（示例顺序队列)
>
> 回顾一下队列的性质，首先我们有一个顺序队列，这个队列的大小为5，其已经包含了四个元素`data1,data2,data3,data4,`接着，我们对这个队列进行出队操作，出队2个元素，队列就变成了这个样子：
>
> ![顺序队列2](1564998282898186.png)
>
> 目前看起来没有问题，那么我们接着再进行入队操作，我们入队2个元素，分别是`data5和data6`，此时我们已经发现问题了，尾指针移动到我们可以进行队列操作的范围之外去了，我们称呼作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为"假溢出"。

队列和游标卡尺差不多，就是一个区间和线段组成的数据类型

![img](队列.png)

```c++
//声明变量 队列的性质就是先进先出
int q[N],hh,tt;
//插入数据
q[++tt];//hh是头（头是向右边移动的） tt是转移元素的变量（tt是新入队的成员）
//可以将 hh 和 tt看做是一个区间
hh++//pop
//判断队列是否为空
  if(hh<=tt) not empty
  else empty;
//取出队头元素
q[hh];
```

### 单调队列

在中学的时候，我们会学一种函数的性质，叫做单调性。单调性是指，在一个区间内部我们可以预测这个数据类型的运行方向。那么显而易见的，单调队列指的是，我们可以预计和控制这个数据类型的运行方向。

队列的性质上面有提到，是一种先进先出的数据结构。我们可以利用这个结构，做一个可动的队列或者说，让数据集通过我们的队列，在通过的时候记录他们的数据变化。这样的操作，就叫做单调队列。

以一个较简单的例子：滑动窗口，大概题意就是，有一个数据条，需要通过我们的窗口（队列），通过的时候记录这个时候队列的最大值和最小值（或者别的什么东西 - 变化一下题目嘛）。

![滑动窗口](image-20230504225237230.png)

```c++
//维护窗口
int h = 1,t = 0; //清空队列
for(int i = 1;;i<=n;i++){ //枚举数据集
    while(h<=t && a[q[t]]>=a[i]) t--;//队尾出队
    q[++t] = i;//队尾入队
    if(q[h]<i-k+1) h++;//对头出队（滑出窗口）
    if(i>=k) printf("%d ",a[q[h]]);//打印最值
}
```

![维护窗口最小值](image-20230504230354394.png)

## 双端队列

![img](./v2-c21942aff1bebe48296dacca04a3ef5b_720w.webp)

双端队列使用双链表实现。

```c++
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

// 结构体，存储位置和变量值
struct Node {
    int val;      // 存储数据的变量值
    int pre, next; // pre和next分别表示前一个节点和后一个节点的索引
} node[N];

int idx, head, tail;

// 初始化，设置虚拟头尾节点
void init() {
    head = 0;        // 虚拟头节点的索引，它不存储数据
    tail = 1;        // 虚拟尾节点的索引，它不存储数据
    node[head].next = tail;    // 头节点的下一个节点是尾节点
    node[tail].pre = head;     // 尾节点的前一个节点是头节点
    idx = 2;          // 当前可用的节点索引从2开始，因为0和1被头尾节点占用了
}

// 在队头插入数据
void push_front(int x) {
    node[idx].val = x;   // 将数据x存储到新节点中
    node[idx].pre = head;    // 新节点的前一个节点是头节点
    node[idx].next = node[head].next;   // 新节点的下一个节点是原头节点的下一个节点
    node[head].next = idx;    // 更新头节点的下一个节点为新节点
    node[node[idx].next].pre = idx;   // 更新原头节点的下一个节点的前一个节点为新节点
    idx++;          // 更新节点索引，为下次插入做准备
}

// 在队尾插入数据
void push_back(int x) {
    node[idx].val = x;    // 将数据x存储到新节点中
    node[idx].pre = node[tail].pre;   // 新节点的前一个节点是原尾节点的前一个节点
    node[idx].next = tail;   // 新节点的下一个节点是尾节点
    node[tail].pre = idx;    // 更新尾节点的前一个节点为新节点
    node[node[idx].pre].next = idx;   // 更新原尾节点的前一个节点的下一个节点为新节点
    idx++;          // 更新节点索引，为下次插入做准备
}

// 从队头弹出数据
void pop_front() {
    if (node[head].next != tail) {   // 确保队列非空
        int to_delete = node[head].next;   // 获取要删除的节点索引
        node[head].next = node[to_delete].next;   // 更新头节点的下一个节点为要删除节点的下一个节点
        node[node[to_delete].next].pre = head;   // 更新要删除节点的下一个节点的前一个节点为头节点
    }
}

// 从队尾弹出数据
void pop_back() {
    if (node[tail].pre != head) {   // 确保队列非空
        int to_delete = node[tail].pre;   // 获取要删除的节点索引
        node[tail].pre = node[to_delete].pre;   // 更新尾节点的前一个节点为要删除节点的前一个节点
        node[node[to_delete].pre].next = tail;   // 更新要删除节点的前一个节点的下一个节点为尾节点
    }
}

// 输出双端队列的值
void print_deque() {
    for (int i = node[head].next; i != tail; i = node[i].next) {
        cout << node[i].val << " ";   // 依次输出双端队列中的元素值
    }
    cout << endl;
}

int main() {
    init();         // 初始化双端队列

    push_back(1);   // 队列变为：1
    push_front(2);  // 队列变为：2 1
    push_back(3);   // 队列变为：2 1 3
    pop_front();    // 队列变为：1 3
    push_back(4);   // 队列变为：1 3 4
    pop_back();     // 队列变为：1 3

    print_deque();  // 输出：1 3

    return 0;
}
```

## [随机链表](https://zhuanlan.zhihu.com/p/100388274)

![list](list.png)

## [栈](https://zhuanlan.zhihu.com/p/346164833)

栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。

而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 LIFO（Last In First Out）结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），我们首先要移开压在它上面的物体（放进去比较晚的物体）。

堆栈中定义了一些操作。两个最重要的是PUSH和POP。PUSH操作在堆栈的顶部加入一个元素。POP操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。

![栈](栈.png)

用我们的数组实现的栈，最关键的点在于：我们是否可以直接不管我们插入栈的数据。 栈的原理就是 先进后出。那么我们只要声明一个数组就可以实现这个功能

```c++
//用数组实现栈功能
//栈 和 操作栈的变量
int stk[N],tt;//变量用来控制我们的栈的容量

//插入栈的数据
stk[++tt] = x;
//pop弹出 这样的数据会直接消失 记得保存stk[kk] 栈顶数据 
tt--; 
//判断栈顶是否为空 (这里是伪代码)
if(tt>0) no empty;
else empty;
//栈顶
stk[kk]
  
//总结 
    栈的作用就是实现两个操作 1.压栈 2.弹栈 - 压栈的操作在用数组实现的时候，我们可以理解 竖向数组的增高（但实际上在现实中更像手枪压弹夹一样）弹栈 - 就是去顶（更像手枪把子弹打出去）
 通常，声明一个栈的时候，我们会用一个变量来维护我们这个栈。 这个变量起到实现上述两个操作的作用 - 例如： h[N]是我们的一个栈 top是我们维护栈的变量
 那么： push操作就是 h[++top] = a(你塞入的子弹)；pop操作就是  top--;
query(栈头) h[top] //重点是插入的时候是先 ++ 在赋值位置的 这样可以保证沉底
//stl中的栈
 <stack> 是栈的头文件名称，用的时候声明一下就好了。
```

栈的应用——递归

在高级语言中，调用自己和其它函数没有本质的不同。我们把一个直接用自己或通过一系列的调用语句间接地调用自己的函数，称作递归函数。每个递归函数必须至少有一个条件，满足时递归不再执行，即不再引用自身而是返回值退出。

递归和迭代的区别是：迭代使用的是循环结构，递归使用的是选择结构。 递归能使程序的结构更清晰、更简洁、更容易让人理解，从而减少读懂代码的时间。但是大量的递归调用会建立函数的副本，会耗费大量的时间和内存。迭代则不需要反复调用函数和占用额外的内存。因此我们应该视不同情况选择不同的代码实现方式。

在前行阶段，对于每一层递归，函数的局部变量、参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量、参数值和返回地址被弹出，用于返回调用层次中执行代码的其余部分，也就是恢复了调用的状态。

**用栈实现计算器**

中缀表达式实现

```c++
//不支持括号
#include <iostream>
#include <stack>
#include <string>

using namespace std;

int calculate(string s) {
    stack<int> nums;
    stack<char> ops;
    int num = 0;
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
        }
        if (!isdigit(c) && c != ' ' || i == s.size() - 1) {
            if (!ops.empty() && (ops.top() == '*' || ops.top() == '/')) {
                int n = nums.top();
                nums.pop();
                if (ops.top() == '*') {
                    nums.push(n * num);
                } else {
                    nums.push(n / num);
                }
                ops.pop();
            } else if (!ops.empty() && (ops.top() == '+' || ops.top() == '-')) {
                if (ops.top() == '+') {
                    nums.push(num);
                } else {
                    nums.push(-num);
                }
                ops.pop();
            } else {
                nums.push(num);
            }
            ops.push(c);
            num = 0;
        }
    }
    int res = 0;
    while (!nums.empty()) {
        res += nums.top();
        nums.pop();
    }
    return res;
}

int main() {
    string s = "3+2*2";
    cout << calculate(s) << endl;
    return 0;
}
```

```c++
//支持括号
#include <iostream>
#include <stack>
#include <string>

using namespace std;

int calculate(string s) {
    stack<int> nums;
    stack<char> ops;
    int num = 0;
    for (int i = 0; i < s.size(); i++) {
        char c = s[i];
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
        }
        if (c == '(') {
            int j = i + 1, cnt = 1;
            while (cnt != 0) {
                if (s[j] == '(') cnt++;
                if (s[j] == ')') cnt--;
                j++;
            }
            num = calculate(s.substr(i + 1, j - i - 2));
            i = j - 1;
        }
        if (!isdigit(c) && c != ' ' || i == s.size() - 1) {
            if (!ops.empty() && (ops.top() == '*' || ops.top() == '/')) {
                int n = nums.top();
                nums.pop();
                if (ops.top() == '*') {
                    nums.push(n * num);
                } else {
                    nums.push(n / num);
                }
                ops.pop();
            } else if (!ops.empty() && (ops.top() == '+' || ops.top() == '-')) {
                if (ops.top() == '+') {
                    nums.push(num);
                } else {
                    nums.push(-num);
                }
                ops.pop();
            } else {
                nums.push(num);
            }
            ops.push(c);
            num = 0;
        }
    }
    int res = 0;
    while (!nums.empty()) {
        res += nums.top();
        nums.pop();
    }
    return res;
}

int main() {
    string s = "3+2*(2+1)";
    cout << calculate(s) << endl;
    return 0;
}
```

逆波兰式实现

```c++
#include <iostream>
#include <stack>
#include <string>
#include <vector>

using namespace std;

int evalRPN(vector<string>& tokens) {
    stack<int> nums;
    for (int i = 0; i < tokens.size(); i++) {
        string s = tokens[i];
        if (s == "+" || s == "-" || s == "*" || s == "/") {
            int num2 = nums.top();
            nums.pop();
            int num1 = nums.top();
            nums.pop();
            if (s == "+") {
                nums.push(num1 + num2);
            } else if (s == "-") {
                nums.push(num1 - num2);
            } else if (s == "*") {
                nums.push(num1 * num2);
            } else {
                nums.push(num1 / num2);
            }
        } else {
            nums.push(stoi(s));
        }
    }
    return nums.top();
}

int main() {
    vector<string> tokens = {"3", "4", "+", "5", "-"};
    cout << evalRPN(tokens) << endl;
    return 0;
}
```

## [堆](https://juejin.cn/post/7134880984528814110)

堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉树。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：
 （1）堆中某个节点的值总是不大于或不小于其父节点的值；
 （2）堆总是一棵完全二叉树。

堆分为两种情况，有最大堆和最小堆。将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。下图图一就是一个最大堆，图二就是一个最小堆。在一个摆放好元素的最小堆中，可以看到，父结点中的元素一定比子结点的元素要小，但对于左右结点的大小则没有规定谁大谁小。

堆常用来实现优先队列，堆的存取是随意的，这就如同我们在图书馆的书架上取书，虽然书的摆放是有顺序的，但是我们想取任意一本时不必像栈一样，先取出前面所有的书，书架这种机制不同于箱子，我们可以直接取出我们想要的书。

![优先队列](二叉树.webp)

```c++
#include <iostream> 
using namespace std; 
// 定义堆的最大容量 
const int MAX_SIZE = 100; 
// 定义堆的数据结构 
int heap[MAX_SIZE]; 
int heapSize; 
// 向堆中插入一个元素 
void insert(int data) 
{ 
    // 如果堆已满，则不能插入 
    if (heapSize == MAX_SIZE) 
        return; 
    // 将新元素插入到堆的末尾 
    heap[heapSize] = data; 
    heapSize++; 
    // 将新元素上浮到正确的位置 
    int current = heapSize - 1; 
    while (current != 0 && heap[current] > heap[(current - 1) / 2]) 
    { 
        int temp = heap[(current - 1) / 2]; 
        heap[(current - 1) / 2] = heap[current]; 
        heap[current] = temp; 
        current = (current - 1) / 2; 
    } 
} 
// 从堆中删除一个元素 
void deleteElement() 
{ 
    // 如果堆为空，则不能删除 
    if (heapSize == 0) 
        return; 
    // 将堆的最后一个元素放到堆顶 
    heap[0] = heap[heapSize - 1]; 
    heapSize--; 
    // 将堆顶元素下沉到正确的位置 
    int current = 0; 
    while (current * 2 + 1 < heapSize) 
    { 
        int largest = current; 
        if (heap[largest] < heap[current * 2 + 1]) 
            largest = current * 2 + 1; 
        if (current * 2 + 2 < heapSize && heap[largest] < heap[current * 2 + 2]) 
            largest = current * 2 + 2; 
        if (largest == current) 
            break; 
        int temp = heap[current]; 
        heap[current] = heap[largest]; 
        heap[largest] = temp; 
        current = largest; 
    } 
} 
int main() 
{ 
    // 初始化堆 
    heapSize = 0; 
    // 向堆中插入元素 
    insert(10); 
    insert(20); 
    insert(30); 
    insert(40); 
    insert(50); 
    // 从堆中删除元素 
    deleteElement(); 
    // 输出堆中的元素 
    for (int i = 0; i < heapSize; i++) 
        cout << heap[i] << " "; 
    cout << endl; 
    return 0; 
}
```

## 对堆栈的理解

优先队列

![优先队列](优先队列.png)

# 字符串

## 并查集

并查集是一种树形的数据结构，支持两种操作，并：将两个不同的元素合并成一个集合；查：查找一个数据的所在集合

在模拟树状结构的时候，fa[x]存储的是节点的父节点，可以理解为特定集合的编号。这里的x和赋值给f[x]的值的关系，可以理解为**节点和父节点连接**的关系。初始化的时候，将每一个节点编号都初始化为自己(自己为一个集合)。

![并查集](image-20230503221426175.png)

#### **查找**

可以理解为顺着当前节点向上爬，找到我们当前集合的根节点。但实际上，我们并不是这样做，我们可以将这个操作进行优化，我们在找根节点的过程，可以顺便将每一个经过的节点的**“父节点”都改为我们的“根节点”**，一个查找循环下来，整一个集合的值都是我们的，根节点（也就是我们当前集合编号），下面是代码解释。

![路径压缩](image-20230503222836310.png)

```c++
//未用路径压缩
int find(int x)
{
    //如果当前这个节点指向的是根节点，说明我们找到了目标集合，返回就行。
 if(fa[x] == x) return x;
    //如果不是，那就递归查找，直到找到我们的目标集合（一定找得到）。
    return find(fa[x]); 
}

//使用路径压缩
int find(int x)
{
    if(fa[x] == x) return x;
    return fa[x] = find(f[a]); //这里就是给路过的节点赋值 - 用的是递归
}
```

#### **合并**

![合并](image-20230503224008918.png)

合并操作，可以理解为两个集合的根节点指向即可。这里举个例子，A集合和B集合，那么B集合序号指向A集合序号即可。

```c++
//合并代码
void unionset(int x,int y){
    //将x的集合编号，赋值成y的集合编号
    //如果再次路径压缩，那么所有x集合的编号都会变成y的编号
    fa[find(x)] = find(y); 
}
```

但是，这样合并可以进行优化，我们可以这样想，如果我们合并两个集合的数量级不在一个级别上，比如一个集合元素个数为2，一个集合元素个数为2e10，这样将集合元素为2的集合作为新集合的标号，确实不太合适。所以说，我们可以直接给每一个集合标记他们的元素数量，然后对其进行合并即可。

```c++
vector<int> siz(N,1);
void unioset(int x,int y){
    x = find(x),y = find(y); //找到各自的集合编号
    if(x == y) return;
    if(siz[x]>siz[y]) swap(x,y);//判断哪个集合更大
    fa[x] = y;//小集合指向大集合
    siz[y]+=siz[x]; //合并一个大集合要加数量
}
```

![并查集的变化](image-20230503230130914.png)

## Trie

Trie树，即字典树，又称单词查找树或键树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计和排序大量的字符串（但不仅限于字符串），所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。

Trie的核心思想是空间换时间。利用字符串的**公共前缀**来降低查询时间的开销以达到提高效率的目的。

![字典树](image-20230504131211298.png)

#### 插入

Trie树，就是利用字符串的相同前缀，来节省我们查找的时间。这个树的根没有意义，只是为了构造这个树存在。可以说，根衔接的都是一个独立的单词（子树）。

![字典树](image-20230504132336132.png)

我们可以想象一下，在一个根下面链接一个一个单词会是什么样子，是不是像一个拂尘一样。我们可以在这个基础之上，对这些单词进行处理：单词是由26个字母排列组合成的，所以说不管单词怎么变，肯定有些单词的前缀是相等的。例如：appear 和 apple。这两个前缀相同，那么我们就可以让"app"为同一支，从p分出两个枝e和p。（当然分支最多26个）以此类推构建字典树。

```c++
//字典树构造
char s[N]
    
int ch[N][26];//儿子数组：存储从节点p沿着j这条路走到的子节点。26是26个字母的映射值（就是1代表a，2代表b以此类推）

int cnt[N];//存储以节点p结尾的单词的插入次数

int idx;//用来节点编号

//插入字符串
void insert(char *s)
{
    int p = 0;
    //遍历全部字符串的字符
    for(int i = 0;s[i];i++){
        int j = s[i]-'a';//字母映射 - 变为0-25的编号
        if(!ch[p][j]) ch[p][j]=++idx;//不存在这个值（就是树中无这个子树）
        p = ch[p][j];
    }
    cnt[p]++;//插入次数 - 表示当前节点子树个数
}
```

#### **查询**

和插入的操作差不多，只要找到我们插入的时候做的标记就行。

```c++
int query(char *s)
{
    int p = 0;;
    for(int i = 0;s[i];i++)
    {
        int j = s[i]-'a';//映射
        if(!ch[p][j]) return 0;;
        p = ch[p][j]; //查找符合，直到子串末尾。都符合则成立
    }
    return cnt[p];
}
```

![总结](image-20230504140704449.png)

## KMP

在学习kmp算法之前，我们先弄清楚暴力求解字符串匹配问题。

给出一个主串S，判断字符串F是否是S的子串，如果是返回T在S中出现的第一个位置，否则返回0.

使用暴力算法解题，从主串S的第一个字符开始和模式串T的第一个字符进行比较，若相等则比较二者后续字符，否则，主串回溯到第二个字符，模式串回溯到第一个字符；继续比较，不匹配，主串回溯到第三个字符，模式串回溯到第一个字符。重新上述过程，直到模式串T中的字符全部比较完毕，说明匹配成功；否则匹配失败。
暴力算法将每一种情况都列举了出来，时间复杂度很高(大概是o(n^2))

```c++
#include <iostream>
using namespace std;

int BF(char *S,char *T){
    int i=0,j=0;
    while(S[i]!='\0'&&T[j]){
        if(S[i]==T[j]){
            i++;
            j++;
        }else{
            i=i-j+1;//主串回溯到上次回溯位置的下一个位置
            j=0;//模式串回溯到第一个位置
        }
    }
    if(T[j]=='\0')
        return i-j+1; //返回T在S中第一次出现的位置
    else return 0;
}

int main(){

    char S[50]={'a','b','a','c','b','a','b','c'};
    char T[50]={'b','a','b','c'};
    cout<<BF(S,T)<<"\n";
    return 0;
}
```

在使用暴力匹配的时候，我们不难发现，每一轮如果匹配失效，那么就会直接放弃这一轮匹配的所有信息；进入到下一轮就重新匹配了。

Kmp算法就是将这一部分信息利用起来，使得下一轮匹配的时候不用重新开始，而是在前面的基础之上回退我们匹配串和前移我们的主串。这样就保留了匹配的信息。

![比较](image-20230504163459568.png)

那我们怎么利用信息呢：我们需要找到匹配串的相等前后缀，将其记录起来：这里就用next数组存储信息

#### next函数

![相等前后缀](image-20230504164818659.png)

那这个next数组有什么用，我们找到相等前后缀的目的是为了保留信息，如果在7这个位置匹配失败了，那么只要找到在6这个位置的前后缀相等的，跳回到最大相等前后缀就行。因为在7之前我们的字符串是完全匹配的，可以吧ne数组理解为匹配位置的长度。

![next数组](image-20230504170809559.png)

```c++
ne[1] = 0;
for(int i = 2,j = 0;i<=n;i++){
    while(j&&P[i]!=P[j+1]) j = ne[j];
    if(P[i] == P[j+1]) j++;
    ne[i] = j;
}
```

![next构造](image-20230504171245977.png)

#### 匹配

这里，使用了双指针思想。i指针维护主串，j指针维护匹配串，i指针只能向前移动，j指针可以来回调整。

![匹配过程](image-20230504172311018.png)

```c++
for(int i = 1,j = 0;i<=m;i++){
    while(j&&S[i]!=P[j+1]) j = ne[j];//回调操作 - ne数组存储的是最大匹配串长度（1-j的），这里赋值相当于将j回调到最大匹配的位置
    if(S[i] == P[j+1]) j++;
    if(j==n) printf("%d\n",i-n+1);
}
```

![kmp时间复杂度](image-20230504172557271.png)

那么总的时间复杂度就是O(m+n)

![总结](image-20230504173358331.png)
