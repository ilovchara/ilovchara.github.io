---
title: 动态规划and贪心
date: 2023-04-28 09:09:57
categories: 算法
tags: 数据结构
typora-root-url: ./动态规划
---

## [动态规划](https://cloud.tencent.com/developer/article/1692068)

> 只有多练才能积累，之后就变练变总结，不要写云里雾里的东西了。

动态规划（Dynamic Programming，简称DP）是一种解决多阶段决策问题的数学优化方法和算法思想。它通常用于解决具有重叠子问题和最优子结构性质的问题，其中最优子结构指的是问题的最优解可以由其子问题的最优解组合而成，而重叠子问题指的是在问题的求解过程中，同一个子问题会被多次计算，这导致了子问题的重复求解。

说人话就是，在计算到我们结果的过程中，有一部分的数据我们已经算了一遍了（甚至需要多遍），我们将这些`重叠字`记录起来，可以方便我们使用。还有呢就是，我们相当于将我们结果的大问题拆开，大问题包裹着小问题，就和俄罗斯套娃一样，只有到了最开始的子问题的时候，才会一层一层往上走。

下面举一个例子：**斐波那契（Fibonacci）数列的第n项**

> 写一个函数，输入n，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下： F(0) = 0, F(1) = 1 F(N) = F(N - 1) + F(N - 2), 其中 N > 1. 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

先用传统递归思想解决这道题：思路平平无奇

```c++
#include<iostream>
using namespace std;

//递归实现
int Fc(int n)
{
   if(n == 0) return 0;
   else if(n == 1) return 1;
   
   return Fc(n-1)+Fc(n-2); 
    
}

int main()
{
    for(int i = 0;i<10;++i){
        cout<<fc(i)<<" ";
    }
    cout<<endl;   
    return 0;    
    
}
```

```c++
//结果
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
F(7) = 13
F(8) = 21

//如果输入的是 8 那么所有的结果会是：
f(8) = f(7) + f(6)
f(7) = f(6) + f(5)
f(6) = f(5) + f(4)
f(5) = f(4) + f(3)
f(4) = f(3) + f(2)
f(3) = f(2) + f(1)
f(2) = f(1) + f(0)
```

明显可以看到，总计 8 次的计算过程中，相同的计算结果有三对进行了**重复计算**（下图中同色项，不包含灰色），也就是说在递归的过程中，把曾经计算过的项进行了**又一次的重复计算**，这样对于时间效率是比较低的，唯一的好处可能就是代码看起来比较好懂，但是终归不是一个好的算法设计方法。

代码中，在计算N的时候就去递归计算 `fib(N-1) + fib(N-2)`，那么，这种情况下的计算过程中。会是下面图中的一个计算过程。

可以发现，会有相当一部分的重复计算，这样对于时间都是重复的消耗。

> 参考图中相同颜色的项，比如说粉色的重复计算、黄色的重复计算等
>
> **注意：**递归中没有对空间进行了增加，始终都是同样的长度，仅仅是不断的弹出和压入

![img](bkaejoe5ad.png)

为了更好的说明这种重复计算带来时间效率的低下。再比如说，相比上述图中的计算节点，再增加一个节点的计算，增加计算F(5)，那么由于递归的计算方式，会有更多的项（下图中线框中部分）进行了重复的计算。在计算`F(5)`的时候，会递归调用`F(4)`和`F(3)`，而在下图中，计算`F(4)`的时候，又会完整的去计算`F(3)`。这样，如果N很大的话，会有更大的时间消耗. 

这样，这棵树的规模进行进行成倍增加，时间复杂度很明显的进行了成倍的扩张。对于时间上来说是很恐怖的.

时间复杂度带来的低效率严重超过了代码的可读性，所以我们可以想办法将**过去计算**过的节点**进行保存**。这样，我们就会用到下面要说的动态规划思想带来的时间上的高效. 

![img](et3sz0g04k.png)

> 时间复杂度：$O(2^N)$   ---> 指数级
>
> 空间复杂度：$O(N)$

-------------------------------

**动态规划：**我们不直接去解决问题，而是在每一步解决问题的时候，达到每一步的最优情况。换句话说，就是在每一步解决问题过程中，利用**过去的状态**以及**当前状态**的情况而达到一个当前的最优状态.

**规划：**在一般解决该类问题的时候，会有一个“填表格”的过程，无论是简单情况下的**一维表格**还是复杂一点的**二维表格**，都是以**开辟空间换时间**的思想，以争取最佳的时间效率. （保存过程中间值，方便后续直接使用）.

**动态：**用上面的案例来说，递归解决过程中的每一步都会从基本问题不断的“自顶向下”去求解，在每一步骤中，会有相同的计算逻辑进行了重复的计算。相比于递归思想，动态规划思想增加了对历史上计算结果的保存，逐步记录下中间的计算结果，在每一步求得最优值.

因此，动态规划可以避免重复计算，达到了时间上的最优，从`O(2^N)`指数级变为`O(N)`常数级别，相较于开辟的一段内存空间存放中间过程值的开销，是非常值得的.

**那么，接下来咱们依照动态规划的思路进行对Fibonacci进行下解决**

依据题中的规则：

`F(0) = 0, F(1) = 1`

`F(N) = F(N - 1) + F(N - 2),  when N > 1`

那么，👇👇F(N) 的值只与他的前两个状态有关系👇👇

a. 初始化值 : `F(0) = 0, F(1) = 1`

b. 想要计算得到`F(2)`， 那么`F(2) = F(0) + F(1)   -->  保存 F(2)`

c. 想要计算得到`F(3)`， 那么`F(3) = F(2) + F(1)   -->  保存 F(3)`

d. 想要计算得到`F(3)`， 那么`F(4) = F(3) + F(2)   -->  保存 F(4)`

利用动态规划思想，以一维数组辅助实现的Fibonacci，看下图

![img](6qd2ia8jfj.png)

是不是很简单的思路，仅仅靠保存过程中的一些值就能很简单的利用循环就可以实现了，没必要用递归反复计算进行实现。

想要计算得到第 n 个值的多少？那么，以下几点是我们必须要做到的

话说只要两个值，现在定义两个变量 dp1 和 dp2。那么，现在咱们一步一步模拟一下：

a. 初始化值 : F(0) = 0, F(1) = 1

![img](t36rk0x8sx.png)

b. 想要计算得到F(2)， 那么F(2) = F(0) + F(1)   -->  保存 F(2)

```js
顺带将F(1)赋值给dp1， f(2)赋值给dp2
```

复制

![img](y5moqglg82.png)

c. 想要计算得到F(3)， 那么F(3) = F(2) + F(1)   -->  保存 F(3)

```js
顺带将F(2)赋值给dp1， F(3)赋值给dp2
```

复制

![img](nnxa1qxt39.png)

d. 想要计算得到F(3)， 那么F(4) = F(3) + F(2)   -->  保存 F(4)

```js
顺带将F(3)赋值给dp1， F(4)赋值给dp2
```

复制

![img](5efrj8zz5e.png)

至此为止，整个过程仅仅用到了两个变量来存储过程中产生的值，也就之前没有优化的空间效率得到了优化

下面是这个程序的代码：

```c++
#include<iostream>
using namespace std;

int fbnq(int n){
    if(n<=1) return n;
    
    vector<int> dp(n+1);
    
    dp[0] = 0;
    dp[1] = 1;
    
    for(int i = 2;i<=n;++i) dp[i] = dp[i-1]+dp[i-2];
    
    return dp[n];
}


int main()
{
    int n;
 	cout<<fbnq(n)<<" ";
    return 0;    
}
```

> 简单来说就是空间换时间，发现的细节就是每个数据都与前面两个计算的数据强关联，这样就可以得出我们`dp`数组的构造。

-----------------------

上面用斐波那契数列问题，引出了下面的几点，在这里再详细赘述一下

在后面的案例中将会尽量严格按照这几个步骤进行解决问题

> 步骤一：定义`dp`数组的含义
>
> 步骤二：定义状态转移方程
>
> 步骤三：初始化过程转移的初始值
>
> 步骤四：可优化点(可选)

步骤一：定义`dp`数组的含义

绝大部分情况下，我们需要定义一维数组或者二维数组进行存储在计算过程中产生的最优值，这里为什么是最优值呢？是因为在解决问题过程中，一般情况dp数组用来保存**从开始到当前情况的最优值**，故而保存的是截止到目前的最优值，避免重复计算（这里看起来思维有混乱的同学们，想想上面Fibonacci 递归解法和动态规划的对比）

**所以，`dp`无论是一维的还是二维的，要想清楚代表什么，一般来说代表的是截止到目前情况下的最优值**

步骤二：定义状态转移方程

什么是动态转移方程？ 如果有一个问题摆在我们面前，然后这个问题在解决的过程中，会发现有很多的重叠的子问题，重叠子结构，而通过这些子问题的解决，最终将会把该问题进行解决

通俗来说，在解决问题过程中，能够发现一个不断解决子问题的动态规律，比如说Fibonacci中的F(N) = F(N - 1) + F(N - 2)，而在其他的可以用动态规划解决的问题中，需要我们自己去发现这样的内在规律。这个是最难的也是最终于要的，只要这一步解决了，接下来我们解决这个问题基本就没问题了.

步骤三：初始化过程转移的初始值

顺着步骤二的思路来，既然动态方程定义好了，是不是需要一个**支点**来撬动它进行不断的计算下去。

那么，这个**支点**就需要我们来初始定义，将动态方程激活，进行计算。举例来说Fibonacci中的F(0) = 0和F(1) = 1，有了这两个值，它的动态方程F(N) = F(N - 1) + F(N - 2)就可以进行下去了

这个就是我们要想好的初始值，实际问题可能还需要我们想想清楚.

步骤四：可优化点(可选)

可优化的这里，最重要的会是`dp`数组这块，也会有不同问题不同的优化点

在例子中，我们会进行不同的优化. 

总之一点，建议大家动笔多画画图，很多细节慢慢就会出现了. 

## 背包问题

背包问题（Knapsack problem）是一种组合优化的NP完全`（NP-Complete，NPC）`问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。`NPC`问题是没有多项式时间复杂度的解法的，但是利用动态规划，我们可以以伪多项式时间复杂度求解背包问题。一般来讲，背包问题有以下几种分类：

- 01背包问题

- 完全背包问题

- 多重背包问题

### `01`背包问题

![image-20230319202209832](image-20230319202209832.png)

![image-20230319214127252](image-20230319214127252.png)

动态规划重点的是状态转移方程:` 01`背包，**代表着物品只有两种可能性 - 放和不放**

`f[i][j] `中的前i件物品放入容量为j的背包中。我们很容易可以看出，数组的第一个维度我们存储的是物品的不同种类，第二个维度存储的是我们的背包容量。

> 可以这样理解，`f[i][j]`就是`i`物品放入背包容量为`j`的状态

更新容量我们就使用：`max(f[i-1][j-w[i]]+c[i],f[i-1][j])`

当然放入物品的时候有两种情况，我们分别判断一下：
		第一种，不放入我们的物品。`f[i][j] = f[i-1][j]`:这里很好理解，遍历到`i-1`这个物品，放入不下`j`就不变化 , 状态不更新把状态传下去。

第二种，放入我们的物品。这里就要考虑代价，也就是`f[i][j] = max(f[i-1][j],f[i-1][j-w[i]]+c[i])` , 放入物品减去对应的体积吗，更新对应的值。记住每一个位置表示着一个状态。

![image-20230319202536339](image-20230319202536339.png)

```c++
//模版思想研究
//用二维数组来理解
 for(int i = 1;i<=n;i++)
        for(int j = 1;j<=m;j++)
            if(j<w[i]) //先决条件：这个位置放不了i这个物品了
                f[i][j] = f[i-1][j];
   			else
                f[i][j] = max(f[i-1][j],f[i-1][j-w[i]]+c[i]); 
 		cout<<f[n][m];
```

--------------------

用二维数组来理解十分容易，但是会浪费一些容量。我们不妨使用滚动数组来构造背包问题。思路如下：

- 外层循环遍历每个物品`i`。

- 内层循环遍历背包的容量`j`。

- 如果当前物品的重量`w[i]`大于背包的容量`j`，表示无法将物品`i`放入背包中，因此`f[j]`的值不变，即`f[j] = f[j]`。这对应于提到的**不放入我们的i**情况。

否则，如果`w[i]`小于或等于背包容量`j`，表示可以考虑将物品`i`

放入背包中。在这种情况下，需要比较两种情况：

`f[j]`表示不放入物品`i`时的最大价值（对应于提到的`f[j] = f[j]`情况）。

`f[j-w[i]] + c[i]`表示放入物品`i`后的最大价值，其中`f[j-w[i]]`是在剩余容量`j-w[i]`下的最大价值，而`c[i]`是物品`i`的价值。你需要选择这两种情况中的较大值作为`f[j]`的新值，即`f[j] = max(f[j], f[j-w[i]] + c[i])`。

![image-20230319202555236](image-20230319202555236.png)

```c++
//用j逆序排序
 for(int i = 1;i<=n;i++)
        for(int j = m;j>=1;j--)
            if(j<w[i]) f[j] = f[j];
   			else f[j] = max(f[j],f[j-w[i]]+c[i]);
```

![image-20230319202608455](image-20230319202608455.png)

```c++
//模版
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 1005;

int N, V; // N表示物品个数，V表示背包容量
int w[MAXN], v[MAXN]; // w[i]表示第i个物品的重量，v[i]表示第i个物品的价值
int dp[MAXN]; // dp[i]表示容量为i的背包所能装下的最大价值

int main() {
    cin >> N >> V;
    for (int i = 1; i <= N; i++) {
        cin >> w[i] >> v[i];
    }

    memset(dp, 0, sizeof(dp)); // 初始化dp数组
    for (int i = 1; i <= N; i++) {
        for (int j = V; j >= w[i]; j--) { // 从后往前遍历，避免重复选择物品
            dp[j] = max(dp[j], dp[j - w[i]] + v[i]); // 状态转移方程
        }
    }

    cout << dp[V] << endl; // 输出结果

    return 0;
}
```

### 完全背包问题*

![image-20230320175854308](image-20230320175854308.png)

![image-20230320175908237](image-20230320175908237.png)

完全背包问题，就是01背包的变形，每个物品可以无限次放入。`f[i][j]`依然和01背包问题相同的，i表示的是我们物品的种类，j表示的是我们背包的容量。放入物品的时候，我们需要选择放入这个物品我们的价值是否会增加

**过程:**

背包容量放不下我们当前这个物品 条件就是`j<w[i]` 所以说我们的容量还是不变` f[i][j] = f[i-1][j]`; (这也就解释了我们可以使用一维数组来维护我们的背包)，这里的`i-1`表示的是前一个物品，就是我们不会改变当前的背包状态

- 当背包可以放入我们当前这个物品，条件也就是`j>=w[i]`我们有两种选择 - 放入和不放入。放入的话就是  `f[i][j] = f[i][j-w[i]]+c[i] `

- `c[i]`是我们的价值(这里的i的意思就是我们物品是无穷的，每一个i表示的意思就是取出当前i这个物品的其中一个)
          不放入就是
         ` f[i][j] = f[i-1][j] `  j就不会变化

- 我们最终的转移方程就是 上面两个合并的结果
         `f[i][j] = f[i-1][j] (j<w[i])`
         ` f[i][j] = max(f[i-1][j],f[i][j-w[i]]+c[i])`

![image-20230320175946146](image-20230320175946146.png)

![image-20230320175955400](image-20230320175955400.png)

下面是代码模版：

```c++
for(int i = 1;i<=n;i++)
	for(int j = 1;j<=m;j++) //这里m是容量
	{
		if(j<w[i]) f[i][j] = f[i-1][j];
		else f[i][j] = max(f[i-1][j],f[i][j-w[i]]+c[i]); //c[i]是i物品的价值
	}
printf("%d",f[n][m]);
```

![image-20230320180004395](image-20230320180004395.png)

![image-20230320180015757](image-20230320180015757.png)

![image-20230320180027068](image-20230320180027068.png)

![image-20230320180039797](image-20230320180039797.png)

![image-20230320180103129](image-20230320180103129.png)

```c++
#include <iostream>
#include <vector>
using namespace std;

// 完全背包问题的动态规划解法
int knapsack(int W, vector<int>& wt, vector<int>& val) {
    int n = wt.size();
    vector<int> dp(W + 1, 0);

    for (int i = 1; i <= n; i++) {
        for (int j = wt[i-1]; j <= W; j++) {
            dp[j] = max(dp[j], dp[j - wt[i-1]] + val[i-1]);
        }
    }

    return dp[W];
}

// 测试
int main() {
    vector<int> wt = {2, 3, 4, 5};
    vector<int> val = {3, 4, 5, 6};
    int W = 8;
    cout << "最大价值为：" << knapsack(W, wt, val) << endl;
    return 0;
}
```

### 多重背包问题

在`01`背包的基础之上，让每一种物品都有对应的容量。只需要多加一个枚举数量的变量就行。

![image-20230320145257361](image-20230320145257361.png)

![image-20230320145415756](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145415756.png)

> 需要注意的是，for循环枚举的是位置，而不是值。

```c++
//在01背包的基础上，让每一件物品都有他们的数量
 //1.v[i],w[i] 体积和价值
 for(int i = 1;i<=n;i++) //物品种类
        for(int j = m; j>=v[i];j--) //背包容量
            f[j] = max(f[j],f[j-v[i]]+w[i]);
 //2.v[i],w[i],s[i]; 体积 价值 数量 
        for(int i = 1;i<=n;i++)
            for(int j = m;j>=v[i];j--)
                for(int k = 0;k<=s[i]&&k*v[i]<=j;k++) 
                    //这里的k表示的是选择物品的数量 - s[i]表示的是当前位置的i物品的数量
                    f[j] = max(f[j],f[j-k*v[i]]+k*w[i]);
```

```c++
//朴素做法
const int N = 1e5+10;
int v[N],w[N],s[N]; //体积 价值 数量
int f[N][N]; //这个是我们的状态转移数组

int main()
{
    cin>>n>>m;
    
    for( int i = 1;i<=n;i++) cin>>v[i]>>w[i]>>s[i]; //这里就是输入对应的价值，由i下标规定数据
    for(int i = 1;j<=n;j++)
        for(int j = 0;j<=m;j++)
            for(int k = 0;k<=s[i]&&k*v[i]<=j;k++)
                f[i][j] = max(f[i][j],f[i-1][j-v[i]*k]+w[i]*k); //这里i-1是把这个i物品选择了（选够了就剔除） - 只要找到一个符合的k就行（我们不管怎么实现的就行）
    cout<<f[n][m]<<endl;
    return 0;
    
}
```

![image-20230320145513754](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145513754.png)

![image-20230320145617888](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230320145617888.png)

```c++
int num = 1;//拆分计数
for(int i = 1;i<=n;i++){
    //v,w,s; 体积，价值，数量
    cin>>v>>w>>s;
    for(int j = 1;j<=s;j<<=1){ //<<=是左移位赋值运算符,等价*2
        vv[num] = j*v; //存体积
        ww[num++] = j*w; //存价值
        s-=j;
    }
    if(s){
        //体积和价值拆分 - 封装为新的数组
        vv[num] = s*v;
        ww[num++] = s*w;
    }
}

//01背包问题 - 基础
 for(i = 1;i<num;i++)
        for(j = m;j>=vv[i];j--)
            f[j] = max(f[j],f[j-vv[i]]+ww[i]);
cout<<f[m];
```

```c++
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 1005; // 物品的最大数量
const int MAXV = 100005; // 背包的最大容量
int n, V; // 物品的数量和背包的容量
int w[MAXN], v[MAXN], s[MAXN]; // 分别表示物品的重量、价值和数量
int dp[MAXV]; // dp[i]表示容量为i的情况下，可以获得的最大价值

// 二进制优化
void binary_optimization(int x, int y) {
    for (int j = V; j >= x; j--) {
        for (int k = 0; k <= s[y] && k * x <= j; k++) {
            dp[j] = max(dp[j], dp[j - k * x] + k * y);
        }
    }
}

int main() {
    cin >> n >> V;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> v[i] >> s[i];
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= s[i]; j *= 2) {
            binary_optimization(w[i] * j, v[i] * j); // 调用二进制优化函数
            s[i] -= j;
        }
        if (s[i] > 0) {
            binary_optimization(w[i] * s[i], v[i] * s[i]);
        }
    }

    cout << dp[V] << endl; // 输出答案
    return 0;
}
```

```c++
//二进制优化
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N];
int f[M];

int main()
{
    cin >> n >> m;

    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while (k <= s)
        {
            cnt ++ ;
            //这里是二进制优化的核心 - 就是将s拆成2进制
            //核心是将物品拆分为2的幂次方个物品
            //每次都拿s拆开二进制的数量
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt ++ ;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt;

    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}

```

### 分组背包问题

在01背包的基础上，增加了物品序列号。只需要将价值生成一个组的序列号就行，然后照常枚举出我们需要的值。

![image-20230321181451351](image-20230321181451351.png)

![image-20230321181510913](image-20230321181510913.png)

```c++
//朴素做法
for(int i = 1;i<=n;i++)
    for(int j = 1;j<=V;j++)//体积
        for(int k = 0;k<=s[i];k++) { //决策
            if(j>=v[i][k])
                f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);
                //不选取i  选取i
        }
cout<<f[n][V];
```

![image-20230321181526186](image-20230321181526186.png)

![image-20230321181540822](image-20230321181540822.png)

```c++
//分组朴素做法
for(int i = 1;i<=n;i++)
 for(int j = 1;j<=V;j++)
  for(int k = 0;k<=s[i];k++)
  {
   if(j>=v[i][k])
    f[i][j] = max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);
  }
cout<<f[n][V];
```

![image-20230321181555557](image-20230321181555557.png)

> 应该也可以用二进制优化策略

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 12010, M = 2010;

int n, m;
int v[N], w[N];
int f[M];

int main()
{
    cin >> n >> m;
    int cnt = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        //这里是将s数量分二进制
        while (k <= s)
        {
            cnt ++ ;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        //这里就构造二进制数组
        if (s > 0)
        {
            cnt ++ ;
            v[cnt] = a * s;
            w[cnt] = b * s;
        }
    }

    n = cnt;

    //2.这里就是选择最大
    for (int i = 1; i <= n; i ++ )
        for (int j = m; j >= v[i]; j -- )
            f[j] = max(f[j], f[j - v[i]] + w[i]);

    cout << f[m] << endl;

    return 0;
}
```

### 混合背包问题

![image-20230320145732542](image-20230320145732542.png)

![image-20230320145752872](image-20230320145752872.png)

![image-20230320145806496](image-20230320145806496.png)

``` c++
//三个背包综合考虑
```
