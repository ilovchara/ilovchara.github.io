---
title: 数据结构 - 图论
date: 2023-04-28 09:05:38
categories: 算法
typora-root-url: 图论
---

## 图论

  图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种，1.是竖向的dfs递归遍历 2.是横向的bfs递归遍历。我们现在先要求掌握两种遍历，然后才开始下一阶段的学习。

### 二叉树

  要了解上述两个遍历模型，就要了解二叉树。二叉树是图的一种特殊造型，二叉树有两种主要形式：满二叉树和完全二叉树.满二叉树的深度和结点是有关系的，一个深度为k的满二叉树，它的节点数是2^k - 1（每一层是两个，减去我们的头结点就ok了）

#### 完全二叉树

  完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数 都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h层，则该层包含 1~ 2^h -1 个节点。（就是叶子结点左边可以不满，其他必须满是这个意思是吗）。

​        ![image-20230216131827500](image-20230216131827500-16923746582101.png)

> 二叉搜索树（建立在完全二叉树的基础之上）
> 有如下的规则（简单来说，左边的都是小于根节点，右边的都是大于根节点）
>  若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值； 
>  若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；
>  它的左、右⼦树也分别为⼆叉排序树

![image-20230216133015856](https://cdn.jsdelivr.net/gh/ilovchara/blog-img/blog-img202308312338279.png)

#### 平衡二叉搜索树

平衡⼆叉搜索树：又被称为AVL`（Adelson-Velsky and Landis）`树，且具有以下性质：它是 ⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。（高度差 注意是高度差！！！！！）

![image-20230216133247245](image-20230216133247245-16923744811933.png)

#### 用数组实现二叉树

![image-20230216134441813](image-20230216134441813-16923744802222.png)

```c++
⽤数组来存储⼆叉树如何遍历的呢？ 如果⽗节点的数组下表是i，那么它的左孩⼦就是i * 2 + 1，右孩⼦就是 i * 2 + 2。 
但是⽤链式表⽰的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。
所以⼤家要了解，⽤数组依然可以表⽰⼆叉树
```

#### 二叉树的链式实现

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};
```

#### 用二叉树理解递归

实现递归的三要素：

> 1. 确定递归函数的参数和返回值： 确定哪些参数是递归的过程中需要处理的，那么就在递归函数⾥加上这个参数， 并且还要明确每次递归的返回值是什么进⽽确定递归函数的返回类型。
> 2. 确定终⽌条件： 写完了递归算法, 运⾏的时候，经常会遇到栈溢出的错误，就是没写终⽌条件或者 终⽌条件写的不对，操作系统也是⽤⼀个栈的结构来保存每⼀层递归的信息，如果 递归没有终⽌，操作系统的内存栈必然就会溢出。
> 3. 确定单层递归的逻辑：
>    确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程

为什么用二叉树可以实现递归，首先让我们回到二叉树中。如果我们搜索一个二叉树的随机节点的值，应该怎么办。

![image-20230216134441813](image-20230216134441813-16923744802222.png)

如果我们要查找e这个位置的数据，依靠上帝视角我们可以直接0-1-4即可查询。但是如果这个树十分庞大导致无法一眼看出，而且计算机也无法做到这么复杂的识别方式，那我们怎么做。

最简单的方法就是一条线查找下去（从左到右）或者说一层层查找（从上到下）。那这个和递归有什么关系呢。

我们现在是在一个二叉树内找数据，从一个节点到另一个节点只有两种方式，要么向左要么向右。而每个节点只有两种情况，要么有值要么没值。遍历的过程每一条线都是独立的，且每次遍历都高度相似（因为向下延伸只有两种方式）。终止条件就是找到我们需要的值。所以说这样的遍历方式符合使用递归的情况，一下是实现递归的具体步骤。

> 下面用递归实现二叉树的遍历，二叉树的遍历有三种。前中后序遍历，但是基本上是差不多的，我们可以通过这三个遍历来看看改变递归函数的语句会产生什么变化。

在遍历构造之前，我们先构造树。

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};
```

##### 前序遍历

前序遍历（对于单独）的逻辑是，从根节点出发，找到左子树，再到右子树。

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};

void PT(TreeNode root)
{
    //如果访问的节点没有子节点
    if(nullptr == root) return;
    
    //打印遍历的节点数据
    cout<<root->data;
    
    //遍历左子树
    PT(root -> left);
    
    //遍历右子树
    PT(root -> right);    
    
}
```

##### 中序遍历

中序遍历的逻辑是，从左子树出发，到根节点，再到右节点

```c++
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
	//和上面相比，就改变了顺序
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}
```

> 这里的逻辑是通过`inorderTraversal(root->left);`这个语句到达我们的最下左节点，然后执行打印` cout << root->data << " ";`最后查询当前遍历到节点的右节点，直到最后没有节点为止。

##### 后序遍历

后序遍历的逻辑是左子树到右子树到根节点。

```c++
// 后序遍历二叉树
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
	//一样的改变顺序
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->data << " ";
}
```

> 我们只针对于遍历到第一个节点来思考，如果我们需要打印这个节点就需要执行前面两个语句，`postorderTraversal(root->left);`和`postorderTraversal(root->right);`。我们**执行完了第一个语句**，这个时候就返回了`root -> 树中最左的节点（执行的是一个函数嘛）`，然后执行第二个函数`postorderTraversal(root->right);`由于这个函数查询了当前这个节点`(root -> 树中最左的节点（执行的是一个函数嘛）)->right` 这个结果，其实就是`null`。所以说当前这个递归的其中一个函数结束了，也就是打印了第一个值。
>
> 结束了递归中的第一个函数，不代表全部函数都结束了。由第一个函数引发的全部函数（大概是2的倍数差不多），还在继续运行以第一个函数举例。
>
> ```c++
> void postorderTraversal(TreeNode* root->left) {
>     if (root == nullptr) {
>         return;
>     }
> 	//当执行完这两个句子的时候，就会打印值
>     postorderTraversal(root->left->left);
>     postorderTraversal(root->left->right);
>     cout << root->data << " ";
> }
> ```
>
> 这样你就能理解了吗，再说下去就会乱了。执行完全部子函数，就可以执行完这个递归函数了。

##### 层序遍历（补充）

层序遍历，就是从根节点出发，一层一层的遍历我们的树。

```c++
//一排一排的遍历 利用队列的特性哟，将根结点入队列 然后然后出入队列，出队列后将其左右孩子结点入队列
//直到队列为空
void SeqTraverse(BiTree tree)
{
	SeqQueue queue = Init_SeqQueue();
	Push_SeqQueue(queue, tree);
	while (!IsEmpty_SeqQueue(queue))
	{
		BiTree root = Pop_SeqQueue(queue);
		printf("%c ", root->data);
        //遍历两个孩子就行 - 因为是二叉树嘛
		if (root->lchild)
			Push_SeqQueue(queue, root->lchild);
		if(root->rchild)
			Push_SeqQueue(queue, root->rchild);
	}
	printf("\n");
}
```

### 图的介绍

图，是一种抽象的数据结构，在我们学习数学的时候，最早接触的图像就是三角形，三角形的属性有三个边，并且是封闭的。在数据结构中，图的理论也和我们的数学是一样的，在其基础之上，我们衍生出了节点，和边集关系。用这些属性，可以帮助我们快速的构造一个像样的图。

对于图，我们可以这样理解，就是节点与节点之间的关系，且关系成环（至少有一个环），如果没有环的话，其实是一种特殊的图像，也就是二叉树。节点彼此的关系，可以理解为边，毕竟声明一个图主要用途就是寻找路径和定位。在此基础上增加了几个定义。

![image-20230809211226304](image-20230809211226304.png)

相对比而言，图严格证明的定义是十分多的，如果要细究会十分抽象和麻烦。我们这边就记几个比较常用语算法中的概念，如果有需要可以去翻维基百科，里面有详细的定义和概念。

首先我们需要了解，组成一个图需要什么，你可能会说，找几个定点将之链接起来，围成一片区域，这样形成的图像不就是图吗。但是，严格来说，单个节点其实也是个图，这样的图被称之为**独立节点**-最简单的图像。这里就引出了图中的第一个概念，顶点。

![image-20230809212302594](image-20230809212302594.png)



在这一张图中，顶点其实没有属性，只有编号，但是顶点可以赋值属性。这就要具体题目具体分析*。类似于我们城市的路线图。

![image-20230809212603095](image-20230809212603095.png)

在这些图中，每个节点都有相应的关系，通过一个线来表示。这个被我们称之为**边**，边中可以赋值，上面的城市路线图，边就承接了两个城市之间的距离这个信息。对于边我们可以用邻接矩阵来承接边的信息，这个信息被称之为**权**。下面就举一个简单的例子。

```c++
//伪代码 - 二维数组表示邻接矩阵
const int N = 1e5+10;
// 每一个位置表示一个顶点
f[N][N];

//如果我们有四个节点 1 2 3 4 那么
f[1][2]; //表示1链接2
f[1][2] = 1; //表示1节点到2节点的边权为1
```

在这里我们只举了单向的边来表示，只有单向的边的图叫做**有向图**，如果链接之间没有方向，那么被称之为**无向图**。前面说，二叉树是一种特殊的图，但是树有一个特点，就是不存在环，但是一般出现的图呢，很正常会出现**环**，那么环的概念是什么呢。

**图环**（Cycle）是指图中的一条路径，它从一个顶点出发，经过一系列不同的顶点，最后回到起始顶点，形成一个闭合的回路。换句话说，图环是一个不包含重复顶点的路径，其起始顶点和终止顶点相同，并且至少包含3条边（或2个顶点）。

从这个概念，我们可以得到环的特殊变式，**连通图**和**强连通图**。

![image-20230809214600123](image-20230809214600123.png)

![image-20230809214636189](image-20230809214636189.png)

具体细节可以看这篇[博客](http://data.biancheng.net/view/201.html),我的理解是，**联通图是，从一个节点可以到达任意的节点。强连通图是在连通图的基础上，有两个方向都可通行。**如果让你编写一个程序判断图是否是连通图你会写吗？其实很简单，只要将我们图中的每个节点遍历一遍即可，遍历到说明在图中，遍历不到说明在这之外。这就是我们之后会涉及到的，图的遍历的两种方法，深度优先遍历和广度优先遍历（不过图还是深度用的多）。

![image-20230809220406017](image-20230809220406017.png)

![image-20230809220953852](./image-20230809220953852.png)

下一个概念是，**子图**，也被称之为图的子集。如果我们需要求得一个图有多少个子集，可以使用幂集的概念。一个包含n个元素的集合的幂集包含2^n个子集，其中包括空集和全集。对于图来说，子集的数量与图的顶点数量有关。假设图有n个顶点，那么图的所有可能子集数量为2^n。这是因为每个顶点都可以选择是否包含在子集中，有包含和不包含两种选择，所以总的可能性是2^n。具体到图的应用中，可以将每个顶点看作是一个元素，然后使用幂集的概念计算子集的数量。这在某些问题中可能是有用的，例如在某些组合问题中，需要考虑图中的顶点子集。需要注意的是，幂集包括空集和全集，所以实际有效的非空子集数量是2^n - 1。

子图对于我们将图转化为树或者说森林也有帮助，这里就不在赘述。在离散数学中也有对于的体型，感兴趣可以去看看离散数学。

![image-20230809221018966](./image-20230809221018966.png)

完全图： 具有n个顶点的无向图，每一对不同的顶点之间都存在一条边。两点关系的一种特殊情况。知道概念就行。一般来说也不是很常见，和普通的图一样。

度数：和树的概念其实是一样的，这里就表示的是当前顶点连接了几个其他顶点。然后出度表示出去的边的数量，入度表示进来的边的数量。

邻接矩阵和邻接表等等讲，就是用来表示图的结构的一种数据结构。下面是总概念，可以简单看看，建议结合教材。

![image-20230809221035439](image-20230809221035439.png)

![image-20230809213919067](image-20230809213919067.png)

#### 图的存储

在讲遍历之前，我们先讲几个常见的存储图的方式。

##### 领接矩阵

开一个二维数组，每一个数组位置相当于一个二维坐标，每个二位坐标存储图中的一个数据。图是二维的嘛，所以说用二维数组存储很好理解。

![image-20230305080127311](image-20230305080127311.png)

```c++
//领接矩阵声明，开一个二维数组； 1.二维数组w[u][v],存储u - v的边权（就是这个连线多长）2.只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）
//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系

int w[N][N]; //声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c
int vis[N];//点集

void dfs(int u){
    vis[u] = true;
    for(int v = 1;v<=n;v++){
        printf("%d,%d,%d\n",u,v,w[u][v]);
        if(vis[u]) continue;
        dfs(v);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b;
        w[a][b] = c; //赋予权值（a点 和 b点）（算是连线）
    }
    dfs(1);
    return 0;
}
```

> 但是如果矩阵的点很散，例如三个点`（1,1）,(10000,10000),(100000,100000)`,那么开的空间很多都会被浪费，所以说只适合用于稠密图。

##### 边集数组

![image-20230305080154969](image-20230305080154969.png)

声明了一个结构体，存储我们两个节点对应的边。好处就是不用按照数组下标开对应大的数组。其实很好理解，声明两个变量存储对应的节点序列，然后声明一个变量存储权即可。

```c++
//边集数组
//结构体下标联系三者
struct edge(){
    int u,v,w; //两点 和 权
}e[M]; //边集合
int vis[N]; //点

void bfs(int u){
    vis[u] = true;
    for(int i = 1;i<=m;i++){
        int v = e[i].v,w = e[i].w; //用结构体中对应的值
        printf("%d,%d,%d",u,v,w); //
        if(vis[v]) continue; //这个点到过了
        dfs(e[i].v);//下一个点
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++)
    {
        cin>>a>>b>>c;
        e[i] = {a,b,c};
        //e[i] = {b,a,c}; //无向图就要加上
    }
    dfs(1);
    return 0;
}
```

##### 领接表

![image-20230302110544398](image-20230302110544398.png)

对于每个节点，领接表创建的结构体数组，存储的是当前节点的所有出边（和图的出度是一个概念），结构体中声明两个变量，一个存储当前节点指向的节点，一个存储连接的边权。（不过我刚开始理解的时候，对于这个`vector<edge> e[N]`理解的有点抽象，感觉是数组的数组，但是确实是:joy:）

![image-20230831223534628](image-20230831223534628.png)

```c++
//领接表（将图用dfs序输出）
//出边数组e[u][i] 存储u点的所有出边{终点 v ， 边权 w}。
    
struct edga{int v,w;}; //声明结构体（代表每个点有的属性）
vector<edga> e[N];//存储的是每一个起点（有n个）

void dfs(int u,int fa)
{
    for(auto ed:e[u]) //遍历当前层的元素
    {
        int v = ed.v,w = ed.w;
        if(v==fa) continue;//判重（父节点记录父节点是否走过）（u和fa是交替使用的）
        printf("%d，%d,%d\n",u,v,w);
        dfs(v,u);// （u,fa,v,u,v,u.......） //fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）
    }   
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图 两边都要连接
        e[a].push_back({b,c});
        e[b].push_back({c,b});
    }
    //1.从哪一个点开始深搜  2.当前节点的父节点
    dfs(1,0);
    return 0;   
    
}
//父节点是相互的，我们用领接表存储的时候，只要连接就是父和子的叠加态（这也解释了为什么可以回溯）

```

##### 链式领接表

![image-20230302111110291](image-20230302111110291.png)

与前面的领接表不同，是按照输入循序给与节点编号，按照编号存储我们的出边的信息，并且用这些信息构造一个数组`h[N]`来存储。然后在一个桶数组，以编号的形式插入我们的数据，就构成了一个链式领接表（是尾插法，`vector`变长数组）

```c++
//链式领接表
/*两个变量：1.边集数组 2.表头数组
1.边集数组存储的是第几条边的属性：e[j]存储第j条边的{起点u，终点v，边权w}
2.表头数组存储的是u点的所有出边的编号：h[u][j](u表示的是当前的点)（j表示的是当前点连接的出边）*/
    
struct edge{int u,v,w};
vector<edge> e; //边集合（边的属性）
vector<int> h[N]; //点的所有出边

void add(int a,int b,int c)
{
    e.push_back({a,b,c}); // 对应边的属性压入
    h[a].push_back(e.szie()-1); //当前边权数组的大小-1（这里的应该是桶数组）    
}
//u当前节点 fa-父节点
void dfs(int u,int fa)
{
    for(int i = 0;i<h[u].size();i++){
        int j = h[u][j];//表示的是当前的点？
        int v = e[j].v,w = e[j].w;
        if(v == fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //邻接表存储数据
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）
    return 0;
    
    
}

```

##### 链式前向星

![image-20230302112003101](image-20230302112003101.png)

e数组表示的是每一个出边的编号，现在相当于是双向的了（`1-4`的同时也`4-1`）,h数组表示出边的编号，编号用节点的编号表示就行，反正每一个节点都是独一无二的。然后在桶数组中，以链表的形式存储就行。

```c++
struct edge{int v,w,ne;};//ne是链接点的编号 - 例如1-4
edge e[M]; // 存储的是所有的边
int idx,h[N]; //点的第一条出边（每个点都有）


//获取第一个出边
void add(int a,int b,int c){
    e[idx] = {b,c,h[a]}; // e结构体存储的是这个边的信息
    //idx给每一个边都搞一个编号 - 独一无二的
    h[a] = idx++;
}


void dfs(int u,int fa)
{
    //横向遍历是为了回溯
    for(int i = h[u];~i;i=e[i].ne){ //~i表示i不等于-1
        int v = e[i].v,w = e[i].w;
        if(v == fa) continue;//判重 回溯
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);/深入
    }    
}
int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);//初始化表头
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图构图
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);
    return 0;     
}
```



![image-20230302112236202](image-20230302112236202.png)

### [图的遍历](https://www.cxyxiaowu.com/9854.html)

![遍历逻辑](image-20230216151302883.png)

讲完了二叉树的遍历，我们来讲讲图的遍历，图和二叉树的逻辑其实也是一样的（因为二叉树也是图）。下面讲讲用深度优先遍历和程序遍历来遍历我们的图。

但是对于图来说，遍历不像二叉树一样简单了，二叉树每个节点最多两个选择，但是对于图来说，每个节点连接的节点数是不一样的，导致递归次数会比树多很多。

#### dfs过程的实现

深度优化遍历( **Depth First Search** )，也有称为 **深度优化搜索** ，简称为 **`DFS`** 。事实上，我们在树的遍历中早已涉及`DFS`，层序遍历、中序遍历和后序遍历都属于深度优先遍历的方式，因为这些遍历方式本质上都归结于**栈**。为了讲清楚`DFS`，我们先来看两个概念。

**右手原则：** 在没有碰到重复顶点的情况下，分叉路口始终是向右手边走，每路过一个顶点就做一个记号。

**左手原则：** 在没有碰到重复顶点的情况下，分叉路口始终是向左手边走，每路过一个顶点就做一个记号。

本文约定以**右手原则**进行深度优先遍历。废话不多说，我们以下图说明深度优先搜索。

![1589850315-3ce63cac0c52019](1589850315-3ce63cac0c52019-1693495997261-22.png)

原则上，我们可以从图中的任何一个顶点开始，进行深度优先遍历，假设我们从顶点A开始，遍历过程中的每一步如下：

第一步：从顶点A开始，将顶点A标记为已访问顶点。

![1589850315-906ab179bb5b850](1589850315-906ab179bb5b850-1693496008513-24.png)

第二步：根据约定的右手原则，访问顶点B，并将B标记为已访问顶点。

![1589850315-906ab179bb5b850-1](1589850315-906ab179bb5b850-1-1693496019174-26.png)

第三步：右手原则，访问顶点C

![1589850316-453854f971022e4](1589850316-453854f971022e4-1693496121022-34.png)

第四步：右手原则，访问顶点D

![1589850316-6b252e146243857](1589850316-6b252e146243857-1693496098000-30.png)

第五步：右手原则，访问顶点E

![1589850316-6600fddac3ef23a](1589850316-6600fddac3ef23a-1693496111738-32.png)

第六步：右手原则，访问顶点F

![1589850317-397dad77492da92 (1)](1589850317-397dad77492da92 (1).png)

第七步：右手原则，应该先访问顶点F的邻接顶点A，但发现A已被访问，则访问除A之外的最右侧顶点G。

![1589850317-1becc6e66c4855c](1589850317-1becc6e66c4855c-1693496129403-36.png)

第八步：右手原则，先访问顶点B，顶点B已被访问；再访问顶点D，顶点D已经被访问；最后访问顶点H。

![1589850317-9b188e21831899e](1589850317-9b188e21831899e-1693496146605-38.png)

第九步：发现顶点H的邻接顶点均已被访问，则退回到顶点G;

第十步：顶点G的邻接顶点均已被访问，则退回到顶点F；

第十一步：顶点F的邻接顶点已被访问，则退回到顶点E；

第十二步：顶点E的邻接顶点均已被访问，则退回到顶点D；

第十三步：顶点D的邻接顶点I尚未被访问，则访问顶点I；

![1589850318-e17b709eef68580](1589850318-e17b709eef68580-1693496178677-42.png)

第十四步：顶点I的邻接顶点均已被访问，则退回到顶点D;

顶点D的邻接顶点均已被访问，退回到顶点C；顶点C的邻接顶点均已被访问，则退回到顶点B；顶点B的邻接顶点均已被访问，则退回到顶点A，顶点A为**起始顶点**，深度优先搜索结束。

> 上述步骤记录的递归遍历图的过程，可以发现，是从一个节点出发一直延伸到全部。
>
> 如果我们只看第一次遍历到的节点，只需要判断当前节点的下一个为位置是否为空，不为空打印，为空就返回`null`,然后每经过一个节点就记录该节点已经遍历过了。
>
> 而对于每一个节点来说，都可以利用这一个函数。所以说就构造递归函数实现遍历。

下面是实现递归的模版：

```c++
#include <vector>
#include <iostream>

using namespace std;

// Definition for a binary tree node.
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> result;
        level(root, 0, result);
        return result;
    }

    void level(TreeNode* root, int level, vector<vector<int>>& result) {
        if (!root) return;
        if (result.size() == level) result.push_back(vector<int>());
        result[level].push_back(root->val);
        if (root->left) level(root->left, level + 1, result);
        if (root->right) level(root->right, level + 1, result);
    }
};

int main() {
    // 创建一个二叉树
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    Solution solution;
    vector<vector<int>> result = solution.levelOrder(root);

    // 输出层次遍历结果
    for (const vector<int>& level : result) {
        for (int val : level) {
            cout << val << " ";
        }
        cout << endl;
    }

    // 释放节点内存
    delete root->left->left;
    delete root->left->right;
    delete root->left;
    delete root->right;
    delete root;

    return 0;
}

```

#### dfs序列

```c++
//dfs模板（感觉是遍历 这个树hhh）
int g[N][N]; //这个就是 表示树（宽度 和 深度）
void dfs(int u,int fa)//fa表示树的根结点（醍醐灌顶）
{
   int sz = g[u].size(); // 整个树的节点个数
   for(int i = 0;i<sz;i++) // 遍历每一个节点
    {
       if(g[u][i]!=fa) // u（代表当前层的一个数据）的i(表示下一层的数据)没用过
        {
           dfs(g[u][i],u);
        }
    }
}
//加一个辅助数组
void dfs(int u,int fa){
  dfs_[++len] = u; //遍历的就是当前的父节点 记录一下 （每次走过的就当是根 - 父节点的就可以了）
  int sz = g[u].size();
  for(int i = 0;i<sz;i++)
  {
     if(g[u][i]!=fa){
        dfs(g[u][i],u);//根节点替换
      }
  }
}
//实例代码
#include<iostream>
#include<algorithm>
using namespace std;
//一维数组 可以用作二维数组吗
vector<int> g[100010];
int dfs_[200020],len;

void dfs(int u,int fa)
{
    dfs_[++len]=u;  
    int sz=g[u].size();
    for(int i=0;i<sz;i++)
    {
        if(g[u][i]!=fa)
        {
            dfs(g[u][i],u);
        }
    }
}

int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
      //两个点 不同方向都有一条边
        int from,to;
        scanf("%d%d",&from,&to);
        g[from].push_back(to);
        g[to].push_back(from);
    }
    dfs(1,0);
    for(int i=1;i<=len;i++)
    {
        printf("%d ",dfs_[i]);
    }
    printf("\n");
}

```

> **dfs序列作用**
>
> 子树加权
>
> ​	在dfs序列中，一个结点的子树序列是连续的。 - 看下面的树： `abdegcfh `我们关注 b结点 发现b - deg 这一段是连续的，就可以利用差分的操作就行加权。然后我们可以发现B字树B-D-E-G，C子树C-F-H都在一段连续的区间中。那么这有什么好处呢？比如说现在有一道题：给你一颗树，给出m个x和w，意为将x子树中的所有点加上一个权值w，最后询问所有点的权值 - 既然dfs序中x和他的所有子节点都在连续的区间上，那么我们就可以将它简化成差分的问题。比如说给b节点加2，就可以简化为给b的差分数组+2，c的差分数组-2 。（又涉及到了差分数组了）怎么找第一个不在B子树中的点 引入时间戳
>
> 时间戳
>
>    作用：记录dfs第一次开始访问这个点的时间以及最后结束访问的时间。（用数组记录时间）

```c++

void dfs(int u,int fa)
{
   int x = len+1;//数组拓展
    s[++len] = ++time; 
   dfs_[len] = u;//存储dfs序列
   int sz = g[u].size();
   for(int i = 0;i<sz;i++)
    {
       if(g[u][i] == fa){
          dfs(g[u][i],u);
        }
    }
   e[x] = time;//存储对应 根节点到子节点的时间区间
}
//如果一个点的起始时间和终结时间被另一个点包括，这个点肯定是另一个点的子节点。（算导里称之为括号化定理）
```

![img](/1188068-20171027104122883-1380446385.png)

![image-20230301212454581](/image-20230301212454581.png)

```c++
//代码 
#include<vector>
#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

vector<int> g[100010];
int dfs_[200020],len,time,s[200020],e[200020],pos[200020];

void dfs(int u,int fa)
{
    int x=len+1;
    s[++len]=++time;//当前点 时间起点
    dfs_[len]=u;
    pos[u]=len;
    int sz=g[u].size();
    for(int i=0;i<sz;i++)
    {
        if(g[u][i]!=fa)
        {
            dfs(g[u][i],u);
        }
    }
    e[x]=time;//时间终点
}

int main()
{
    int n,m;
    scanf("%d %d",&n,&m);
  //输入我们的树
    for(int i=1;i<=n;i++) 
    {
      //用邻接表表示树
        int from,to;
        scanf("%d%d",&from,&to);
        g[from].push_back(to);
        g[to].push_back(from);
    }
    dfs(1,0);
    for(int i=1;i<=m;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        x=pos[x];
        y=pos[y];
        if(s[x]<=s[y]&&e[y]<=e[x])
        {
            printf("YES\n");
        }
        else
        {
            printf("NO\n");
        }
    }
}
```

#### [层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/)

层序遍历是用队列构造的，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。

`BFS`使用队列，把每个还没有搜索到的点依次放入队列，然后再弹出队列的头部元素当做当前遍历点。`BFS`总共有两个模板：

1.如果不需要确定当前遍历到了哪一层，`BFS`模板如下。

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 定义图的节点数据结构
struct Node {
    int value;  // 节点的值
    vector<Node*> neighbors;  // 相邻节点列表
    bool visited;  // 标记节点是否已经访问过

    Node(int val) : value(val), visited(false) {}
};

// BFS遍历函数
void bfs(Node* start) {
    queue<Node*> q;
    q.push(start);

    while (!q.empty()) {
        Node* cur = q.front();
        q.pop();

        if (!cur->visited) {
            cout << "Visiting node with value: " << cur->value << endl;
            cur->visited = true;

            for (Node* neighbor : cur->neighbors) {
                if (neighbor && !neighbor->visited) {
                    q.push(neighbor);
                }
            }
        }
    }
}

int main() {
    // 创建图节点
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    Node* node4 = new Node(4);

    // 建立节点之间的连接关系
    node1->neighbors = {node2, node3};
    node2->neighbors = {node1, node4};
    node3->neighbors = {node1, node4};
    node4->neighbors = {node2, node3};

    // 从起始节点开始BFS遍历
    bfs(node1);

    // 释放节点内存
    delete node1;
    delete node2;
    delete node3;
    delete node4;

    return 0;
}

```

2.如果要确定当前遍历到了哪一层，`BFS`模板如下。 这里增加了`level`表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。`size`表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 定义图的节点数据结构
struct Node {
    int value;  // 节点的值
    vector<Node*> neighbors;  // 相邻节点列表
    bool visited;  // 标记节点是否已经访问过

    Node(int val) : value(val), visited(false) {}
};

// BFS按层级遍历函数
void bfsByLevel(Node* start) {
    queue<Node*> q;
    q.push(start);
    int level = 0;

    while (!q.empty()) {
        int size = q.size();
        cout << "Level " << level << ": ";
        
        while (size--) {
            Node* cur = q.front();
            q.pop();

            if (!cur->visited) {
                cout << cur->value << " ";
                cur->visited = true;

                for (Node* neighbor : cur->neighbors) {
                    if (neighbor && !neighbor->visited) {
                        q.push(neighbor);
                    }
                }
            }
        }

        cout << endl;
        level++;
    }
}

int main() {
    // 创建图节点
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    Node* node4 = new Node(4);

    // 建立节点之间的连接关系
    node1->neighbors = {node2, node3};
    node2->neighbors = {node1, node4};
    node3->neighbors = {node1, node4};
    node4->neighbors = {node2, node3};

    // 从起始节点开始按层级BFS遍历
    bfsByLevel(node1);

    // 释放节点内存
    delete node1;
    delete node2;
    delete node3;
    delete node4;

    return 0;
}
```

上面两个是通用模板，在任何题目中都可以用，是要记住的！

### [拓扑排序](https://zhuanlan.zhihu.com/p/135094687)

拓扑排序只是针对特定的一类图,也就是有向无环图。

- 这个图的边必须是有方向的；

- 图内无环。

为什么必须要无环呢，如果有环，拓扑排序将会是一个无限的序列，将无限自指。

![img](v2-1e72742f8cc825e716ab74f68a3d38f6_720w.webp)

如果一个图里有环，比如上图，想执行1就要先执行3，想执行3就要先执行2，想执行2就要先执行1，这成了个死循环，无法找到正确的打开方式，所以找不到它的一个拓扑序。

> 其实和缺氧的科技树很像，你必须要完成前置条件才能达到我们最终的条件。或者拿`moba`游戏，你只有把全部防御塔推了才能推掉对面的水晶。

![img](v2-49a86090444ba413a1d11e09715d1283_720w.webp)

这种图叫 `AOV `(Activity On Vertex) 网络，在这种图里：

- 顶点：表示活动；
- 边：表示活动间的先后关系

在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。

**所以一个 AOV 网应该是一个 DAG，即有向无环图，否则某些活动会无法进行。**
**那么所有活动可以排成一个可行线性序列，这个序列就是`拓扑序列`。**

那么这个序列的`实际意义`是：
**按照这个顺序，在每个项目开始时，能够保证它的前驱活动都已完成，从而使整个工程顺利进行。**

> 注意，有时候拓扑序并不是唯一的，比如在这个例子中，先学 `C1 再学 C2`，和先 `C2 后 C1` 都行，都是这个图的正确的拓扑序，但这是两个顺序了。

在上面的图里，大家很容易就看出来了它的拓扑序，但当工程越来越庞大时，依赖关系也会变得错综复杂，那就需要用一种系统性的方式方法来求解了。

> 那么我们回想一下刚刚自己找拓扑序的过程，为什么我们先看上了 `C1, C2?`

因为它们没有依赖别人啊，
也就是它的`入度为 0`.

> **入度**：顶点的入度是指「**指向该顶点的边**」的数量；
> **出度**：顶点的出度是指该顶点指向其他点的边的数量。

所以我们先执行入度为 0 的那些点，
那也就是要记录每个顶点的入度。
因为**只有当它的 `入度 = 0` 的时候，我们才能执行它。**

在刚才的例子里，最开始 `C1, C2 `的入度就是 0，所以我们可以先执行这两个。

那在这个算法里第一步就是得到每个顶点的入度。

#### 预处理

拿到了这个之后，就可以执行入度为` 0 `的这些点了，也就是 `C1, C2.`

那我们把可以被执行的这些点，放入一个`待执行的容器`里，这样之后我们一个个的从这个容器里取顶点就好了。

至于这个`容器`究竟选哪种`数据结构`，这取决于我们需要做哪些`操作`，再看哪种数据结构可以为之服务。

那么首先可以把`[C1, C2]`放入`容器`中，

然后想想我们需要哪些操作吧！

我们最常做的操作无非就是`把点放进来`，`把点拿出去`执行了，也就是需要一个 `offer` 和 `poll` 操作比较高效的数据结构，那么 `queue` 就够用了。

（其他的也行，放进来这个容器里的顶点的地位都是一样的，都是可以执行的，和进来的顺序无关，但何必非得给自己找麻烦呢？一个常规顺序的简简单单的 `queue` 就够用了。）

> 解析实现顺序可以去标题的博客看，下面是具体实现拓扑排序的代码

![image-20230302193314874](/image-20230302193314874.png)

![image-20230302195721755](/image-20230302195721755.png)

![image-20230302195739338](/image-20230302195739338.png)

![image-20230302195757415](/image-20230302195757415.png)

```c++
/*简单来说就是 按照 前面点最少的顺序排序（也就是入度从小到大）
1.Kahn算法
   起点是从入度为0的点开始的（这样才能入度从小到大），使用队列来维护我们的点；1.初始化：将所有入度为0的点压入我们的队列（顺序不重要）；2.每次从q中取出一个点x放入数组tp（存储最终序列）；3.将x的所有出边删除：这个时候的x是队头，边被删除那么对应的连接点的入度就变成0，就可以压入队列；4.重复23步骤。5.如果tp中的数据和我们的点的数量一样，那么就有拓扑序列，如果不一样，那就没有。（有向 无环图才有拓扑序列）
*/
vector<int> e[N],tp;//tp是我们最终输出的拓扑序列
int din[N]//存储着点的入度（画图是不是要用领接表）

bool toposort()
{
    queue<int> q; //让入度0的进入队伍
 for(int i = 1;i<=n;i++)
        if(din[i] == 0) q.push(i); // din数组记录的是入度
    while(q.size()){
        int x = q.front();
        q.pop(); //让队头出栈 并且删除对应的边
        tp.push_back(x);
        for(auto y:e[N]){
            if(--din[y]==0) q.push(y);//删除对应的边 并且让对应的数据入队
        }
    }    
    return tp.size() = n;
}

int main()
{
 cin>>n>>m;
    for(int i = 0;i<m;i++){
        cin>>a>>b;
        e[a].push_back(b);
        din[b]++;
    }
    if(!toposort()) puts("-1") ; //如果数量不满足 则说明这个不是拓扑序列
    else for(auto x:tp) printf("%d",x); //将拓扑序列输出
    return 0;
}

```

```c++
//dfs求拓扑序列(变色法)
//不懂翻转序列 - 翻转序列是因为尾插法吧
/*1.染色法（yxc用的）
    每个点的颜色都会变化，从0 - -1 - 1，经历三次变色；1.初始状态，所有点染色为0；2.枚举每一个点，进入x点（是我们的指针），把x染色为-1，枚举x的儿子y，如果y的颜色为0，那么说明没碰过该点，进入y继续走（这里应该是检测有无环 - 会不会回到x）；3.如果枚举完x（当前数据 - 也算是队头）的儿子，将x压入tp数组；4.如果发现，有-1的出现（那么就是有环出现了），返回false，退出。*/

vector<int> e[N],tp;//e[N] 应该是树，，或者是领接表画的图
int c[N]; //染色数组

bool dfs(int x)
{
    c[x] = -1;
    for(int y:e[x]){
        if(c[y]<0) return 0; //有环
        else if(!c[y])
            if(!dfs(y)) return 0;
    }
    c[x] = 1;
    tp.push_back(x); //当前这个数据遍历完成 压入我们的tp数组
    return 1;
}

bool toposort(){
    memset(c,0,sizeof(c)); // 初始化 - 刚开始全部点的颜色为0
    for(int x = 1;x<=n;x++)
        if(!c[x])
            if(!dfs(x)) return 0;
 reverse(tp.begin(),tp.end());//翻转序列 为啥？
    return 1;
}
```

### Dijkstra - 最短路算法

![image-20230302202401928](/image-20230302202401928.png)

![image-20230302204100958](/image-20230302204100958.png)

```c++
//简单来说：就是每次选择最短路线进行前进（画最小生成树）
三个数组： 1.e[u] 存储节点u的所有出边的终点和边权 2.d[u] 存储u到源点的最小距离（源点就是当前连边的点）（d[u]需要遍历）3.vis[u] 标记是否出圈
    1.初始的时候，所有点都在圈中，vis = 0,d[s] = 0,d[其他点] = 正无穷
    2.从圈中选择一个距离最小的点，u，打标记出圈（贪心）
    3.对u的所有出边执行松弛操作 - 尝试更新邻点v的最小距离
    4.重复2,3操作，直到圈内为空
//代码
struct edge{int v,w;};//点 和 权
vector<edge> e[N];//边
int d[N],vis[N];//d数组是存储当前点的最小距离 - vis标记当前集合中的点（有没有调用这个点）

void dijkstra(int s)
{
    for(int i = 0;i<=n;i++) d[i] = inf;//初始化 全部点的距离都为无穷大
    d[s] = 0;
    //枚举每个点 内部枚举全部的点比较他们的距离大小（选最小的边权） - 就是每个点都要比较它自身和其它点的距离关系  （图遍历就是两层 for的）
    for(int i = 1;i<n;i++){
        int u = 0;
        for(int j = 1;j<=n;j++)//枚举全部点（包括自身）
            if(!vis[j]&&d[j]<d[u]) u = j; //如果这个点没被测过 并且 当前边权小
        
        vis[u] = 1;//标记u点（下次就选不到了）
        //遍历全部的点 v点的距离更新为最短的点 ed是迭代器：用处是迭代全部的点
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>d[u]+w){//无穷大 > 其他（这样来筛数据）
                d[v] = d[u]+w;
            }
        }
    }
}

int main()
{
    cin>>n>>m>>s;
    for(int i = 0;i<m;i++){
        cin>>a>>b>>c;
        //领接表插入图
        e[a].push_back({b,c});//点 连接点 边权
    }    
    dijkstra(s);
}
```

![image-20230302204110774](/image-20230302204110774.png)

![image-20230302205328621](/image-20230302205328621.png)

```c++
//堆优化 - 用优先队列维护别更新点的集合。
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N];
//优先队列
priority_queue<pair<int,int>> q;//大根堆（把距离取负值） - 距离最小的元素最大 - 一定在堆顶（懂了 距离从小到大优化）

void dijkstra(int s)
{
    //1.全部点的距离都是无穷大
    for(int i = 0;i<=n;i++) d[i] = inf;
    d[s] = 0; q.push({0,s});//自己和自己距离为0
    //2.枚举进入队列中的数据
    while(q.size()){
        auto t = q.top(); q.pop();
        //u是点吗
        int u = t.second;
        if(vis[u]) continue;//判重
        vis[u] = true; //之前忘记标记出队了
        //当前点 遍历全部点 出来的边权最小的数据
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>d[u]+w){
                d[v] = d[u]+w;
                q.push({-d[v],v}); //大根堆
            }
        }
    }
}
```

![image-20230302205410861](/image-20230302205410861.png)

```c++
//就是两个模板 优化的地方就是枚举的时候用队列维护
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N]; //边 和 点
//s是起点
void dijkstra(int s)
{
    for(int i = 0;i<=n;i++) d[i] = 0x3f3f3f; //无穷大的值
    d[s] = 0; //对于自己和自己的距离当然是0了
    
    for(int i = 0;i<=n;i++){//枚举次数
        int u = 0;
        //优化 就是把这里优化了 取消了枚举全部点
        for(int j = 1;j<=n;j++) //枚举点
            if(!vis[j]&&d[j]<d[u]) u = j;
        vis[u] = 1;
        for(auto ed:e[u]){ //ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）
            int v = ed.v,w = ed.w;
            if(d[v]>d[u]+w) {
                d[v] = d[u]+w;
                q.push_back({-d[v],v});//插入到 大根堆上
            }
        }            
    }    
}
```

![image-20230302205417632](/image-20230302205417632.png)

### Bellman-Ford  - 处理负权边的最短路算法

```c++
//llman-Ford 算法是一种用于求解带权图中单源最短路径的算法，可以处理负权边，但不能处理负权环。
 它的时间复杂度为 $O(VE)$，其中 $V$ 是顶点数，$E$ 是边数。Bellman-Ford 算法的基本思想是对所有的边进行 $V-1$ 轮松弛操作，以求出所有可能的最短路径。如果在第 $V$ 轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。
    
//Bellman-Ford算法是一种用于计算带权有向图中单源最短路径的算法。
    它由Richard Bellman和Lester Ford分别在1958年和1956年发表，而实际上Edward F. Moore也在1957年发布了相同的算法，因此，此算法也常被称为Bellman-Ford-Moore算法1。它比Dijkstra的算法慢，但更通用，因为它能够处理边权值为负数的图2。

//单源最短路
    单源最短路问题是图论中的一个基本问题，它指的是给定一张有权图，如何求某两点之间的最短路径1。解决这个问题的算法有很多，比如Dijkstra算法和Bellman-Ford算法等。
```

![image-20230304212846831](/image-20230304212846831.png)

![image-20230304210834724](/image-20230304210834724.png)

![image-20230304212028882](/image-20230304212028882.png)

```c++
//目的是算出图中的最短路（单源最短路：是指在一个图中，给你一个起点（起点固定），然后终点不是固定的，求起点到任意终点的最短路径）

struct edge{int v,w;}; //这里是 点 和 权
vector<edge> e[N];
int d[N];

//内部变量是起点
bool bellmanford(int s)
{
    //初始化边集
    memset(d,inf,sizeof d);
    d[s] = 0;
    //标记
    bool flag;
    for(int i = 1;i<=n;i++){//n轮更新
        flag = false; //标记（看有无更新）
        for(int u = 1;u<=n;u++){ //每个点枚举出边
            if(d[u] == inf) continue;
            //枚举u的领点 就行松弛操作
            for(auto ed:e[u]){ //u的出边
                int v = ed.v,w = ed.w;
                if(d[v]>d[u]+w){
                    d[v] = d[u] + w;
                    flag = true; //更新完成 就变true
                }
            }
        }
        if(!flag) break; //没有更新就退出
    }
    return flag; //第n轮 = true 那么说明就有环    
}
```

### spfa 算法 - 用bf就好了

```c++
SPFA 算法是Bellman-Ford算法的队列优化算法的别称，通常用于求含负权边的单源最短路径，以及判负权环。SPFA 最坏情况下复杂度和朴素Bellman-Ford相同，为o(VE).
//其实还不如直接用Bellman-ford
```

![image-20230304212218685](/image-20230304212218685.png)

![image-20230304212529352](/image-20230304212529352.png)

![image-20230304212738052](/image-20230304212738052.png)

```c++
//堆优化 bellman 算法 - spfa算法
struct edge{int v,w;};
vector<edge> e[N];//点集合
int d[N],cnt[N],vis[N]; //边 边数 开关
queue<int> q; //队列

bool spfa(int s){
    memset(d,inf,sizeof d);
    //开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集
    d[s] = 0; vis[s] = 1; q.push(s); 
    while(q.size()){
        //这里是将前面初始化的点操作的地方，每次都只操作一个点
        int u = q.front(); q.pop(); vis[u] = 0;
     for(auto ed:e[u]){
            int v = ed.v , w = ed.w;
            //比较枚举点和当前点 的长度 更新最短值
            if(d[v]>d[u]+w){
                d[v] = d[u]+w;
                cnt[v] = cnt[u]+1; //记录边数
                if(cnt[v]>=n) return true;
                if(!vis[v]) q.push(v),vis[v] = 1;
            }
        }
    }
    return false;
}
```

### Floyd算法 - 点到点的最短路

![image-20230307160057133](/image-20230307160057133.png)

![image-20230307160205801](/image-20230307160205801.png)

![image-20230307160839691](/image-20230307160839691.png)

```c++
// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）
// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）

//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）
void floyd(){
    for(int k;k<=n;k++) //以k为桥(k枚举的是所有点)
        for(int i=1 ;i<=n;i++)
            for(int j = 1;j<=n;j++)
                d[i][j] = mid(d[i][j],d[i][k]+d[k][j]); //二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）
}
```

![image-20230307161152125](/image-20230307161152125.png)

```c++
//路径记录原理不了解
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 210;
int n,m,k;
int d[N][N];
void floyd(){
    for(int k = 1;k <= n;k++)
        for(int i = 1;i <= n;i++)
            for(int j = 1;j <= n;j++)
                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);
}
int main(){
    cin >> n >> m >> k;
    fill(d[0],d[0]+N*N,0x3f3f3f3f);
    for(int i = 1;i <= n;i++) d[i][i] = 0;
    while(m--){
        int a,b,c; cin >> a >> b >> c;
        d[a][b] = min(d[a][b],c);
    }
    floyd();
    while(k--){
        int a,b; cin >> a >> b;
        if(d[a][b] > 0x3f3f3f3f/2) cout << "impossible" << endl;
        else cout << d[a][b] << endl;
    }
}
```

![image-20230307161434260](/image-20230307161434260.png)

### 最小生成树 - prim算法

![image-20230308192754299](/image-20230308192754299.png)

```c++
//没有优化版本 - 基于贪心算法
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N];//d是边的长度 

bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf;
    d[s] = 0;
    for(int i = 1;i<=n;i++){
        int u = 0;
        for(int j = 1;j<=n;j++)
            if(!vis[j]&&d[j]<d[u]) u = j; //排除选过的点 - 这里是选领点的（懂了）
        vis[u] = 1;
        ans+=d[u];//边权和（最小生成树的边权和）
        if(d[u]!=inf) cnt++; //判断是否联通
        //遍历到u这个点（u之前的也是一起的，算是连续的）
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w;   
            }
        }
    }
    return cnt == n; //返回true就是有最小生成树的 返回false
}


```

![image-20230308110618789](/image-20230308110618789.png)

```c++
//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。
int n,m,s,a,b,c,ans,cnt;
struct edge{int v,w;}; //构造一个结构体 内部有点和边的属性
vector<edge> e[N];//领点（也算是所有点？）
int d[N],vis[N];
priority_queue<pair<int,int>> q; //这里创一个优先队列（就是堆）
//s是起点
bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf; //先初始化全部的边 - 每个边都是无穷大
    //起点
    d[s] = 0;q.push({0,s});
    while(q.size()){
        //取出q队列的点？ - 后面有进入点？
        int u = q.top().second; q.pop();
        if(vis[u]) continue; 
        vis[u] = 1;
        ans+=d[u]; cnt++;
        //这里应该就是插入 领点的步骤
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w; //对应点v边权最小的边
                q.push({-d[v],v});//大根堆
            }
        }
    }
    return cnt == n; //这里判断的是啥？
}


```

![image-20230308110724388](/image-20230308110724388.png)

### 最小生成树 - 克鲁斯卡尔算法 - 并查集

![image-20230308125205044](/image-20230308125205044.png)

![image-20230308125225033](/image-20230308125225033.png)

```c++
克鲁斯卡尔算法（Kruskal）是一种使用贪婪方法的最小生成树算法。该算法初始将图视为森林，图中的每一个顶点视为一棵单独的树。一棵树只与它的邻接顶点中权值最小且不违反最小生成树属性（不构成环）的树之间建立连边。
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=200010;
int n,m;
//结构体存储边的信息
struct edge{
    int a,b,w;
}e[M];
//比较函数 （用来作为排序算法的参数）
bool cmp(edge x,edge y){
    return x.w<y.w;
}
//并查集
int p[N];
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].w);
    //排序边权（我们是用贪心来筛选的）
    sort(e+1,e+m+1,cmp);
    //初始化并查集
    for(int i=1;i<=n;i++) p[i]=i;
    int res=0,cnt=0;
    for(int i=1;i<=m;i++){
        //每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）
        int a=find(e[i].a),b=find(e[i].b),w=e[i].w;
        //查一下是否是连通块
        if(a!=b){
            //纳入后宫
            p[a]=b;
            res+=w;
            cnt++;
        }
        if(cnt==n-1) break;  //成树
    }
    printf("%d\n",res);//输出边权
}
```

### 总结

![image-20230308100226384](/image-20230308100226384.png)

## 补充

### 染色法判断二分图*

![image-20230314143817025](/image-20230314143817025.png)

```c++
//染色法判断二分图
首先随机选择一个未染色的顶点，将其染成红色或蓝色（或其他任意两种不同颜色）。
然后将与该顶点相邻的所有顶点染成与其不同的颜色。
重复上述过程，直到所有顶点都被染色或者发现某个顶点和它相邻的顶点已经被染成了相同的颜色。
如果所有顶点都被染色，那么这个图就是二分图；如果发现有冲突，那么这个图就不是二分图。

//二分图
二分图是图论中的一种特殊模型，它的定义是1234：如果一个无向图的顶点集可以分成两个互不相交的子集，使得每条边的两个端点分别属于这两个子集，那么这个无向图就是二分图。例如，下图就是一个二分图：
    A   B   C
    | / | / |
    D   E   F
就是映射是吧，两个不同的集合中有连边，相同集合的不连边
```

```c++
//判断此图是否是二分图
#include<bits/stdc++.h>
using namespace std;

const int N = 1e6+10,M = 2e6+10;

int h[N],e[N],ne[M],idx; //e是点集 ne是边集
int color[N]; //存储每一个点的状态 一共有三种 起始0 染色 1 - 2

void add(int a,int b){
    e[idx] = b, ne[idx] = h[a],h[a] = idx++; //把h[a]理解为前面的桶形数组就好了
}
//每次访问一个顶点u，就会先递归地访问它的所有邻接点，直到没有未访问的邻接点为止，
//然后再回溯到上一层。这样可以保证每个连通分量内的顶点都被染色。
bool dfs(int u,int c)
{
    color[u] = c; //c是什么意思 - 是当前点的染色状态 （只有三种 0 1 2 用3减去就前后不一样了）
    
    for(int i = h[u]; ~i;i = ne[i]){
        int j = e[i]; //邻点
        if(!color[j]){
            if(!dfs(j,3-c)) return false;
        //这个是递归地调用dfs函数，给顶点j和它的邻接点染色，并判断是否有冲突。
        //如果返回false，就说明发现了不符合二分图的情况，就返回false。
        //冲突是指同一个子集内的顶点颜色相同，或者不同子集内的顶点颜色不同。
        //这些情况都不满足二分图的定义，所以要返回false。
            }
        else if(color[j] == c) return false;
        //如果顶点j已经被染色，并且与u的颜色相同，就说明同一个子集内有边相连，不符合二分图的定义，就返回false。
    }
    return true;
}

int main()
{
    int n,m;
    cin>>n>>m;
    memset(h, -1, sizeof h);
    
    while(m--){
        int a,b;
        cin>>a>>b;
        add(a,b); add(b,a); //无向图
    }
    bool flag = true;
    for(int i = 1;i<=n;i++)
        if(!color[i])
        {
           if(!dfs(i,1))
           {
               flag = false;
               break;
           }
        }
    if(flag) puts("Yes");
    else puts("No");
    
    return 0;
    
    
}
```

![image-20230314144148781](/image-20230314144148781.png)

![image-20230314144232392](/image-20230314144232392.png)

```c++
#include <iostream>
#include <vector>
using namespace std;

const int N = 510; // 顶点数的最大值
int n1, n2; // 二分图左右两边的顶点数
vector<int> g[N]; // 邻接表存储图
int match[N]; // match[i]表示右边第i个点当前匹配的左边的点
bool st[N]; // st[i]表示右边第i个点是否已经被遍历过

// 在二分图中寻找增广路
bool find(int x) {
    for (int i = 0; i < g[x].size(); i++) {
        int j = g[x][i];
        if (!st[j]) {
            st[j] = true;
            if (match[j] == 0 || find(match[j])) {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}

// 求二分图最大匹配数
int main() {
    cin >> n1 >> n2;
    int m; // 边数
    cin >> m;
    while (m--) {
        int a, b;
        cin >> a >> b;
        g[a].push_back(b);
    }

    int res = 0; // 最大匹配数
    for (int i = 1; i <= n1; i++) {
        memset(st, false, sizeof st);
        if (find(i)) res++;
    }

    cout << res << endl;

    return 0;
}
```

### 二分图的最大匹配

#### 匈牙利算法*

![image-20230314205307317](/image-20230314205307317.png)

```c++
1.匈牙利算法 - 二分图的最大匹配
 二分图，简单来说就是不同集合有联系；同一集合不可以有联系； - 边数最多的一组匹配被称之为最大匹配
 在二分图的前提下： 1.交替路 2.增广路  - 交替路就是匹配和不匹配边交替出现 - 增光路就是匹配和不匹配交换身份，看有没有多路径，多了就是增广路

const int N = 1e5+10,M = 2e5+10;
int n,m,k,a,b,ans,idx;
struct edge{int v,ne;}e[M]; //点（对应位置的妹子） ne 另一集合的点是吗
int h[N],idx;
int vis[N],match[M]; //标记 和 匹配

//链式前向星
void add(int a, int b){
    e[++idx] = {b,h[a]};
    h[a] = idx++; //横置数组向右移动
}
//男女匹配问题 (boy and girl）
bool bfs(int u){
    //每一个都要匹配看看
    for(int i = h[u]; i;i = e[i].ne){
        int v = e[i].v; //妹子
        if(vis[v]) continue;
        vis[v] = 1; //标记
        if(!match[v]||dfs(match[v])){ //没有匹配 || 能不能换（dfs的功能就是判断能不能换）
            match[v] = u;//成对
            return 1;
        }
    }
    return 0;
}

int main()
{
    cin>>n>>m>>k;
    for(int i = 0;i<k;i++) cin>>a>>b,add(a,b); //建图
    for(int i = 1;i<=n;i++){
        memset(vis,0,sizeof vis);
        if(dfs(i)) ans++;
    }
    cout<<ans;
    return 0; 
    
}

```

#### 染色法判断二分图

![image-20230315104701595](/image-20230315104701595.png)

![image-20230315123714291](/image-20230315123714291.png)

```c++
//1.二分图的定义
 两个不同的集合，互相联通 - 相同集合不可能联通
//2.染色法
    可以用dfs和bfs来实现染色法，重点是怎么实现前后颜色不同。 我们运用两个标记来判断对应节点的状态： 1 表示这个节点是红 2表示是黑 0表示没选这个（加上个判重）
   
struct edge{int v,ne;}e[M];
int h[N];
int color[N]; //颜色有三种 0 1 2

void add(int a,int b){
    e[++idx] = {b,h[a]}; //用链式前向星存储的
    h[a] = idx++;
}
//u点的颜色c 
bool bfs(int u,int c)
{
    color[u] = c;
    //枚举u的领边
    for(int i = h[u];i;e[i].ne)
    {
        int v = e[i].v;
        if(!color[v]){ //还没有被访问
            if(dfs(v,3-c)) return 1; //改变不同层的颜色
        }
        else if(color[v] == c) return 1;
    }   
    
}

int main()
{
    cin>>n>>m;
    for(int i = 0;i<m;i++){
        int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    bool flag = 0;
    for(int i = 1;i<=n;i++)
        if(!color[i])
            if(!dfs(i,1)){
                flag = 1;//有奇环
                break;
            }
    if(flag) puts("No");
    else puts("Yes");
    return 0;    
}
```

![image-20230314142804998](/image-20230314142804998.png)

![image-20230314143439093](/image-20230314143439093.png)

![image-20230314143503237](/image-20230314143503237.png)

### [最近公共祖先](https://www.bilibili.com/video/BV1A94y12737/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811)

#### 朴素方法

![image-20230319121246852](/image-20230319121246852.png)

```c++
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 100005;
int n, m;
vector<int> tree[MAXN]; // 邻接表存储树
int depth[MAXN], parent[MAXN]; // 深度和父亲节点

// 深度优先搜索遍历计算深度和父亲节点
void dfs(int u, int p) {
    depth[u] = depth[p] + 1;
    parent[u] = p;
    for (int v : tree[u]) {
        if (v != p) dfs(v, u);
    }
}

// 计算两个节点的最近公共祖先
int lca(int u, int v) {
    while (depth[u] > depth[v]) u = parent[u];
    while (depth[v] > depth[u]) v = parent[v];
    while (u != v) {
        u = parent[u];
        v = parent[v];
    }
    return u;
}

int main() {
    cin >> n >> m; // 读入节点数和查询数量
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v; // 读入边
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    dfs(1, 0); // 计算深度和父亲节点
    
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v; // 读入查询
        cout << lca(u, v) << endl; // 输出结果
    }
    
    return 0;
}
这个模板中，n 是树的节点数，m 是查询数量。对于每组查询，它读入两个节点编号 u 和 v，然后调用函数 lca(u,v) 来获取它们的最近公共祖先。
```

#### Tarjan算法

![image-20230314144355261](/image-20230314144355261.png)

```c++
//Tarjan算法是由Robert Tarjan发明的一种图算法。它可以用于解决许多不同类型的问题，包括寻找强连通分量、双连通分量、割点和割边等。其中一种应用是在树中查找节点对的最近公共祖先（LCA）。Tarjan算法通过深度优先搜索和并查集数据结构来高效地解决这个问题。

//tarjan算法 ： 利用并查集
vector<int> e[N];
vector<pair<int,int>> query[N];
int fa[N],vis[N],ans[M];
//并查集
int find(int u)
{
    if(u == fa[u]) return u;
    return fa[u] = find(fa[u]);    
}
void tarjan(int u){
    fa[u] = u; // 初始化父亲为自己
    vis[u] = true; // 标记
    for(auto v:e[u])
    {
        if(!vis[v]){
            tarjan[v];
            fa[v] = u;
        }
    }
    for(auto q:query[u]){
        int v = q.first,i = q.second;
        if(vis[v]) ans[i] = find(v);
    }
}
```

#### 树链剖分(不理解)

![image-20230315210121556](/image-20230315210121556.png)

![image-20230315210610462](/image-20230315210610462.png)

```c++
vector<int> e[N];
int fa[N],dep[N],son[N],sz[N];
int top[N];

void dfs1(int u,int father){
    fa[u] = father, dep[u] = dep[father]+1,sz[u] = 1;
    for(int v:e[u]){
        if(v==father) continue;
        dfs1(v,u);
        sz[u] += sz[v];
        if(sz[son[u]]<sz[v]) son[u] = v;
    }
}

void dfs2(int u,int t)
{
    top[u] = t;
    if(!son[u]) return;
    dfs2(son[u],t);
    for(int v:e[u]){
        if(v == fa[u] || v == son[u]) continue;
        dfs2(v,v);
    }
}

int lca(int u,int v){
    while(top[u]!=top[v]){
        if(dep[top[u]]<dep[top[v]]) swap(u,v);
        u = fa[top[u]];
    }
    return dep[u]<dep[v]?u:v;
}
```

#### 倍增算法（不理解）

![image-20230315210919875](/image-20230315210919875.png)

![image-20230315210938761](/image-20230315210938761.png)

![image-20230315210958755](/image-20230315210958755.png)

```c++

```

#### 总

![image-20230315210622550](/image-20230315210622550.png)

## 补充2

### 线段树*

![image-20230401100823894](/image-20230401100823894.png)

![image-20230401100840271](/image-20230401100840271.png)

![image-20230401100850209](/image-20230401100850209.png)

![image-20230401100859800](/image-20230401100859800.png)

![image-20230401100913730](/image-20230401100913730.png)

### 树状数组*

