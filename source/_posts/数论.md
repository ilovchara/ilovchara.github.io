---
title: 数论 - 简单讲解数论
date: 2023-04-28 09:09:10
categories: 算法
typora-root-url: 数论
tags: 数据结构
---

#  [数论](https://oi-wiki.org/)

## [欧几里得算法](https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)

### 求最大公约数

欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g，意思是能够同时整除a和b的自然数中最大的一个。两个数的最大公约数通常写成`gcd(a,b)`，或者简写成`(a,b)`，但是第二种写法也被使用在其他数学概念，如二维向量的坐标。

>  特别的如果`gcd(a,b) = 1`则a和b互质，也就是说没有数能同时除以`a或者b`。

令`g = gcd(a,b)`.由于a和b都是g的整数倍，所以可以写成`a = mg,b = ng`,并且不存在更大的整数`G>g`使等式成立。为了使得g足够大，就要使得a和b中所有的公约数都提取出来归入g中，所以说自然数m，n一定互质（可以理解为互质导致两个数据距离足够大，一个极端小，一个极端大），并且a和b的最大公约数可以被a和b的所有其他公因数`c`整除(就是说，a和b的因素包含在`g`是吗)

前面讲述的是辗转相除法的特质，下面来讲辗转相除法的算法代码，顾名思义辗转相除法就是将两个数据不停相除，直到一方为0.

```c++
//两个数据得是整数
int open_M(int a,int b)
{
    int result = 1;
    if(a>b) result = gcd(a,b);
    else result = gcd(b,a);
}

//gcd - 递归计算
int gcd(int a,int b){
    //简单的记忆 - 只要传入的第二个参数为0 - 那么最大公约数就是第一个参数
    if(a%b == 0) return b;
    else gcd(b,a%b); 
}

```

用上面的例子可能不好理解，下面用一个图形化实例来解释辗转相除法

![image-20230907103114003](image-20230907103114003.png)

> 假设我们有一个长方形，其长度为a，宽度为b，我们的目标是找到一个能够完全覆盖这个长方形的最大长方形，而且没有部分超出原始长方形的边界。(试着理解，a和b是两个数据)
>
> 1. 首先，我们尝试将较大的长方形（a）分割成较小的长方形（b）和一些余下的部分（q），使得a = b + q，其中q的长度小于b。我们将q看作是原始长方形中未被覆盖的部分。
> 2. 然后，我们继续以同样的方式，尝试找到能够完全覆盖q的最大长方形，其长度为b'，同时q = b' + q'，其中q'的长度小于b'。
> 3. 我们不断重复这个过程，直到找到一个长方形（b''），它能够完全覆盖q''，其中q'' = b'' + 0。这时，q''是一个没有余下部分的长方形。
> 4. 这个最终的长方形（b''）的长度就是原始长方形（a）和我们一路上找到的所有长方形（b、b'、...）的最大公约数。
>
> 辗转相除法的核心思想是通过不断地将较大的长方形分割成较小的长方形，直到找到一个没有余下部分的长方形，来寻找两个数的最大公约数。这个过程反映了欧几里德算法的工作方式，其中我们一次又一次地计算余数，直到余数为0，此时除数就是最大公约数。

对于两个整数a和b，假设a > b。我们可以使用欧几里德算法来计算它们的最大公约数`(gcd)`。这个算法的基本思想是，用b去除a并计算余数，然后将b替换为a，将余数替换为b，然后继续这个过程，直到余数变为0。此时，b的值就是a和b的最大公约数。

现在，我们来看一下这个性质：假设a除以b的商和余数分别是p和q，即`a = b * p + q`。那么我们可以得出以下结论：

1. `gcd(b, q) `可以整除b和q，因为它是b和q的最大公约数。
2. 根据欧几里德算法的步骤，q不断替换b，直到q变为0。此时，b的值就是a和b的最大公约数。

因此，我们可以总结为：`gcd(b, q) `可以整除b和a，因为最终它就是a和b的最大公约数。

> 为什么第一个参数要大于第二个参数呢，因为最后出现的0不能作为除数。
>
> 如果还是不能理解，就记住公式就行吧。

### [扩展欧几里得](https://zhuanlan.zhihu.com/p/100567253)*

#### 求解线性同余方程

形如

`ax≡b (mod n)`

这个就是线性同余方程，其中`a,b,n`都为常量，x是未知数，这个方程可以化为(取模n - 变为方程)

`ax = kn+b`

这里的k为任意常数，于是一般式为：

`ax+by+c = 0`

这个方程就是二维的直线方程，这个方程的解集是一些排列成直线的点。

拓展欧几里得可以用于求解线性同余方程`ax≡b (mod n)`,实际上拓展欧几里得是在求解最大公约数的时候对其加上一些限制，达到解决问题的目的。

下面是求解方程`ax≡b (mod n)`的具体步骤：

首先，确保a和n互质，即`gcd(a, n) = 1`。如果`gcd(a, n)`不等于1，那么线性同余方程没有整数解。

> 特别的：当a和n不互质时，线性同余方程ax ≡ b (mod n)可能没有整数解或者只在特殊情况下有解。让我们来看两个例子：
>
> **例子 a和n互质**
>
> 假设我们有线性同余方程：
>
> `3x ≡ 2 (mod 7)`
>
> 在这个情况下，a = 3，n = 7。a和n是互质的，因为它们的最大公约数`gcd(3, 7) = 1`。因此，这个方程有整数解。解可以通过拓展欧几里得算法等方法找到。一个解是x = 5，因为`3 * 5 ≡ 15 ≡ 2 (mod 7)`。
>
> **例子 和n不互质**
>
> 现在，考虑线性同余方程：
>
> `4x ≡ 2 (mod 6)`
>
> 在这个情况下，a = 4，n = 6。a和n不互质，因为它们的最大公约数`gcd(4, 6) = 2`。因此，这个方程可能没有整数解，因为`4x与2 (mod 6)`有一个共同的因子2。
>
> 如果我们尝试将`4x ≡ 2 (mod 6)`除以2，我们得到`2x ≡ 1 (mod 3)`，这个方程有整数解x = 2。但是这不是原始方程`4x ≡ 2 (mod 6)`的解，因为我们只是在原方程的基础上除以了一个公因子2。
>
> 这个例子说明，当a和n不互质时，线性同余方程可能没有整数解，或者解可能存在于一个较小的模数下。

使用拓展欧几里得算法来计算a和n的最大公约数`gcd(a, n)`，以及同时找到x和y，使得`ax + ny = gcd(a, n)`。这一步的目标是找到x的值。

如果`gcd(a, n)`等于1（表示a和n互质），则方程ax ≡ b (mod n)有唯一整数解。这个解可以通过将x乘以b并对n取模来获得，即x ≡ bx (mod n)。

```c++
#include <iostream>

int extended_gcd(int a, int b, int &x, int &y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    
    int x1, y1;
    int gcd = extended_gcd(b % a, a, x1, y1);
    
    x = y1 - (b / a) * x1;
    y = x1;
    
    return gcd;
}

int solve_linear_congruence(int a, int b, int n, int &x) {
    int x0, y0;
    int gcd = extended_gcd(a, n, x0, y0);
    
    if (b % gcd != 0) {
        return -1; //不存在整数解
    }
    
    x = (x0 * (b / gcd)) % n;
    if (x < 0) {
        x += n; // 确保x为正数
    }
    
    return gcd;
}

int main() {
    int a = 3;
    int b = 2;
    int n = 11;
    int x;
    
    int gcd = solve_linear_congruence(a, b, n, x);
    
    if (gcd == -1) {
        std::cout << "没有整数解" << std::endl;
    } else {
        std::cout << "方程整数解是： " << a << "x ≡ " << b << " (mod " << n << ") 是 x ≡ " << x << " (mod " << n << ")" << std::endl;
    }
    
    return 0;
}

```

#### [实现贝祖定理](https://oi-wiki.org/math/number-theory/bezouts/)*

定义：

> 给定两个整数a和b ，一定存在整数x和y ，使得`ax+by=gcd(a,b)`
>
> 换句话说，若`ax + by = m `有整数解当且仅当m是`gcd(a,b)`的倍数。

证明：

![image-20230907141937287](image-20230907141937287.png)

具体看`oi`网吧，我也没搞懂证明过程。

我们现在只需要证明：`对于任意整数a和b，存在整数x和y，使得ax + by = gcd(a, b)。`下面是一个简单的解决问题的步骤

首先，使用欧几里得算法计算a和b的最大公约数`（GCD）`。这可以通过反复取余数的方式来实现，直到余数为0为止。`GCD`就是最后一个非零余数。

在计算`GCD`的过程中，我们会得到一系列的等式，这些等式可以用来表示`GCD`为前两个数的线性组合。具体来说，如果我们得到了以下等式：

```c++
//原本的辗转相除法
GCD(a, b) = GCD(b, a % b)
```

那么根据贝祖定理，可以表示为：

```c++
//贝祖定理
GCD(a, b) = x * a + y * (a % b)
```

其中，x和y是与b和a % b相关的系数。

接下来，我们将递归地使用相同的过程，但是将b和a % b作为新的a和b，直到余数为0为止。此时，`GCD`就是最后一个非零余数，同时我们也得到了x和y的最终值，它们满足贝祖定理的要求。

最终，我们可以得到a和b的最大公约数`GCD(a, b)`，以及满足贝祖定理的整数x和y，使得`ax + by = GCD(a, b)`。

> 上面的算式也没啥含金量，就是知道公式根据公式套模版，但是理解和证明贝祖定理是比较困难的。

下面是实现的代码：

```c++
#include <iostream>

// 函数用于计算最大公约数（GCD）以及满足贝祖定理的x和y
int extendedGCD(int a, int b, int& x, int& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }

    int x1, y1;
    int gcd = extendedGCD(b, a % b, x1, y1);

    x = y1;
    y = x1 - (a / b) * y1;

    return gcd;
}

int main() {
    int a = 48;
    int b = 18;
    int x, y;

    int gcd = extendedGCD(a, b, x, y);

    std::cout << "GCD(" << a << ", " << b << ") = " << gcd << std::endl;
    std::cout << "x = " << x << ", y = " << y << std::endl;

    return 0;
}

```

## [快速幂问题](https://zhuanlan.zhihu.com/p/95902286)

顾名思义，这个算法实现的是快速求取高幂次的数据。在我们平常计算幂的数据的时候，通常会选择一个一个乘，举个例子：

```c++
//例如我要计算 7^10
void c()
{
    int a = 7;
    for(int i = 1;i<=10;i++){
        a*=7;
    }
}
```

这样子确实能够实现我们的目的，但是由于循环次数过多导致算法效率太慢，我们就不使用这种算法，改为使用快速幂算法。

让我们先来思考一个问题：**7的10次方，怎样算比较快？**

**方法1：**最朴素的想法，`7*7=49，49*7=343`，... 一步一步算，共进行了**9次**乘法。

这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。

**方法2：**先算7的5次方，即`7*7*7*7*7`，再算它的平方，共进行了**5次**乘法。

但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。

**方法3：**先算7*7得49，则7的5次方为`49*49*7`，再算它的平方，共进行了**4次**乘法。

模仿这样的过程，我们得到一个在`O(log n)`时间内计算出幂的算法，也就是快速幂。

----------

那要怎么样才能实现这种效果呢，我们可以使用二进制来优化我们的乘法运算，使其更加高效的相乘。

![image-20230907153701347](image-20230907153701347.png)

```c++
//非递归快速幂
int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘 - 提高次，就是和十进制的十位百位一样的
        n >>= 1;       //n往右移一位 - 位运算将十进制数据转换为二进制移动位置
    }
    return ans;
}
```

最初ans为1，然后我们一位一位算：

1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。

101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。

10的最后一位是0，跳过，右移，自乘。

然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。

![img](v2-e99e321dcff33699093cde2876424dbe_720w.webp)

### 快速幂扩展

上面所述的都是**整数**的快速幂，但其实，在算 a^n 时，只要a的数据类型支持**乘法**且**满足结合律**，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：

```c++
//泛型的非递归快速幂
template <typename T>
T qpow(T a, ll n)
{
    T ans = 1; // 赋值为乘法单位元，可能要根据构造函数修改
    while (n)
    {
        if (n & 1)
            ans = ans * a; // 这里就最好别用
        自乘了，不然重载完*还要重载*=，有点麻烦。
        n >>= 1;
        a = a * a;
    }
    return ans;
}
```



## 乘法逆元

定义：

如果一个线性同余方程`ax≡1(mod b)`,则x称之为`a mod b`的逆元，记作`a^-1`

```c++
//乘法逆元
乘法逆元是乘法运算在模意义下的一个概念，即存在一个数a，使得a*b≡1（mod n），其中a就叫做b的乘法逆元，记为b^(-1) (mod n)。它的用处是在模意义下实现除法的目的，可以用来求模意义下的乘法对角线，解方程组等。
```

### 拓展欧几里得实现逆元

```c++
//扩展欧几里得算法实现逆元
int exgcd(int a, int b, int &x, int &y) 
{
    if (b == 0) 
    {
        x = 1;
        y = 0;
        return a;
    }
    int r = exgcd(b, a % b, x, y);
    int t = x;
    x = y;
    y = t - a / b * y;
    return r;
}

int inverse(int a, int m) 
{
    int x, y;
    int gcd = exgcd(a, m, x, y);
    return x >= 0 ? x : x + m;
}
```

### 快速幂实现乘法逆元

证明：

因为 `ax ≡ 1 (mod b); `

> 

所以 `ax ≡ a^(b-1) (mod b) ` 

所以 `x ≡ a^(b-2)(mod b) `

## [欧拉函数](https://zhuanlan.zhihu.com/p/151756874)

定义

在[数论](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%95%B8%E8%AB%96)中，对正[整数](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8)*n*，**欧拉函数φ(n)**是小于或等于*n*的正整数中与*n*[互质](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA)的数的数目。此[函数](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E6%95%B0%E5%AD%A6))以其首名研究者[欧拉](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89)命名，它又称为**φ函数**（由[高斯](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%8D%A1%E7%88%BE%C2%B7%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E9%AB%98%E6%96%AF)所命名）或是**欧拉总计函数**（totient function，由[西尔维斯特](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E8%A9%B9%E5%A7%86%E6%96%AF%C2%B7%E7%B4%84%E7%91%9F%E5%A4%AB%C2%B7%E8%A5%BF%E7%88%BE%E7%B6%AD%E6%96%AF%E7%89%B9)所命名）。

例如`φ(8) = 4`，因为`1,3,5,7`均和8互质。

也可以从简化剩余系的角度来解释，简化剩余系(reduced residue system)也称既约剩余系或缩系，是m的完全剩余系中与m[互素](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%92%E7%B4%A0/869678)的数构成的[子集](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%90%E9%9B%86/5017034)，如果模m的一个剩余类里所有数都与m互素，就把它叫做与模m互素的[剩余类](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%89%A9%E4%BD%99%E7%B1%BB/3712708)。在与模m互素的全体剩余类中，从每一个类中各任取一个数作为代表组成的集合，叫做模m的一个简化剩余系。

`（1，3，5，7）`就构成了8的一个简化剩余系。

> 欧拉函数的定义是：
>   `Φ(N) = (p1^k1)*(p2^k2)…*(pr^kr)`
>    其中`p1、p2…pr`是大于1的所有不相等的质数，而`k1、k2…kr`是正整数。
>    `Φ(N)`表示小于等于`N`的正整数中，与`N`互质的数之积。欧拉函数的意义就是计算满足特定限制条件的正整数值
>
> 说人话就是，欧拉函数可以把一个数分解成质因数的乘积。

 标准分解式

标准分解式：将质因数分解的结果，按照质因数大小，由小到大排列，并将相同质因数的连乘积，以指数形式表示，此种表示法称为标准分解式。

如2020的标准分解式是

![img](v2-4305f9672e7bf9135245f0f4a9517a48_720w.png)

> 整数（除了0）都可被质因数分解，质因数分解是一个在理论上可行但在实际中对于大整数来说非常耗时的计算问题。

欧拉函数计算方法

（1）先化为标准分解式形式

![img](/v2-7fff527aba93db7a2de6722d126b7720_720w.png)

（2）再依照下式规则计算

![img](/v2-1b46934f0398099451934b434301000e_720w.png)

例如：

![img](/v2-7944fd84b22ba208a1ecc4873ab1889b_720w.png)

但是获得大整数的标准分解式却很困难

![img](v2-f37804d83b944f0f8f87638a8ea5a897_720w.webp)

下面是实现欧拉函数的一个代码：分解质因数

```c++
//注意欧拉函数只适用于整数
#include <iostream>

using namespace std;

// 计算最大公约数
long long gcd(long long a, long long b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// 计算欧拉函数
long long euler_phi(long long n) {
    long long result = n;
    for (long long i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0)
                n /= i;
            result -= result / i;
        }
    }
    if (n > 1)
        result -= result / n;
    return result;
}

int main() {
    long long n;

    cout << "请输入一个正整数：";
    cin >> n;

    if (n <= 0) {
        cout << "请输入一个大于0的正整数。" << endl;
        return 1;
    }

    long long phi = euler_phi(n);
    cout << "欧拉函数 φ(" << n << ") = " << phi << endl;

    return 0;
}

```

### 欧拉定理

![img](v2-43c417f37ca53e2e888bc01a0333229e_720w.png)

> 对于任何正整数n和与n互质的正整数a（即，a和n没有共同的质因数），以下等式成立：
>
> `a^φ(n) ≡ 1 (mod n)`
>
> 其中，^表示幂运算，`φ(n)`表示欧拉函数（`Euler's Totient Function`），≡ 表示模同余。`φ(n)`表示小于等于n且与n互质的正整数的个数。

```c++
//欧拉定理的代码生成
#include"iostream"

using namespace std;

//定义欧拉函数
long euler(long n)
{
    long ans=n,i,j;
    for ( i=2;i*i<=n;i++)
    {
        if(n%i==0)
        {
            ans=ans-ans/i;
            while(n%i==0) 
            {
                n/=i;
            }
        }
    }
    if(n>1) 
    {
        ans=ans-ans/n;
    }
    return ans;
}

int main()
{
    long n;
 
    cout << "请输入一个正整数：";
    cin >> n;
    cout << "此数的欧拉函数值为："<< euler(n) << endl;
    return 0;
}
```

### [费马小定理](https://zhuanlan.zhihu.com/p/352730090)

![img](v2-7c38ca526acacc32abafb21bdaf5e813_720w.webp)

> 费马小定理：
> 如果p是一个素数，而a是任何不能被p整除的整数，那么p能除`aᵖ⁻¹ - 1`
>
> 费马小定理是欧拉定理的特殊形态。

这个由皮埃尔·德·费马在1640年发现的数字性质，本质上是说，取任意素数p和任意不能被该素数整除的数a，假设p = 7, a = 20。通过费马小定理，我们发现：

![img](v2-c90abd1c754389f68fe7c001c7993946_720w.webp)

```c++
//前置消息
辗转相除法 gcd(a,b); //求取最小公倍数
#include <iostream> 
using namespace std; 
  
// Function to compute gcd of two numbers 
int gcd(int a, int b) 
{ 
    if (b == 0) 
        return a; 
    return gcd(b, a % b); 
} 
  
//main function
int main() 
{ 
    int a = 98, b = 56; 
    cout << "GCD of " << a << " and " << b << " is " << gcd(a, b); 
    return 0; 
}

```

```c++
//费马小定理

//它指出，如果一个自然数p是一个素数，并且a是一个不能被p整除的任意一个正整数，那么a的p次方一定模p等于a。

#include <iostream>
using namespace std;

int main(){
    int a, b, c;
    cout << "Enter two different numbers: ";
    cin >> a >> b;
    c = a*a + b*b;
    
    if(c % (a+b) == 0)
        cout << "弗尔马尔的小定理得到验证。";
    else 
        cout << "Felmar的小定理尚未得到验证";
    
    return 0;
}
```

## 中国剩余定理

```c++
中国剩余定理的用途有： 
      1、在数论中，它可用于解决同余方程； 
      2、在密码学中，它可用于将私钥分成多份存放，并能通过合并多份共享私钥来解密信息；       3、在密码学中，它还可以用于生成曲线密码，能够抗攻击； 
    4、在数值分析中，它可用于解决系统方程组； 
    5、在计算机科学中，它可用于解决复杂图形计算问题； 
    6、它还可以用于解决一系列复杂的模式识别问题； 
    7、在数据库领域，它可用于解决复杂的查询优化问题
```

```c++
/*
* 中国剩余定理：求解一组数的方程组 x = ai (mod ni) 所有a_i, n_i都是正整数 
* 并且互质，即gcd(n_i, n_j) = 1 (1 ≤ i ≤ k, 1 ≤ j ≤ k, i ≠j)则存在这样一个整数x，
* 使得x≡ai(modni)成立，且0≤x<n1 * n2 *...nk。
*/
int chinese_remainder(int *n, int *a, int len) {  // 传入ni和ai的数组，len表示数组的长度
 int p, i, j, m, n_i, x; //定义变量
 x = 0;
 p = 1;
 for (i = 0; i < len; i++) { // 求出n1 x n2 x ... nk
  p *= n[i];
 }

 // 中国剩余定理算法 
 // 之所以不影响x的值，是因为m == (p / n[i]) * ai mod n[i]
 for (i = 0; i < len; i++) {
  n_i = p / n[i];
  m = extended_Euclid(n_i, n[i]);  //  扩展欧几里得算法计算出逆元
  x += a[i] * m * n_i;
 }

 return x % p;
}

// 扩展欧几里得算法
int extended_Euclid(int a, int b) {
 int x, y, d;
 if (b == 0) {
  x = 1;
  y = 0;
  d = a;
  return d;
 }
 int x1, y1, d1;
 d1 = extended_Euclid(b, a % b);
 x1 = y1;  // 记录上一次的结果 
 y1 = x1 - (a / b)* y1;
 d = d1;
 x = x1;
 y = y1;

 // 由模线性方程性质可知 
 // 如果a, b互质， 那么对于模线性方程 ax + by = c 有唯一解， 
 // 而该解恰好为 d = gcd(a, b) 的一组特解
 if (d == 1) 
  return (x + b) % b; // 返回模逆元 
}
```

## [高斯消元](https://blog.nowcoder.net/n/5705bab812774f1eb6e60c2e8c55ca1e?from=nowcoder_improve)

```c++
//高斯消元是一种数学计算方法，用于快速求解系数表示的线性方程组的解，它也被称为高斯-赛洛加算法，以著名的普林斯顿大学数学家高斯命名。该方法把方程组分为上三角形组和下三角形组，通过变换方程中的系数值，最终获得方程的解。
//高斯消元法用于解决线性方程组的系数矩阵形式，即通过将系数矩阵通过合并和分解，从而求解出给定线性方程组的参数值解
//解决多项式方程的算法 - 是线性代数的知识
```

```c++
//高斯消元的证明
#include<iostream>
#include<iomanip>
using namespace std;
public void gauss_jordan(double a[][],double b[],int n)//a为系数矩阵，b为常数项，n为未知数个数
{
    int i,j,k,r;
    double m,s;

    for(i=0;i<n-1;i++)
    {
        r = i;
        for(j = i+1; j < n; j++)
            if(fabs(a[j][i]) > fabs(a[r][i])) 
                r=j;
        //将第r行与第i行交换
        if(r != i) 
        {
            for(k = 0; k < n; k++) 
            {
                m = a[i][k];
                a[i][k] = a[r][k];
                a[r][k] = m;
            }
            s = b[i];
            b[i] = b[r];
            b[r] = s;
        }
        //用第i行的元素除以第i列第一个元素
        m = a[i][i];
        b[i] = b[i]/m;
        for(k = 0; k < n; k++)
            a[i][k] = a[i][k]/m;
        //化为型
        for(j=0;j<n;j++)
        {
            if(j == i) continue;
            s = a[j][i];
            for(k = 0;k<n;k++)
                a[j][k] = a[j][k] - a[i][k]*s;
            b[j] = b[j] - b[i]*s;
        }
    }
    //输出解
    for(i=0;i<n;i++)
    {
        printf("x%d = %f\n",i,b[i]);
    }
return ;
}
```

## [质数筛](https://oi-wiki.org/math/number-theory/sieve/)

```c++
//计算质数的代码(暴力根源)
#include <iostream>  
using namespace std;  
int main()  
{  
    int i, j, count;  
    cout << " 它的2到100间的质数有: \n";  
    for(i=2;i<100;i++)  
    {  
        count = 0;  
        for(j=2;j<i;j++)//判断i是否为质数，若count==0则为质数  
        {  
            if(i%j == 0)  
            {  
                count++;  
                break;  
            }  
        }  
        if(count==0)  
        {  
            cout<<i<<" ";  
        }  
    }  
    cout << "\n";  
}
```

```c++
//加上合数优化
#include<iostream>
using namespace std;

bool i_p(int x)
{
    if(x<2) return false;
    //如果一个数是合数（不是素数），那么它的最小因数一定不会超过它的平方根
    //这个属性可以用反陈述来证明。设 a 和 b 是 n 的两个因子，使得 a*b = n。如果两者都大于 √n，则 a.b > √n， * √n，这与表达式 “a * b = n” 相矛盾。（可以理解为 a 和 b 最大就 √n）
    for(int i = 2;i<=x/i;i++)
        if(x%i == 0) return false;
    return true;   
    
}


int main()
{
    int n;
    cin>>n;
    
    while(n--){
        int x;
        cin>>x;
        if(i_p(x)) puts("Yes");
        else puts("No");
    }
    return 0;
    
    
}
```

### 试除法

```c++
//代码模版
#include <iostream>
#include <vector>
using namespace std;

vector<pair<int, int>> trial_division(int n) {
    // n是要分解的整数
    // 返回一个向量，包含n的所有质因数和它们的次数
    vector<pair<int, int>> factors; // 存储质因数和次数的向量
    int i = 2; // 从2开始试除
    while ( i <= n/i) { // 只需要试到根号n就可以了
        int s = 0; // 记录i出现的次数
        while (n % i == 0) { // 如果n能被i整除，就更新n和s
            n /= i; // 用i约分n
            s++; // 增加i的次数（当前质数的指数）
        }
        if (s > 0) { // 如果s大于0，说明i是n的一个质因数，把它加入factors向量
            factors.push_back(make_pair(i, s));
        }
        i++; // 增加i，继续试除下一个数
    }
    if (n > 1) { // 如果n最后大于1，说明它本身是一个质数，也要加入factors向量(理解)
        factors.push_back(make_pair(n, 1));
    }
    return factors; // 返回factors向量
}
```

### 试除法求约数

```c++
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

vector<int> get_divisors(int x){
    vector<int> res;
    for(int i = 1;i<=x/i;i++)
    //整除流入
        if(x%i == 0){
            //如果i是质因数 - 塞入res数组中
            res.push_back(i); 
            //除数相等的情况 就只有i了嘛
            if(i!=x/i) res.push_back(x/i);
        }
        //排个序 (可不可以用 set存储啊)
        sort(res.begin(),res.end());
        return res;
}


int main()
{
    int n;
    cin>>n;
    
    while (n -- ){
        int x;
        cin>>x;
        auto res = get_divisors(x);
        for( auto x:res) cout<<x<<" ";
        cout<<endl;
    }
    return 0;
    
}
```

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int N = 110, mod = 1e9+7;//题目的意思就是和mod取模的得数

//这个代码求约数是用约数个数定理12的方法。约数个数定理是：
//如果一个数可以分解为质因数的形式，如M = x^a * y^b * z^c * …，则M的约数个数 = (a+1) (b+1) (c+1)…。
//这个代码就是先把每个输入的数分解成质因数，然后用哈希表记录每个质因数的指数，最后用公式计算出所有输入的数的最小公倍数的约数个数。
int main()
{
    int n;
    cin>>n;
    //哈希表的键是质数，值是质数对应的指数
    //primes[i], i是键，primes[i]是值
    unordered_map<int,int> primes; 
    //unordered_map的迭代器是一个指针，指向这个元素，通过迭代器来取得它的值。它的键值分别是迭代器的first和second属性12。
    //例如，it->first就是键，it->second就是值。
    //当然也不一定存储键值对 - 也可以存储二者
    while (n -- ){
        int x;
        cin>>x;
        for(int i = 2;i<=x/i;i++)
            while(x%i == 0){
                x/=i;
                primes[i]++; //对应位置的质数记录 （算是记录指数）
            }
        if(x>1) primes[x]++; //只剩下一个数据 这个数据必然是质数
    }
    LL res = 1;
    for(auto p:primes) res = res*(p.second+1)%mod;
    cout<<res<<endl;
    return 0;
}
```

### 筛法

![定义](https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)

```c++
//1.埃拉托色尼筛
埃拉托色尼筛的原理是这样的：
    首先，把所有小于等于n的自然数都列出来，从2开始，把1排除掉。
    然后，从2开始，把它的所有倍数都标记为合数，也就是不是素数的数。
    接着，找到下一个没有被标记的数，它一定是素数，然后把它的所有倍数都标记为合数。
    重复这个过程，直到没有更多的没有被标记的数为止。
    最后，所有没有被标记的数就是素数

 /*质数筛法是一种经典的求解质数的方法，它利用筛过程来获得所有质数。这个算法强调效率，通常使用比较基本的操作，来求解比较大的质数。 筛法的原理是：从2开始，把2的倍数筛掉，然后3，4，5，把3的倍数筛掉，以此类推。最后剩下的就是质数。 如何实现质数筛法：  1. 首先设置一个长度为n的数组，并将数组初始化，其数字依次为2, 3, …, n。   
2. 从2开始遍历数组中的元素，依次筛除其2、3、4、… 倍数的数，即将数组中对应元素置0。  3. 筛完后，把数组中非0元素存入一个新数组中，这些非0元素即为质数。 
```

```c++
#include<iostream>
using namespace std;

const int N = 1e6+10;

int primes[N],cnt;
bool st[N];

void get_primes(int n){
    for(int i = 2;i<=n;i++){
        if(st[i]) continue;
        //1.primes[cnt++] = i;的作用是把i这个素数存入primes数组中
        //  并且把cnt加一，表示素数的个数增加了一个。
        primes[cnt++] = i;
        //2.;这个循环的作用是把i的所有倍数都标记为合数，也就是非素数。
        //  这样，当i增加时，就可以跳过已经被标记为合数的数字，只考虑没有被标记的数字，因为它们可能是素数。
        for(int j = i+i;j<=n;j+=i) st[j] = true;
    }
}


int main()
{
    int n;
    cin>>n;
    get_primes(n);
    cout<<cnt<<endl;
    return 0;
    
}
```

```c++
//2.线性筛法（埃拉托色尼筛优化版）
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        //如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            //primes[j] * i这个数标记为合数
            st[primes[j] * i] = true;
            //如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}

```

## 求约数

```c++
//约数
约数是一个数据的因子，可以用这个约数凑成我们的这个数据
//试除法
  测试除法是一种数学操作，用来衡量和检查两个数字的除法运算结果是否正确。它通常包括算术问题、实数求余以及其他形式的除法运算。
//代码
#include <iostream>
#include <math.h>
using namespace std;

//试除法，求约数
void FindDivisor(int n)
{
    for (int i = 2; i <= sqrt(n); i++)
    {
        while (n % i == 0)
        {
            cout << i << "  ";
            n /= i;
        }
    }
    if (n > 1) 
    {
        cout << n;
    }
    cout << endl;
}

int main()
{
    int n;
    cout << "Please enter an integer:";
    cin >> n;

    cout << n << "的约数有：" ;
    FindDivisor(n);
    
    system("pause");
    return 0;
}
```

## 求组合数

### 组合计数*

  本质上，求组合数就是按照公式就可以求出来的。

### 线性筛法 - 求组合数

![image-20230317103427722](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317103427722.png)

```c++
//线性筛法板子
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        //如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            //primes[j] * i这个数标记为合数
            st[primes[j] * i] = true;
            //如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}
```

```c++
//用这个方法 - 就是减少阶层的计算次数
//同时，组合数太大了只能用高精度的数据存储
//n！（阶层）中的p的个数 ，p是质数
int get(int n,int p){
    //n容纳p的个数有上限的
    int s = 0;
    while(n) s+=n/p,n/=p;
    return s;
}
//c中的p的个数(算质数的个数) - 算组合数中的质数个数
int getC(int n,int m,int p){
    return get(n,p) - get(m,p) - get(n-m,p);
}

//组合数公式 就是 - get/(get(n,p) - get(m,p) - get(n-m,p))

//数组乘质数？
void mul(int C[],int p,int &len){
    //高精度
    int t = 0;
    for(int i = 0;i<len;i++){
        t+=C[i]*p;
        C[i] = t%10;
        t/=10;
    }
    while(t){
        C[len++] = t%10;
        t/=10;
    }
}

int main()
{
    int C[N],len = 1,C[0]= 1;
    for(int i = 0;i<cnt;i++){
        int p = prim[i];
        int s = getC(n,m,p);
        while(s--) mul(C,p,len); //这里算的结果是吗
    }
    
}
```

### 快速幂 - 求组合数  - 乘法逆元(不太会)

![image-20230317190202981](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317190202981.png)

```c++
//快速幂板子
#include<iostream>
using namespace std;

typedef long long LL;

LL qmi(int a,int b,int p){
    LL res = 1%p;
    //把次数转化成二进制 - 有1就代表有一次
    while(b){
        if(b&1) res = res*a%p;
        a = a*(LL)a%p;
        b>>=1;
    }
    return res;
}


int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        cout<<qmi(a,b,c)<<endl;
    }
    return 0;
    
    
    
}
```

```c++
//快速幂求组合数
LL qpow(LL a,int b)
{
    LL res = 1;
    while(b){
        if(b&1) res = res*a%p;
        a = a*a%p;
        b >>= 1;
    }
    return res;
}

void init()
{
    f[0] = g[0] = 1;
    for(int i = 1;i<N;i++){
        f[i] = f[i-1]*i%P;
        g[i] = g[i-1]*qpow(i,P-2)%P;
    }
    LL getC(LL n,LL m){
        return f[n]*g[m]%P*g[n-m]%P;
    }
}
```

```c++
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n,m;
//求出对应的次方 也就是a^b - 也可以用来求乘法逆元 a^(p-2)
//乘法逆元原理： a*a^(p-2) = 1(modp) 这样就行 我们要求a的乘法逆元就是a^(p-2)
int qpow(int a,int b)
{
    int ans=1;
    while(b)
    {
        if(b&1) ans=1ll*ans*a%mod;
        a=1ll*a*a%mod;
        b>>=1;
    }
    return ans;
}
int inv(int x)
{
    return qpow(x,mod-2);
}
int main()
{
    cin>>n>>m;
    int ans=1;
    for(int i=1;i<=m;i++)
    {
        ans=1ll*ans*(n-i+1)%mod;
        ans=1ll*ans*inv(i)%mod;
    }
    cout<<ans<<endl;
    return 0;
}
```

### 递推法 - 求组合数 - 杨辉三角形

![image-20230317191900241](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191900241.png)

![image-20230317191910081](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191910081.png)

![杨辉三角形](C:\Users\Administrator\Pictures\杨辉三角形.jpg)

```c++
//杨辉三角形求解组合数
//就是 当前这个数据 等于上面的左右数据的加和 - 那么就用动态规划解决这个问题就ok了
//但是怎么构造杨辉三角形呢 - 初始化三角形的两条边把
void getC()
{
    for(int i = 0;i<N;i++) //N是上限 - 底的吗
        for(int j = 0;j<=i;j++)
            if(j == 0) C[i][j] = 1;//j是尽头(把三角形当成是二分之一的正方形)
      else C[i][j] = (C[i-1][j]+C[i-1][j-1])%mod;
}
```

```c++
#include<iostream>
using namespace std;
int main()
{
    int n;
    cin>>n;
    int a[100][100]={0};
    for(int i=1;i<=n;i++)
    {
        a[i][1]=1;
        a[i][i]=1;
    }
    for(int i=3;i<=n;i++)
    {
        for(int j=2;j<=i-1;j++)
        {
            a[i][j]=a[i-1][j-1]+a[i-1][j];
        }
    }
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=i;j++)
        {
            cout<<a[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```

### 卢卡斯定理

![image-20230317192018240](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192018240.png)

![image-20230317192035378](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192035378.png)

```c++
#include <iostream> 
using namespace std;
int f[20][20];//定义二维数组，用来中间存储计算结果 
int cmn(int m,int n)  
{     
    int i,j;
    for(i=0;i<=m;++i)  //循环m步，从0开始 
       for(j=0;j<=n;++j)  //循环n步，也是从0开始  
        if(j==0||i==j)    //当i等于0或者i等于j时，直接赋值为1 
           f[i][j]=1;
        else 
           f[i][j]=f[i-1][j-1]+f[i-1][j];//其他的都是在上一步的计算结果上加+1，依次类推
     return f[m][n];  //返回结果 
}
int main()
{
    int m,n;
    cout<<"请输入任意m.n来得到组合数：";
    cin>>m>>n;
    int result=cmn(m,n);
    cout<<m<<"C"<<n<<"="<<result<<endl; //输出结果
    return 0;
}
```

## 欧几里得算法

![image-20230316143057971](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230316143057971.png)

```c++
/*辗转相除法，又称欧几里得算法，是一种求两个非负整数的最大公约数的算法1。最大公约数是能够同时整除两个整数的最大的正整数2。辗转相除法的基本思想是：如果a和b都能被c整除，那么a和b的余数也能被c整除。因此，可以用a和b的余数代替b，重复这个过程，直到余数为0为止。此时，a就是最大公约数3。

例如，要求18和30的最大公约数，可以这样做：

18 = 0 × 30 + 18

30 = 1 × 18 + 12

18 = 1 × 12 + 6

12 = 2 × 6 + 0

此时，余数为0，所以最大公约数是6。*/

//大除小，小除大除小的余数，这样反复直到一方变为0是这样吗
#include<iostream>
using namespace std;

int gcd(int a,int b){
    return b?gcd(b,a%b):a;
}

int main()
{
    int n;
    cin>>n;
    while(n--){
        int a,b;
        cin>>a>>b;
        cout<<gcd(a,b)<<endl;
    }
    
    return 0;
    
}
```

### 裴蜀定理

```c++
1.裴蜀定理（Bézout’s identity）又称裴蜀引理，是数论中的一个重要定理。它指出，对于任意整数 a 和 b，如果它们的最大公约数为 d，那么一定存在整数 x 和 y，使得不定方程 ax + by = d 有解。

2.换句话说，对于任意整数 a 和 b，它们的线性组合（即形如 ax + by 的整数）一定包含它们的最大公约数。此外，根据裴蜀定理还可以推出：如果不定方程 ax + by = c 有整数解，则当且仅当 c 是 a 和 b 的最大公约数的倍数时成立。

裴蜀定理在求解不定方程、计算模逆元等问题中都有重要应用。

//简单来说：就是构造一个这样的 ax + by = gcd(a,b); 只要gcd(a,b)能被我们题目的数据整除，就说明有整数解
```

```c++
假设我们要求解不定方程 3x + 5y = 11。首先，我们可以使用扩展欧几里得算法求出 3 和 5 的最大公约数以及不定方程 3x + 5y = gcd(3,5) 的一组整数解。运算结果显示，gcd(3,5) = 1，且不定方程 3x + 5y = 1 的一组整数解为 (x0,y0) = (2,-1)。//就是只要 3x + 5y = 1 的解也就是1 -  能够被原来的 11 整除 那么就有整数解

由于 11 是 gcd(3,5) 的倍数，因此原不定方程有整数解。它的一组特殊解为 (x0 * c/d, y0 * c/d) = (2 * 11/1,-1 * 11/1) = (22,-11)。此外，根据裴蜀定理，原不定方程的通解为 (22 + k * b/d,-11 - k * a/d) = (22 + k * 5,-11 - k * 3)（其中 k 为任意整数）。

因此，当 k=0 时，(x,y)=(22,-11) 是原不定方程的一组整数解；当 k=-1 时，(x,y)=(17,-8) 是原不定方程的另一组整数解；当 k=1时，(x,y)=(27,-14) 是原不定方程的第三组整数解。
   
```

### 扩展欧几里得算法(求不定方程)

![image-20230316150108768](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230316150108768.png)

```c++
//求不定方程 - 判断有无整数解是这个样子吗
//根据裴蜀定理，当且仅当 c 是 a 和 b 的最大公约数的倍数时，不定方程才有整数解。
int exgcd(int a,int b,int &x,int &y){
    if(b==0){
        x = 1,y = 0;
        return a;
    }
    int x1,y1,d;
    d = exgcd(b,a%b,x1,y1);
    x = y1,y = x1-a/b*y1; //用欧几里得构造
    return d; //这个就是被除的
}

int main()
{
    int a,b,c,x,y;
    cin>>a>>b>>c;
    int d = exgcd(a,b,x,y);
    if(c%d == 0) printf("%d %d",c/d*x,c/d*y); //能整除就是有整数解 - 无就是无
    else puts("none");
    return 0;    
}
```

## 快速幂算法

![image-20230317191357823](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317191357823.png)

```c++
/*快速幂：
可以这样理解，将指数转化为二进制，有1就乘，没1就不乘。 是通过二进制 一次执行多次乘法来缩减算法复杂度的
快速幂算法就是通过二进制来判断哪些位需要乘，哪些位不需要乘，从而减少乘法的次数。

例如，如果要计算 7 的 13 次方，可以将 13 写成二进制的 1101，然后有：

7^13 = 7(23 + 2^2 + 2^0) = 7(23) * 7(22) * 7(20)

= (7 * 7)^4 * (7 * 7)^2 * (7 * 7)^1

= (49)^4 * (49)^2 * (49)^1

这样就只需要做三次乘法，而不是十二次。
*/
#include<iostream>
using namespace std;

typedef long long LL;

LL qmi(int a,int b,int p){
    LL res = 1%p;
    //把次数转化成二进制 - 有1就代表有一次
    while(b){
        if(b&1) res = res*a%p;
        a = a*(LL)a%p;
        b>>=1;
    }
    return res;
}


int main()
{
    int n;
    cin>>n;
    while(n--)
    {
        int a,b,c;
        cin>>a>>b>>c;
        cout<<qmi(a,b,c)<<endl;
    }
    return 0;
    
    
    
}
```

### 快速幂求逆元

```c++
//根据费马小定理
a^(p-1) ≡ 1 (mod p)，所以a * a^(p-2) ≡ 1 (mod p)，也就是说x = a^(p-2)就是a的逆元。
//就是要构造 a^(p-1) ≡ 1 (mod p) 那么有 a* a^(p-2) ≡ 1 (mod p)  a^(p-2)这个就是我们的目标值（用逆元是为了减少运算次数）


#include <iostream>
#include <algorithm>

using namespace std;

typedef long long LL;


LL qmi(int a, int b, int p)
{
    LL res = 1;
    while (b)
    {
        //mod质数 这里就是快速幂啦
        if (b & 1) res = res * a % p;
        a = a * (LL)a % p;
        b >>= 1;
    }
    return res;
}


int main()
{
    int n;
    scanf("%d", &n);
    while (n -- )
    {
        
        int a, p;
        scanf("%d%d", &a, &p);
        if (a % p == 0) puts("impossible");
        else printf("%lld\n", qmi(a, p - 2, p));
        //如果p是一个质数，那么根据费马小定理，我们有a^(p-1) ≡ 1 (mod p)
        //所以a * a^(p-2) ≡ 1 (mod p)，也就是说x = a^(p-2)就是a的逆元。
    }

    return 0;
}
```



```c++

```

## 容斥原理

![image-20230317192341534](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192341534.png)

## 高斯消元

### 求解线性方程组

![image-20230317192423405](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317192423405.png)

## 中国剩余定理

![image-20230317193339194](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193339194.png)

![image-20230317193528005](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193528005.png)

![image-20230317193536881](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193536881.png)

### 中国剩余定理拓展

![image-20230317193608034](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193608034.png)

![image-20230317193627036](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193627036.png)

![image-20230317193636294](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230317193636294.png)
