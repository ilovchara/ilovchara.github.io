---
title: 数论
date: 2023-04-28 09:09:10
categories: 算法
typora-root-url: 数论
tags: 数据结构
---

#  [数论](https://oi-wiki.org/)

## [欧几里得算法](https://zh.wikipedia.org/wiki/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95)

### [求最大公约数](https://www.zhihu.com/question/51427771)

> 公式是这样的：`gcd(a, b) = gcd(b, a mod b)` 直到`b`为`0`

欧几里得的辗转相除法计算的是两个自然数a和b的最大公约数g，意思是能够同时整除a和b的自然数中最大的一个。两个数的最大公约数通常写成`gcd(a,b)`。

要求两个数的最大公约数，不妨假设a>b。假设b是a的约数，那么最大公约数应该是b。所以说最大公约数取决于较小的那个数据，范围为[1,b]。也就是说，我们输入到gcd中的数据一定是一大一小的，这里默认a>b。

> 特别的如果`gcd(a,b) = 1`说明我们的`a,b`只存在一个公约数`1`，表明`a,b`互质

令`g = gcd(a,b)`.由于a和b都是g的整数倍(这里的**g是最大公因数**)，所以可以写成`a = mg,b = ng`,并且不存在更大的整数`G>g`使等式成立。为了使得g足够大，就要使得**a和b中所有的公约数**都提取出来归入g中。这就导致了自然数`m，n`一定互质（这里可以用反证法来证明），并且a和b的最大公约数可以被a和b的所有其他公因数`c`整除。

> 反证法证明:
>
> 假设自然数m和n不是互质的，也就是说它们有一个大于`1`的公约数`d`。
>
> 因此我们可以表示`m和n`为：
>
> `m = dx, n = dy`
>
> 其中`x`和`y`是大于`1`的整数。然后，我们将`a`和`b`表示为：
>
> `a = mg = d*x*g` , `b = ng = d*y*g`
>
> 因此，`a和b`都可以被`d`整除，这表明它们有一个公因数`d`。因此，假设不成立，这意味着`m和n`是互质的。

```c++
//两个数据得是整数
int open_M(int a,int b)
{
    int result = 1;
    if(a>b) result = gcd(a,b);
    else result = gcd(b,a);
}

//gcd - 递归计算
int gcd(int a,int b){
    //简单的记忆 - 只要传入的第二个参数为0 - 那么最大公约数就是第一个参数
    if(a%b == 0) return b;
    else gcd(b,a%b); 
}

```

用上面的例子可能不好理解，下面用一个图形化实例来解释辗转相除法

![image-20230907103114003](image-20230907103114003.png)

> 假设我们有一个长方形，其长度为a，宽度为b，我们的目标是找到一个能够完全覆盖这个长方形的最大长方形，而且没有部分超出原始长方形的边界。
>
> - 首先，我们尝试将较大的长方形（a）分割成较小的长方形（b）和一些余下的部分（q），使得a = b + q，其中q的长度小于b。我们将q看作是原始长方形中未被覆盖的部分。
>
> - 然后，我们继续以同样的方式，尝试找到能够完全覆盖q的最大长方形，其长度为b'，同时q = b' + q'，其中q'的长度小于b'。
>
> - 我们不断重复这个过程，直到找到一个长方形（b''），它能够完全覆盖q''，其中q'' = b'' + 0。这时，q''是一个没有余下部分的长方形。
>
> - 这个最终的长方形（b''）的长度就是原始长方形（a）和我们一路上找到的所有长方形（b、b'、...）的最大公约数。
>
> 辗转相除法的核心思想是通过不断地将较大的长方形分割成较小的长方形，直到找到一个没有余下部分的长方形，来寻找两个数的最大公约数。这个过程反映了欧几里德算法的工作方式，其中我们一次又一次地计算余数，直到余数为0，此时除数就是最大公约数。为什么第一个参数要大于第二个参数呢，因为最后出现的0不能作为除数。如果还是不能理解，就记住公式就行吧。
>

### [扩展欧几里得](https://zhuanlan.zhihu.com/p/100567253)

拓展欧几里得算法：在辗转相除途中求出不定方程 `ax+by = c`的一组解。

#### 求解线性同余方程

形如

`ax≡b (mod n)`

这个就是线性同余方程，其中`a,b,n`都为常量，x是未知数，这个方程可以化为(取模n - 变为方程)

`ax = kn+b`

这里的k为任意常数，于是一般式为：

`ax+by+c = 0`

这个方程就是二维的直线方程，这个方程的解集是一些排列成直线的点。拓展欧几里得可以用于求解线性同余方程`ax≡b (mod n)`,实际上拓展欧几里得是在求解最大公约数的时候对其加上一些限制，达到解决问题的目的。下面是求解方程`ax≡b (mod n)`的具体步骤：

- 首先，确保a和n互质，即`gcd(a, n) = 1`。如果`gcd(a, n)`不等于1，那么线性同余方程没有整数解。

- 使用欧几里得算法来计算a和n的最大公约数`gcd(a, n)`，以及同时找到x和y，使得`ax + ny = gcd(a, n)`。这一步的目标是找到x的值。

- 如果`gcd(a, n)`等于1（表示a和n互质），则方程ax ≡ b (mod n)有唯一整数解。这个解可以通过将x乘以b并对n取模来获得，即`x ≡ bx (mod n)`。

> 特别的：当a和n不互质时，线性同余方程ax ≡ b (mod n)可能没有整数解或者只在特殊情况下有解。让我们来看两个例子：
>
> **例子 a和n互质**
>
> 假设我们有线性同余方程：
>
> `3x ≡ 2 (mod 7)`
>
> 在这个情况下，a = 3，n = 7。a和n是互质的，因为它们的最大公约数`gcd(3, 7) = 1`。
>
> 对于方程`3x ≡ 2 (mod 7)`我们可以将之化为:`x = 3/2 + k*7/2` 这里肯定是一个整数值，因为`k`是任意值.
>
> 因此，这个方程有整数解。解可以通过拓展欧几里得算法等方法找到。一个解是x = 5，因为`3 * 5 ≡ 15 ≡ 2 (mod 7)`。
>
> **例子 和n不互质**
>
> 现在，考虑线性同余方程：
>
> `4x ≡ 2 (mod 6)`
>
> 在这个情况下，a = 4，n = 6。a和n不互质，因为它们的最大公约数`gcd(4, 6) = 2`。
>
> 对于方程`4x ≡ 2 (mod 6)` 可以化为 `2x ≡ 1 (mod 3)`
>
> 因此，这个方程可能没有整数解，因为`4x与2 (mod 6)`有一个共同的因子2。
>
> 如果我们尝试将`4x ≡ 2 (mod 6)`除以2，我们得到`2x ≡ 1 (mod 3)`，这个方程有整数解x = 2。但是这不是原始方程`4x ≡ 2 (mod 6)`的解，因为我们只是在原方程的基础上除以了一个公因子2。
>
> 这个例子说明，当a和n不互质时，线性同余方程可能没有整数解，或者解可能存在于一个较小的模数下。

```c++
#include <iostream>

int extended_gcd(int a, int b, int &x, int &y) {
    if (a == 0) {
        x = 0;
        y = 1;
        return b;
    }
    
    int x1, y1;
    int gcd = extended_gcd(b % a, a, x1, y1);
    
    x = y1 - (b / a) * x1;
    y = x1;
    
    return gcd;
}

int solve_linear_congruence(int a, int b, int n, int &x) {
    int x0, y0;
    int gcd = extended_gcd(a, n, x0, y0);
    
    if (b % gcd != 0) {
        return -1; //不存在整数解
    }
    
    x = (x0 * (b / gcd)) % n;
    if (x < 0) {
        x += n; // 确保x为正数
    }
    
    return gcd;
}

int main() {
    int a = 3;
    int b = 2;
    int n = 11;
    int x;
    
    int gcd = solve_linear_congruence(a, b, n, x);
    
    if (gcd == -1) {
        std::cout << "没有整数解" << std::endl;
    } else {
        std::cout << "方程整数解是： " << a << "x ≡ " << b << " (mod " << n << ") 是 x ≡ " << x << " (mod " << n << ")" << std::endl;
    }
    
    return 0;
}

```

#### [实现贝祖定理](https://oi-wiki.org/math/number-theory/bezouts/)*

定义：

> 给定两个整数a和b ，一定存在整数x和y ，使得`ax+by=gcd(a,b)`
>
> 换句话说，若`ax + by = m `有整数解当且仅当m是`gcd(a,b)`的倍数。

![image-20230907141937287](image-20230907141937287.png)

具体看`oi`网吧，我也没搞懂证明过程。

我们现在只需要证明：**`对于任意整数a和b，存在整数x和y，使得ax + by = gcd(a, b)。`**下面是一个简单的解决问题的步骤

首先，使用欧几里得算法计算a和b的最大公约数`（GCD）`。这可以通过反复取余数的方式来实现，直到余数为0为止。`GCD`就是最后一个非零余数。

在计算`GCD`的过程中，我们会得到一系列的等式，这些等式可以用来表示`GCD`为前两个数的线性组合。具体来说，如果我们得到了以下等式：

```c++
//原本的辗转相除法
GCD(a, b) = GCD(b, a % b)
```

那么根据贝祖定理，可以表示为：

```c++
//贝祖定理
GCD(a, b) = x * a + y * (a % b)
```

其中，x和y是与b和a % b相关的系数。

接下来，我们将递归地使用相同的过程，但是将b和a % b作为新的a和b，直到余数为0为止。此时，`GCD`就是最后一个非零余数，同时我们也得到了x和y的最终值，它们满足贝祖定理的要求。

最终，我们可以得到a和b的最大公约数`GCD(a, b)`，以及满足贝祖定理的整数x和y，使得`ax + by = GCD(a, b)`。

> 上面的算式也没啥含金量，就是知道公式根据公式套模版，但是理解和证明贝祖定理是比较困难的。

```c++
#include <iostream>

// 函数用于计算最大公约数（GCD）以及满足贝祖定理的x和y
int extendedGCD(int a, int b, int& x, int& y) {
    if (b == 0) {
        x = 1;
        y = 0;
        return a;
    }

    int x1, y1;
    int gcd = extendedGCD(b, a % b, x1, y1);

    x = y1;
    y = x1 - (a / b) * y1;

    return gcd;
}

int main() {
    int a = 48;
    int b = 18;
    int x, y;

    int gcd = extendedGCD(a, b, x, y);

    std::cout << "GCD(" << a << ", " << b << ") = " << gcd << std::endl;
    std::cout << "x = " << x << ", y = " << y << std::endl;

    return 0;
}

```

## [快速幂问题](https://zhuanlan.zhihu.com/p/95902286)

顾名思义，这个算法实现的是快速求取高幂次的数据。在我们平常计算幂的数据的时候，通常会选择一个一个乘，举个例子：

```c++
//例如我要计算 7^10
void c()
{
    int a = 7;
    for(int i = 1;i<=10;i++){
        a*=7;
    }
}
```

这样子确实能够实现我们的目的，但是由于循环次数过多导致算法效率太慢，我们就不使用这种算法，改为使用快速幂算法。

让我们先来思考一个问题：**7的10次方，怎样算比较快？**

**方法1：**最朴素的想法，`7*7=49，49*7=343`，... 一步一步算，共进行了**9次**乘法。

这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。

**方法2：**先算7的5次方，即`7*7*7*7*7`，再算它的平方，共进行了**5次**乘法。

但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。

**方法3：**先算7*7得49，则7的5次方为`49*49*7`，再算它的平方，共进行了**4次**乘法。

模仿这样的过程，我们得到一个在`O(log n)`时间内计算出幂的算法，也就是快速幂。

----------

那要怎么样才能实现这种效果呢，我们可以使用二进制来优化我们的乘法运算(其实也是倍增思想)，使其更加高效的相乘。

![image-20230907153701347](image-20230907153701347.png)

```c++
//非递归快速幂
int qpow(int a, int n){
    int ans = 1;
    while(n){
        if(n&1)        //如果n的当前末位为1
            ans *= a;  //ans乘上当前的a
        a *= a;        //a自乘 - 提高幂，就是和十进制的十位百位一样的
        n >>= 1;       //n往右移一位,个位数算过了，进位了
    }
    return ans;
}
```

最初ans为1，然后我们一位一位算：

`1010`的最后一位是`0`，所以`a^0`这一位不要。然后`1010`变为`101`，`a`进位变为`a^1`。

`101`的最后一位是`1`，所以`a^1`这一位是需要乘的，乘入`ans`。`101`变为`10`，`a`再自乘进位`a^2`。

`10`的最后一位是`0`，跳过，右移，自乘进位。

`1`的最后一位是`1`，`ans`再乘上`7^8`。循环结束，返回结果。

![img](v2-e99e321dcff33699093cde2876424dbe_720w.webp)

### 快速幂扩展

上面所述的都是**整数**的快速幂，但其实，在算 `a^n` 时，只要a的数据类型支持**乘法**且**满足结合律**，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：

```c++
//泛型的非递归快速幂
template <typename T>
T qpow(T a, ll n)
{
    T ans = 1; // 赋值为乘法单位元，可能要根据构造函数修改
    while (n)
    {
        if (n & 1)
            ans = ans * a; // 这里就最好别用
        自乘了，不然重载完*还要重载*=，有点麻烦。
        n >>= 1;
        a = a * a;
    }
    return ans;
}
```

## [乘法逆元](https://zhuanlan.zhihu.com/p/378728642)

数学上的乘法逆元就是一个数的倒数，既a的逆元是`1/a`,也就是和a相乘得到1的数据。`ax = 1`,则x是a的乘法逆元。这里讨论有关于取模运算的乘法逆元，既对于整数a,与a互质的数b作为模数，当整数x满足`ax mod b ≡ 1`时，称`x`为`a`关于模`b`的逆元，也就是`a * x % b == 1`

在算法竞赛中，经常会遇到求解数据很大，则输出模 `10^9+7` 的解这类要求。加法、减法、乘法等操作，基于同余理论直接取模即可。但遇到除法时，某步中间结果不一定能完成整除，就无法求解了。

举个例子：求`3 * 6 / 3` 对 `7` 取模的结果。我们直接算出`3 * 6 / 3`的结果是`6`，对`7`取模得最终答案是 `6` 。但我们通常面对的问题是中间结果超过`int`甚至`long long` 的范围，而不得不在**每一步基于同余理论取模**，我们用这个例子尝试一下：

还是求 `3 * 6 / 3 % 7`

第一步：`3 * 6 == 18`，`18 % 7 == 4`

第二步：`4` 这个中间结果再做 `4 / 3` 无法整除，就无法进行下去了。

**但我们可以求出除数 `3` 关于模数`7`的逆元 `5`**（根据逆元定义，`5` 符合 `3 * 5 % 7 == 1`），从而，**用乘以`5`代替除以`3`**。上述第二步除法变乘法： `4 * 5 == 20`，`20 % 7 == 6`从而也计算出了正确的结果 **`6`** 。

> 也就是说，要找到一个乘法逆元满足，相乘 = 1，然后替代掉我们的除法

![image-20230907163058460](image-20230907163058460.png)

### [拓展欧几里得实现逆元](https://zhuanlan.zhihu.com/p/378728642)

在上面我们了解过了，扩展欧几里得算法则是求`ax+by = gcd(a,b)`的一组可行解:

我们来看它和乘法逆元的关系：

- 逆元： a关于模b的逆元 整数d满足`a*d mod b ≡ 1`
- 拓展欧几里得：求方程`ax+by = gcd(a,b)`的一组可行解

逆元的`a*d mod b ≡ 1`, 等价于 `ad - kb = 1`,其中k为未知整数。

设d为x，`-k为y`，则`ad-kb = 1`转为`ax+by=1` ，也就是求x就可以得到a关于模 b 的逆元。

```c++
//扩展欧几里得算法实现逆元
int exgcd(int a, int b, int &x, int &y) 
{
    if (b == 0) 
    {
        x = 1;
        y = 0;
        return a;
    }
    int r = exgcd(b, a % b, x, y);
    int t = x;
    x = y;
    y = t - a / b * y;
    return r;
}

int inverse(int a, int m) 
{
    int x, y;
    int gcd = exgcd(a, m, x, y);
    return x >= 0 ? x : x + m;
}
```

### 快速幂实现乘法逆元

本质上是使用费马小定理，下面简单介绍一下费马小定理：

费马小定理：对于整数 a 与质数 b ，若 a 与 b 互质，则有：`a^(b-1) mod b ≡ 1`

拆一下也就变成了`a*a^(b-2) mod b ≡ 1` 也就将乘法逆元的公式拼凑成功了。然后就是进行幂的运算，这样使用快速幂即可。

求逆元，就用 `b-2` 和 b 代替 快速幂取模中的 `n` 和 `mod`：

时间复杂度：大约`O(log b)`。

适用范围：一般在模数 `b` 是质数的时候。

下面是实现的具体代码：

```c++
#include <iostream>

using namespace std;

// 计算a的幂次b模m的结果
long long fastModuloExponentiation(long long a, long long b, long long m) {
    long long result = 1;
    a %= m;
    while (b > 0) {
        if (b % 2 == 1) {
            result = (result * a) % m;
        }
        a = (a * a) % m;
        b /= 2;
    }
    return result;
}

// 计算a关于模数m的乘法逆元
long long multiplicativeInverse(long long a, long long m) {
    // 使用快速幂计算a^(m-2) % m
    return fastModuloExponentiation(a, m - 2, m);
}

int main() {
    long long a, m;
    cout << "请输入整数a：";
    cin >> a;
    cout << "请输入模数m：";
    cin >> m;

    long long inverse = multiplicativeInverse(a, m);

    cout << "整数 " << a << " 关于模数 " << m << " 的乘法逆元是：" << inverse << endl;

    return 0;
}

```

## [欧拉函数](https://zhuanlan.zhihu.com/p/151756874)

定义

在[数论](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%95%B8%E8%AB%96)中，对正[整数](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B8)*n*，**欧拉函数φ(n)**是小于或等于*n*的正整数中与*n*[互质](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA)的数的数目。此[函数](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0_(%E6%95%B0%E5%AD%A6))以其首名研究者[欧拉](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E6%AD%90%E6%8B%89)命名，它又称为**φ函数**（由[高斯](https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%E5%8D%A1%E7%88%BE%C2%B7%E5%BC%97%E9%87%8C%E5%BE%B7%E9%87%8C%E5%B8%8C%C2%B7%E9%AB%98%E6%96%AF)所命名）或是**欧拉总计函数**。

例如`φ(8) = 4`，因为`1,3,5,7`均和8互质。

也可以从简化剩余系的角度来解释，简化剩余系(reduced residue system)也称既约剩余系或缩系，是m的完全剩余系中与m[互素](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E4%BA%92%E7%B4%A0/869678)的数构成的[子集](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%AD%90%E9%9B%86/5017034)，如果模m的一个剩余类里所有数都与m互素，就把它叫做与模m互素的[剩余类](https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E5%89%A9%E4%BD%99%E7%B1%BB/3712708)。在与模m互素的全体剩余类中，从每一个类中各任取一个数作为代表组成的集合，叫做模m的一个简化剩余系。

`（1，3，5，7）`就构成了8的一个简化剩余系。

> 欧拉函数的定义是：
>   `Φ(N) = (p1^k1)*(p2^k2)…*(pr^kr)`
>    其中`p1、p2…pr`是大于1的所有不相等的质数，而`k1、k2…kr`是正整数。
>    `Φ(N)`表示小于等于`N`的正整数中，与`N`互质的数之积。欧拉函数的意义就是计算满足特定限制条件的正整数值
>
> 说人话就是，欧拉函数可以把一个数分解成质因数的乘积。

 标准分解式

标准分解式：将质因数分解的结果，按照质因数大小，由小到大排列，并将相同质因数的连乘积，以指数形式表示，此种表示法称为标准分解式。

如2020的标准分解式是

![img](v2-4305f9672e7bf9135245f0f4a9517a48_720w.png)

> 整数（除了0）都可被质因数分解，质因数分解是一个在理论上可行但在实际中对于大整数来说非常耗时的计算问题。

欧拉函数计算方法

（1）先化为标准分解式形式

![img](v2-7fff527aba93db7a2de6722d126b7720_720w.png)

（2）再依照下式规则计算

![img](v2-1b46934f0398099451934b434301000e_720w.png)

例如：

![img](/v2-7944fd84b22ba208a1ecc4873ab1889b_720w.png)

但是获得大整数的标准分解式却很困难

![img](v2-f37804d83b944f0f8f87638a8ea5a897_720w.webp)

下面是实现欧拉函数的一个代码：分解质因数

```c++
//注意欧拉函数只适用于整数
#include <iostream>

using namespace std;

// 计算最大公约数
long long gcd(long long a, long long b) {
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

// 计算欧拉函数
long long euler_phi(long long n) {
    long long result = n;
    for (long long i = 2; i * i <= n; i++) {
        if (n % i == 0) {
            while (n % i == 0)
                n /= i;
            result -= result / i;
        }
    }
    if (n > 1)
        result -= result / n;
    return result;
}

int main() {
    long long n;

    cout << "请输入一个正整数：";
    cin >> n;

    if (n <= 0) {
        cout << "请输入一个大于0的正整数。" << endl;
        return 1;
    }

    long long phi = euler_phi(n);
    cout << "欧拉函数 φ(" << n << ") = " << phi << endl;

    return 0;
}

```

> 欧拉函数简单理解就是，任何一个整数都可以将之质因数分解。

### 欧拉定理

![img](v2-43c417f37ca53e2e888bc01a0333229e_720w.png)

> 对于任何正整数n和与n互质的正整数a（即，a和n没有共同的质因数），以下等式成立：
>
> `a^φ(n) ≡ 1 (mod n)`
>
> 其中，^表示幂运算，`φ(n)`表示欧拉函数（`Euler's Totient Function`），≡ 表示模同余。`φ(n)`表示小于等于n且与n互质的正整数的个数。

```c++
//欧拉定理的代码生成
#include"iostream"

using namespace std;

//定义欧拉函数
long euler(long n)
{
    long ans=n,i,j;
    for ( i=2;i*i<=n;i++)
    {
        if(n%i==0)
        {
            ans=ans-ans/i;
            while(n%i==0) 
            {
                n/=i;
            }
        }
    }
    if(n>1) 
    {
        ans=ans-ans/n;
    }
    return ans;
}

int main()
{
    long n;
 
    cout << "请输入一个正整数：";
    cin >> n;
    cout << "此数的欧拉函数值为："<< euler(n) << endl;
    return 0;
}
```

### [费马小定理](https://www.cnblogs.com/RioTian/p/13938770.html)

对于费马小定理，可以理解为是欧拉函数的一种特殊状态，`a^φ(n) ≡ 1 (mod n)`.下面列出的是欧拉函数的公式

`a^(p-1) ≡ 1 (mod p)` 

这里举一个例子：

`2^5-1 = 2^4 = 16 ≡ 1(mod 5)`

可以看出，mod的这个质数之后会余下1，这个性质朴素存在，但是也有例外：![image-20230907224817684](image-20230907224817684.png)

对于定理的证明，可以观看这个[视频](https://www.youtube.com/watch?v=u2D3Fe41IC0),然后下面是实现费马小定理的代码：

```c++
#include <iostream>

// 计算 (a^b) % mod，使用费马小定理
long long mod_pow(long long a, long long b, long long mod) {
    if (b == 0) {
        return 1;
    }
    long long result = 1;
    a %= mod;
    while (b > 0) {
        if (b % 2 == 1) {
            result = (result * a) % mod;
        }
        a = (a * a) % mod;
        b /= 2;
    }
    return result;
}

// 计算 a 在模 mod 下的逆元，使用费马小定理
long long mod_inverse(long long a, long long mod) {
    return mod_pow(a, mod - 2, mod);
}

int main() {
    long long a = 7; // 你的底数
    long long mod = 13; // 你的模数
    long long result = mod_pow(a, mod - 2, mod);
    std::cout << "逆元: " << result << std::endl;
    return 0;
}

```

> 费马小定理常用于实现别的算法，实现自己的就很少。
>
> 乘法逆元和组合性数学也可以使用这个来实现，了解即可

## [中国剩余定理](https://zhuanlan.zhihu.com/p/44591114)

中国剩余定理是为了解决一元线性同余方程组而存在的，

![image-20230908143445893](image-20230908143445893.png)

假设我们需要解决这样的方程组：

`x = 2 (mod 5)`

`x = 3 (mod 7)`

目的是要求出x的值，假设y是这个函数的解决方法，那么`y+35`也是一个解决方案，所以说只需要找到一个数据`mod 35`，通过暴力算法，可以得到一个数据 `x = 17(mod 35)`.

> `x % 5 = 2`  `原理就是用for循环枚举就行`
>
> `x % 7 = 3`

对于任何这样的方程组，中国剩余定理告诉我们在一定模数范围内总有唯一解，并描述了如何有效找到目标解。

定理：当`p,q`互质，那么方程组

`x = a (mod p)`

`x = b (mod q)`

有一个独特的解决方案`x`模数`pq`

![image-20230908150544523](image-20230908150544523.png)

![image-20230908151047563](image-20230908151047563.png)

> 具体的计算流程：
>
> 1. 确保所有的模数` n₁、n₂、...、nₖ `两两互素。如果它们不互素，你需要将它们分解成互素的模数并分别解决每个子组。
> 2. 计算` M = n₁ * n₂ * ... * nₖ，`即所有模数的乘积。
> 3. 对于每个 i，计算 `Mᵢ = M / nᵢ`，即去除掉 nᵢ 的乘积。
> 4. 对于每个 i，计算 Mᵢ 的模反元素（即 Mᵢ 在模 nᵢ 下的乘法逆元），通常用记号 Mi⁻¹ 表示。这可以使用扩展欧几里得算法来计算。
> 5. 最后，计算 `x = (a₁ * M₁ * M₁⁻¹ + a₂ * M₂ * M₂⁻¹ + ... + aₖ * Mₖ * Mₖ⁻¹) % M。`
>
> 这个 x 就是满足所有模同余方程的解。
>
> 下面是一个简单的示例，以帮助理解：
>
> 考虑以下方程组：
>
> 1. `x ≡ 2 (mod 3)`
> 2. `x ≡ 3 (mod 5)`
> 3. `x ≡ 2 (mod 7)`
>
> 首先，计算` M = 3 * 5 * 7 = 105。`
>
> 然后，计算` M₁ = M / 3 = 35，M₂ = M / 5 = 21，M₃ = M / 7 = 15。`
>
> 接下来，计算 M₁、M₂、M₃ 在模 n₁、n₂、n₃ 下的模反元素：
>
> - `M₁⁻¹ ≡ 35⁻¹ ≡ 2 (mod 3)`
> - `M₂⁻¹ ≡ 21⁻¹ ≡ 1 (mod 5)`
> - `M₃⁻¹ ≡ 15⁻¹ ≡ 1 (mod 7)`
>
> 最后，计算 x：
>
> `x = (2 * 35 * 2 + 3 * 21 * 1 + 2 * 15 * 1) % 105 x = (140 + 63 + 30) % 105 x = 233 % 105 x = 23`
>
> 所以，方程组的解是 `x ≡ 23 (mod 105)。`这就是中国剩余定理的应用示例。

下面是具体实现的代码：

```c++
#include <iostream>
#include <vector>

using namespace std;

// 计算模反元素的函数，使用扩展欧几里得算法
long long mod_inverse(long long a, long long m) {
    long long m0 = m, x0 = 0, x1 = 1;
    while (a > 1) {
        long long q = a / m;
        m = a % m;
        a = m0;
        m0 = m;
        long long temp = x0 - q * x1;
        x0 = x1;
        x1 = temp;
    }
    return x1 < 0 ? x1 + m0 : x1;
}

// 实现中国剩余定理的函数
long long chinese_remainder_theorem(const vector<long long>& a, const vector<long long>& n) {
    // 确保输入的 a 和 n 有相同的长度
    if (a.size() != n.size()) {
        throw invalid_argument("The input vectors must have the same size.");
    }

    long long N = 1;
    for (long long ni : n) {
        N *= ni;
    }

    long long result = 0;
    for (size_t i = 0; i < a.size(); ++i) {
        long long Ni = N / n[i];
        result += a[i] * Ni * mod_inverse(Ni, n[i]);
    }

    return result % N;
}

int main() {
    // 例子：解 x ≡ 2 (mod 3), x ≡ 3 (mod 5), x ≡ 2 (mod 7)
    vector<long long> a = {2, 3, 2};
    vector<long long> n = {3, 5, 7};

    long long solution = chinese_remainder_theorem(a, n);
    cout << "The solution is: " << solution << endl;

    return 0;
}

```

## [高斯消元](https://cloud.tencent.com/developer/article/1087352)

高斯消元法，是线性代数中的一个[算法](https://cloud.tencent.com/developer/tools/blog-entry?target=http%3A%2F%2Flib.csdn.net%2Fbase%2Fdatastructure)，可用来求解线性方程组，并可以求出矩阵的秩，以及求出可逆方阵的逆矩阵。 高斯消元法的原理是： 若用初等行变换将增广矩阵 化为 ，则`AX = B与CX = D`是同解方程组。

所以我们可以用初等行变换把增广矩阵转换为行阶梯阵，然后回代求出方程的解。

![image](5bynwh32a2.png)

构造增广矩阵，即系数矩阵A增加上常数向量b（A|b）  

![image](ahv19vepb0.png)

 通过以交换行、某行乘以非负常数和两行相加这三种初等变化将原系统转化为更简单的三角形式（triangular form）    注：这里的初等变化可以通过系数矩阵A乘上初等矩阵E来实现  

![image](s7at02swx8.png)

 从而得到简化的三角方阵组，注意它更容易解

![image](9uo7gd9be7.png)

 这时可以使用向后替换算法(也就是最后的方程向前带) 求解得  `z=-4/-4=1, y=4-2z=4-2=2, x= (1-y-z)/2=(1-2-1)/2=-1`  

总结上面过程，高斯消元法其实就是下面非常简单的过程

**原线性方程组    ——>    高斯消元法   ——>  下三角或上三角形式的线性方程组      ——> 前向替换算法求解（对于上三角形式，采用后向替换算法）**

![img](f17gajsz1a.png)

下面是思路代码：

```c++
#include <iostream>
#include <vector>

using namespace std;

// 定义矩阵类型，用于存储方程组的系数矩阵
typedef vector<vector<double>> Matrix;

// 高斯消元函数，将方程组化为上三角矩阵
bool gaussian_elimination(Matrix& A, vector<double>& b) {
    int n = A.size();
    
    for (int i = 0; i < n; ++i) {
        // 寻找主元素
        int pivot_row = i;
        for (int j = i + 1; j < n; ++j) {
            if (abs(A[j][i]) > abs(A[pivot_row][i])) {
                pivot_row = j;
            }
        }
        
        // 交换当前行和主元素所在行
        swap(A[i], A[pivot_row]);
        swap(b[i], b[pivot_row]);
        
        // 如果主元素接近于零，则无法继续计算
        if (abs(A[i][i]) < 1e-10) {
            return false;
        }
        
        // 将当前行的主元素缩放为1
        double pivot = A[i][i];
        for (int j = i; j < n; ++j) {
            A[i][j] /= pivot;
        }
        b[i] /= pivot;
        
        // 使用当前行的主元素将下面的行消元
        for (int j = i + 1; j < n; ++j) {
            double factor = A[j][i];
            for (int k = i; k < n; ++k) {
                A[j][k] -= factor * A[i][k];
            }
            b[j] -= factor * b[i];
        }
    }
    
    return true;
}

// 回代函数，解出方程组的解
vector<double> back_substitution(const Matrix& A, const vector<double>& b) {
    int n = A.size();
    vector<double> x(n);
    
    for (int i = n - 1; i >= 0; --i) {
        x[i] = b[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= A[i][j] * x[j];
        }
    }
    
    return x;
}

int main() {
    // 示例方程组的系数矩阵 A 和右侧常数向量 b
    Matrix A = {{2, 1, -1},
                {-3, -1, 2},
                {-2, 1, 2}};
    vector<double> b = {8, -11, -3};

    // 解线性方程组
    if (gaussian_elimination(A, b)) {
        vector<double> solution = back_substitution(A, b);
        cout << "Solution:" << endl;
        for (int i = 0; i < solution.size(); ++i) {
            cout << "x[" << i << "] = " << solution[i] << endl;
        }
    } else {
        cout << "No unique solution exists." << endl;
    }

    return 0;
}

```

## [求质数](https://oi-wiki.org/math/number-theory/sieve/)

### 试除法

如果我们想要知道小于等于n有多少个素数呢？

一个自然的想法是对于小于等于n每个数进行一次质数检验。这种暴力的做法显然不能达到最优复杂度。

```c++
//计算质数的代码(暴力根源)
#include <iostream>  
using namespace std;  
int main()  
{  
    int i, j, count;  
    cout << " 它的2到100间的质数有: \n";  
    for(i=2;i<100;i++)  
    {  
        count = 0;  
        for(j=2;j<i;j++)//判断i是否为质数，若count==0则为质数  
        {  
            if(i%j == 0)  
            {  
                count++;  
                break;  
            }  
        }  
        if(count==0)  
        {  
            cout<<i<<" ";  
        }  
    }  
    cout << "\n";  
}
```

在前面的基础上，加上了合数优化：

- 如果一个数是合数（不是素数），那么它可以被分解为两个或更多个正整数的乘积。

- 如果一个数 `n` 是合数，那么它的最小因子（除了1以外）一定不会大于它的平方根 `sqrt(n)`。

> 基于这两个观察，可以得出合数优化的原理：
>
> - **在判断一个数是否为素数时，只需要检查从2到该数的平方根的整数范围内是否存在能整除该数的整数，而不必遍历整个范围直到该数本身。**
>
> 这是因为如果一个数 `n` 是合数，那么它一定可以被表示为 `n = a * b`，其中 `a` 和 `b` 是两个大于1的整数。如果 `a` 大于 `sqrt(n)`，那么 `b` 必然小于 `sqrt(n)`，因为 `a * b = n`。因此，我们只需要检查从2到 `sqrt(n)` 的整数范围内是否存在能整除 `n` 的整数，如果存在，就可以确定 `n` 是合数。如果不存在，那么 `n` 就很可能是素数。

```c++
//加上合数优化
//这里解决的是，判断这个数据是否为质数
#include<iostream>
using namespace std;

bool i_p(int x)
{
    if(x<2) return false;
    //如果一个数是合数（不是素数），那么它的最小因数一定不会超过它的平方根
    //这个属性可以用反陈述来证明。设 a 和 b 是 n 的两个因子，使得 a*b = n。如果两者都大于 √n，则 a.b > √n， * √n，这与表达式 “a * b = n” 相矛盾。（可以理解为 a 和 b 最大就 √n）
    for(int i = 2;i<=x/i;i++)
        if(x%i == 0) return false;
    return true;   
    
}


int main()
{
    int n;
    cin>>n;
    
    while(n--){
        int x;
        cin>>x;
        if(i_p(x)) puts("Yes");
        else puts("No");
    }
    return 0;
    
    
}
```

### 试除法求约数

前面利用试除法判断一个数据是否为质数，现在求n这个数据内部有多少约数。

```c++
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

vector<int> get_divisors(int x){
    vector<int> res;
    for(int i = 1;i<=x/i;i++)
    //整除流入
        if(x%i == 0){
            //如果i是质因数 - 塞入res数组中
            res.push_back(i); 
            //除数相等的情况 就只有i了嘛
            if(i!=x/i) res.push_back(x/i);
        }
        //排个序 (可不可以用 set存储啊)
        sort(res.begin(),res.end());
        return res;
}


int main()
{
    int n;
    cin>>n;
    
    while (n -- ){
        int x;
        cin>>x;
        auto res = get_divisors(x);
        for( auto x:res) cout<<x<<" ";
        cout<<endl;
    }
    return 0;
    
}
```

下面的代码用于计算一组整数的最小公倍数的约数个数：

```c++
#include<bits/stdc++.h>
using namespace std;

typedef long long LL;
const int N = 110, mod = 1e9 + 7;

int main()
{
    int n;
    cin >> n;
    
    unordered_map<int, int> primes; // 使用哈希表存储质因数及其指数

    while (n--) {
        int x;
        cin >> x;

        // 分解质因数
        for (int i = 2; i * i <= x; i++) {
            while (x % i == 0) {
                x /= i;
                primes[i]++; // 记录每个质因数的指数
            }
        }

        if (x > 1)
            primes[x]++; // 如果剩余的数大于1，说明它本身是一个质数，记录其指数
    }

    LL res = 1;
    for (auto p : primes) {
        res = res * (p.second + 1) % mod;
    }

    cout << res << endl;
    return 0;
}

```

### 质数筛

![定义](https://upload.wikimedia.org/wikipedia/commons/b/b9/Sieve_of_Eratosthenes_animation.gif)

埃拉托色尼筛的原理是这样的：

- 首先，把所有小于等于n的自然数都列出来，从2开始，把1排除掉。
- 然后，从2开始，把它的所有倍数都标记为合数，也就是不是素数的数。
- 接着，**找到下一个没有被标记的数，它一定是素数**，然后把它的所有倍数都标记为合数。重复这个过程，直到没有更多的没有被标记的数为止。
- 最后，所有没有被标记的数就是素数

```c++
#include<iostream>
using namespace std;

const int N = 1e6+10;

int primes[N],cnt;
bool st[N];

void get_primes(int n){
    for(int i = 2;i<=n;i++){
        if(st[i]) continue;
        //  primes[cnt++] = i;的作用是把i这个素数存入primes数组中
        //  并且把cnt加一，表示素数的个数增加了一个。
        primes[cnt++] = i;
        //  这个循环的作用是把i的所有倍数都标记为合数，也就是非素数。
        //  这样，当i增加时，就可以跳过已经被标记为合数的数字，只考虑没有被标记的数字，因为它们可能是素数。
        for(int j = i+i;j<=n;j+=i) st[j] = true;
    }
}


int main()
{
    int n;
    cin>>n;
    get_primes(n);
    cout<<cnt<<endl;
    return 0;
    
}
```

### [线性筛法](https://www.jianshu.com/p/f16d318efe9b)

线性筛法的主要思想是，对于每个数x，只考虑它的最小质因数。初始时，将每个合数（非素数）标记为其最小质因数。然后，从小到大遍历2到n的整数，如果某个数x还没有被标记为合数，那么它就是素数，并且将它的倍数标记为x。

线性筛法的关键是避免多次标记。对于每个数x，它只会被其最小质因数标记一次，因此不会重复标记。这使得线性筛法的时间复杂度相对较低，比传统的埃拉托斯特尼筛法更高效，特别是在生成大量素数时。

> 以下是线性筛法的基本步骤：
>
> 1. 初始化一个布尔数组（或标记数组）`is_prime`，用于标记每个整数是否为素数。初始时，所有数都标记为素数。
> 2. 初始化一个数组`primes`，用于存储生成的素数。初始时，`primes`为空。
> 3. 从2开始遍历到n的每个整数x：
>    - 如果`is_prime[x]`为true，表示x是素数，将x添加到`primes`数组中。
>    - 对于x的每个质因数p（p从2开始，逐渐增加），将x * p标记为合数，并将最小质因数设置为p。
>    - 如果x被标记为合数后，跳出内层循环。
> 4. 当遍历完2到n的所有整数后，`primes`数组中就包含了所有小于等于n的素数。

```c++
//2.线性筛法（埃拉托色尼筛优化版）
#include <iostream>
#include <algorithm>

using namespace std;

const int N= 1000010;

int primes[N], cnt;
bool st[N];

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        //如果i没有被标记为合数，就把它加入到primes数组中，并且把cnt加一。cnt是用来记录素数的个数的变量。这样可以把所有的素数都存储起来，方便后面的使用。
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            //primes[j] * i这个数标记为合数
            st[primes[j] * i] = true;
            //如果i能被primes[j]整除，就跳出循环，这样可以避免重复地标记一些合数。
            if (i % primes[j] == 0) break;
        }
    }
}

int main()
{
    int n;
    cin >> n;

    get_primes(n);

    cout << cnt << endl;

    return 0;
}

```

## [求组合数](https://segmentfault.com/a/1190000005072018)

### 组合计数

 在中学数学中，我们其实已经学会了组合数的公式了，基础的公式是：

![img](webp.webp)

线性写法为：`c(m,n) = m!/((m-n)!*n!)`

但是，如果按照公式计算，时间复杂度非常高，下面是一个原始组合数模版代码：

```c++
#include <iostream>
using namespace std;

// 计算阶乘
unsigned long long factorial(int n) {
    if (n == 0 || n == 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

// 计算组合数
unsigned long long combination(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    } else {
        return factorial(n) / (factorial(k) * factorial(n - k));
    }
}

int main() {
    int n, k;
    cout << "请输入总数n：";
    cin >> n;
    cout << "请输入要选择的元素数k：";
    cin >> k;

    unsigned long long result = combination(n, k);

    cout << "组合数 C(" << n << ", " << k << ") = " << result << endl;

    return 0;
}

```

这个代码使用的是递归的思想，来计算这个组合数，当然在这个模版的基础上，我们也可以将之优化.

------------------------------

采用阶乘计算稍大数组合数是不合适的，而且效率不高，但是可以先对公式进行转换然后再进行计算：
 **1.对公式两边取自然对数**

![2475558-a800e7d9bea07740](2475558-a800e7d9bea07740.webp)

**2.根据对数性质进行转换**

![2475558-576a246a59455baa](2475558-576a246a59455baa.webp)

![2475558-14dada8828552c4c](2475558-14dada8828552c4c.webp)

- 消除相同项![2475558-cd4aabbfde8e8344](2475558-cd4aabbfde8e8344.webp)

- 到这就已经将阶乘转换成对数连加，极大的降低了运算的复杂度。另外，依据组合数性质：![2475558-5cf3a8040bf13892](2475558-5cf3a8040bf13892.webp)

当 `n > m/2 `时，`n 相对于 m - n `是一个较大的数，此时可以取 `n = m - n`进行计算。

**3.进行计算**
 以第2步得到的公式计算出

![img](2475558-b30e33e52cf70ad7.webp)

的值，然后再取反对数就可以得到组合数结果了。

用这种方法计算组合数，如果只计算`ln(C(m,n))`的话，`n`可以取到整型数据的极限值`65535，ln(C(65535,32767)) = 45419.6`

而计算时间可以达到毫秒级。当然，如果要取反对数得到最终的组合数的话，m的取值就不能达到这么大了，但是这种算法仍然可以保证m取到`1000`以上。

--------

```c++
#include <iostream>
#include <cmath>

// 计算组合数的自然对数
double logCombination(int n, int k) {
    if (k < 0 || k > n) {
        return 0.0;
    }

    double result = 0.0;

    for (int i = 1; i <= k; i++) {
        result += log(static_cast<double>(n - i + 1)) - log(static_cast<double>(i));
    }

    return result;
}

int main() {
    int n, k;
    std::cout << "请输入总数n：";
    std::cin >> n;
    std::cout << "请输入要选择的元素数k：";
    std::cin >> k;

    double result = exp(logCombination(n, k)); // 恢复为普通数值

    std::cout << "组合数 C(" << n << ", " << k << ") = " << result << std::endl;

    return 0;
}

```

### 卢卡斯定理

卢卡斯定理（Lucas's Theorem）是一种与组合数和模运算相关的数学定理，它扩展了二项式定理的应用，特别适用于计算组合数模素数的情况。该定理以法国数学家Édouard Lucas的名字命名。

卢卡斯定理的主要内容是描述如何将组合数C(n, k) 模素数p 分解为更小的组合数的乘积，然后再模p运算。具体来说，定理陈述如下：

对于给定的正整数n、k 和素数p（p 必须大于n），可以将组合数C(n, k) 模p 分解为以下形式的乘积：

C(n, k) ≡ C(n mod p, k mod p) * C(n/p, k/p) (mod p)

其中，C(n mod p, k mod p) 表示将n 和k 分别模p 后的余数所对应的组合数，C(n/p, k/p) 表示将n 和k 分别除以p 后的商所对应的组合数。

卢卡斯定理在计算组合数模素数时非常有用，因为它可以将大的组合数分解成小的组合数，并通过模运算得到结果，从而避免大整数计算。

![image-20230317192018240](image-20230317192018240.png)

![image-20230317192035378](image-20230317192035378.png)

```c++
#include <iostream> 
using namespace std;
int f[20][20];//定义二维数组，用来中间存储计算结果 
int cmn(int m,int n)  
{     
    int i,j;
    for(i=0;i<=m;++i)  //循环m步，从0开始 
       for(j=0;j<=n;++j)  //循环n步，也是从0开始  
        if(j==0||i==j)    //当i等于0或者i等于j时，直接赋值为1 
           f[i][j]=1;
        else 
           f[i][j]=f[i-1][j-1]+f[i-1][j];//其他的都是在上一步的计算结果上加+1，依次类推
     return f[m][n];  //返回结果 
}
int main()
{
    int m,n;
    cout<<"请输入任意m.n来得到组合数：";
    cin>>m>>n;
    int result=cmn(m,n);
    cout<<m<<"C"<<n<<"="<<result<<endl; //输出结果
    return 0;
}
```
