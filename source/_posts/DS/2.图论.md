---
title: 图论
date: 2023-04-28 09:05:38
categories: 算法
tags: 数据结构
description: 包括树，图
typora-root-url: ./2.图论
---

## 图论

> 参考了：https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/#_2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E4%BB%8B

图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种

- 是竖向的dfs递归遍历
- 是横向的bfs递归遍历。

### 树

树是由N个节点构成的有限集合，当N=0的时候称之为空树。树也可以看做是存储数据的一种数据类型，其逻辑结构常见的有二叉树，完全二叉树等等；树的节点和数的深度是有关系的，对于一个深度为K的满二叉树来说，它的节点个数`2^K-1`其中减去1是减去了根节点。

一个树且当N>1的时候，其余节点可以分为M个有限互不相交的有限集合。每一个节点算是一个独立的树，称之为根的子树。在树中，与其他数据结构一样，有前驱和后继的设定。对于根节点来说，它没有直接前驱。对于底部的节点来说，它没有直接后继。

树适合表示有层级的结构的数据，类似于游戏中的阶段，或者随机生成的地图。都需要记录前一个状态，然后跳转到另一个状态。状态的区别就是其节点的子和父属性。

一个树有几种属性

- 结点：组成树的基本变量
- 度：结点孩子个数
- 深度，高度和层次：深度从根节点开始向下计数，高度从叶节点向上计数。如果我们知道一个二叉树的节点个数，那么可以估计高度的数量级大概为`h=log2(N+1)`

![树](./20240511171215-1723797363701-239.png)

#### 二叉树

使用的最多和最基础的就是二叉树，二叉树是有N个节点构成的有限集合。其中，结点为0、只有根节点、只有左子树、只有右子树、左右子树都有和只有右子树，以上这些都是二叉树的形态。

⼆叉树是种特殊的树，它最多有两个⼦树，分别为左⼦树和右⼦树，并且两个子树是有序的，不可以互换。也就是说，在⼆叉树中不存在度⼤于 2 的节点。

##### 满二叉树

如图是一个满二叉树，可以看到每一个层级中，其节点个数都是符合`2^n（n为层级）`

![二叉树](./20240511171342-1723797363701-238.png)

满二叉树满足以下特点：

- 叶子节点只出现在最下面一层。
- 非叶子节点的度一定为 2。
- 在同等深度的二叉树中，满二叉树的节点个数最多，叶子节点个数最多。

如果我们对满二叉树的节点进行编号，根节点编号为 1，然后按照层次依次向下，每一层从左至右的顺序进行编号。则深度为 k 的满二叉树最后一个节点的编号为 2*k*−1。

##### 完全二叉树

在完全二叉树中，除了最底层外，其余每一层的节点数都达到了最大值。最底层的节点全部集中在最左侧，且可能未完全填满。如果最底层为第 h 层，则该层包含的节点数范围为 1 到 2^h−1 个。完全二叉树满足以下特点：

- 叶子节点只能出现在最下面两层。
- 最下层的叶子节点一定集中在该层最左边的位置上。
- 倒数第二层如果有叶子节点，则该层的叶子节点一定集中在右边的位置上。
- 如果节点的度为 1，则该节点只偶遇左孩子节点，即不存在只有右子树的情况。
- 同等节点数的二叉树中，完全二叉树的深度最小。

![image-20230216131827500](/image-20230216131827500-16923746582101-1721820002716-2.png)

#### [二叉搜索树](https://algo.itcharge.cn/07.Tree/02.Binary-Search-Tree/01.Binary-Search-Tree/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)

二叉搜索树（建立在完全二叉树的基础之上）有如下的规则（简单来说，左节点小于父节点，右节点大于父节点）

- 若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；
- 若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；
- 它的左、右⼦树也分别为⼆叉搜索树

![二叉搜索树](./20240511171406-1723797363701-240.png)

##### 平衡二叉搜索树

平衡二叉搜索树：一种结构平衡的二叉搜索树。即叶节点高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉搜索树。平衡二叉树可以在` O(logn) `内完成插入、查找和删除操作。又被称为`AVL（Adelson-Velsky and Landis）`树，满足以下性质：

- 空二叉树是一棵 AVL 树。
- 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 `∣h(ls)−h(rs)∣≤1` 是左子树的高度，`h(rs)` 是右子树的高度。
- AVL 树的高度为 `O(logn)`

![image-20230216133247245](/image-20230216133247245-16923744811933-1721820002716-3.png)

#### 实现二叉树

二叉树的存储结构分为两种：「顺序存储结构」和「链式存储结构」

##### 顺序存储结构

使用顺序存储结构实现二叉树，也就是使用一维数组存储二叉树的节点，节点存储位置则采用完全二叉树的节点层次编号，按照层次从上至下，每一层从左至右的顺序依次存放二叉树的数据元素。在进行顺序存储时，如果对应的二叉树节点不存在，则设置为「空节点」。

![image-20230216134441813](./image-20230216134441813-16923744802222-1721820002716-4-1723797363701-243.png)

数组模拟二叉树，原理是改数组索引定义，采用`0-based`索引，也就是数组的0号位置设置为根节点，具体操作：

- 对于任意节点的索引为`i`，它的左子节点的索引为`2i + 1`。

- 它的右子节点的索引为`2i + 2`。

- 它的父节点的索引为`(n - 1) / 2`（当n不为0时）。

```c++
//结构体定义节点属性
struct TreeNode{
  int val;
  TreeNode *left; //定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数初始化  
};

// 构建二叉树
TreeNode* buildTree(vector<int>& arr, int index) {
    if (index >= arr.size() || arr[index] == -1) {
        return nullptr; // 返回空指针表示空节点
    }

    TreeNode* root = new TreeNode(arr[index]);
    root->left = buildTree(arr, 2 * index + 1); // 构建左子树
    root->right = buildTree(arr, 2 * index + 2); // 构建右子树

    return root;
}
```

对于完全二叉树（尤其是满二叉树）来说，采用顺序存储结构比较合适，它能充分利用存储空间；而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。并且，由于顺序存储结构固有的一些缺陷，会使得二叉树的插入、删除等操作不方便，效率也比较低。对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。

##### 链式存储结构

二叉树采用链式存储结构时，每个链节点包含一个用于数据域 val，存储节点信息；还包含两个指针域 left 和 right，分别指向左右两个孩子节点，当左孩子或者右孩子不存在时，相应指针域值为空。二叉链节点结构如下图所示。

![二叉链节点](./20240511171434-1723797363701-248.png)

链式存储结构实现二叉树很好理解，每一个节点都由指向左右子树的指针。下面是实现节点的伪代码

```c++
// 输入：一个数组 arr，其中 arr[i] 表示二叉树节点 i 的值，-1 表示该节点为空
// 输出：二叉树存储在数组中的形式

function buildBinaryTree(arr):
    for each index i in arr:
        if arr[i] == -1:
            continue // 跳过空节点
        node_value = arr[i]  // 当前节点的值

        // 计算左子节点的索引
        left_index = 2 * i + 1
        if left_index < length(arr):
            left_child = arr[left_index]

        // 计算右子节点的索引
        right_index = 2 * i + 2
        if right_index < length(arr):
            right_child = arr[right_index]

    return arr  // 返回构造好的顺序存储结构的二叉树
```

二叉树的链表存储结构具有灵活、方便的特点。节点的最大数目只受系统最大可存储空间的限制。一般情况下，二叉树的链表存储结构比顺序存储结构更省空间（用于存储指针域的空间开销只是二叉树中节点数的线性函数），而且对于二叉树实施相关操作也很方便，因此，一般我们使用链式存储结构来存储二叉树。

![二叉树的链式存储结构](./20240511171446-1723797363701-241.png)

#### 二叉树遍历

> 二叉树遍历可以用递归实现

假设我们要查找e这个位置的数据，依靠上帝视角我们可以直接`0-1-4`即可查询。但是如果这个树十分庞大导致无法一眼看出，而且计算机也无法做到这么复杂的识别方式。最简单的方法就是一条线查找下去（从左到右）或者说一层层查找（从上到下）。

![image-20230216134441813](./image-20230216134441813-16923744802222-1721820002716-4-1723797363701-243.png)

现在是在一个二叉树内找数据，从一个节点到另一个节点只有两种方式，要么向左要么向右。而每个节点只有两种情况，要么有值要么没值。遍历的过程每一条线都是独立的，且每次遍历都高度相似（因为向下延伸只有两种方式）。终止条件就是找到我们需要的值。所以说这样的遍历方式符合使用递归的情况，以下是用递归实现遍历二叉树的代码：

> 二叉树的遍历有三种。前中后序遍历，但是基本上是差不多的，我们可以通过这三个遍历来看看改变递归函数的语句会产生什么变化。

在遍历构造之前，我们先构造树。

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};
```

##### 前序遍历

二叉树的前序遍历规则为：

- 如果二叉树为空，则返回。
- 如果二叉树不为空，则：
  1. 访问根节点。
  2. 以前序遍历的方式遍历根节点的左子树。
  3. 以前序遍历的方式遍历根节点的右子树

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};

void PT(TreeNode root)
{
    //如果访问的节点没有子节点
    if(nullptr == root) return;
    
    //打印遍历的节点数据
    cout<<root->data;
    
    //遍历左子树
    PT(root -> left);
    
    //遍历右子树
    PT(root -> right);    
    
}
```

如下图所示，该二叉树的前序遍历顺序为：**`A−B−D−H−I−E−C−F−J−G−K`**

![二叉树的前序遍历](./20240511171628-1723797363701-242.png)

二叉树的前序遍历递归实现的过程，实际上就是调用系统栈的过程。我们也可以使用一个显式栈 stack 来模拟递归的过程。

> 事实上，递归函数就是用栈来实现的

前序遍历的顺序为：根节点 - 左子树 - 右子树，而根据栈的「先入后出」特点，所以入栈的顺序应该为：先放入右子树，再放入左子树。这样可以保证最终遍历顺序为前序遍历顺序。

二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
   - 弹出栈顶元素 node，并访问该元素。
   - 如果 node 的右子树不为空，则将 node 的右子树入栈。
   - 如果 node 的左子树不为空，则将 node 的左子树入栈。

##### 中序遍历

二叉树的中序遍历规则为：

- 如果二叉树为空，则返回。
- 如果二叉树不为空，则：
  1. 以中序遍历的方式遍历根节点的左子树。
  2. 访问根节点。
  3. 以中序遍历的方式遍历根节点的右子树。

```c++
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
  //和上面相比，就改变了顺序
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}
```

从二叉树的中序遍历规则可以看出：中序遍历过程也是一个递归过程。在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后访问根节点，最后再遍历子树根节点的右子树的顺序进行遍历。

如下图所示，该二叉树的中序遍历顺序为：**H−D−I−B−E−A−F−J−C−K−G**

> 中序遍历是指，中间节点永远夹在在遍历左右节点之间

![二叉树的中序遍历](./20240511171643-1723797363701-247.png)

##### 后序遍历

二叉树的后序遍历规则为：

- 如果二叉树为空，则返回。
- 如果二叉树不为空，则：
  1. 以后序遍历的方式遍历根节点的左子树。
  2. 以后序遍历的方式遍历根节点的右子树。
  3. 访问根节点。

从二叉树的后序遍历规则可以看出：后序遍历过程也是一个递归过程。在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后遍历子树根节点的右子树，最后再访问根节点的顺序进行遍历。

如下图所示，该二叉树的后序遍历顺序为：**H−I−D−E−B−J−F−K−G−C−A**

```c++
// 后序遍历二叉树
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    postorderTraversal(root->left); //左子树变为新的根节点
    postorderTraversal(root->right); //右子树变为新的根节点
    cout << root->data << " ";
}
```

> 这里模拟一下，访问到H节点，由于H节点无直接后继，那么其执行的两个函数的返回值将是空。
>
> ```c++
> postorderTraversal(root->left); //左子树变为新的根节点
> postorderTraversal(root->right); //右子树变为新的根节点
> ```
>
> 也就是说，这个时候打印的节点信息就是H这个点的节点信息了。第一次访问到的节点必定是H节点，因为在递归栈中，先压入的都是这个函数。
>
> ```c++
> postorderTraversal(root->left); //左子树变为新的根节点
> ```
>
> 压到H这个节点的时候结束程序，也就输出H的这个程序弹出栈了。也就是第一次执行完成了上面的程序，然后再压入；重复上述流程，就可以用后续遍历输出所有节点的值了。
>
> ```c++
> postorderTraversal(root->right); //右子树变为新的根节点
> ```
>
> 后续遍历：直观的描述就是每一个子树的根节点最后遍历到，也就是相对于左右子节点来说最后一个输出根节点的值（每一个子树）。

![二叉树的后序遍历](./20240511171658-1723797363701-244.png)

##### 层序遍历

二叉树的层序遍历：遍历过程是一个广度优先搜索过程。在遍历的时候是按照第 1 层、第 2 层、…… 最后一层依次遍历的，而同一层节点则是按照从左至右的顺序依次访问的。

如下图所示，该二叉树的层序遍历顺序为：**A−B−C−D−E−F−G−H−I−J−K**

![二叉树的层序遍历](./20240511175431-1723797363701-245.png)

二叉树的层序遍历是通过**队列**来实现的。具体步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 令根节点入队。
3. 当队列不为空时，求出当前队列长度 si
4. 依次从队列中取出这 si 个元素，并对这 si 个元素依次进行访问。然后将其左右孩子节点入队，然后继续遍历下一层节点。
5. 当队列为空时，结束遍历。

二叉树的层序遍历代码实现如下：

```c++
// 直到队列为空
// 二分搜索树的层序遍历
public void levelOrder(){

    // 我们使用LinkedList来作为我们的队列
    LinkedList<Node> q = new LinkedList<Node>();
    q.add(root);
    while( !q.isEmpty() ){

        Node node = q.remove();

        System.out.println(node.key);
  
        if( node.left != null )
            q.add( node.left );
        if( node.right != null )
            q.add( node.right );
    }
}
```

#### [二叉树的还原](https://algo.itcharge.cn/07.Tree/01.Binary-Tree/04.Binary-Tree-Reduction/#_1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%98%E5%8E%9F%E7%AE%80%E4%BB%8B)

如果已知节点的某种遍历序列，能否确定这棵二叉树呢？并且确定的二叉树是否是唯一的呢？

我们先来回顾一下二叉树的前序遍历、中序遍历、后序遍历规则。

- 非空二叉树的前序遍历规则：
  1. 访问根节点。
  2. 以前序遍历的方式遍历根节点的左子树。
  3. 以前序遍历的方式遍历根节点的右子树。
- 非空二叉树的中序遍历规则：
  1. 以中序遍历的方式遍历根节点的左子树。
  2. 访问根节点。
  3. 以中序遍历的方式遍历根节点的右子树。
- 非空二叉树的后序遍历规则：
  1. 以后序遍历的方式遍历根节点的左子树。
  2. 以后序遍历的方式遍历根节点的右子树。
  3. 访问根节点。

#### [线段树](https://algo.itcharge.cn/07.Tree/03.Segment-Tree/01.Segment-Tree/#_4-1-rmq-%E9%97%AE%E9%A2%98)

#### [树状数组](https://algo.itcharge.cn/07.Tree/04.Binary-Indexed-Tree/)

#### [并查集](https://algo.itcharge.cn/07.Tree/05.Union-Find/)

给定一个二叉树，任选两个节点，求出二者延伸出的最近父结点，例如：

![clipboard.png](/bV2odt-1721820002718-56.png)

朴素算法就是，先将两个节点在同一层，然后一步一步往上走就是。

```c++
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7, MAX_M = 500000+7;

int n,m,s;
int d[MAX_N]; //保存节点深度
int f[MAX_N]; //保存节点的父节点

int head[MAX_N], cnt=-1;
struct Edge{
    int to , next;
}e[MAX_N*2];

void add(int u,int v){
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u,int fa) // u为当前节点,fa为父节点
{
    f[u] = fa;
    d[u] = d[fa]+1;
    for(int i=head[u];i!=-1;i=e[i].next){
        int v = e[i].to;
        if(v!=fa)
            dfs(v,u);
    }
}

int lca(int x,int y)
{
    if(d[x]>d[y])  //令y为更深节点
     swap(x,y);
    //协同高度
    while(d[x]<d[y])
        y = f[y]; //向上移动 - 协同高度
    //移动到同一节点
    while(x!=y)
        x = f[x],y = f[y];
    //最后的可能就是根节点了
    if(x==0)
        x=s;
    return x;
}

int main()
{
    memset(head,-1,sizeof(head));
    int a,b;
    scanf("%d%d%d",&n,&m,&s);
    for(int i=1;i<n;i++)
    {
        scanf("%d%d",&a,&b);
        add(a,b);
        add(b,a);                      //无向图，要加两次
    }
    dfs(s,0);

    for(int i=1;i<=m;i++)
    {
        scanf("%d%d",&a,&b);
        printf("%d\n",lca(a,b));
    }

    return 0;
}
```

#### 哈夫曼树

### 图

> **图（Graph）**：由顶点的非空有限集合 V （由 n>0 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)

- **顶点（Vertex）**：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。
- **边（Edge）**：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=⟨u,v⟩，表示从 u 到 v 的一条边，其中 u 称为起始点，v 称为终止点。

![img](./20220307145142-1723797363701-246.png)

- **子图（Sub Graph）**：对于图 G=(V,E) 与 G′=(V′,E′)，如果存在 V′⊆V，E′⊆E，则称图 G′ 是图 G 的一个子图。在下面的示意图中我们给出了一个图 *G* 及其一个子图 *G*′。特别的，根据定义，G 也是其自身的子图。

![img](./20220317163120-1723797363701-249.png)

#### 图的分类

##### 有向图与无向图

按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。

- **无向图（Undirected Graph）**：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。
- **有向图（Directed Graph）**：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。

在无向图中，每条边都是由两个顶点组成的无序对。例如下图左侧中的顶点 v1 和顶点 v2 之间的边记为 (v1,v2) 或 (v2,v1)

在有向图中，有向边也被称为弧，每条弧是由两个顶点组成的有序对，例如下图右侧中从顶点 v1 到顶点 *v*2 的弧，记为 ⟨*v*1,*v*2⟩，v1 被称为弧尾，v2 被称为弧头，如下图所示。

![img](./20220307160017-1723797363701-250.png)

如果无向图中有 n 个顶点，则无向图中最多有 n×(n−1)/2n 条边。而具有 n*×(*n−1)/2 条边的无向图称为 **「完全无向图（Completed Undirected Graph）」**。

如果有向图中有 n 个顶点，则有向图中最多有 n×(n−1) 条弧。而具有 n×(n−1) 条弧的有向图称为 **「完全有向图（Completed Directed Graph）」**。

如下图所示，左侧为包含 4 个顶点的完全无向图，右侧为包含 4 个顶点的完全有向图。

![img](./20220308151436-1723797363701-254.png)

下面介绍一下无向图和有向图中一个重要概念 **「顶点的度」**。

- **顶点的度**：与该顶点 vi 相关联的边的条数，记为 TD(vi)

例如上图左侧的完全无向图中，顶点 v3 的度为 3。

而对于有向图，我们可以将顶点的度分为 **「顶点的出度」** 和 **「顶点的入度」**。

- **顶点的出度**：以该顶点 vi 为出发点的边的条数，记为 OD(vi)。
- **顶点的入度**：以该顶点 vi为终止点的边的条数，记为 ID(vi)。
- 有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 TD(vi)=OD(vi)+ID(vi)。

例如上图右侧的完全有向图中，顶点 v3 的出度为 3，入度为 3，顶点 v3 的度为 3+3=6

##### 环形图和无环图

如果顶点 vi0 可以通过一系列的顶点和边，到达顶点 vim，则称顶点 vi0 和顶点 vim 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。

- **环（Circle）**：如果一条路径的起始点和终止点相同（即 vi0==vim），则称这条路径为「回路」或者「环」。
- **简单路径**：顶点序列中顶点不重复出现的路径称为「简单路径」。

而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。

- **环形图（Circular Graph）**：如果图中存在至少一条环路，则该图称为「环形图」。
- **无环图（Acyclic Graph）**：如果图中不存在环路，则该图称为「无环图」。

特别的，在有向图中，如果不存在环路，则将该图称为「有向无环图（Directed Acyclic Graph）」，缩写为 DAG。因为有向无环图拥有为独特的拓扑结构，经常被用于处理动态规划、导航中寻求最短路径、数据压缩等多种算法场景。

如下图所示，分别为：无向无环图、无向环形图、有向无环图和有向环形图。其中有向环形图中的顶点 v1、v2、v3 与相连的边构成了一个环。

![环形图和无环图](./20220317115641-1723797363701-253.png)

##### 连通图和非连通图

在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称顶点 vi 和 vj 是连通的。

- **连通无向图**：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。
- **非连通无向图**：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。

如下图所示，左侧图中 v1 与 v2、v3、v4、v5、v6 都是连通的，所以该图为连通无向图。右侧图中 v1 与 v2、v3、v4 都是连通的，但是 v1 和 v5、v6 之间不存在任何路径，则该图为非连通无向图。

![img](./20220317163249-1723797363701-251.png)

下面介绍一下无向图的「连通分量」概念。有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的「连通分量」。

- **连通子图**：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。
- **连通分量**：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。
- **极⼤连通⼦图**：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。

例如上图中右侧的非连通无向图，其本身是非连通的。但顶点 v1、v2、v3、v4 与其相连的边构成的子图是连通的，并且不存在包含它的更大的连通子图了，所以该子图是原图的一个连通分量。同理，顶点 v5、v6 与其相连的边构成的子图也是原图的一个连通分量。

##### 强连通有向图和强连通分量

在有向图中，如果从顶点 vi 到 vj 有路径，并且从顶点 vj 到 vi 也有路径，则称顶点 vi 与 vj 是连通的。

- **强连通有向图**：如果图中任意两个顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通有向图。
- **非强连通有向图**：如果图中至少存在一对顶点之间不存在任何路径，则该图称为非强连通有向图。

如下图所示，左侧图中任意两个顶点之间都有路径，则左侧图为强连通有向图。右侧图中顶点 v7 无法通过路径到达其他顶点，则右侧图为非强连通有向图。

![img](./20220317133500-1723797363701-252.png)

与无向图类似，有向图的一个极大强连通子图称为该图的 **强连通分量**。

- **强连通子图**：如果有向图的子图是连通有向图，则该子图称为原图的强连通子图。
- **强连通分量**：有向图中的一个极⼤强连通⼦图，称为该图的强连通分量。
- **极⼤强连通⼦图**：有向图中的一个强连通子图，并且不存在包含它的更大的强连通子图。

例如上图中，右侧的非强连通有向图，其本身不是强连通的（顶点 v7 无法通过路径到达其他顶点）。但顶点 v1、v2、v3、v4、v5、v6 与其相连的边构成的子图（即上图的左侧图）是强连通的，并且不存在包含它的更大的强连通子图了，所以该子图是原图的一个强连通分量（即上图中的左侧图是右侧图的强连通分量）。同理，顶点 v7 构成的子图也是原图的一个强连通分量。

##### 带权图

有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 **权**。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。

- **带权图**：如果图的每条边都被赋以⼀个权值，这种图称为带权图。
- **网络**：带权的连通⽆向图称为⽹络。

在下面的示意图中，我们给出了一个带权图的例子。

![img](./20220317135207-1723797363701-255.png)

##### 稠密图和稀疏图

根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。

- **稠密图（Dense Graph）**：有很多条边或弧（边的条数 e 接近于完全图的边数）的图称为稠密图。
- **稀疏图（Sparse Graph）**：有很少条边或弧（边的条数 e 远小于完全图的边数，如 e*<*n×log2n）的图称为稀疏图。

#### 图的存储方式

图的结构比较复杂，我们需要表示顶点和边。一个图可能有任意多个（有限个）顶点，而且任何两个顶点之间都可能存在边。我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。

图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。

接下来我们来介绍几个常用的图的存储结构。在下文中，我们约定用 n 代表顶点数目，m代表边数目，TD(vi) 表示顶点 vi 的度。

##### 领接矩阵

邻接矩阵是使用二维数组来存储图像，每一个位置表示一个坐标，对应坐标中的值表示权。权的意思是从一个节点到另一个节点的距离。如果当前节点没有下一个坐标的话，其权的值标记为无穷大，表示不可达。

在下面的示意图中，左侧是一个无向图，右侧则是该无向图对应的邻接矩阵结构。

![img](./20220317144826-1723797363701-256.png)

邻接矩阵的特点：

- 优点：实现简单，并且可以直接查询顶点 vi与 vj 之间是否有边存在，还可以直接查询边的权值。
- 缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 n*>105）时，使用邻接矩阵建立一个 n*×*n* 的二维数组不太现实。所有邻接表只适合用于稠密图

![image-20230305080127311](./image-20230305080127311-1721820002717-12-1723797363701-257.png)

```c++
//领接矩阵声明，开一个二维数组； 
//1.二维数组w[u][v],存储u - v的边权（就是这个连线多长）
//2.只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）
//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系
#include<iostream>
using namespace std;

int w[N][N]; //声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c
int vis[N];//点集

void dfs(int u){
    vis[u] = true;
    for(int v = 1;v<=n;v++){
        printf("%d,%d,%d\n",u,v,w[u][v]);
        if(vis[u]) continue;
        dfs(v);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b;
        w[a][b] = c; //赋予权值（a点 和 b点）（算是连线）
        //w[b][a] = c;
    }
    //遍历打印
    dfs(1);
    return 0;
}
```

##### 边集数组

**边集数组（Edgeset Array）**：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点 vi、终点 vj 和边的权值 val（如果是带权图）。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的边集数组结构。

![img](./20220317161454-1723797363701-258.png)

采用边集数组计算节点的度或者查找某条边时，需要遍历整个边集数组，时间复杂度为 O(m)，`m` 是边的数量。**除非特殊必要，很少用使用边集数组来存储图。**

一般来说，边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任何一条边的运算。

![image-20230305080154969](./image-20230305080154969-1721820002716-7-1723797363701-259.png)

声明了一个结构体，存储我们两个节点对应的边。好处就是不用按照数组下标开对应大的数组。声明两个变量存储对应的节点序列，然后声明一个变量存储权即可。

```c++
//边集数组
//结构体下标联系三者
#include<iostream>
using namespace std;
struct edge(){
    int u,v,w; //两点 和 权
}e[M]; //边集合
int vis[N]; //点

//理解每个眼神只有一个值
//bfs负责深度 - for负责宽度
void bfs(int u){
    vis[u] = true;
    for(int i = 1;i<=m;i++){
        int v = e[i].v,w = e[i].w; //用结构体中对应的值
        printf("%d,%d,%d",u,v,w);
        if(vis[v]) continue; //这个点到过了
        dfs(e[i].v);//下一个点
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++)
    {
        cin>>a>>b>>c;
        e[i] = {a,b,c};
        //e[i] = {b,a,c}; //无向图就要加上
    }
    dfs(1);
    return 0;
}
```

##### 领接表

**邻接表（Adjacency List）**：使用顺序存储和链式存储相结合的存储结构来存储图的顶点和边。其数据结构包括两个部分，其中一个部分是数组，主要用来存放顶点的数据信息，另一个部分是链表，用来存放边信息。

![image-20230302110544398](./image-20230302110544398-1721820002716-10-1723797363701-260.png)

在邻接表的存储方法中，对于对图中每个顶点 vi 建立一个线性链表，把所有邻接于 vi 的顶点链接到单链表上。这样对于具有 `n` 个顶点的图而言，其邻接表结构由 `n` 个线性链表组成。

然后我们在每个顶点前边设置一个表头节点，称之为「顶点节点」。每个顶点节点由「顶点域」和「指针域」组成。其中顶点域用于存放某个顶点的数据信息，指针域用于指出该顶点第 `1` 条边所对应的链节点。

为了方便随机访问任意顶点的链表，通常我们会使用一组顺序存储结构（数组）存储所有「顶点节点」部分，顺序存储结构（数组）的下标表示该顶点在图中的位置。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的邻接表结构。

![img](./20220317154531-1723797363701-261.png)

```c++
//领接表（将图用dfs序输出） - 父节点和子节点的连接方式
//出边数组e[u][i] 存储u点的所有出边{终点 v,边权 w}。
#include<iostream>
using namespace std;

struct edga{int v,w;}; //声明结构体（代表每个点有的属性）
vector<edga> e[N];//存储的是每一个起点（有n个）

void dfs(int u,int fa)
{
    for(auto ed:e[u]) //遍历当前层的元素
    {
        int v = ed.v,w = ed.w;
        if(v==fa) continue;//(记录父结点)（u和fa是交替使用的）
        printf("%d，%d,%d\n",u,v,w);
        dfs(v,u);//fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）
    }   
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图 两边都要连接
        //{}结构体的插入方式
        e[a].push_back({b,c});
        e[b].push_back({c,b});
    }
    //1.从哪一个点开始深搜  2.当前节点的父节点
    dfs(1,0);
    return 0;   
    
}
```

##### 链式领接表

![image-20230302111110291](./image-20230302111110291-1721820002716-8-1723797363701-262.png)

`h`数组存储插入数据的编号，在这里也就是输入的`e`这些节点编号。`e`数组存储的是两个不同的节点连接的信息。

```c++
//1.表头数据存储读入数据的顺序，然后给边编号 - 节点的出边的索引
//2.边集数组存储的是边的信息
#include<iostream>
using namespace std;

struct edge{int u,v,w};
vector<edge> e; //边集合（边的属性）
vector<int> h[N]; //点的所有出边

void add(int a,int b,int c)
{
    e.push_back({a,b,c}); // 对应边的属性压入
    h[a].push_back(e.size()-1); //边号
}
//u当前节点 fa-父节点
void dfs(int u,int fa)
{
    for(int i = 0;i<h[u].size();i++){
        int j = h[u][i];//输入点编号顺序 - 表示u连i
        int v = e[j].v,w = e[j].w;
        if(v == fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //邻接表存储数据
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）
    return 0;
    
    
}
```

##### 链式前向星

**链式前向星（Linked Forward Star）**：也叫做静态邻接表，实质上就是使用静态链表实现的邻接表。链式前向星将边集数组和邻接表相结合，可以快速访问一个节点所有的邻接点，并且使用很少的额外空间。

> 就是用数组模拟链表来实现邻接表

![img](./20220317161217-1723797363701-263.png)

链式前向星采用了一种静态链表的存储方式，可以说是目前建图和遍历效率最高的存储方式。

链式前向星由两种数据结构组成：

- **特殊的边集数组**：`edges`，其中 `edges[i]` 表示第 `i` 条边。`edges[i].vj` 表示第 `i` 条边的终止点，`edges[i].val` 表示第 `i` 条边的权值，`edges[i].next` 表示与第 `i` 条边同起始点的下一条边的存储位置。
- **头节点数组**：`head`，其中 `head[i]` 存储以顶点 `i` 为起始点的第 `1` 条边在数组 `edges` 中的下标。

链式前向星其实并没有改变边集数组原来的存储数学，只是利用 `head` 数组构成静态链表，建立了顶点 vi 和顶点 vi 所连第 `1` 条边的关系。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的链式前向星结构。

如果需要在该图中遍历顶点 v1 的所有边，则步骤如下：

- 找到以顶点 v1 为起始点的的 `1` 条边在数组 `edges` 中的下标，即 `index = head[1] = 1 `。则在 `edges` 数组中找到与顶点 v1 相连的第 `1` 条边为 `edges[1]`，即 ⟨v1,v5⟩，权值为 6。
- 查找 `index = self.edges[1].next = 0 `，则在 `edges` 数组中找到与顶点 v1 相连的第 `2` 条边 `edges[0]`，即 ⟨v1,v2⟩，权值为 5。
- 继续查找 `index = self.edges[0].next = -1`，则不存在其余边，查找结束。

![image-20230302112003101](./image-20230302112003101-1721820002717-31-1723797363701-264.png)

```c++
#include<iostream>
using namespace std;

struct edge{int v,w,ne;};//ne是链接点的编号 - 例如1-4
edge e[M]; // 存储当前节点的出边
int idx,h[N]; //idx是提供编号的变量，h是每个节点的第一条出边的编号


//获取第一个出边
void add(int a,int b,int c){
    //a第一条出边和b连接 - 这里h[a]表示a的出边
    e[idx] = {b,c,h[a]}; 
    //idx给每一个边都搞一个编号 - 让b和a联系
    h[a] = idx++;
}


void dfs(int u,int fa)
{
    //横向遍历产生分支
    for(int i = h[u];~i;i=e[i].ne){ //~i表示i不等于-1
        int v = e[i].v,w = e[i].w;
        if(v == fa) continue;//判重 产生新分支
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);//深入
    }    
}

int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);//初始化表头
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图构图
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);
    return 0;     
}
```

##### 哈希表

哈希表（字典）可以轻松的实现邻接表。哈希表实现邻接表包含两个哈希表：第一个哈希表主要用来存放顶点的数据信息，哈希表的键是顶点，值是该点所有邻接边构成的另一个哈希表。另一个哈希表用来存放顶点相连的边信息，哈希表的键是边的终点，值是边的权重。

哈希表实现邻接表的时间复杂度：

- 图的初始化和创建操作：O(n+m)
- 查询是否存在 vi 到 vj 的边：O(1)。
- 遍历某个点的所有边：O(TD(vi))
- 遍历整张图：O(n+m)

哈希表实现邻接表的空间复杂度：

- 空间复杂度：O(n+m)

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

// 顶点信息类
class VertexNode {
public:
    int vi;  // 顶点
    unordered_map<int, int> adj_edges;  // 邻接边和权值
    
    VertexNode(int vi) : vi(vi) {}
};

// 图类
class Graph {
public:
    unordered_map<int, VertexNode*> vertices;  // 顶点集合
    
    // 构造函数
    Graph() {}
    
    // 析构函数，释放动态内存
    ~Graph() {
        for (auto it : vertices) {
            delete it.second;
        }
    }
    
    // 图的创建操作，edges为边信息
    void createGraph(const vector<vector<int>>& edges) {
        for (const auto& edge : edges) {
            int vi = edge[0];
            int vj = edge[1];
            int val = edge[2];
            addEdge(vi, vj, val);
        }
    }
    
    // 向图中添加顶点
    void addVertex(int vi) {
        vertices[vi] = new VertexNode(vi);
    }
    
    // 向图的邻接表中添加边：vi - vj，权值为 val
    void addEdge(int vi, int vj, int val) {
        if (vertices.find(vi) == vertices.end()) {
            addVertex(vi);
        }
        if (vertices.find(vj) == vertices.end()) {
            addVertex(vj);
        }
        vertices[vi]->adj_edges[vj] = val;
    }
    
    // 获取 vi - vj 边的权值
    int getEdge(int vi, int vj) {
        if (vertices.find(vi) != vertices.end() && 
            vertices[vi]->adj_edges.find(vj) != vertices[vi]->adj_edges.end()) {
            return vertices[vi]->adj_edges[vj];
        }
        return -1;  // 如果边不存在，返回 -1
    }
    
    // 根据邻接表打印图的边
    void printGraph() {
        for (const auto& vertex : vertices) {
            int vi = vertex.first;
            for (const auto& edge : vertex.second->adj_edges) {
                int vj = edge.first;
                int val = edge.second;
                cout << vi << " - " << vj << " : " << val << endl;
            }
        }
    }
};

int main() {
    Graph graph;
    vector<vector<int>> edges = {{1, 2, 5}, {1, 5, 6}, {2, 4, 7}, 
                                 {4, 3, 9}, {3, 1, 2}, {5, 6, 8}, {6, 4, 3}};
    graph.createGraph(edges);
    cout << "Edge value between 3 and 4: " << graph.getEdge(3, 4) << endl;
    graph.printGraph();
    
    return 0;
}
```

#### [图的遍历](https://algo.itcharge.cn/08.Graph/02.Graph-Traversal/01.Graph-DFS/#_1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%80%E4%BB%8B)

##### 递归遍历

**深度优先搜索算法（Depth First Search）**：英文缩写为 DFS，是一种用于搜索树或图结构的算法。深度优先搜索算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。

深度优先搜索算法中所谓的深度优先，就是说优先沿着一条路径走到底，直到无法继续深入时再回头。在深度优先遍历的过程中，**我们需要将当前遍历节点 u 的相邻节点暂时存储起来，以便于在回退的时候可以继续访问它们。**遍历到的节点顺序符合「后进先出」的特点，这正是「递归」和「堆栈」所遵循的规律，所以深度优先搜索可以通过「递归」或者「堆栈」来实现。

接下来我们以一个无向图为例，介绍一下深度优先搜索的算法步骤。

- 选择起始节点 u，并将其标记为已访问。

  ![深度优先搜索 1](./202309042321406-1723797363701-265.png)

- 检查当前节点是否为目标节点（看具体题目要求）。

  ![深度优先搜索 2](./202309042323911.png)

- 如果当前节点 u 是目标节点，则直接返回结果。

  ![深度优先搜索 3](./202309042324370.png)

- 如果当前节点 u 不是目标节点，则遍历当前节点 u 的所有未访问邻接节点。

  ![深度优先搜索 4](./202309042325587.png)

- 对每个未访问的邻接节点 v，从节点 v 出发继续进行深度优先搜索（递归）。

  ![深度优先搜索 5](./202309042325689-1723797363701-266.png)

- 如果节点 u 没有未访问的相邻节点，回溯到上一个节点，继续搜索其他路径。

  ![深度优先搜索 6](./202309042325770-1723797363701-267.png)

- 重复 2∼6步骤，直到遍历完整个图或找到目标节点为止。

```c++
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    // 深度优先搜索递归函数
    void dfs_recursive(unordered_map<string, vector<string>>& graph, const string& u, unordered_set<string>& visited) {
        cout << u << endl;             // 访问节点
        visited.insert(u);             // 节点 u 标记其已访问

        for (const string& v : graph[u]) {
            if (visited.find(v) == visited.end()) {  // 节点 v 未访问过
                // 递归遍历节点 v
                dfs_recursive(graph, v, visited);
            }
        }
    }
};

int main() {
    // 构建图
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"A", "C", "D"}},
        {"C", {"A", "B", "D", "E"}},
        {"D", {"B", "C", "E", "F"}},
        {"E", {"C", "D"}},
        {"F", {"D", "G"}},
        {"G", {}}
    };

    // 创建 Solution 对象并调用深度优先搜索
    unordered_set<string> visited;
    Solution().dfs_recursive(graph, "A", visited);

    return 0;
}
```

##### [层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/)

**广度优先搜索算法（Breadth First Search）**：英文缩写为 BFS，又译作宽度优先搜索 / 横向优先搜索，是一种用于搜索树或图结构的算法。广度优先搜索算法从起始节点开始，逐层扩展，先访问离起始节点最近的节点，后访问离起始节点稍远的节点。以此类推，直到完成整个搜索过程。

因为遍历到的节点顺序符合「先进先出」的特点，所以广度优先搜索可以通过「队列」来实现。接下来我们以一个无向图为例，介绍一下广度优先搜索的算法步骤。

- 将起始节点 u 放入队列中，并标记为已访问。

![广度优先搜索 1](./20230905152316-1723797363701-269.png)

- 从队列中取出一个节点，访问它并将其所有的未访问**邻接节点 v** 放入队列中。

![广度优先搜索 2](./20230905152327-1723797363701-268.png)

- 标记已访问的节点 v，以避免重复访问。

![广度优先搜索 3](./20231009141628-1723797363701-272.png)

- 重复步骤 2∼3，直到队列为空或找到目标节点。

![广度优先搜索 4](./20230905152401-1723797363701-270.png)

- 访问它并将其所有的未访问**邻接节点 v** 放入队列中。

![广度优先搜索 5](./20230905152420-1723797363701-271.png)

- 结点出队

![广度优先搜索 6](./20230905152433-1723797363701-274.png)

- 结点出队，队列为空算法结束

![广度优先搜索 7](./20230905152445-1723797363701-273.png)

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 定义图的节点数据结构
struct Node {
    int value;  // 节点的值
    vector<Node*> neighbors;  // 相邻节点列表
    bool visited;  // 标记节点是否已经访问过

    Node(int val) : value(val), visited(false) {}
};

// BFS遍历函数
void bfs(Node* start) {
    queue<Node*> q;
    q.push(start);

    while (!q.empty()) {
        Node* cur = q.front();
        q.pop();

        if (!cur->visited) {
            cout << "Visiting node with value: " << cur->value << endl;
            cur->visited = true;

            for (Node* neighbor : cur->neighbors) {
                if (neighbor && !neighbor->visited) {
                    q.push(neighbor);
                }
            }
        }
    }
}

int main() {
    // 创建图节点
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    Node* node4 = new Node(4);

    // 建立节点之间的连接关系
    node1->neighbors = {node2, node3};
    node2->neighbors = {node1, node4};
    node3->neighbors = {node1, node4};
    node4->neighbors = {node2, node3};

    // 从起始节点开始BFS遍历
    bfs(node1);

    // 释放节点内存
    delete node1;
    delete node2;
    delete node3;
    delete node4;

    return 0;
}
```

#### [拓扑排序](https://zhuanlan.zhihu.com/p/135094687)

**拓扑排序（Topological Sorting）**：一种对有向无环图（DAG）的所有顶点进行线性排序的方法，使得图中任意一点 u 和 v，如果存在有向边 <u,v>，则 u 必须在 v 之前出现。对有向图进行拓扑排序产生的线性序列称为满足拓扑次序的序列，简称拓扑排序。

图的拓扑排序是针对有向无环图（DAG）来说的，无向图和有向有环图没有拓扑排序，或者说不存在拓扑排序。

![有向无环图](./202405092308713-1723797363701-276.png)

如上图中的有向无环图（DAG）所示，v1→v2→v3→v4→v5→v6 是该图的一个拓扑序列。与此同时，v1→v2→v3→v4→v6→v5 也是该图的一个拓扑序列。也就是说，对于一个有向无环图来说，拓扑序列可能不止一个。

![image-20230302193314874](./image-20230302193314874-1721820002717-18-1723797363701-275.png)

拓扑排序有两种实现方法，分别是「Kahn 算法」和「DFS 深度优先搜索算法」。接下来我们依次来看下它们是如何实现的。

##### KAHN算法

**Kahn 算法的基本思想**：

1. **不断找寻有向图中入度为 0 的顶点，将其输出**。
2. 然后删除入度为 0 的顶点和从该顶点出发的有向边。
3. 重复上述操作直到图为空，或者找不到入度为 0 的节点为止。

![image-20230302195721755](./image-1723797363701-278.png)

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 100005;  // 假设最大顶点数为 100000

vector<int> e[N];   // 邻接表存储图
vector<int> tp;     // 存储最终输出的拓扑序列
int din[N];         // 存储每个顶点的入度
int n, m;           // 顶点数和边数

bool toposort() {
    queue<int> q;

    // 初始化：将所有入度为 0 的顶点加入队列
    for (int i = 1; i <= n; i++) {
        if (din[i] == 0) q.push(i);
    }

    while (!q.empty()) {
        int x = q.front();
        q.pop();  // 从队列中取出队头

        tp.push_back(x);  // 加入拓扑序列

        // 删除以 x 为起点的所有边
        for (int y : e[x]) {
            if (--din[y] == 0) q.push(y);  // 如果 y 的入度为 0，加入队列
        }
    }

    // 如果拓扑序列中的顶点数等于图中的顶点数，则返回 true
    return tp.size() == n;
}

int main() {
    cin >> n >> m;

    // 读取图的边信息
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
        din[b]++;
    }

    if (!toposort()) {
        puts("-1");  // 如果无法形成拓扑序列，输出 -1
    } else {
        for (int x : tp) printf("%d ", x);  // 输出拓扑序列
        puts("");  // 换行
    }

    return 0;
}

```

##### DFS算法

**基于 DFS 实现拓扑排序算法的基本思想**：

1. 对于一个顶点 u，深度优先遍历从该顶点出发的有向边 <u,v>。如果从该顶点 u 出发的所有相邻顶点 v 都已经搜索完毕，则回溯到顶点 u 时，该顶点 u应该位于其所有相邻顶点 v 的前面（拓扑序列中）。
2. 这样一来，当我们对每个顶点进行深度优先搜索，在回溯到该顶点时将其放入栈中，则最终从栈顶到栈底的序列就是一种拓扑排序。

![image-20230302195739338](./image-20230302195739338-1721820002717-20-1723797363701-277.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm>  // 引入 reverse 函数
#include <cstring>    // 引入 memset 函数，用于初始化数组
using namespace std;

const int N = 100005;  // 假设最大顶点数为 100000

vector<int> e[N];   // 邻接表表示的图
vector<int> tp;     // 存储最终的拓扑序列
int c[N];           // 用于染色的数组（0：未访问，-1：正在访问，1：已访问）
int n, m;           // 顶点数和边数

bool dfs(int x) {
    c[x] = -1;  // 将当前节点标记为正在访问

    for (int y : e[x]) {
        if (c[y] < 0) return false;  // 如果 y 正在访问中，说明存在环
        if (c[y] == 0 && !dfs(y)) return false;  // 如果 y 未访问，则继续 DFS
    }

    c[x] = 1;           // 当前节点访问完成，标记为已访问
    tp.push_back(x);    // 将节点加入拓扑序列
    return true;
}

bool toposort() {
    memset(c, 0, sizeof(c));  // 初始化所有节点为未访问状态

    for (int x = 1; x <= n; x++) {
        if (c[x] == 0) {
            if (!dfs(x)) return false;  // 如果发现有环，返回 false
        }
    }

    reverse(tp.begin(), tp.end());  // 翻转拓扑序列，使其为正确的顺序
    return true;
}

int main() {
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
    }

    if (!toposort()) {
        cout << "-1" << endl;  // 如果存在环，输出 -1
    } else {
        for (int x : tp) cout << x << " ";  // 输出拓扑序列
        cout << endl;
    }

    return 0;
}
```

#### 最短路算法

顾名思义，从任意顶点出发到另一顶点的最短距离。也就是权重最小。

##### [Dijkstra](https://www.zhihu.com/tardis/zm/art/40338107?source_id=1003)

> 基于贪心思想，也就是每次选择的路径权重是最小的，达成局部最小变为全局最小。
>
> ![image-20230904102403004](./image-20230904102403004-1721820002717-22-1723797363701-279.png)

![image-20230302202401928](./image-20230302202401928-1721820002717-23-1723797363701-280.png)

![image-20230302204100958](./image-20230302204100958-1721820002717-24-1723797363701-281.png)

简单来说：就是每次选择最短路线进行前进：

- `e[u]` 存储节点`u`的所有出边的起点和边权

- `d[u]`存储`u`到目标点的最小距离（`d[u]`需要遍历）

- `vis[u] `标记是否出圈

```c++
#include <iostream>
#include <vector>
#include <limits>

using namespace std;

const int N = 1005; // 最大节点数量
const int inf = numeric_limits<int>::max(); // 无穷大表示

struct Edge {
    int v, w; // 当前节点
};

vector<Edge> e[N]; // 邻接表表示图
int d[N]; // 存储最短距离
int vis[N]; // 标记节点是否已经访问

void dijkstra(int s, int n) {
    for (int i = 1; i <= n; i++) {
        d[i] = inf; // 初始化距离为无穷大
        vis[i] = 0; // 初始化节点未访问
    }

    d[s] = 0; // 起点到自身距离为0

    for (int i = 1; i <= n; i++) {
        
        int u = 0;

        // 选择未访问节点中距离最小的节点 u
        // 第一次更新找到哪个点都无所谓 - 后面for遍历全部会松弛一遍的
        for (int j = 1; j <= n; j++) {
            if (!vis[j] && d[j] < d[u]) {
                u = j;
            }
        }

        vis[u] = 1; // 标记节点 u 为已访问

        // 更新从节点 u 出发的边的目标节点的距离
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            //松弛操作 - 将无穷大的值松弛为输入值
            if (!vis[v] && d[v] > d[u] + w) {
                d[v] = d[u] + w;
            }
        }
    }
}

int main() {
    int n, m, s;
    cin >> n >> m >> s; // 输入节点数量、边数量和起点

    for (int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c; // 输入边的起点、终点和权值
        e[a].push_back({b, c}); // 添加边到邻接表
    }

    dijkstra(s, n); // 调用 Dijkstra 算法计算最短路径

    // 输出从起点到每个节点的最短距离
    for (int i = 1; i <= n; i++) {
        cout << "Shortest distance from " << s << " to " << i << " is " << d[i] << endl;
    }

    return 0;
}
```

![image-20230302204110774](./image-20230302204110774-1721820002717-25-1723797363701-282.png)

![image-20230302205328621](./image-20230302205328621-1721820002717-26-1723797363701-283.png)

```c++
//这里用的是小根堆 - 就不用加-号了
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 100005;
const int inf = 0x3f3f3f3f;

// 堆优化 - 用优先队列维护被更新点的集合
struct edge {
    int v, w;
};

vector<edge> e[N];
int d[N];
bool vis[N];

void dijkstra(int s) {
    // 1. 全部点的距离都是无穷大
    fill(d, d + N, inf);
    d[s] = 0;

    // 2. 创建小根堆（最小堆） - pair的第一个元素是距离
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
    q.push({0, s});

    // 3. 循环迭代
    while (!q.empty()) {
        int u = q.top().second;
        q.pop();

        if (vis[u]) continue;
        vis[u] = true;

        for (const auto& ed : e[u]) {
            int v = ed.v, w = ed.w;

            if (d[v] > d[u] + w) {
                d[v] = d[u] + w;
                q.push({d[v], v});
            }
        }
    }
}

int main() {
    int n, m, s;
    cin >> n >> m >> s;

    for (int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        e[u].push_back({v, w});
    }

    dijkstra(s);

    for (int i = 1; i <= n; i++) {
        if (d[i] == inf) cout << "INF ";
        else cout << d[i] << " ";
    }
    cout << endl;

    return 0;
}
```

![image-20230302205410861](./image-20230302205410861-1721820002717-27-1723797363701-284.png)

```c++
//就是两个模板 优化的地方就是枚举的时候用队列维护
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N]; //边 和 点
//s是起点
void dijkstra(int s)
{
    for(int i = 0;i<=n;i++) d[i] = 0x3f3f3f; //无穷大的值
    d[s] = 0; //对于自己和自己的距离当然是0了
    
    for(int i = 0;i<=n;i++){//枚举次数
        int u = 0;
        //优化 就是把这里优化了 取消了枚举全部点
        for(int j = 1;j<=n;j++) //枚举点
            if(!vis[j]&&d[j]<d[u]) u = j;
        vis[u] = 1;
        for(auto ed:e[u]){ //ed 我们可以看做 就是e[u]（数组长度u）内部的数据（一个点）
            int v = ed.v,w = ed.w;
            if(d[v]>d[u]+w) {
                d[v] = d[u]+w;
                q.push_back({-d[v],v});//插入到 大根堆上
            }
        }            
    }    
}
```

![image-20230302205417632](./image-20230302205417632-1721820002717-28-1723797363701-288.png)

##### [Bellman-Ford](https://zhuanlan.zhihu.com/p/352724346)*

贝尔曼-福特算法`（Bellman-Ford）`是由理查德·贝尔曼和莱斯特·福特创立的，求解**单源最短路径问题**的一种算法。它的原理是对图进行`V-1`次**松弛操作**，得到所有可能的最短路径。其优于`Dijkstra`算法的方面是边的权值可以为**负数**、实现简单，缺点是时间复杂度过高，高达`O(VE)`

![img](./v2-3253617aa1280adbe911e9fae4133584_720w-1721820002717-29-1723797363701-286.webp)

然后迭代对于起点链接的节点进行松弛

![img](./v2-b79ce7e33dcee4a3e915bd1d1d2866e7_720w-1721820002717-30-1723797363701-285.webp)

每一个节点的距离 - 起点的距离 = 和起点的距离

![img](./v2-f407fdcc6ac680d357f535258e3f12d8_720w-1721820002717-32-1723797363701-287.webp)

![img](./v2-0b8efc7f4fcf5d767fc7b678c1d08c8c_720w-1721820002717-37-1723797363701-289.webp)

它的时间复杂度为 `O(VE)`，其中 `V` 是顶点数，`E`是边数。`Bellman-Ford` 算法的基本思想是对所有的边进行 `V-1 `轮松弛操作，以求出所有可能的最短路径。如果在第 `V`轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。

![image-20230304212846831](./image-20230304212846831-1721820002717-33-1723797363701-290.png)

![image-20230304210834724](./image-20230304210834724-1721820002717-36-1723797363701-291.png)

![image-20230304212028882](./image-20230304212028882-1721820002717-35-1723797363702-292.png)

```c++
const int INF = 1e9;
const int N = 1005; // 根据你的需求设置节点数量上限

struct edge {
    int v, w;
};

vector<edge> e[N];
int d[N];

bool bellmanFord(int n, int s) {
    fill(d, d + n, INF);
    d[s] = 0;

    for (int i = 0; i < n - 1; i++) { // 最多执行 n-1 轮松弛操作
        bool flag = false;
        for (int u = 1; u <= n; u++) {
            if (d[u] == INF) continue;

            for (auto ed : e[u]) {
                int v = ed.v, w = ed.w;
                if (d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    flag = true;
                }
            }
        }
        if (!flag) break; // 如果本轮没有更新，提前退出
    }

    // 检测是否存在负权环
    for (int u = 1; u <= n; u++) {
        if (d[u] == INF) continue;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (d[v] > d[u] + w) {
                return true; // 存在负权环
            }
        }
    }

    return false; // 不存在负权环
}
```

##### [spfa 算法](https://wat1r.github.io/2020/09/21/spfa-algorithm-master/)

何为`SPFA（Shortest Path Faster Algorithm）`算法:

给定一个加权连通图，选取一个顶点，称为起点，求取起点到其它所有顶点之间的最短距离，其显著特点是可以求含负权图的单源最短路径，且效率较高。（`spfa`是求单源最短路径最短路径)的一种算法，它还有一个重要的功能是判负环（在差分约束系统中会得以体现），在`Bellman-ford`算法的基础上加上一个队列优化，减少了冗余的松弛操作，是一种高效的最短路算法。

**`spfa算法思想`：**`spfa`就是`BellmanFord`的一种实现方式，其具体不同在于，对于处理松弛操作时，采用了队列（先进先出方式）操作，从而大大降低了时间复杂度但是`spfa`容易被卡常数，所以说最差复杂度和BF算法差不多,而且`spfa`不适用负权环，只适用于负权边。还是推荐用`bf`算法

![image-20200921211548307.png](./image-20200921211548307-1721820002717-38-1723797363702-293.png)

`spfa`可以用来判断图中是否有环

![image-20230304212218685](./image-20230304212218685-1721820002717-39-1723797363702-294.png)

![image-20230304212529352](./image-20230304212529352-1721820002717-40-1723797363702-295.png)

![image-20230304212738052](./image-20230304212738052-1721820002717-41-1723797363702-296.png)

```c++
//堆优化 bellman 算法 - spfa算法
struct edge{int v,w;};
vector<edge> e[N];//点集合
int d[N],cnt[N],vis[N]; //边 边数 开关
queue<int> q; //队列

bool spfa(int s){
    memset(d,inf,sizeof d);
    //开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集
    d[s] = 0; vis[s] = 1; q.push(s); 
    while(q.size()){
        //这里是将前面初始化的点操作的地方，每次都只操作一个点
        int u = q.front(); q.pop(); vis[u] = 0;
     for(auto ed:e[u]){
            int v = ed.v , w = ed.w;
            //比较枚举点和当前点 的长度 更新最短值
            if(d[v]>d[u]+w){
                d[v] = d[u]+w;
                cnt[v] = cnt[u]+1; //记录边数
                if(cnt[v]>=n) return true;
                if(!vis[v]) q.push(v),vis[v] = 1;
            }
        }
    }
    return false;
}
```

##### [Floyd算法](https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd)

Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，我们的目标是寻找从点i到点j的最短路径，在经过过度节点的情况。

从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）

从任意节点`i`到任意节点`j`的最短路径不外乎2种可能：

- 是直接从`i到j`，

- 是从`i`经过若干个节点`k到j`。

所以，我们假设`Dis(i,j)`为节点`u`到节点`v`的最短路径的距离，对于每一个节点`k`，我们检查`Dis(i,k) + Dis(k,j) < Dis(i,j)`是否成立，如果成立，证明从`i到k`再到`j`的路径比`i`直接到j的路径短，我们便设置**`Dis(i,j) = Dis(i,k) + Dis(k,j)`**，这样一来，当我们遍历完所有节点`k`，`Dis(i,j)`中记录的便是`i到j`的最短路径的距离。

![image-20230307160057133](./image-20230307160057133-1721820002717-42-1723797363702-297.png)

![image-20230307160205801](./image-20230307160205801-1721820002717-43-1723797363702-298.png)

![image-20230307160839691](./image-20230307160839691-1721820002718-44-1723797363702-299.png)

```c++
// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）
// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）

//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）
void floyd(){
    for(int k;k<=n;k++) //以k为桥(k枚举的是所有点)
        for(int i=1 ;i<=n;i++)
            for(int j = 1;j<=n;j++)
                d[i][j] = mid(d[i][j],d[i][k]+d[k][j]); //二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）
}
```

![image-20230307161152125](./image-20230307161152125-1721820002718-45-1723797363702-300.png)

```c++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 210;
int n,m,k;
int d[N][N];
void floyd(){
    for(int k = 1;k <= n;k++)
        for(int i = 1;i <= n;i++)
            for(int j = 1;j <= n;j++)
                d[i][j] = min(d[i][j],d[i][k]+d[k][j]);
}
int main(){
    cin >> n >> m >> k;
    fill(d[0],d[0]+N*N,0x3f3f3f3f);
    for(int i = 1;i <= n;i++) d[i][i] = 0;
    while(m--){
        int a,b,c; cin >> a >> b >> c;
        d[a][b] = min(d[a][b],c);
    }
    floyd();
    while(k--){
        int a,b; cin >> a >> b;
        if(d[a][b] > 0x3f3f3f3f/2) cout << "impossible" << endl;
        else cout << d[a][b] << endl;
    }
}
```

![image-20230307161434260](./image-20230307161434260-1721820002718-46-1723797363702-301.png)

#### 最小生成树

在了解「最小生成树」之前，我们需要要先理解 「生成树」的概念。

**图的生成树（Spanning Tree）**：如果无向连通图 G 的一个子图是一棵包含图 G 所有顶点的树，则称该子图为 G 的生成树。生成树是连通图的包含图中的所有顶点的极小连通子图。图的生成树不惟一。从不同的顶点出发进行遍历，可以得到不同的生成树。

换句话说，生成树是原图 G 的一个子图，它包含了原图 G 的所有顶点，并且通过选择图中一部分边连接这些顶点，使得子图中没有环。

生成树有以下特点：

1. **包含所有顶点**：生成树中包含了原图的所有顶点。
2. **连通性**：生成树是原图的一个连通子图，意味着任意两个顶点之间都存在一条路径。
3. **无环图**：生成树一个无环图。
4. **边数最少**：在包含所有顶点的情况下，生成树的边数最少，其边数为顶点数减 1。

![img](./20231211100145-1723797363702-302.png)

**最小生成树（Minimum Spanning Tree）**：无向连通图 G 的所有生成树中，边的权值之和最小的生成树，被称为最小生成树。

最小生成树除了包含生成树的特点之外，还具有一个特点。

**边的权值之和最小**：在包含所有顶点的情况下，最小生成树的边的权重之和是所有可能的生成树中最小的。

![img](./20231211101937-1723797363702-303.png)

为了找到无向图的最小生成树，常用的算法有「Prim 算法」和「Kruskal 算法」。

- **Prim 算法**：从一个起始顶点出发，逐步选择与已经构建的树连接的最短边，直到包含所有顶点为止。
- **Kruskal 算法**：基于边的排序和并查集数据结构，逐步添加边，并保证所选边不会构成环路，直到构建出最小生成树。

##### prim算法

**Prim 算法的算法思想**：每次选择最短边来扩展最小生成树，从而保证生成树的总权重最小。算法通过不断扩展小生成树的顶点集合 MST，逐步构建出最小生成树。

![image-20230308192754299](./image-20230308192754299-1721820002718-47-1723797363702-304.png)

Prim算法的基本思路：

- 选择一个起始节点（可以是任意节点），将其加入生成树中，初始化生成树为空。
- 在每一步中，从已经在生成树中的节点集合出发，选择一个距离生成树最近的节点（即与生成树中的某个节点相邻且权重最小的节点），将其加入生成树中。
- 这个过程重复执行，直到生成树包含了图中的所有节点为止。最终生成的树就是最小生成树。

```c++
//没有优化版本 - 基于贪心算法
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N];//d是边的长度 

bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf;
    d[s] = 0;
    for(int i = 1;i<=n;i++){
        int u = 0;
        for(int j = 1;j<=n;j++)
            if(!vis[j]&&d[j]<d[u]) u = j; //排除选过的点 - 这里是选领点的（懂了）
        vis[u] = 1;
        ans+=d[u];//边权和（最小生成树的边权和）
        if(d[u]!=inf) cnt++; //判断是否联通
        //遍历到u这个点（u之前的也是一起的，算是连续的）
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w;   
            }
        }
    }
    return cnt == n; //返回true就是有最小生成树的 返回false
}
```

在Prim算法之上，优化其使用的数据结构，把队列替换为优先队列。就是Heap-Prim算法。

![image-20230308110618789](./image-20230308110618789-1721820002718-48-1723797363702-305.png)

```c++
//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。
int n,m,s,a,b,c,ans,cnt;
struct edge{int v,w;}; //构造一个结构体 内部有点和边的属性
vector<edge> e[N];//领点（也算是所有点？）
int d[N],vis[N];
priority_queue<pair<int,int>> q; //这里创一个优先队列（就是堆）
//s是起点
bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf; //先初始化全部的边 - 每个边都是无穷大
    //起点
    d[s] = 0;q.push({0,s});
    while(q.size()){
        //取出q队列的点？ - 后面有进入点？
        int u = q.top().second; q.pop();
        if(vis[u]) continue; 
        vis[u] = 1;
        ans+=d[u]; cnt++;
        //这里应该就是插入 领点的步骤
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w; //对应点v边权最小的边
                q.push({-d[v],v});//大根堆
            }
        }
    }
    return cnt == n; //这里判断的是啥？
}


```

![image-20230308110724388](./image-20230308110724388-1721820002718-49-1723797363702-306.png)

##### Kruskal算法

**Kruskal 算法的算法思想**：通过依次选择权重最小的边并判断其两个端点是否连接在同一集合中，从而逐步构建最小生成树。这个过程保证了最终生成的树是无环的，并且总权重最小。

- 将图中的所有边按照权重从小到大进行排序。

- 初始化一个空的最小生成树。

- 从权重最小的边开始，依次考虑每条边，如果该边不会导致生成树中出现环路（即加入这条边后，两个节点已经在同一个连通分量中），就将这条边加入生成树中。

重复步骤3，直到生成树中包含了图中的所有节点，此时最小生成树构建完成。

![image-20230308125205044](./image-20230308125205044-1721820002718-50-1723797363702-312.png)

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=200010;
int n,m;
//结构体存储边的信息
struct edge{
    int a,b,w;
}e[M];
//比较函数 （用来作为排序算法的参数）
bool cmp(edge x,edge y){
    return x.w<y.w;
}
//并查集
int p[N];
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].w);
    //排序边权（我们是用贪心来筛选的）
    sort(e+1,e+m+1,cmp);
    //初始化并查集
    for(int i=1;i<=n;i++) p[i]=i;
    int res=0,cnt=0;
    for(int i=1;i<=m;i++){
        //每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）
        int a=find(e[i].a),b=find(e[i].b),w=e[i].w;
        //查一下是否是连通块
        if(a!=b){
            //纳入后宫
            p[a]=b;
            res+=w;
            cnt++;
        }
        if(cnt==n-1) break;  //成树
    }
    printf("%d\n",res);//输出边权
}
```

> 三种方法比较

![image-20230308125225033](./image-20230308125225033-1721820002718-51-1723797363702-307.png)

#### 二分图

##### 染色法判断二分图

 二分图是节点由两个集合组成，且两个集合内部没有边的图。

![image-20231121222329287](./image-20231121222329287-1721820002718-52-1723797363702-310.png)

根据二分图不存在奇环的特性，我们可以使用染色法来判断二分图。因为我们不可能在一部之内走回我们同集合的节点，也就是说，我们的相邻节点一定是不同集合的，所以说我们每遍历一格，就标记不同的颜色，只要相邻的节点颜色相同，那么就说明不是二分图。^ ^

- 选择一个起始节点，将其染成颜色A（可以用0和1表示两种颜色）。

- 从起始节点开始，对于与其相邻的节点，将其染成颜色B。

- 继续递归地对与颜色A节点相邻的节点染成颜色B，与颜色B节点相邻的节点染成颜色A。

- 如果在染色的过程中发现相邻的两个节点已经被染成了相同的颜色，那么图不是二分图。

- 如果成功染色完所有节点而没有发现相邻节点颜色相同的情况，那么图是二分图。

![image-20230314144148781](./image-20230314144148781-1721820002718-53-1723797363702-308.png)

这里用深度优先遍历来实现判断二分图：

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int M = 1e5+10;
const int N = 2e5+10;
//父结点 - 当前节点 - 出边
struct edge{int v,ne;}e[M];
//h数组存储的是所有的出边 - a节点索引
int h[N],idx;
int n,m;
int color[N];

void add(int a,int b){
    e[++idx] = {b,h[a]};
    h[a] = idx;
}
//分为两种颜色 - 1 - 2 - 0是未上色
//dfs上色的过程中，也在找
//for是找 - dfs是上色
bool dfs(int u,int c){
    color[u] = c;
    for(int i = h[u];i;i = e[i].ne){
        int v = e[i].v;
        //没有上色 - 就上色
        if(!color[v]) {
            if(dfs(v,3-c)) return true;
        }
        else if(color[v] == c) return true;
    }
    return false;
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
  int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    bool flag = false;
    for(int i = 1;i<=n;i++)
        if(!color[i])
            //dfs找到一处就会返回，对于每个点找一下领结的点就行
            if(dfs(i,1)){
                flag = true;
                break;
            }
    if(flag) puts("No");
    else puts("Yes");
    return 0;
    
    
}
```

![image-20230314144232392](./image-20230314144232392-1721820002718-54-1723797363702-309.png)

##### 匈牙利算法

![image-20230314205307317](./image-20230314205307317-1721820002718-55-1723797363702-311.png)

解决二分图最大匹配问题：两个集合连线匹配对数最大

- 选择一个未匹配的左侧节点作为起始点，如果所有左侧节点都已经匹配，则说明找到了一个最大匹配。
- 对于选定的起始点，尝试将其与未匹配的右侧节点进行匹配。如果可以找到一个未匹配的右侧节点与起始点相连接，那么建立这个匹配，否则，尝试改变匹配路径。
- 如果可以改变匹配路径，就寻找一条增广路径（alternating path），这是一条交替经过匹配边和非匹配边的路径，以尽量多地增加匹配数目。增广路径的搜索通常使用深度优先搜索`（DFS）`或广度优先搜索`（BFS）`。
- 如果找到了增广路径，就根据这条路径来改变匹配，然后返回步骤1，继续查找下一个未匹配的左侧节点。
- 如果没有找到增广路径，说明已经找到了最大匹配，算法终止。

因为我们需要让两个集合匹配对数最大，所以说需要在两个集合之间不停连线试错，`dfs`帮助我们提供不同的连线方案，让我们达到匹配数最大。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10,M = 2e5+10;
int n,m,k,a,b,ans,idx;
struct edge{int v,ne;}e[M]; //点（对应位置的妹子） ne 另一集合的点
int h[N],idx;
int vis[N],match[M]; //标记 和 匹配

//链式前向星
void add(int a, int b){
    e[++idx] = {b,h[a]};
    h[a] = idx++; //给边编号
}
//男女匹配问题 (boy and girl）
bool bfs(int u){
    //每一个都要匹配看看
    for(int i = h[u]; i;i = e[i].ne){
        int v = e[i].v; //妹子
        if(vis[v]) continue;
        vis[v] = 1; //标记
        if(!match[v]||dfs(match[v])){ //没有匹配 || dfs遍历判断这个方案能不能成功 - 不能就换一个
            match[v] = u;//成对
            return 1;
        }
    }
    return 0;
}

int main()
{
    cin>>n>>m>>k;
    for(int i = 0;i<k;i++) cin>>a>>b,add(a,b); //建图
    for(int i = 1;i<=n;i++){
        memset(vis,0,sizeof vis);
        if(dfs(i)) ans++;
    }
    cout<<ans;
    return 0; 
    
}

```

##### 倍增算法

在朴素算法中，我们移动的次数太多了，也就是一个一个跳，这样太慢。我们的目的是找到到达的终点，举个例子：我们走路回家，在一定的时间间隔可能也就移动一米，但是我们坐车回家在一定的时间间隔那就可能很多米了。道理是这样：

```c++
#include<iostream>
using namespace std;

const int N = 5e5+10;
vector<int> e[N];
int n,m,s,a,b;
int dep[N],fa[N][20];

void dfs(int u,int father){
    dep[u] = dep[father]+1;
    //向上跳 - 1 2 4 祖先节点?
    fa[u][0] = father;
    for(int i = 1;i<=19;i++)
        fa[u][i] = fa[fa[u][i-1]][i-1];
    for(int v:e[u]) 
        if(v!=father) dfs(v,u);
}

int lca(int u,int v){
    if(dep[u]<dep[v]) swap(u,v);
    //两个节点到同一层
    for(int i = 19;i>=0;i--)
        if(dep[fa[u][i]]>=dep[v])
            u = fa[u][i];
    if(u==v) return v;
    // 在跳到LCA的下一层
    for(int i = 19;i>=0;i--)
        if(fa[u][i] != fa[v][i])
            u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

int main()
{
    cin >> n >> m >> s; // 读取节点数、边数和根节点

    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        e[u].push_back(v);
        e[v].push_back(u);
    }

    dfs(s, 0); // 初始化数据

    for (int i = 0; i < m; i++) {
        cin >> a >> b;
        int lca_result = lca(a, b);
        cout << "LCA of " << a << " and " << b << " is: " << lca_result << endl;
    }

    return 0;
    
}
```

> 8.16暂时这样吧
