---
title: 图论
date: 2023-04-28 09:05:38
categories: 算法
tags: 数据结构
description: 包括树，图
typora-root-url: ./2.图论
---

## 图论

> 参考了：https://algo.itcharge.cn/07.Tree/01.Binary-Tree/01.Binary-Tree-Basic/#_2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%80%E4%BB%8B

图是用点和边组成的一种数据类型，点与点之间用边来联系在一起。（图通常用于解决，最短路径问题、最小生成树问题、最大流问题）有关于图的问题，大概就是最短路，最小生成树，贪心价值最大，还有图的两种遍历。有关于图的数学知识我们尚不讨论，但是关于图的遍历我们需要了解。目前，常规的遍历方法有两种

- 是竖向的dfs递归遍历
- 是横向的bfs递归遍历。

### 树

树是由N个节点构成的有限集合，当N=0的时候称之为空树。树也可以看做是存储数据的一种数据类型，其逻辑结构常见的有二叉树，完全二叉树等等；树的节点和数的深度是有关系的，对于一个深度为K的满二叉树来说，它的节点个数`2^K-1`其中减去1是减去了根节点。

一个树且当N>1的时候，其余节点可以分为M个有限互不相交的有限集合。每一个节点算是一个独立的树，称之为根的子树。在树中，与其他数据结构一样，有前驱和后继的设定。对于根节点来说，它没有直接前驱。对于底部的节点来说，它没有直接后继。

树适合表示有层级的结构的数据，类似于游戏中的阶段，或者随机生成的地图。都需要记录前一个状态，然后跳转到另一个状态。状态的区别就是其节点的子和父属性。

一个树有几种属性

- 结点：组成树的基本变量
- 度：结点孩子个数
- 深度，高度和层次：深度从根节点开始向下计数，高度从叶节点向上计数。如果我们知道一个二叉树的节点个数，那么可以估计高度的数量级大概为`h=log2(N+1)`

![树](./20240511171215-1723797363701-239.png)

#### 二叉树

使用的最多和最基础的就是二叉树，二叉树是有N个节点构成的有限集合。其中，结点为0、只有根节点、只有左子树、只有右子树、左右子树都有和只有右子树，以上这些都是二叉树的形态。

⼆叉树是种特殊的树，它最多有两个⼦树，分别为左⼦树和右⼦树，并且两个子树是有序的，不可以互换。也就是说，在⼆叉树中不存在度⼤于 2 的节点。

##### 满二叉树

如图是一个满二叉树，可以看到每一个层级中，其节点个数都是符合`2^n（n为层级）`

![二叉树](./20240511171342-1723797363701-238.png)

满二叉树满足以下特点：

- 叶子节点只出现在最下面一层。
- 非叶子节点的度一定为 2。
- 在同等深度的二叉树中，满二叉树的节点个数最多，叶子节点个数最多。

如果我们对满二叉树的节点进行编号，根节点编号为 1，然后按照层次依次向下，每一层从左至右的顺序进行编号。则深度为 k 的满二叉树最后一个节点的编号为 2*k*−1。

##### 完全二叉树

在完全二叉树中，除了最底层外，其余每一层的节点数都达到了最大值。最底层的节点全部集中在最左侧，且可能未完全填满。如果最底层为第 h 层，则该层包含的节点数范围为 1 到 2^h−1 个。完全二叉树满足以下特点：

- 叶子节点只能出现在最下面两层。
- 最下层的叶子节点一定集中在该层最左边的位置上。
- 倒数第二层如果有叶子节点，则该层的叶子节点一定集中在右边的位置上。
- 如果节点的度为 1，则该节点只偶遇左孩子节点，即不存在只有右子树的情况。
- 同等节点数的二叉树中，完全二叉树的深度最小。

![完全二叉树与非完全二叉树](./20220218174000.png)

#### [二叉搜索树](https://algo.itcharge.cn/07.Tree/02.Binary-Search-Tree/01.Binary-Search-Tree/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)

二叉搜索树（建立在完全二叉树的基础之上）有如下的规则（简单来说，左节点小于父节点，右节点大于父节点）

- 若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；
- 若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；
- 它的左、右⼦树也分别为⼆叉搜索树

![二叉搜索树](./20240511171406-1723797363701-240.png)

##### 平衡二叉搜索树

平衡二叉搜索树：一种结构平衡的二叉搜索树。即叶节点高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉搜索树。平衡二叉树可以在` O(logn) `内完成插入、查找和删除操作。又被称为`AVL（Adelson-Velsky and Landis）`树，满足以下性质：

- 空二叉树是一棵 AVL 树。
- 如果 T 是一棵 AVL 树，那么其左右子树也是 AVL 树，并且 `∣h(ls)−h(rs)∣≤1` 是左子树的高度，`h(rs)` 是右子树的高度。
- AVL 树的高度为 `O(logn)`

![平衡二叉树与非平衡二叉树](./20220221103552.png)

#### 实现二叉树

二叉树的存储结构分为两种：「顺序存储结构」和「链式存储结构」

##### 顺序存储结构

使用顺序存储结构实现二叉树，也就是使用一维数组存储二叉树的节点，节点存储位置则采用完全二叉树的节点层次编号，按照层次从上至下，每一层从左至右的顺序依次存放二叉树的数据元素。在进行顺序存储时，如果对应的二叉树节点不存在，则设置为「空节点」。

![image-20230216134441813](./image-20230216134441813-16923744802222-1721820002716-4-1723797363701-243.png)

数组模拟二叉树，原理是改数组索引定义，采用`0-based`索引，也就是数组的0号位置设置为根节点，具体操作：

- 对于任意节点的索引为`i`，它的左子节点的索引为`2i + 1`。

- 它的右子节点的索引为`2i + 2`。

- 它的父节点的索引为`(n - 1) / 2`（当n不为0时）。

```c++
//结构体定义节点属性
struct TreeNode{
  int val;
  TreeNode *left; //定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数初始化  
};

// 构建二叉树
TreeNode* buildTree(vector<int>& arr, int index) {
    if (index >= arr.size() || arr[index] == -1) {
        return nullptr; // 返回空指针表示空节点
    }

    TreeNode* root = new TreeNode(arr[index]);
    root->left = buildTree(arr, 2 * index + 1); // 构建左子树
    root->right = buildTree(arr, 2 * index + 2); // 构建右子树

    return root;
}
```

对于完全二叉树（尤其是满二叉树）来说，采用顺序存储结构比较合适，它能充分利用存储空间；而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。并且，由于顺序存储结构固有的一些缺陷，会使得二叉树的插入、删除等操作不方便，效率也比较低。对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。

##### 链式存储结构

二叉树采用链式存储结构时，每个链节点包含一个用于数据域 val，存储节点信息；还包含两个指针域 left 和 right，分别指向左右两个孩子节点，当左孩子或者右孩子不存在时，相应指针域值为空。二叉链节点结构如下图所示。

![二叉链节点](./20240511171434-1723797363701-248.png)

链式存储结构实现二叉树很好理解，每一个节点都由指向左右子树的指针。下面是实现节点的伪代码

```c++
// 输入：一个数组 arr，其中 arr[i] 表示二叉树节点 i 的值，-1 表示该节点为空
// 输出：二叉树存储在数组中的形式

function buildBinaryTree(arr):
    for each index i in arr:
        if arr[i] == -1:
            continue // 跳过空节点
        node_value = arr[i]  // 当前节点的值

        // 计算左子节点的索引
        left_index = 2 * i + 1
        if left_index < length(arr):
            left_child = arr[left_index]

        // 计算右子节点的索引
        right_index = 2 * i + 2
        if right_index < length(arr):
            right_child = arr[right_index]

    return arr  // 返回构造好的顺序存储结构的二叉树
```

二叉树的链表存储结构具有灵活、方便的特点。节点的最大数目只受系统最大可存储空间的限制。一般情况下，二叉树的链表存储结构比顺序存储结构更省空间（用于存储指针域的空间开销只是二叉树中节点数的线性函数），而且对于二叉树实施相关操作也很方便，因此，一般我们使用链式存储结构来存储二叉树。

![二叉树的链式存储结构](./20240511171446-1723797363701-241.png)

#### 二叉树遍历

> 二叉树遍历可以用递归实现

假设我们要查找e这个位置的数据，依靠上帝视角我们可以直接`0-1-4`即可查询。但是如果这个树十分庞大导致无法一眼看出，而且计算机也无法做到这么复杂的识别方式。最简单的方法就是一条线查找下去（从左到右）或者说一层层查找（从上到下）。

![image-20230216134441813](./image-20230216134441813-16923744802222-1721820002716-4-1723797363701-243.png)

现在是在一个二叉树内找数据，从一个节点到另一个节点只有两种方式，要么向左要么向右。而每个节点只有两种情况，要么有值要么没值。遍历的过程每一条线都是独立的，且每次遍历都高度相似（因为向下延伸只有两种方式）。终止条件就是找到我们需要的值。所以说这样的遍历方式符合使用递归的情况，以下是用递归实现遍历二叉树的代码：

> 二叉树的遍历有三种。前中后序遍历，但是基本上是差不多的，我们可以通过这三个遍历来看看改变递归函数的语句会产生什么变化。

在遍历构造之前，我们先构造树。

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};
```

##### 前序遍历

二叉树的前序遍历规则为：

- 如果二叉树为空，则返回。
- 如果二叉树不为空，则：
  1. 访问根节点。
  2. 以前序遍历的方式遍历根节点的左子树。
  3. 以前序遍历的方式遍历根节点的右子树

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};

void PT(TreeNode root)
{
    //如果访问的节点没有子节点
    if(nullptr == root) return;
    
    //打印遍历的节点数据
    cout<<root->data;
    
    //遍历左子树
    PT(root -> left);
    
    //遍历右子树
    PT(root -> right);    
    
}
```

如下图所示，该二叉树的前序遍历顺序为：**`A−B−D−H−I−E−C−F−J−G−K`**

![二叉树的前序遍历](./20240511171628-1723797363701-242.png)

二叉树的前序遍历递归实现的过程，实际上就是调用系统栈的过程。我们也可以使用一个显式栈 stack 来模拟递归的过程。

> 事实上，递归函数就是用栈来实现的

前序遍历的顺序为：根节点 - 左子树 - 右子树，而根据栈的「先入后出」特点，所以入栈的顺序应该为：先放入右子树，再放入左子树。这样可以保证最终遍历顺序为前序遍历顺序。

二叉树的前序遍历显式栈实现步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 初始化维护一个栈，将根节点入栈。
3. 当栈不为空时：
   - 弹出栈顶元素 node，并访问该元素。
   - 如果 node 的右子树不为空，则将 node 的右子树入栈。
   - 如果 node 的左子树不为空，则将 node 的左子树入栈。

##### 中序遍历

二叉树的中序遍历规则为：

- 如果二叉树为空，则返回。
- 如果二叉树不为空，则：
  1. 以中序遍历的方式遍历根节点的左子树。
  2. 访问根节点。
  3. 以中序遍历的方式遍历根节点的右子树。

```c++
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
  //和上面相比，就改变了顺序
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}
```

从二叉树的中序遍历规则可以看出：中序遍历过程也是一个递归过程。在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后访问根节点，最后再遍历子树根节点的右子树的顺序进行遍历。

如下图所示，该二叉树的中序遍历顺序为：**H−D−I−B−E−A−F−J−C−K−G**

> 中序遍历是指，中间节点永远夹在在遍历左右节点之间

![二叉树的中序遍历](./20240511171643-1723797363701-247.png)

##### 后序遍历

二叉树的后序遍历规则为：

- 如果二叉树为空，则返回。
- 如果二叉树不为空，则：
  1. 以后序遍历的方式遍历根节点的左子树。
  2. 以后序遍历的方式遍历根节点的右子树。
  3. 访问根节点。

从二叉树的后序遍历规则可以看出：后序遍历过程也是一个递归过程。在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后遍历子树根节点的右子树，最后再访问根节点的顺序进行遍历。

如下图所示，该二叉树的后序遍历顺序为：**H−I−D−E−B−J−F−K−G−C−A**

```c++
// 后序遍历二叉树
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    postorderTraversal(root->left); //左子树变为新的根节点
    postorderTraversal(root->right); //右子树变为新的根节点
    cout << root->data << " ";
}
```

> 这里模拟一下，访问到H节点，由于H节点无直接后继，那么其执行的两个函数的返回值将是空。
>
> ```c++
> postorderTraversal(root->left); //左子树变为新的根节点
> postorderTraversal(root->right); //右子树变为新的根节点
> ```
>
> 也就是说，这个时候打印的节点信息就是H这个点的节点信息了。第一次访问到的节点必定是H节点，因为在递归栈中，先压入的都是这个函数。
>
> ```c++
> postorderTraversal(root->left); //左子树变为新的根节点
> ```
>
> 压到H这个节点的时候结束程序，也就输出H的这个程序弹出栈了。也就是第一次执行完成了上面的程序，然后再压入；重复上述流程，就可以用后续遍历输出所有节点的值了。
>
> ```c++
> postorderTraversal(root->right); //右子树变为新的根节点
> ```
>
> 后续遍历：直观的描述就是每一个子树的根节点最后遍历到，也就是相对于左右子节点来说最后一个输出根节点的值（每一个子树）。

![二叉树的后序遍历](./20240511171658-1723797363701-244.png)

##### 层序遍历

二叉树的层序遍历：遍历过程是一个广度优先搜索过程。在遍历的时候是按照第 1 层、第 2 层、…… 最后一层依次遍历的，而同一层节点则是按照从左至右的顺序依次访问的。

如下图所示，该二叉树的层序遍历顺序为：**A−B−C−D−E−F−G−H−I−J−K**

![二叉树的层序遍历](./20240511175431-1723797363701-245.png)

二叉树的层序遍历是通过**队列**来实现的。具体步骤如下：

1. 判断二叉树是否为空，为空则直接返回。
2. 令根节点入队。
3. 当队列不为空时，求出当前队列长度 si
4. 依次从队列中取出这 si 个元素，并对这 si 个元素依次进行访问。然后将其左右孩子节点入队，然后继续遍历下一层节点。
5. 当队列为空时，结束遍历。

二叉树的层序遍历代码实现如下：

```c++
// 直到队列为空
// 二分搜索树的层序遍历
public void levelOrder(){

    // 我们使用LinkedList来作为我们的队列
    LinkedList<Node> q = new LinkedList<Node>();
    q.add(root);
    while( !q.isEmpty() ){

        Node node = q.remove();

        System.out.println(node.key);
  
        if( node.left != null )
            q.add( node.left );
        if( node.right != null )
            q.add( node.right );
    }
}
```

#### 还原二叉树

题目是依靠二叉树的前中后序的信息，来推出对应的另一个序列

##### 前中

前序遍历的信息：

- **前序遍历**的第一个节点是根节点。
- 根据**前序遍历**的第二个节点到第`n`个节点可以确定左子树的前序遍历，同样可以确定右子树的前序遍历。

中序遍历的信息：

- 在**中序遍历**中，根节点将二叉树分为左子树和右子树。

```yaml
函数 build_postorder(前序遍历, 中序遍历):
    如果 前序遍历 为空 或者 中序遍历 为空:
        返回 空列表

    # 前序遍历的第一个元素是根节点
    根节点 = 前序遍历[0]

    # 在中序遍历中找到根节点的位置
    根节点索引 = 在 中序遍历 中找到 根节点 的位置

    # 划分左子树和右子树的中序遍历
    左子树的中序遍历 = 中序遍历[0 到 根节点索引 - 1]
    右子树的中序遍历 = 中序遍历[根节点索引 + 1 到 末尾]

    # 根据左子树的大小划分左子树和右子树的前序遍历
    左子树的前序遍历 = 前序遍历[1 到 1 + 左子树的中序遍历的长度 - 1]
    右子树的前序遍历 = 前序遍历[1 + 左子树的中序遍历的长度 到 末尾]

    # 递归处理左子树和右子树，得到它们的后序遍历
    左子树的后序遍历 = build_postorder(左子树的前序遍历, 左子树的中序遍历)
    右子树的后序遍历 = build_postorder(右子树的前序遍历, 右子树的中序遍历)

    # 合并后序遍历结果
    返回 左子树的后序遍历 + 右子树的后序遍历 + [根节点]

```

##### 前后

前序遍历的信息：

- **前序遍历**的第一个节点是根节点。
- 在**前序遍历**中，根节点后紧跟的节点属于左子树

后序遍历的信息：

- **后序遍历**的最后一个节点也是根节点。
- 在**后序遍历**中，根节点前紧靠的节点也是左子树的最后一个节点。

```yaml
函数 build_inorder(前序遍历, 后序遍历):
    如果 前序遍历 为空 或者 后序遍历 为空:
        返回 空列表

    如果 前序遍历 的长度是 1:
        返回 前序遍历  # 只有一个节点，直接返回

    # 前序遍历的第一个节点是根节点
    根节点 = 前序遍历[0]

    # 后序遍历的最后一个节点也是根节点
    # 前序遍历中，根节点后的第一个节点是左子树的根节点
    左子树的根节点 = 前序遍历[1]

    # 在后序遍历中找到左子树根节点的位置
    左子树根节点索引 = 在 后序遍历 中找到 左子树的根节点 的位置

    # 确定左子树的后序遍历
    左子树的后序遍历 = 后序遍历[0 到 左子树根节点索引]

    # 确定左子树的前序遍历
    左子树的前序遍历 = 前序遍历[1 到 1 + 左子树根节点索引]

    # 递归处理左子树和右子树，得到它们的中序遍历
    左子树的中序遍历 = build_inorder(左子树的前序遍历, 左子树的后序遍历)
    右子树的中序遍历 = build_inorder(
        前序遍历[1 + 左子树根节点索引 到 末尾], 
        后序遍历[左子树根节点索引 + 1 到 根节点的前一个]
    )

    # 合并中序遍历结果
    返回 左子树的中序遍历 + [根节点] + 右子树的中序遍历
```

##### 中后

后序遍历的信息：

- **后序遍历**的最后一个节点是根节点。
- 根据**后序遍历**中的前`n-1`个节点，可以确定左子树和右子树的后序遍历。

中序遍历的信息：

- 在**中序遍历**中，根节点将二叉树分为左子树和右子树。

```yaml
函数 build_preorder(中序遍历, 后序遍历):
    如果 中序遍历 为空 或者 后序遍历 为空:
        返回 空列表

    如果 中序遍历 的长度是 1:
        返回 中序遍历  # 只有一个节点，直接返回

    # 后序遍历的最后一个节点是根节点
    根节点 = 后序遍历[-1]

    # 在中序遍历中找到根节点的位置
    根节点索引 = 在 中序遍历 中找到 根节点 的位置

    # 划分左子树和右子树的中序遍历
    左子树的中序遍历 = 中序遍历[0 到 根节点索引 - 1]
    右子树的中序遍历 = 中序遍历[根节点索引 + 1 到 末尾]

    # 根据左子树和右子树的中序遍历划分后序遍历
    左子树的后序遍历 = 后序遍历[0 到 左子树的中序遍历长度 - 1]
    右子树的后序遍历 = 后序遍历[左子树的中序遍历长度 到 倒数第二个]

    # 递归处理左子树和右子树，得到它们的前序遍历
    左子树的前序遍历 = build_preorder(左子树的中序遍历, 左子树的后序遍历)
    右子树的前序遍历 = build_preorder(右子树的中序遍历, 右子树的后序遍历)

    # 合并前序遍历结果
    返回 [根节点] + 左子树的前序遍历 + 右子树的前序遍历
```

#### [并查集](https://algo.itcharge.cn/07.Tree/05.Union-Find/)

并查集用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

并查集的重要思想在于，**用集合中的一个元素代表集合**。我曾看过一个有趣的比喻，把集合比喻成**帮派**，而代表元素则是**帮主**。接下来我们利用这个比喻，看看并查集是如何运作的。

- 对于只有一个元素的集合，代表元素自然是唯一的那个元素

![img](./v2-09fa3fa35e5411444b327d9cb9a31057_1440w.webp)

- 合并1号和3号所在的集合，1号为代表元素

![img](./v2-3bf6c1a6ecf87fa93f4dbab2012446c7_1440w.webp)

- 合并3号和2号所在的集合，合并代表元素，组合成一个新集合。

![img](./v2-be12a6c795572d2acd77dcd49de35127_1440w.webp)

重复上述结果就可以构成一个并查集。并查集是一个**树**状的结构，要寻找集合的代表元素，只需要一层一层往上访问**父节点**（图中箭头所指的圆），直达树的**根节点**（图中橙色的圆）即可。根节点的父节点是它自己。可以直接把它画成一棵树：

![img](./v2-cca3ddf5806a221201ed78caf1d27041_1440w.png)

##### 初始并查集

- 初始化，集合中每个元素都为一个集合。假如有编号为1, 2, 3, ..., n的n个元素，我们用一个数组fa[]来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。

```c++
int fa[MAXN];
inline void init(int n)
{
    for (int i = 1; i <= n; ++i)
        // 集合中每个元素都为一个集合
        fa[i] = i;
}
```

- 查询，访问集合代表元素，用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，只需要看它们的根节点是否相同即可。

```c++
int find(int x)
{
    if(fa[x] == x)
        return x;
    else
        return find(fa[x]);
}
```

- 合并，先找到两个集合的代表元素，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者。

```c++
inline void merge(int i, int j)
{
    fa[find(i)] = find(j);
}
```

##### 倍增法优化

通过引入倍增法（也称为“跳跃表”或“稀疏表”方法）来减少查询的时间复杂度。具体来说，倍增法可以在预处理阶段构建一个祖先表，使得每次查询可以在 O(log⁡n)的时间复杂度内完成。

```c++
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7;
const int LOG_N = 20; // log2(MAX_N) 取上界

int n, m, s;
int d[MAX_N]; // 保存节点深度
int f[MAX_N][LOG_N]; // 保存节点的 2^j 级父节点

int head[MAX_N], cnt = -1;
struct Edge {
    int to, next;
} e[MAX_N * 2];

void add(int u, int v) {
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u, int fa) // u为当前节点, fa为父节点
{
    f[u][0] = fa; // 直接父节点
    d[u] = d[fa] + 1;
    for (int j = 1; j < LOG_N; j++) {
        f[u][j] = f[f[u][j-1]][j-1]; // 预处理所有2^j父节点
    }
    for (int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].to;
        if (v != fa) {
            dfs(v, u);
        }
    }
}

int lca(int x, int y) {
    if (d[x] > d[y]) // 令y为更深节点
        swap(x, y);

    // 使x和y的深度相同
    for (int j = LOG_N - 1; j >= 0; j--) {
        if (d[f[y][j]] >= d[x]) {
            y = f[y][j];
        }
    }

    if (x == y) return x;

    // 同时向上移动直到找到最近公共祖先
    for (int j = LOG_N - 1; j >= 0; j--) {
        if (f[x][j] != f[y][j]) {
            x = f[x][j];
            y = f[y][j];
        }
    }

    return f[x][0]; // 返回LCA
}

int main() {
    memset(head, -1, sizeof(head));
    memset(f, 0, sizeof(f)); // 初始化 f 数组
    int a, b;
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &a, &b);
        add(a, b);
        add(b, a); // 无向图，要加两次
    }
    dfs(s, 0);

    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &a, &b);
        printf("%d\n", lca(a, b));
    }

    return 0;
}
```

##### 路径压缩优化

最简单的并查集效率是比较低的。例如，来看下面这个场景：

![img](./v2-49b5dd7af650192373e96d29f9c4b8cf_1440w.webp)

现在我们要merge(2,3)，于是从2找到1，fa[1]=3，于是变成了这样：

![img](./v2-6f85fc7c5578aa20400ac56f0da31e37_1440w.webp)

然后我们又找来一个元素4，并需要执行merge(2,4)：

![img](./v2-1d3ef8a42d424cbec76135ce8a494ff7_1440w.webp)

从2找到1，再找到3，然后fa[3]=4，于是变成了这样：

![img](./v2-23c367515ace6fc0603692dfd865849f_1440w.webp)

这样可能会形成一条长长的**链**，随着链越来越长，我们想要从底部找到根节点会变得越来越难。

怎么解决呢？我们可以使用**路径压缩**的方法。既然我们只关心一个元素对应的**根节点**，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：

![img](./v2-c2f835398a3e54d8209bf5e034ac6820_1440w.png)

其实这说来也很好实现。只要我们在查询的过程中，**把沿途的每个节点的父节点都设为根节点**即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：

- 合并

  ```c++
  int find(int x)
  {
      if(x == fa[x])
          return x;
      else{
          fa[x] = find(fa[x]);  //父节点设为根节点
          return fa[x];         //返回父节点
      }
  }
  ```

- 简化

  ```c++
  int find(int x)
  {
      return x == fa[x] ? x : (fa[x] = find(fa[x]));
  }
  ```

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 500000 + 7;

int n, m, s;
vector<int> adj[MAX_N]; // 邻接表存储树
int parent[MAX_N]; // 并查集中的父节点
int ancestor[MAX_N]; // 记录每个节点的祖先
int visited[MAX_N]; // 记录节点是否被访问过
int lca_res[MAX_N]; // 保存每次查询的结果
vector<pair<int, int>> queries[MAX_N]; // 保存LCA查询

// 并查集的路径压缩
int find(int x) {
    if (x != parent[x]) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

// Tarjan's LCA
void tarjan(int u) {
    ancestor[u] = u;
    visited[u] = 1;
    for (int v : adj[u]) {
        if (!visited[v]) {
            tarjan(v);
            parent[v] = u; // 合并子节点到当前节点
        }
    }
    // 处理LCA查询
    for (auto &[v, index] : queries[u]) {
        if (visited[v]) {
            lca_res[index] = ancestor[find(v)];
        }
    }
}

int main() {
    cin >> n >> m >> s;
    
    // 初始化
    for (int i = 1; i <= n; ++i) {
        parent[i] = i;
    }
    
    int a, b;
    for (int i = 1; i < n; ++i) {
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a); // 无向图
    }

    for (int i = 1; i <= m; ++i) {
        cin >> a >> b;
        queries[a].push_back({b, i});
        queries[b].push_back({a, i});
    }

    tarjan(s);

    for (int i = 1; i <= m; ++i) {
        cout << lca_res[i] << endl;
    }

    return 0;
}
```

#### [哈夫曼树](https://pdai.tech/md/algorithm/alg-basic-tree-hafman.html)

哈夫曼树推理是通过叶子节点，所以理解的时候需要忽略非叶子节点

![img](./alg-tree-hafman-1.png)

`路径与路径长度`: 从树中一个节点到另一个节点之间的分支构成了两个节点之间的路径，路径上的分支数目称作路径长度。若规定根节点位于第一层，则根节点到第H层的节点的路径长度为H-1。如到40 的路径长度为1；30的路径长度为2；20的路径长度为3。

`节点的权`: 将树中的节点赋予一个某种含义的数值作为该节点的权值，该值称为节点的权；

`带权路径长度`: 从根节点到某个节点之间的路径长度与该节点的权的乘积。例如上图节点10的路径长度为3,它的带权路径长度为10 * 3 = 30；

`树的带权路径长度`: **树的带权路径长度为所有叶子节点的带权路径长度之和，称为WPL。**上图的WPL = 1x40+2x30+3x10+3x20 = 190，而哈夫曼树就是树的带权路径最小的二叉树。

##### 哈夫曼树的构建

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，哈夫曼树的构造规则为:

- 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
- 在森林中选出根结点的权值最小的两棵树进行合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
- 从森林中删除选取的两棵树，并将新树加入森林；
- 重复上面两步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

上图中，它的叶子节点为{10，20，30，40}，以这4个权值构建哈夫曼树的过程为:

![img](./alg-tree-hafman-2.png)

##### 哈夫曼编码

为{10，20，30，40}这四个权值构建了哈夫曼编码后，我们可以由如下规则获得它们的哈夫曼编码:

从根节点到每一个叶子节点的路径上，左分支记为0，右分支记为1，将这些0与1连起来即为叶子节点的哈夫曼编码。如下图:

| **(字母)权值** | **编码** |
| :------------: | :------: |
|       10       |   100    |
|       20       |   101    |
|       30       |    11    |
|       40       |    0     |

由此可见，出现频率越高的字母(也即权值越大)，其编码越短。这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。

具体流程如下:

![img](./alg-tree-hafman-5.jpeg)

```c++
#include <iostream>
#include <queue>
#include <vector>
#include <map>
using namespace std;

// 哈夫曼树的节点结构
struct HuffmanNode {
    char ch;  // 存储的字符
    int freq; // 该字符的频率
    HuffmanNode *left, *right;

    HuffmanNode(char ch, int freq) : ch(ch), freq(freq), left(nullptr), right(nullptr) {}
};

// 自定义比较器，用于优先队列
struct Compare {
    bool operator()(HuffmanNode* left, HuffmanNode* right) {
        return left->freq > right->freq; // 最小堆，频率小的优先级高
    }
};

// 构建哈夫曼树
HuffmanNode* buildHuffmanTree(const map<char, int>& freqMap) {
    priority_queue<HuffmanNode*, vector<HuffmanNode*>, Compare> minHeap;

    // 创建叶子节点并插入优先队列
    for (auto pair : freqMap) {
        minHeap.push(new HuffmanNode(pair.first, pair.second));
    }

    // 构建哈夫曼树
    while (minHeap.size() > 1) {
        HuffmanNode* left = minHeap.top();
        minHeap.pop();
        HuffmanNode* right = minHeap.top();
        minHeap.pop();

        // 创建一个新节点，它的频率是两个子节点频率之和
        HuffmanNode* node = new HuffmanNode('\0', left->freq + right->freq);
        node->left = left;
        node->right = right;

        // 将新节点插入优先队列
        minHeap.push(node);
    }

    // 最终队列中的唯一节点就是哈夫曼树的根节点
    return minHeap.top();
}

// 生成哈夫曼编码
void generateHuffmanCodes(HuffmanNode* root, string code, map<char, string>& huffmanCode) {
    if (!root) return;

    // 叶子节点
    if (!root->left && !root->right) {
        huffmanCode[root->ch] = code;
    }

    // 向左子树添加 '0'
    generateHuffmanCodes(root->left, code + "0", huffmanCode);
    // 向右子树添加 '1'
    generateHuffmanCodes(root->right, code + "1", huffmanCode);
}

// 打印哈夫曼编码
void printHuffmanCodes(const map<char, string>& huffmanCode) {
    for (auto pair : huffmanCode) {
        cout << pair.first << ": " << pair.second << endl;
    }
}

int main() {
    // 输入字符及其频率
    map<char, int> freqMap = {
        {'a', 5}, {'b', 9}, {'c', 12}, {'d', 13}, {'e', 16}, {'f', 45}
    };

    // 构建哈夫曼树
    HuffmanNode* root = buildHuffmanTree(freqMap);

    // 生成哈夫曼编码
    map<char, string> huffmanCode;
    generateHuffmanCodes(root, "", huffmanCode);

    // 打印哈夫曼编码
    printHuffmanCodes(huffmanCode);

    return 0;
}
```

### 图

> **图（Graph）**：由顶点的非空有限集合 V （由 n>0 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)

- **顶点（Vertex）**：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。
- **边（Edge）**：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=⟨u,v⟩，表示从 u 到 v 的一条边，其中 u 称为起始点，v 称为终止点。

![img](./20220307145142-1723797363701-246.png)

- **子图（Sub Graph）**：对于图 G=(V,E) 与 G′=(V′,E′)，如果存在 V′⊆V，E′⊆E，则称图 G′ 是图 G 的一个子图。在下面的示意图中我们给出了一个图 *G* 及其一个子图 *G*′。特别的，根据定义，G 也是其自身的子图。

![img](./20220317163120-1723797363701-249.png)

#### 图的分类

##### 有向图与无向图

按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。

- **无向图（Undirected Graph）**：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。
- **有向图（Directed Graph）**：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。

在无向图中，每条边都是由两个顶点组成的无序对。例如下图左侧中的顶点 v1 和顶点 v2 之间的边记为 (v1,v2) 或 (v2,v1)

在有向图中，有向边也被称为弧，每条弧是由两个顶点组成的有序对，例如下图右侧中从顶点 v1 到顶点 *v*2 的弧，记为 ⟨*v*1,*v*2⟩，v1 被称为弧尾，v2 被称为弧头，如下图所示。

![img](./20220307160017-1723797363701-250.png)

如果无向图中有 n 个顶点，则无向图中最多有 n×(n−1)/2n 条边。而具有 n*×(*n−1)/2 条边的无向图称为 **「完全无向图（Completed Undirected Graph）」**。

如果有向图中有 n 个顶点，则有向图中最多有 n×(n−1) 条弧。而具有 n×(n−1) 条弧的有向图称为 **「完全有向图（Completed Directed Graph）」**。

如下图所示，左侧为包含 4 个顶点的完全无向图，右侧为包含 4 个顶点的完全有向图。

![img](./20220308151436-1723797363701-254.png)

下面介绍一下无向图和有向图中一个重要概念 **「顶点的度」**。

- **顶点的度**：与该顶点 vi 相关联的边的条数，记为 TD(vi)

例如上图左侧的完全无向图中，顶点 v3 的度为 3。

而对于有向图，我们可以将顶点的度分为 **「顶点的出度」** 和 **「顶点的入度」**。

- **顶点的出度**：以该顶点 vi 为出发点的边的条数，记为 OD(vi)。
- **顶点的入度**：以该顶点 vi为终止点的边的条数，记为 ID(vi)。
- 有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 TD(vi)=OD(vi)+ID(vi)。

例如上图右侧的完全有向图中，顶点 v3 的出度为 3，入度为 3，顶点 v3 的度为 3+3=6

##### 环形图和无环图

如果顶点 vi0 可以通过一系列的顶点和边，到达顶点 vim，则称顶点 vi0 和顶点 vim 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。

- **环（Circle）**：如果一条路径的起始点和终止点相同（即 vi0==vim），则称这条路径为「回路」或者「环」。
- **简单路径**：顶点序列中顶点不重复出现的路径称为「简单路径」。

而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。

- **环形图（Circular Graph）**：如果图中存在至少一条环路，则该图称为「环形图」。
- **无环图（Acyclic Graph）**：如果图中不存在环路，则该图称为「无环图」。

特别的，在有向图中，如果不存在环路，则将该图称为「有向无环图（Directed Acyclic Graph）」，缩写为 DAG。因为有向无环图拥有为独特的拓扑结构，经常被用于处理动态规划、导航中寻求最短路径、数据压缩等多种算法场景。

如下图所示，分别为：无向无环图、无向环形图、有向无环图和有向环形图。其中有向环形图中的顶点 v1、v2、v3 与相连的边构成了一个环。

![环形图和无环图](./20220317115641-1723797363701-253.png)

##### 连通图和非连通图

在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称顶点 vi 和 vj 是连通的。

- **连通无向图**：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。
- **非连通无向图**：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。

如下图所示，左侧图中 v1 与 v2、v3、v4、v5、v6 都是连通的，所以该图为连通无向图。右侧图中 v1 与 v2、v3、v4 都是连通的，但是 v1 和 v5、v6 之间不存在任何路径，则该图为非连通无向图。

![img](./20220317163249-1723797363701-251.png)

下面介绍一下无向图的「连通分量」概念。有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的「连通分量」。

- **连通子图**：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。
- **连通分量**：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。
- **极⼤连通⼦图**：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。

例如上图中右侧的非连通无向图，其本身是非连通的。但顶点 v1、v2、v3、v4 与其相连的边构成的子图是连通的，并且不存在包含它的更大的连通子图了，所以该子图是原图的一个连通分量。同理，顶点 v5、v6 与其相连的边构成的子图也是原图的一个连通分量。

##### 强连通有向图和强连通分量

在有向图中，如果从顶点 vi 到 vj 有路径，并且从顶点 vj 到 vi 也有路径，则称顶点 vi 与 vj 是连通的。

- **强连通有向图**：如果图中任意两个顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通有向图。
- **非强连通有向图**：如果图中至少存在一对顶点之间不存在任何路径，则该图称为非强连通有向图。

如下图所示，左侧图中任意两个顶点之间都有路径，则左侧图为强连通有向图。右侧图中顶点 v7 无法通过路径到达其他顶点，则右侧图为非强连通有向图。

![img](./20220317133500-1723797363701-252.png)

与无向图类似，有向图的一个极大强连通子图称为该图的 **强连通分量**。

- **强连通子图**：如果有向图的子图是连通有向图，则该子图称为原图的强连通子图。
- **强连通分量**：有向图中的一个极⼤强连通⼦图，称为该图的强连通分量。
- **极⼤强连通⼦图**：有向图中的一个强连通子图，并且不存在包含它的更大的强连通子图。

例如上图中，右侧的非强连通有向图，其本身不是强连通的（顶点 v7 无法通过路径到达其他顶点）。但顶点 v1、v2、v3、v4、v5、v6 与其相连的边构成的子图（即上图的左侧图）是强连通的，并且不存在包含它的更大的强连通子图了，所以该子图是原图的一个强连通分量（即上图中的左侧图是右侧图的强连通分量）。同理，顶点 v7 构成的子图也是原图的一个强连通分量。

##### 带权图

有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 **权**。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。

- **带权图**：如果图的每条边都被赋以⼀个权值，这种图称为带权图。
- **网络**：带权的连通⽆向图称为⽹络。

在下面的示意图中，我们给出了一个带权图的例子。

![img](./20220317135207-1723797363701-255.png)

##### 稠密图和稀疏图

根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。

- **稠密图（Dense Graph）**：有很多条边或弧（边的条数 e 接近于完全图的边数）的图称为稠密图。
- **稀疏图（Sparse Graph）**：有很少条边或弧（边的条数 e 远小于完全图的边数，如 e*<*n×log2n）的图称为稀疏图。

#### 图的存储方式

图的结构比较复杂，我们需要表示顶点和边。一个图可能有任意多个（有限个）顶点，而且任何两个顶点之间都可能存在边。我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。

图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。

接下来我们来介绍几个常用的图的存储结构。在下文中，我们约定用 n 代表顶点数目，m代表边数目，TD(vi) 表示顶点 vi 的度。

##### 领接矩阵

邻接矩阵是使用二维数组来存储图像，每一个位置表示一个坐标，对应坐标中的值表示权。权的意思是从一个节点到另一个节点的距离。如果当前节点没有下一个坐标的话，其权的值标记为无穷大，表示不可达。

在下面的示意图中，左侧是一个无向图，右侧则是该无向图对应的邻接矩阵结构。

![img](./20220317144826-1723797363701-256.png)

邻接矩阵的特点：

- 优点：实现简单，并且可以直接查询顶点 vi与 vj 之间是否有边存在，还可以直接查询边的权值。
- 缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 n*>105）时，使用邻接矩阵建立一个 n*×*n* 的二维数组不太现实。所有邻接表只适合用于稠密图

![image-20230305080127311](./image-20230305080127311-1721820002717-12-1723797363701-257.png)

```c++
//领接矩阵声明，开一个二维数组； 
//1.二维数组w[u][v],存储u - v的边权（就是这个连线多长）
//2.只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）
//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系
#include<iostream>
using namespace std;

int w[N][N]; //声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c
int vis[N];//点集

void dfs(int u){
    vis[u] = true;
    for(int v = 1;v<=n;v++){
        printf("%d,%d,%d\n",u,v,w[u][v]);
        if(vis[u]) continue;
        dfs(v);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b;
        w[a][b] = c; //赋予权值（a点 和 b点）（算是连线）
        //w[b][a] = c;
    }
    //遍历打印
    dfs(1);
    return 0;
}
```

##### 边集数组

**边集数组（Edgeset Array）**：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点 vi、终点 vj 和边的权值 val（如果是带权图）。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的边集数组结构。

![img](./20220317161454-1723797363701-258.png)

采用边集数组计算节点的度或者查找某条边时，需要遍历整个边集数组，时间复杂度为 O(m)，`m` 是边的数量。**除非特殊必要，很少用使用边集数组来存储图。**

一般来说，边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任何一条边的运算。

![image-20230305080154969](./image-20230305080154969-1721820002716-7-1723797363701-259.png)

声明了一个结构体，存储我们两个节点对应的边。好处就是不用按照数组下标开对应大的数组。声明两个变量存储对应的节点序列，然后声明一个变量存储权即可。

```c++
//边集数组
//结构体下标联系三者
#include<iostream>
using namespace std;
struct edge(){
    int u,v,w; //两点 和 权
}e[M]; //边集合
int vis[N]; //点

//理解每个眼神只有一个值
//bfs负责深度 - for负责宽度
void bfs(int u){
    vis[u] = true;
    for(int i = 1;i<=m;i++){
        int v = e[i].v,w = e[i].w; //用结构体中对应的值
        printf("%d,%d,%d",u,v,w);
        if(vis[v]) continue; //这个点到过了
        dfs(e[i].v);//下一个点
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++)
    {
        cin>>a>>b>>c;
        e[i] = {a,b,c};
        //e[i] = {b,a,c}; //无向图就要加上
    }
    dfs(1);
    return 0;
}
```

##### 领接表

**邻接表（Adjacency List）**：使用顺序存储和链式存储相结合的存储结构来存储图的顶点和边。其数据结构包括两个部分，其中一个部分是数组，主要用来存放顶点的数据信息，另一个部分是链表，用来存放边信息。

![image-20230302110544398](./image-20230302110544398-1721820002716-10-1723797363701-260.png)

在邻接表的存储方法中，对于对图中每个顶点 vi 建立一个线性链表，把所有邻接于 vi 的顶点链接到单链表上。这样对于具有 `n` 个顶点的图而言，其邻接表结构由 `n` 个线性链表组成。

然后我们在每个顶点前边设置一个表头节点，称之为「顶点节点」。每个顶点节点由「顶点域」和「指针域」组成。其中顶点域用于存放某个顶点的数据信息，指针域用于指出该顶点第 `1` 条边所对应的链节点。

为了方便随机访问任意顶点的链表，通常我们会使用一组顺序存储结构（数组）存储所有「顶点节点」部分，顺序存储结构（数组）的下标表示该顶点在图中的位置。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的邻接表结构。

![img](./20220317154531-1723797363701-261.png)

```c++
//领接表（将图用dfs序输出） - 父节点和子节点的连接方式
//出边数组e[u][i] 存储u点的所有出边{终点 v,边权 w}。
#include<iostream>
using namespace std;

struct edga{int v,w;}; //声明结构体（代表每个点有的属性）
vector<edga> e[N];//存储的是每一个起点（有n个）

void dfs(int u,int fa)
{
    for(auto ed:e[u]) //遍历当前层的元素
    {
        int v = ed.v,w = ed.w;
        if(v==fa) continue;//(记录父结点)（u和fa是交替使用的）
        printf("%d，%d,%d\n",u,v,w);
        dfs(v,u);//fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）
    }   
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图 两边都要连接
        //{}结构体的插入方式
        e[a].push_back({b,c});
        e[b].push_back({c,b});
    }
    //1.从哪一个点开始深搜  2.当前节点的父节点
    dfs(1,0);
    return 0;   
    
}
```

##### 链式领接表

![image-20230302111110291](./image-20230302111110291-1721820002716-8-1723797363701-262.png)

`h`数组存储插入数据的编号，在这里也就是输入的`e`这些节点编号。`e`数组存储的是两个不同的节点连接的信息。

```c++
//1.表头数据存储读入数据的顺序，然后给边编号 - 节点的出边的索引
//2.边集数组存储的是边的信息
#include<iostream>
using namespace std;

struct edge{int u,v,w};
vector<edge> e; //边集合（边的属性）
vector<int> h[N]; //点的所有出边

void add(int a,int b,int c)
{
    e.push_back({a,b,c}); // 对应边的属性压入
    h[a].push_back(e.size()-1); //边号
}
//u当前节点 fa-父节点
void dfs(int u,int fa)
{
    for(int i = 0;i<h[u].size();i++){
        int j = h[u][i];//输入点编号顺序 - 表示u连i
        int v = e[j].v,w = e[j].w;
        if(v == fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //邻接表存储数据
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）
    return 0;
    
    
}
```

##### 链式前向星

**链式前向星（Linked Forward Star）**：也叫做静态邻接表，实质上就是使用静态链表实现的邻接表。链式前向星将边集数组和邻接表相结合，可以快速访问一个节点所有的邻接点，并且使用很少的额外空间。

> 就是用数组模拟链表来实现邻接表

![img](./20220317161217-1723797363701-263.png)

链式前向星采用了一种静态链表的存储方式，可以说是目前建图和遍历效率最高的存储方式。

链式前向星由两种数据结构组成：

- **特殊的边集数组**：`edges`，其中 `edges[i]` 表示第 `i` 条边。`edges[i].vj` 表示第 `i` 条边的终止点，`edges[i].val` 表示第 `i` 条边的权值，`edges[i].next` 表示与第 `i` 条边同起始点的下一条边的存储位置。
- **头节点数组**：`head`，其中 `head[i]` 存储以顶点 `i` 为起始点的第 `1` 条边在数组 `edges` 中的下标。

链式前向星其实并没有改变边集数组原来的存储数学，只是利用 `head` 数组构成静态链表，建立了顶点 vi 和顶点 vi 所连第 `1` 条边的关系。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的链式前向星结构。

如果需要在该图中遍历顶点 v1 的所有边，则步骤如下：

- 找到以顶点 v1 为起始点的的 `1` 条边在数组 `edges` 中的下标，即 `index = head[1] = 1 `。则在 `edges` 数组中找到与顶点 v1 相连的第 `1` 条边为 `edges[1]`，即 ⟨v1,v5⟩，权值为 6。
- 查找 `index = self.edges[1].next = 0 `，则在 `edges` 数组中找到与顶点 v1 相连的第 `2` 条边 `edges[0]`，即 ⟨v1,v2⟩，权值为 5。
- 继续查找 `index = self.edges[0].next = -1`，则不存在其余边，查找结束。

![image-20230302112003101](./image-20230302112003101-1721820002717-31-1723797363701-264.png)

```c++
#include<iostream>
using namespace std;

struct edge{int v,w,ne;};//ne是链接点的编号 - 例如1-4
edge e[M]; // 存储当前节点的出边
int idx,h[N]; //idx是提供编号的变量，h是每个节点的第一条出边的编号


//获取第一个出边
void add(int a,int b,int c){
    //a第一条出边和b连接 - 这里h[a]表示a的出边
    e[idx] = {b,c,h[a]}; 
    //idx给每一个边都搞一个编号 - 让b和a联系
    h[a] = idx++;
}


void dfs(int u,int fa)
{
    //横向遍历产生分支
    for(int i = h[u];~i;i=e[i].ne){ //~i表示i不等于-1
        int v = e[i].v,w = e[i].w;
        if(v == fa) continue;//判重 产生新分支
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);//深入
    }    
}

int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);//初始化表头
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图构图
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);
    return 0;     
}
```

##### 哈希表

哈希表（字典）可以轻松的实现邻接表。哈希表实现邻接表包含两个哈希表：第一个哈希表主要用来存放顶点的数据信息，哈希表的键是顶点，值是该点所有邻接边构成的另一个哈希表。另一个哈希表用来存放顶点相连的边信息，哈希表的键是边的终点，值是边的权重。

哈希表实现邻接表的时间复杂度：

- 图的初始化和创建操作：O(n+m)
- 查询是否存在 vi 到 vj 的边：O(1)。
- 遍历某个点的所有边：O(TD(vi))
- 遍历整张图：O(n+m)

哈希表实现邻接表的空间复杂度：

- 空间复杂度：O(n+m)

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

// 顶点信息类
class VertexNode {
public:
    int vi;  // 顶点
    unordered_map<int, int> adj_edges;  // 邻接边和权值
    
    VertexNode(int vi) : vi(vi) {}
};

// 图类
class Graph {
public:
    unordered_map<int, VertexNode*> vertices;  // 顶点集合
    
    // 构造函数
    Graph() {}
    
    // 析构函数，释放动态内存
    ~Graph() {
        for (auto it : vertices) {
            delete it.second;
        }
    }
    
    // 图的创建操作，edges为边信息
    void createGraph(const vector<vector<int>>& edges) {
        for (const auto& edge : edges) {
            int vi = edge[0];
            int vj = edge[1];
            int val = edge[2];
            addEdge(vi, vj, val);
        }
    }
    
    // 向图中添加顶点
    void addVertex(int vi) {
        vertices[vi] = new VertexNode(vi);
    }
    
    // 向图的邻接表中添加边：vi - vj，权值为 val
    void addEdge(int vi, int vj, int val) {
        if (vertices.find(vi) == vertices.end()) {
            addVertex(vi);
        }
        if (vertices.find(vj) == vertices.end()) {
            addVertex(vj);
        }
        vertices[vi]->adj_edges[vj] = val;
    }
    
    // 获取 vi - vj 边的权值
    int getEdge(int vi, int vj) {
        if (vertices.find(vi) != vertices.end() && 
            vertices[vi]->adj_edges.find(vj) != vertices[vi]->adj_edges.end()) {
            return vertices[vi]->adj_edges[vj];
        }
        return -1;  // 如果边不存在，返回 -1
    }
    
    // 根据邻接表打印图的边
    void printGraph() {
        for (const auto& vertex : vertices) {
            int vi = vertex.first;
            for (const auto& edge : vertex.second->adj_edges) {
                int vj = edge.first;
                int val = edge.second;
                cout << vi << " - " << vj << " : " << val << endl;
            }
        }
    }
};

int main() {
    Graph graph;
    vector<vector<int>> edges = {{1, 2, 5}, {1, 5, 6}, {2, 4, 7}, 
                                 {4, 3, 9}, {3, 1, 2}, {5, 6, 8}, {6, 4, 3}};
    graph.createGraph(edges);
    cout << "Edge value between 3 and 4: " << graph.getEdge(3, 4) << endl;
    graph.printGraph();
    
    return 0;
}
```

#### [图的遍历](https://algo.itcharge.cn/08.Graph/02.Graph-Traversal/01.Graph-DFS/#_1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%80%E4%BB%8B)

##### 递归遍历

**深度优先搜索算法（Depth First Search）**：英文缩写为 DFS，是一种用于搜索树或图结构的算法。深度优先搜索算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。

深度优先搜索算法中所谓的深度优先，就是说优先沿着一条路径走到底，直到无法继续深入时再回头。在深度优先遍历的过程中，**我们需要将当前遍历节点 u 的相邻节点暂时存储起来，以便于在回退的时候可以继续访问它们。**遍历到的节点顺序符合「后进先出」的特点，这正是「递归」和「堆栈」所遵循的规律，所以深度优先搜索可以通过「递归」或者「堆栈」来实现。

接下来我们以一个无向图为例，介绍一下深度优先搜索的算法步骤。

- 选择起始节点 u，并将其标记为已访问。

  ![深度优先搜索 1](./202309042321406-1723797363701-265.png)

- 检查当前节点是否为目标节点（看具体题目要求）。

  ![深度优先搜索 2](./202309042323911.png)

- 如果当前节点 u 是目标节点，则直接返回结果。

  ![深度优先搜索 3](./202309042324370.png)

- 如果当前节点 u 不是目标节点，则遍历当前节点 u 的所有未访问邻接节点。

  ![深度优先搜索 4](./202309042325587.png)

- 对每个未访问的邻接节点 v，从节点 v 出发继续进行深度优先搜索（递归）。

  ![深度优先搜索 5](./202309042325689-1723797363701-266.png)

- 如果节点 u 没有未访问的相邻节点，回溯到上一个节点，继续搜索其他路径。

  ![深度优先搜索 6](./202309042325770-1723797363701-267.png)

- 重复 2∼6步骤，直到遍历完整个图或找到目标节点为止。

```c++
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    // 深度优先搜索递归函数
    void dfs_recursive(unordered_map<string, vector<string>>& graph, const string& u, unordered_set<string>& visited) {
        cout << u << endl;             // 访问节点
        visited.insert(u);             // 节点 u 标记其已访问

        for (const string& v : graph[u]) {
            if (visited.find(v) == visited.end()) {  // 节点 v 未访问过
                // 递归遍历节点 v
                dfs_recursive(graph, v, visited);
            }
        }
    }
};

int main() {
    // 构建图
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"A", "C", "D"}},
        {"C", {"A", "B", "D", "E"}},
        {"D", {"B", "C", "E", "F"}},
        {"E", {"C", "D"}},
        {"F", {"D", "G"}},
        {"G", {}}
    };

    // 创建 Solution 对象并调用深度优先搜索
    unordered_set<string> visited;
    Solution().dfs_recursive(graph, "A", visited);

    return 0;
}
```

##### [层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/)

**广度优先搜索算法（Breadth First Search）**：英文缩写为 BFS，又译作宽度优先搜索 / 横向优先搜索，是一种用于搜索树或图结构的算法。广度优先搜索算法从起始节点开始，逐层扩展，先访问离起始节点最近的节点，后访问离起始节点稍远的节点。以此类推，直到完成整个搜索过程。

因为遍历到的节点顺序符合「先进先出」的特点，所以广度优先搜索可以通过「队列」来实现。接下来我们以一个无向图为例，介绍一下广度优先搜索的算法步骤。

- 将起始节点 u 放入队列中，并标记为已访问。

![广度优先搜索 1](./20230905152316-1723797363701-269.png)

- 从队列中取出一个节点，访问它并将其所有的未访问**邻接节点 v** 放入队列中。

![广度优先搜索 2](./20230905152327-1723797363701-268.png)

- 标记已访问的节点 v，以避免重复访问。

![广度优先搜索 3](./20231009141628-1723797363701-272.png)

- 重复步骤 2∼3，直到队列为空或找到目标节点。

![广度优先搜索 4](./20230905152401-1723797363701-270.png)

- 访问它并将其所有的未访问**邻接节点 v** 放入队列中。

![广度优先搜索 5](./20230905152420-1723797363701-271.png)

- 结点出队

![广度优先搜索 6](./20230905152433-1723797363701-274.png)

- 结点出队，队列为空算法结束

![广度优先搜索 7](./20230905152445-1723797363701-273.png)

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 定义图的节点数据结构
struct Node {
    int value;  // 节点的值
    vector<Node*> neighbors;  // 相邻节点列表
    bool visited;  // 标记节点是否已经访问过

    Node(int val) : value(val), visited(false) {}
};

// BFS遍历函数
void bfs(Node* start) {
    queue<Node*> q;
    q.push(start);

    while (!q.empty()) {
        Node* cur = q.front();
        q.pop();

        if (!cur->visited) {
            cout << "Visiting node with value: " << cur->value << endl;
            cur->visited = true;

            for (Node* neighbor : cur->neighbors) {
                if (neighbor && !neighbor->visited) {
                    q.push(neighbor);
                }
            }
        }
    }
}

int main() {
    // 创建图节点
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    Node* node4 = new Node(4);

    // 建立节点之间的连接关系
    node1->neighbors = {node2, node3};
    node2->neighbors = {node1, node4};
    node3->neighbors = {node1, node4};
    node4->neighbors = {node2, node3};

    // 从起始节点开始BFS遍历
    bfs(node1);

    // 释放节点内存
    delete node1;
    delete node2;
    delete node3;
    delete node4;

    return 0;
}
```

#### [拓扑排序](https://zhuanlan.zhihu.com/p/135094687)

**拓扑排序（Topological Sorting）**：一种对有向无环图（DAG）的所有顶点进行线性排序的方法，使得图中任意一点 u 和 v，如果存在有向边 <u,v>，则 u 必须在 v 之前出现。对有向图进行拓扑排序产生的线性序列称为满足拓扑次序的序列，简称拓扑排序。

图的拓扑排序是针对有向无环图（DAG）来说的，无向图和有向有环图没有拓扑排序，或者说不存在拓扑排序。

![有向无环图](./202405092308713-1723797363701-276.png)

如上图中的有向无环图（DAG）所示，v1→v2→v3→v4→v5→v6 是该图的一个拓扑序列。与此同时，v1→v2→v3→v4→v6→v5 也是该图的一个拓扑序列。也就是说，对于一个有向无环图来说，拓扑序列可能不止一个。

![image-20230302193314874](./image-20230302193314874-1721820002717-18-1723797363701-275.png)

拓扑排序有两种实现方法，分别是「Kahn 算法」和「DFS 深度优先搜索算法」。接下来我们依次来看下它们是如何实现的。

##### KAHN算法

**Kahn 算法的基本思想**：

1. **不断找寻有向图中入度为 0 的顶点，将其输出**。
2. 然后删除入度为 0 的顶点和从该顶点出发的有向边。
3. 重复上述操作直到图为空，或者找不到入度为 0 的节点为止。

![image-20230302195721755](./image-1723797363701-278.png)

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 100005;  // 假设最大顶点数为 100000

vector<int> e[N];   // 邻接表存储图
vector<int> tp;     // 存储最终输出的拓扑序列
int din[N];         // 存储每个顶点的入度
int n, m;           // 顶点数和边数

bool toposort() {
    queue<int> q;

    // 初始化：将所有入度为 0 的顶点加入队列
    for (int i = 1; i <= n; i++) {
        if (din[i] == 0) q.push(i);
    }

    while (!q.empty()) {
        int x = q.front();
        q.pop();  // 从队列中取出队头

        tp.push_back(x);  // 加入拓扑序列

        // 删除以 x 为起点的所有边
        for (int y : e[x]) {
            if (--din[y] == 0) q.push(y);  // 如果 y 的入度为 0，加入队列
        }
    }

    // 如果拓扑序列中的顶点数等于图中的顶点数，则返回 true
    return tp.size() == n;
}

int main() {
    cin >> n >> m;

    // 读取图的边信息
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
        din[b]++;
    }

    if (!toposort()) {
        puts("-1");  // 如果无法形成拓扑序列，输出 -1
    } else {
        for (int x : tp) printf("%d ", x);  // 输出拓扑序列
        puts("");  // 换行
    }

    return 0;
}

```

##### DFS算法

**基于 DFS 实现拓扑排序算法的基本思想**：

1. 对于一个顶点 u，深度优先遍历从该顶点出发的有向边 <u,v>。如果从该顶点 u 出发的所有相邻顶点 v 都已经搜索完毕，则回溯到顶点 u 时，该顶点 u应该位于其所有相邻顶点 v 的前面（拓扑序列中）。
2. 这样一来，当我们对每个顶点进行深度优先搜索，在回溯到该顶点时将其放入栈中，则最终从栈顶到栈底的序列就是一种拓扑排序。

![image-20230302195739338](./image-20230302195739338-1721820002717-20-1723797363701-277.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm>  // 引入 reverse 函数
#include <cstring>    // 引入 memset 函数，用于初始化数组
using namespace std;

const int N = 100005;  // 假设最大顶点数为 100000

vector<int> e[N];   // 邻接表表示的图
vector<int> tp;     // 存储最终的拓扑序列
int c[N];           // 用于染色的数组（0：未访问，-1：正在访问，1：已访问）
int n, m;           // 顶点数和边数

bool dfs(int x) {
    c[x] = -1;  // 将当前节点标记为正在访问

    for (int y : e[x]) {
        if (c[y] < 0) return false;  // 如果 y 正在访问中，说明存在环
        if (c[y] == 0 && !dfs(y)) return false;  // 如果 y 未访问，则继续 DFS
    }

    c[x] = 1;           // 当前节点访问完成，标记为已访问
    tp.push_back(x);    // 将节点加入拓扑序列
    return true;
}

bool toposort() {
    memset(c, 0, sizeof(c));  // 初始化所有节点为未访问状态

    for (int x = 1; x <= n; x++) {
        if (c[x] == 0) {
            if (!dfs(x)) return false;  // 如果发现有环，返回 false
        }
    }

    reverse(tp.begin(), tp.end());  // 翻转拓扑序列，使其为正确的顺序
    return true;
}

int main() {
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
    }

    if (!toposort()) {
        cout << "-1" << endl;  // 如果存在环，输出 -1
    } else {
        for (int x : tp) cout << x << " ";  // 输出拓扑序列
        cout << endl;
    }

    return 0;
}
```

#### 最短路算法

> 顾名思义，从任意顶点出发到另一顶点的最短距离。也就是权重最小。

**单源最短路径（Single Source Shortest Path）**：对于一个带权图 G=(V,E)，其中每条边的权重是一个实数。另外，给定 v 中的一个顶点，称之为源点。则源点到其他所有各个顶点之间的最短路径长度，称为单源最短路径。

这里的路径长度，指的是路径上各边权之和。单源最短路径问题的核心是找到从源点到其他各个顶点的路径，使得路径上边的权重之和最小。

常见的解决单源最短路径问题的算法包括：

1. **Dijkstra 算法**：一种贪心算法，用于解决无负权边的情况。它逐步扩展当前已知最短路径的范围，选择当前距离起始节点最近的节点，并更新与该节点相邻的节点的距离。
2. **Bellman-Ford 算法**：适用于有负权边的情况。它通过多次迭代来逐步逼近最短路径，每次迭代都尝试通过更新边的权重来缩短路径。
3. **SPFA 算法**：优化的 Bellman-Ford 算法，它在每次迭代中不遍历所有的边，而是选择性地更新与当前节点相关的边，从而提高了算法的效率。

##### Dijkstra

基于贪心思想，也就是每次选择的路径权重是最小的，达成局部最小变为全局最小。

- Dijkstra 算法从指定的节点（源节点）出发，寻找它与图中所有其它节点之间的最短路径。
- Dijkstra 算法会记录当前已知的最短路径，并在寻找到更短的路径时更新。
- 一旦找到源节点与其他节点之间的最短路径，那个节点会被标记为“已访问”并添加到路径中。
- 重复寻找过程，直到图中所有节点都已经添加到路径中。这样，就可以得到从源节点出发访问所有其他节点的最短路径方案。
- Dijkstra 只能用在权重为**正**的图中，因为计算过程中需要将边的权重相加来寻找最短路径。如果图中有负权重的边，这个算法就无法正常工作。就会无限循环。

![image-20230302202401928](./image-20230302202401928-1721820002717-23-1723797363701-280.png)

假设要在这个图中寻找最短路，首先要用一个数据结构记录这个图，这个数据结构被称之为权重数组，这里因为数据量比较少所以用邻接矩阵存储。（就是正常的二维数组）

![image-20240817104040294](./image-20240817104040294.png)

用正常的邻接矩阵存储即可

![image-20240817104006732](./image-20240817104006732.png)

确定的A作为算法的源点，我们就可以通过遍历所有节点的方法更新上面的权重矩阵。

- 从源点出发，标记自身的距离为0

  ![image-20240817104421601](./image-20240817104421601.png)

- 检索源点A的邻居，比较其邻居的最小权值，将信息记录到权重矩阵中。

  ![image-20240817104711825](./image-20240817104711825.png)

- 再通过检索到的节点D，比较其邻居的最小权值，并且将D点的权与E点权相加，将信息记录到权重矩阵中。

  ![image-20240817104958555](./image-20240817104958555.png)

对遍历到的节点重复上述操作，就可以得到一个记录从源节点出发到各个点的最短路经了。

![image-20240817105356106](./image-20240817105356106.png)

> 这个矩阵就是描述上面的图

![image-20240817105415145](./image-20240817105415145.png)

用代码实现，这里采用邻接表存储图像

- `e[u]` 存储图像

- `d[u]`记录边权

- `vis[u] `标记是否访问

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// 定义边的结构体，包含目标顶点v和边的权重w
struct edge {
    int v, w;
};

vector<edge> e[N]; // 邻接表表示的图，e[i]存储从顶点i出发的所有边
int d[N], vis[N];  // d[i]存储从起点到顶点i的最短路径长度，vis[i]表示顶点i是否已被访问

// Dijkstra算法函数，计算从起点s到其他顶点的最短路径
void dijkstra(int s) {
    // 初始化所有顶点的最短路径长度为无穷大
    for(int i = 0; i < n; i++) d[i] = INT_MAX;
    d[s] = 0; // 起点的最短路径长度为0
    
    // 主循环，遍历图中的所有顶点
    for(int i = 1; i <= n; i++) { // 枚举次数
        int u = 0; // 当前未访问的顶点中距离最小的顶点
        
        // 找到当前未访问且距离最小的顶点u
        for(int j = 1; j <= n; j++) { // 枚举点
            if(!vis[j] && d[j] < d[u]) u = j;
        }
        
        vis[u] = 1; // 标记顶点u已被访问
        
        // 更新与顶点u相邻的顶点的最短路径
        for(auto ed : e[u]) { // 枚举边
            int v = ed.v, w = ed.w; // 获取相邻顶点v及边的权重w
            if(d[v] > d[u] + w) { // 如果从u经过到v的路径更短，则更新d[v]
                d[v] = d[u] + w;
            }            
        }
    }    
}

int main() {
    int n, m, s;
    cin >> n >> m >> s; // 输入顶点数n，边数m，以及起点s
    
    // 输入图的边信息
    for(int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c; // 输入边的起点a，终点b，和权重c
        e[a].push_back({b, c}); // 将边添加到邻接表中
    }
    
    dijkstra(s); // 调用Dijkstra算法，计算从起点s到其他顶点的最短路径
    return 0;
}
```

![image-20230302204110774](./image-20230302204110774-1721820002717-25-1723797363701-282.png)

> 堆优化的时间复杂度为O(logn)，

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <limits.h>

using namespace std;

struct edge {
    int v, w;
}; 

vector<edge> e[N]; // 邻接表存储图，e[i]表示从顶点i出发的所有边
int d[N], vis[N];  // d数组存储从源点到每个点的最短距离，vis数组标记点是否被访问过
priority_queue<pair<int, int>> q; // 大根堆，存储负的距离值以实现优先队列

void dijkstra(int s) {
    for(int i = 0; i <= n; i++) d[i] = inf; // 初始化所有点的距离为无穷大
    d[s] = 0; // 源点s的距离初始化为0
    q.push({0, s}); // 将(0, s)入队，注意距离为负值（大根堆）

    while(!q.empty()) { // 当队列不为空时，继续处理
        auto t = q.top(); // 取出队列中的元素，t为pair(-距离, 顶点)
        q.pop(); // 移除队列中的元素
        int u = t.second; // 当前处理的顶点为u

        if(vis[u]) continue; // 如果顶点u已经被访问过，则跳过
        vis[u] = 1; // 标记顶点u为已访问

        for(auto ed : e[u]) { // 枚举顶点u的所有出边
            int v = ed.v; // 获取当前边的目标顶点v
            int w = ed.w; // 获取当前边的权重w

            // 如果从u到v的路径比当前已知的最短路径更短，则更新d[v]
            if(d[v] > d[u] + w) {
                d[v] = d[u] + w;
                q.push({-d[v], v}); // 将(-d[v], v)入队，使用负值实现大根堆
            }
        }
    }
}

int main() {
    int n, m, s;
    // 输入顶点数n、边数m以及起点s
    cin >> n >> m >> s;
    for(int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        e[a].push_back({b, c}); // 将边(b, c)添加到顶点a的邻接表中
    }

    dijkstra(s); // 调用Dijkstra算法计算从源点到其他顶点的最短路径

    return 0;
}

```

<img src="./image-20240817123229639.png" alt="image-20240817123229639" style="zoom:150%;" />

##### [spfa 算法](https://www.cnblogs.com/shadowland/p/5870640.html)

SPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，它是Bellman-ford的队列优化，它是一种十分高效的最短路算法。

很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)。

但是，SPFA算法稳定性较差，在稠密图中SPFA算法时间复杂度会退化。

实现方法：**建立一个队列**，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。**然后执行松弛操作**，用队列里有的点去刷新起始点到所有点的最短路，**如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。**重复执行直到队列为空。

> 这个图用三种颜色标注
>
> - 黄色标注入队的点
> - 绿色表示要出队
> - 红色表示已经出队

![image-20200921211548307.png](./image-20200921211548307-1721820002717-38-1723797363702-293.png)

此外，SPFA算法还可以判断图中是否有负权环，即一个点入队次数超过N。

![image-20230304212218685](./image-20230304212218685-1721820002717-39-1723797363702-294.png)

- 算法大致流程是用一个队列来进行维护。 初始时将源加入队列。 每次从队列中取出一个元素，并对所有与他相邻的点进行[松弛](http://www.nocow.cn/index.php/松弛)，若某个相邻的点松弛成功，如果该点没有在队列中，则将其入队。 直到队列为空时算法结束。
- 判断有无负环：如果某个点进入队列的**次数超过V次**则存在负环（SPFA无法处理带负环的图）

![image-20230304212738052](./image-20230304212738052-1721820002717-41-1723797363702-296.png)

```c++
//堆优化 bellman 算法 - spfa算法
struct edge{int v,w;};
vector<edge> e[N];//点集合
int d[N],cnt[N],vis[N]; //边 边数 开关
queue<int> q; //队列

bool spfa(int s){
    memset(d,inf,sizeof d);
    //开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集
    d[s] = 0; vis[s] = 1; q.push(s); 
    while(q.size()){
        //这里是将前面初始化的点操作的地方，每次都只操作一个点
        int u = q.front(); q.pop(); vis[u] = 0;
     for(auto ed:e[u]){
            int v = ed.v , w = ed.w;
            //比较枚举点和当前点 的长度 更新最短值
            if(d[v]>d[u]+w){
                d[v] = d[u]+w;
                cnt[v] = cnt[u]+1; //记录边数
                if(cnt[v]>=n) return true;
                if(!vis[v]) q.push(v),vis[v] = 1;
            }
        }
    }
    return false;
}
```

##### Bellman-Ford

> 处理负权图

**Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。**对于给定的带权（有向或无向）图 G=（V,E），其源点为s，加权函数 w是 边集 E 的映射。对图G运行Bellman-Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。

**Bellman-Ford**算法流程分为三个阶段：

- 初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;
- 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；运行`V-1`次
- 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 d[v]中。

```c++
G:图G
E(G):边的集合 //用边集数组存储
S: 源顶点
Dis[i]:表示s到i的最短距离,初始为+∞
D[s]=0;
for (int i=0;i<|v|-1;i++)
 for each (u,v)∈E(G)
   if(dis[u]+w(u,v)<dis[v]
       dis[v]=dis[u]+w(u,v);
for each (u,v)∈E(G)
 if(d[v]>d[u]+w(u,v)
   return false;//返回false,说明存在负权回路
return true;
```

初始化，更新源点的距离，为之后松弛其他结点的权做准备。

![img](./v2-3253617aa1280adbe911e9fae4133584_720w-1721820002717-29-1723797363701-286.webp)

迭代到源点连接的点上，将无穷松弛为经过的路径，在连接的节点处更新权值，权值为经过路径值的和。

![img](./v2-b79ce7e33dcee4a3e915bd1d1d2866e7_720w-1721820002717-30-1723797363701-285.webp)

对于迭代到的其他结点，重复上序的操作，重复次数为`|V|-1`；V表示当前图的节点个数

![img](./v2-f407fdcc6ac680d357f535258e3f12d8_720w-1721820002717-32-1723797363701-287.webp)

它的时间复杂度为 `O(VE)`，其中 `V` 是顶点数，`E`是边数。`Bellman-Ford` 算法的基本思想是对所有的边进行 `V-1 `轮松弛操作，以求出所有可能的最短路径。如果在第 `V`轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。

![img](./v2-0b8efc7f4fcf5d767fc7b678c1d08c8c_720w-1721820002717-37-1723797363701-289.webp)

**Bellman－Ford算法实现可以大致分为三个部分** ：

- 第一，初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为0，其它的点的值设为无穷大（表示不可达）。 
- 第二，进行循环，循环下标为从1到n－1（n等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。 
- 第三，遍历途中所有的边（edge（u，v）），判断是否存在这样情况： d（v） > d (u) + w(u,v) 则返回false，表示途中存在从源点可达的权为负的回路。

![image-20230304210834724](./image-20230304210834724-1721820002717-36-1723797363701-291.png)

```c++
const int INF = 1e9;
const int N = 1005; // 根据你的需求设置节点数量上限

struct edge {
    int v, w;
};

vector<edge> e[N];
int d[N];

bool bellmanFord(int n, int s) {
    fill(d, d + n, INF);
    d[s] = 0;

    for (int i = 0; i < n - 1; i++) { // 最多执行 n-1 轮松弛操作
        bool flag = false;
        for (int u = 1; u <= n; u++) {
            if (d[u] == INF) continue;

            for (auto ed : e[u]) {
                int v = ed.v, w = ed.w;
                if (d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    flag = true;
                }
            }
        }
        if (!flag) break; // 如果本轮没有更新，提前退出
    }

    // 检测是否存在负权环
    for (int u = 1; u <= n; u++) {
        if (d[u] == INF) continue;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (d[v] > d[u] + w) {
                return true; // 存在负权环
            }
        }
    }

    return false; // 不存在负权环
}
```

##### [Floyd算法](https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd)

Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，我们的目标是寻找从点i到点j的最短路径，在经过过度节点的情况。

从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）

从任意节点`i`到任意节点`j`的最短路径不外乎2种可能：

- 是直接从`i到j`，

- 是从`i`经过若干个节点`k到j`。

所以，我们假设`Dis(i,j)`为节点`u`到节点`v`的最短路径的距离，对于每一个节点`k`，我们检查`Dis(i,k) + Dis(k,j) < Dis(i,j)`是否成立，如果成立，证明从`i到k`再到`j`的路径比`i`直接到j的路径短，我们便设置**`Dis(i,j) = Dis(i,k) + Dis(k,j)`**，这样一来，当我们遍历完所有节点`k`，`Dis(i,j)`中记录的便是`i到j`的最短路径的距离。

![image-20230307160057133](./image-20230307160057133-1721820002717-42-1723797363702-297.png)

初始化和其他最短路算法是一样的，都是通过坐标定位权关系。`i-j`用`a[i][j]`。`j-i`用`a[j][i]`。

![image-20230307160205801](./image-20230307160205801-1721820002717-43-1723797363702-298.png)

> [萌新版本](https://www.cnblogs.com/wangyuliang/p/9216365.html)

![image-20230307160839691](./image-20230307160839691-1721820002718-44-1723797363702-299.png)

```c++
// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）
// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）

//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）
void floyd(){
    for(int k;k<=n;k++) //以k为桥(k枚举的是所有点)
        for(int i=1 ;i<=n;i++)
            for(int j = 1;j<=n;j++)
                d[i][j] = mid(d[i][j],d[i][k]+d[k][j]); //二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）
}
```

![image-20230307161152125](./image-20230307161152125-1721820002718-45-1723797363702-300.png)

```c++
#include <iostream>
#include <algorithm> // 引入algorithm库，使用min函数
using namespace std;

const int N = 210; // 定义常量N，表示最大节点数
int n, m, k; // n表示节点数，m表示边数，k表示询问次数
int d[N][N]; // 存储最短路径的二维数组

// Floyd-Warshall算法，用于计算任意两点之间的最短路径
void floyd(){
    for(int k = 1; k <= n; k++) // 枚举中间节点k
        for(int i = 1; i <= n; i++) // 枚举起点i
            for(int j = 1; j <= n; j++) // 枚举终点j
                // 更新i到j的最短路径，如果通过k点可以得到更短的路径
                // k点将会遍历所有的点
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main(){
    cin >> n >> m >> k; // 输入节点数n、边数m和询问次数k
    fill(d[0], d[0] + N*N, 0x3f3f3f3f); 

    // 自己到自己的距离为0
    for(int i = 1; i <= n; i++) d[i][i] = 0;

    // 读取m条边的信息
    while(m--){
        int a, b, c; cin >> a >> b >> c; // 输入边的起点a，终点b，以及权重c
        d[a][b] = min(d[a][b], c); // 更新起点到终点的最短路径，防止重边
    }

    // 运行Floyd-Warshall算法
    floyd();

    // 处理k次查询
    while(k--){
        int a, b; cin >> a >> b; // 输入查询的起点a和终点b
        // 如果d[a][b]超过0x3f3f3f3f的一半，表示两点之间不可达
        if(d[a][b] > 0x3f3f3f3f/2) cout << "impossible" << endl;
        else cout << d[a][b] << endl; // 否则输出最短路径
    }
}
```

<img src="./image-20240817141427254.png" alt="image-20240817141427254" style="zoom:150%;" />

#### 最小生成树

在了解「最小生成树」之前，我们需要要先理解 「生成树」的概念。

**图的生成树（Spanning Tree）**：如果无向连通图 G 的一个子图是一棵包含图 G 所有顶点的树，则称该子图为 G 的生成树。生成树是连通图的包含图中的所有顶点的极小连通子图。图的生成树不惟一。**从不同的顶点出发进行遍历，可以得到不同的生成树。**

换句话说，生成树是原图 G 的一个子图，它包含了原图 G 的所有顶点，并且通过选择图中一部分边连接这些顶点，使得子图中没有环。

生成树有以下特点：

- **包含所有顶点**：生成树中包含了原图的所有顶点。
- **连通性**：生成树是原图的一个连通子图，意味着任意两个顶点之间都存在一条路径。
- **无环图**：生成树一个无环图。
- **边数最少**：在包含所有顶点的情况下，生成树的边数最少，其边数为顶点数减 1。

![img](./20231211100145-1723797363702-302.png)

**最小生成树（Minimum Spanning Tree）**：无向连通图 G 的所有生成树中，边的权值之和最小的生成树，被称为最小生成树。最小生成树除了包含生成树的特点之外，还具有一个特点。

**边的权值之和最小**：在包含所有顶点的情况下，最小生成树的边的权重之和是所有可能的生成树中最小的。

![img](./20231211101937-1723797363702-303.png)

为了找到无向图的最小生成树，常用的算法有「Prim 算法」和「Kruskal 算法」。

- **Prim 算法**：从一个起始顶点出发，逐步选择与已经构建的树连接的最短边，直到包含所有顶点为止。
- **Kruskal 算法**：基于边的排序和并查集数据结构，逐步添加边，并保证所选边不会构成环路，直到构建出最小生成树。

##### prim算法

**Prim 算法的算法思想**：每次选择最短边来扩展最小生成树，从而保证生成树的总权重最小。算法通过不断扩展小生成树的顶点集合 MST，逐步构建出最小生成树。

![image-20230308192754299](./image-20230308192754299-1721820002718-47-1723797363702-304.png)

Prim算法的基本思路：

- 选择一个起始节点（可以是任意节点），将其加入生成树中，初始化生成树为空。
- 在每一步中，从已经在生成树中的节点集合出发，选择一个距离生成树最近的节点（即与生成树中的某个节点相邻且权重最小的节点），将其加入生成树中。
- 这个过程重复执行，直到生成树包含了图中的所有节点为止。最终生成的树就是最小生成树。

```c++
//基于贪心算法
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N];//d是边的长度 

bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf;
    d[s] = 0;
    for(int i = 1;i<=n;i++){
        int u = 0;
        for(int j = 1;j<=n;j++)
            if(!vis[j]&&d[j]<d[u]) u = j; //排除选过的点 - 这里是选领点的（懂了）
        vis[u] = 1;
        ans+=d[u];//边权和（最小生成树的边权和）
        if(d[u]!=inf) cnt++; //判断是否联通
        //遍历到u这个点（u之前的也是一起的，算是连续的）
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w;   
            }
        }
    }
    return cnt == n; //返回true就是有最小生成树的 返回false
}
```

在Prim算法之上，优化其使用的数据结构，把队列替换为优先队列。就是Heap-Prim算法。

<img src="./image-20240817143213186.png" alt="image-20240817143213186" style="zoom:150%;" />

```c++
//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。
int n,m,s,a,b,c,ans,cnt;
struct edge{int v,w;}; //构造一个结构体 内部有点和边的属性
vector<edge> e[N];//领点（也算是所有点？）
int d[N],vis[N];
priority_queue<pair<int,int>> q; //这里创一个优先队列（就是堆）
//s是起点
bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf; //先初始化全部的边 - 每个边都是无穷大
    //起点
    d[s] = 0;q.push({0,s});
    while(q.size()){
        //取出q队列的点？ - 后面有进入点？
        int u = q.top().second; q.pop();
        if(vis[u]) continue; 
        vis[u] = 1;
        ans+=d[u]; cnt++;
        //这里应该就是插入 领点的步骤
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w; //对应点v边权最小的边
                q.push({-d[v],v});//大根堆
            }
        }
    }
    return cnt == n; //这里判断的是啥？
}
```

<img src="./image-20240817143228949.png" alt="image-20240817143228949" style="zoom:150%;" />

##### Kruskal算法

**Kruskal 算法的算法思想**：通过依次选择权重最小的边并判断其两个端点是否连接在同一集合中，从而逐步构建最小生成树。这个过程保证了最终生成的树是无环的，并且总权重最小。

- 将图中的所有边按照权重从小到大进行排序。

- 初始化一个空的最小生成树。

- 从权重最小的边开始，依次考虑每条边，如果该边不会导致生成树中出现环路（即加入这条边后，两个节点已经在同一个连通分量中），就将这条边加入生成树中。这里会使用并查集，能够高效合并联通分量。

重复步骤3，直到生成树中包含了图中的所有节点，此时最小生成树构建完成。

<img src="./image-20240817143241729.png" alt="image-20240817143241729" style="zoom:150%;" />

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=200010;
int n,m;
//结构体存储边的信息
struct edge{
    int a,b,w;
}e[M];
//比较函数 （用来作为排序算法的参数）
bool cmp(edge x,edge y){
    return x.w<y.w;
}
//并查集
int p[N];
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].w);
    //排序边权（我们是用贪心来筛选的）
    sort(e+1,e+m+1,cmp);
    //初始化并查集
    for(int i=1;i<=n;i++) p[i]=i;
    int res=0,cnt=0;
    for(int i=1;i<=m;i++){
        //每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）
        int a=find(e[i].a),b=find(e[i].b),w=e[i].w;
        //查一下是否是连通块
        if(a!=b){
            //纳入后宫
            p[a]=b;
            res+=w;
            cnt++;
        }
        if(cnt==n-1) break;  //成树
    }
    printf("%d\n",res);//输出边权
}
```

> 三种方法比较

<img src="./image-20240817143255848.png" alt="image-20240817143255848" style="zoom:150%;" />

#### 二分图

##### 染色法判断二分图

 二分图是节点由两个集合组成，且两个集合内部没有边的图。

<img src="./image-20240817154204395.png" alt="image-20240817154204395" style="zoom:150%;" />

根据二分图不存在奇环的特性，我们可以使用染色法来判断二分图。因为我们不可能在一部之内走回我们同集合的节点，也就是说，我们的相邻节点一定是不同集合的，所以说我们每遍历一格，就标记不同的颜色，只要相邻的节点颜色相同，那么就说明不是二分图。^ ^

- 选择一个起始节点，将其染成颜色A（可以用0和1表示两种颜色）。

- 从起始节点开始，对于与其相邻的节点，将其染成颜色B。

- 继续递归地对与颜色A节点相邻的节点染成颜色B，与颜色B节点相邻的节点染成颜色A。

- 如果在染色的过程中发现相邻的两个节点已经被染成了相同的颜色，那么图不是二分图。

- 如果成功染色完所有节点而没有发现相邻节点颜色相同的情况，那么图是二分图。

<img src="./image-20240817154234887.png" alt="image-20240817154234887" style="zoom:150%;" />

这里用深度优先遍历来实现判断二分图：

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int M = 1e5+10;
const int N = 2e5+10;
//父结点 - 当前节点 - 出边
struct edge{int v,ne;}e[M];
//h数组存储的是所有的出边 - a节点索引
int h[N],idx;
int n,m;
int color[N];

void add(int a,int b){
    e[++idx] = {b,h[a]};
    h[a] = idx;
}
//分为两种颜色 - 1 - 2 - 0是未上色
//dfs上色的过程中，也在找
//for是找 - dfs是上色
bool dfs(int u,int c){
    color[u] = c;
    for(int i = h[u];i;i = e[i].ne){
        int v = e[i].v;
        //没有上色 - 就上色
        if(!color[v]) {
            if(dfs(v,3-c)) return true;
        }
        else if(color[v] == c) return true;
    }
    return false;
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
  int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    bool flag = false;
    for(int i = 1;i<=n;i++)
        if(!color[i])
            //dfs找到一处就会返回，对于每个点找一下领结的点就行
            if(dfs(i,1)){
                flag = true;
                break;
            }
    if(flag) puts("No");
    else puts("Yes");
    return 0;
    
    
}
```

<img src="./image-20240817154301771.png" alt="image-20240817154301771" style="zoom:150%;" />

##### 匈牙利算法

<img src="./image-20240817154317723.png" alt="image-20240817154317723" style="zoom:150%;" />

解决二分图最大匹配问题：两个集合连线匹配对数最大

- 选择一个未匹配的左侧节点作为起始点，如果所有左侧节点都已经匹配，则说明找到了一个最大匹配。
- 对于选定的起始点，尝试将其与未匹配的右侧节点进行匹配。如果可以找到一个未匹配的右侧节点与起始点相连接，那么建立这个匹配，否则，尝试改变匹配路径。
- 如果可以改变匹配路径，就寻找一条增广路径（alternating path），这是一条交替经过匹配边和非匹配边的路径，以尽量多地增加匹配数目。增广路径的搜索通常使用深度优先搜索`（DFS）`或广度优先搜索`（BFS）`。
- 如果找到了增广路径，就根据这条路径来改变匹配，然后返回步骤1，继续查找下一个未匹配的左侧节点。
- 如果没有找到增广路径，说明已经找到了最大匹配，算法终止。

因为我们需要让两个集合匹配对数最大，所以说需要在两个集合之间不停连线试错，`dfs`帮助我们提供不同的连线方案，让我们达到匹配数最大。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10,M = 2e5+10;
int n,m,k,a,b,ans,idx;
struct edge{int v,ne;}e[M]; //点（对应位置的妹子） ne 另一集合的点
int h[N],idx;
int vis[N],match[M]; //标记 和 匹配

//链式前向星
void add(int a, int b){
    e[++idx] = {b,h[a]};
    h[a] = idx++; //给边编号
}
//男女匹配问题 (boy and girl）
bool bfs(int u){
    //每一个都要匹配看看
    for(int i = h[u]; i;i = e[i].ne){
        int v = e[i].v; //妹子
        if(vis[v]) continue;
        vis[v] = 1; //标记
        if(!match[v]||dfs(match[v])){ //没有匹配 || dfs遍历判断这个方案能不能成功 - 不能就换一个
            match[v] = u;//成对
            return 1;
        }
    }
    return 0;
}

int main()
{
    cin>>n>>m>>k;
    for(int i = 0;i<k;i++) cin>>a>>b,add(a,b); //建图
    for(int i = 1;i<=n;i++){
        memset(vis,0,sizeof vis);
        if(dfs(i)) ans++;
    }
    cout<<ans;
    return 0; 
    
}

```
