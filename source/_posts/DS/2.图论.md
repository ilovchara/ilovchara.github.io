---
title: 图论
date: 2023-04-28 09:05:38
categories: 算法
tags: 数据结构
description: 包括树，图
typora-root-url: ./2.图论
---

## 图论

### 树

树是由`N`个节点构成的有限集合，当`N=0`的时候称之为空树。树也可以看做是存储数据的一种数据类型，其逻辑结构常见的有二叉树，完全二叉树等等；**树的节点和数的深度是有关系的，对于一个深度为K的满二叉树来说，它的节点个数`2^K-1`其中减去`1`是减去了根节点。**

一个树且当`N>1`的时候，其余节点可以分为`M`个有限互不相交的有限集合。**每一个节点算是一个独立的树**，称之为根的子树。在树中，与其他数据结构一样，有前驱和后继的设定。对于根节点来说，它没有直接前驱。对于底部的叶节点来说，它没有直接后继。

树适合表示有层级的结构的数据，类似于游戏中的阶段，或者随机生成的地图。都需要记录前一个状态，然后跳转到另一个状态。状态的区别就是其节点的子和父属性。

一个树有几种基础属性

- 结点：组成树的基本变量
- 度：结点孩子个数
- 深度，高度：深度从**根节点开始向下**计数，高度**从叶节点向上计数**。如果我们知道一个二叉树的节点个数，那么可以估计高度的数量级大概为`h=log2(N+1)`

![树](./20240511171215-1723797363701-239.png)

#### 二叉树*

二叉树是由`N`个节点组成的有限集合，其基本形态包括：空树、仅有根节点、只有左子树、只有右子树、左右子树均存在等。**每个节点最多有两个子节点，分别为左子树和右子树**，且它们是有序的，不能互换。在二叉树中，不存在度大于2的节点。

**满二叉树**

如图是一个满二叉树，可以看到每一个层级中，其节点个数都是符合`2^n（n为层级）`

![二叉树](./20240511171342-1723797363701-238.png)

满二叉树满足以下特点：

- 叶子节点只出现在最下面一层。
- 非叶子节点的度一定为 2。
- 在同等深度的二叉树中，**满二叉树的节点个数最多**，叶子节点个数最多。

对于深度为 k 的满二叉树，节点编号是从根节点开始，按照层次依次编号，每一层从左到右进行编号。满二叉树的总节点数可以通过公式 `2^k−1 `计算（这里 k 是树的深度，深度从1开始）。深度为 k 的满二叉树**最后一个节点的编号应该是 `2^k−1`**。

**完全二叉树**

在完全二叉树中，除了最底层外，其余每一层的节点数都达到了最大值。最底层的节点全部集中在最左侧，且可能未完全填满。如果最底层为第 h 层，则该层包含的节点数范围为 `1` 到 `2^h−1` 个。完全二叉树满足以下特点：

- 叶子节点只能出现在最下面两层。
- 最下层的叶子节点一定集中在该层**最左边**的位置上。
- **倒数第二层如果有叶子节点，则该层的叶子节点一定集中在右边的位置上。**
- 如果节点的度为 1，则该节点只偶遇左孩子节点，即不存在只有右子树的情况。
- **同等节点数的二叉树中，完全二叉树的深度最小。**

![完全二叉树与非完全二叉树](./20220218174000.png)

#### 二叉树构造

二叉树的存储结构分为两种：「顺序存储结构」和「链式存储结构」

**顺序存储结构**

使用顺序存储结构实现二叉树，也就是**使用一维数组存储二叉树的节点**，节点存储位置则采用完全二叉树的节点层次编号，按照层次从上至下，每一层从左至右的顺序依次存放二叉树的数据元素。在进行顺序存储时，**如果对应的二叉树节点不存在，则设置为「空节点」。**

![image-20230216134441813](./image-20230216134441813-16923744802222-1721820002716-4-1723797363701-243.png)

数组模拟二叉树，**原理是改数组索引定义，**采用`0-based`索引，也就是数组的`0`号位置设置为根节点，对于任意节点的索引为 `i`

- **左子节点的索引为 `2i + 1`**。
- **右子节点的索引为 `2i + 2`**。
- **父节点的索引为 `(i - 1) / 2`**（当 `i ≠ 0` 时）

也可以采用`1-base`索引，这样就不用多一步`+`运算，对于任意节点的索引 `i`：

- **左子节点的索引为 `2i`**。
- **右子节点的索引为 `2i + 1`**。
- **父节点的索引为 `i / 2`**（当 `i ≠ 1` 时）。

```c++
//结构体定义节点属性
struct TreeNode{
  int val;
  TreeNode *left; //定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数初始化  
};

// 构建二叉树
TreeNode* buildTree(vector<int>& arr, int index) {
    if (index >= arr.size() || arr[index] == -1) {
        return nullptr; // 返回空指针表示空节点
    }

    TreeNode* root = new TreeNode(arr[index]);
    root->left = buildTree(arr, 2 * index + 1); // 构建左子树
    root->right = buildTree(arr, 2 * index + 2); // 构建右子树

    return root;
}
```

对于完全二叉树尤其是满二叉树来说，采用**顺序存储结构**比较合适，它能充分利用存储空间；而对于一般二叉树，如果需要设置很多的「空节点」，则采用顺序存储结构就会浪费很多存储空间。并且，由于顺序存储结构固有的一些缺陷，**会使得二叉树的插入、删除等操作不方便**，效率也比较低。对于二叉树来说，当树的形态和大小经常发生动态变化时，更适合采用链式存储结构。

**链式存储结构**

二叉树采用链式存储结构时，每个链节点包含一个用于数据域` val`，存储节点信息；还包含两个指针域 `left` 和 `right`，分别指向左右两个孩子节点，当左孩子或者右孩子不存在时，相应指针域值为空。二叉链节点结构如下图所示。

![二叉链节点](./20240511171434-1723797363701-248.png)

链式存储结构实现二叉树很好理解，每一个节点都由指向左右子树的指针。下面是实现节点的伪代码

```c++
// 构建二叉树的函数，输入一个数组，输出顺序存储形式的二叉树
void buildBinaryTree(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == -1) {
            continue; // 跳过空节点
        }

        // 当前节点的值
        int node_value = arr[i];
        printf("Node %d: %d\n", i, node_value);

        // 计算左子节点的索引
        int left_index = 2 * i + 1;
        if (left_index < size && arr[left_index] != -1) {
            printf("  Left child of node %d: %d\n", i, arr[left_index]);
        } else {
            printf("  Left child of node %d: NULL\n", i);
        }

        // 计算右子节点的索引
        int right_index = 2 * i + 2;
        if (right_index < size && arr[right_index] != -1) {
            printf("  Right child of node %d: %d\n", i, arr[right_index]);
        } else {
            printf("  Right child of node %d: NULL\n", i);
        }
    }
}
```

二叉树的**链表存储结构具有灵活、方便的特点**。节点的最大数目只受系统最大可存储空间的限制。一般情况下，二叉树的**链表存储结构比顺序存储结构更省空间**（用于存储指针域的空间开销只是二叉树中节点数的线性函数），而且对于二叉树实施相关操作也很方便，因此，一般我们使用链式存储结构来存储二叉树。

![二叉树的链式存储结构](./20240511171446-1723797363701-241.png)

##### **二叉树遍历**

遍历的目的是为了找到这个二叉树每一个节点的存储的数据，可以根据二叉树的逻辑拓扑来构造遍历的函数，通常由三种遍历方式。递归遍历，层序遍历还有优先级遍历。

![image-20230216134441813](./image-20230216134441813-16923744802222-1721820002716-4-1723797363701-243.png)

当我们使用递归遍历二叉树时，可以将其视作由三个部分构成的树：左子树、右子树和根节点。这种视角下，有三种经典的遍历方式：

1. **前序遍历（Preorder traversal）**：根节点 -> 左子树 -> 右子树
2. **中序遍历（Inorder traversal）**：左子树 -> 根节点 -> 右子树
3. **后序遍历（Postorder traversal）**：左子树 -> 右子树 -> 根节点

递归的优势在于它能够让代码保持简洁和易读。相比之下，如果不使用递归，需要借助栈或数组来模拟递归的调用过程，这会导致代码量大大增加，并且难以维护和理解。

递归本质上是**将一个大问题划分为多个小问题**，并通过递归调用逐步解决这些小问题，最终实现对整个大问题的解决。在遍历二叉树时，每次递归调用都是在处理一个子树，**这种分而治之的策略使得遍历操作变得清晰而高效。**

因此，递归在处理树结构时具有显著的优势，能够简化代码逻辑，提高代码的可读性和可维护性，同时也更符合树的自然结构和递归定义的思想。

![image-20241013170507586](./image-20241013170507586.png)

为了实现递归遍历，首先得声明一下二叉树的节点，每一个节点都要有两个指针，标记该节点的左右子树。其实在逻辑上和双链表是一样的。

```c++
struct TreeNode{
  int val;
  TreeNode *left;//定义left指针 指向左子树
  TreeNode *right;//right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};
```

**前序遍历**

二叉树的前序遍历规则为：如果二叉树为空，则返回。如果二叉树不为空，则：

- 访问根节点。
- 以前序遍历的方式遍历根节点的左子树。
- 以前序遍历的方式遍历根节点的右子树

```c++
struct TreeNode{
  int val;
  TreeNode *left; //定义left指针 指向左子树
  TreeNode *right; //right指针 指向右子树
  TreeNode(int x):val(x),left(NULL),right(NULL){}//构造函数  
};

void PT(TreeNode root)
{
    //如果访问的节点没有子节点
    if(nullptr == root) return;
    
    //打印遍历的节点数据
    cout<<root->data;
    
    //递归遍历左子树
    PT(root -> left);
    
    //递归遍历右子树
    PT(root -> right);    
    
}
```

如下图所示，该二叉树的前序遍历顺序为：**`A−B−D−H−I−E−C−F−J−G−K`**

![二叉树的前序遍历](./20240511171628-1723797363701-242.png)

二叉树的前序遍历递归实现的过程，实际上就是调用系统栈的过程。我们也可以使用数组模拟栈来实现前序遍历，但是会显得特别复杂。

```c
#include <iostream>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;  // 指向左子树
    TreeNode *right; // 指向右子树
    TreeNode(int x) : val(x), left(NULL), right(NULL) {} // 构造函数
};

void PreorderTraversal(TreeNode* root) {
    if (root == nullptr) return; // 如果根节点为空，直接返回
    
    const int MAX_SIZE = 100; // 假设树的最大节点数为100
    TreeNode* stack[MAX_SIZE]; // 创建模拟栈的数组
    int top = -1; // 栈顶指针

    // 从根节点开始入栈
    stack[++top] = root;

    while (top != -1) { // 当栈不为空时循环
        // 出栈
        TreeNode* node = stack[top--];
        
        // 访问当前节点
        cout << node->val << " ";

        // 先右子树入栈，再左子树入栈
        // 这样左子树在栈顶，会优先被访问
        if (node->right != nullptr) {
            stack[++top] = node->right; // 右子树入栈
        }
        if (node->left != nullptr) {
            stack[++top] = node->left; // 左子树入栈
        }
    }
}

int main() {
    // 示例树：
    //       1
    //      / \
    //     2   3
    //    / \
    //   4   5

    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    cout << "前序遍历结果：";
    PreorderTraversal(root);
    cout << endl;

    // 释放内存（略，实际应用中应考虑内存管理）

    return 0;
}
```

前序遍历的顺序为：`根节点 - 左子树 - 右子树`，而根据栈的「先入后出」特点，所以入栈的顺序应该为：先放入右子树，再放入左子树。这样可以保证最终遍历顺序为前序遍历顺序。

**中序遍历**

二叉树的中序遍历规则为：如果二叉树为空，则返回。如果二叉树不为空

- 以中序遍历的方式遍历根节点的左子树。
- 访问根节点。
- 以中序遍历的方式遍历根节点的右子树。

```c++
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }
  	//和上面相比，就改变了顺序
    inorderTraversal(root->left);
    cout << root->data << " ";
    inorderTraversal(root->right);
}
```

从二叉树的中序遍历规则可以看出，中序遍历是一个递归过程。在遍历任何一棵子树时，顺序是先遍历子树的左子树，然后访问根节点，最后再遍历右子树。因此，对于给定的二叉树，其中序遍历顺序为：**H−D−I−B−E−A−F−J−C−K−G**。

中序遍历的特征是中间节点永远夹在左右子节点之间。然而，仅仅依赖于中序遍历的顺序，我们无法唯一确定二叉树的根节点或其结构。要准确确定树的形状，需要结合前序遍历或后序遍历的信息。

![二叉树的中序遍历](./20240511171643-1723797363701-247.png)

**后序遍历**

二叉树的后序遍历规则为：如果二叉树为空，则返回。如果二叉树不为空，则：

- 以后序遍历的方式遍历根节点的左子树。
- 以后序遍历的方式遍历根节点的右子树。
- 访问根节点。

从二叉树的后序遍历规则可以看出：后序遍历过程也是一个递归过程。在遍历任何一棵子树时仍然是按照先遍历子树根节点的左子树，然后遍历子树根节点的右子树，最后再访问根节点的顺序进行遍历。如下图所示，该二叉树的后序遍历顺序为：**H−I−D−E−B−J−F−K−G−C−A**

```c++
// 后序遍历二叉树
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) {
        return;
    }

    postorderTraversal(root->left); //左子树变为新的根节点
    postorderTraversal(root->right); //右子树变为新的根节点
    cout << root->data << " ";
}
```

> 这里模拟一下，访问到H节点，由于H节点无直接后继，那么其执行的两个函数的返回值将是空。
>
> ```c++
> postorderTraversal(root->left); //左子树变为新的根节点
> postorderTraversal(root->right); //右子树变为新的根节点
> ```
>
> 也就是说，这个时候打印的节点信息就是H这个点的节点信息了。第一次访问到的节点必定是H节点，因为在递归栈中，先压入的都是这个函数。
>
> ```c++
> postorderTraversal(root->left); //左子树变为新的根节点
> ```
>
> 压到H这个节点的时候结束程序，也就输出H的这个程序弹出栈了。也就是第一次执行完成了上面的程序，然后再压入；重复上述流程，就可以用后续遍历输出所有节点的值了。
>
> ```c++
> postorderTraversal(root->right); //右子树变为新的根节点
> ```
>
> 后续遍历：直观的描述就是**每一个子树的根节点最后遍历到**，也就是相对于左右子节点来说最后一个输出根节点的值（每一个子树）。

![二叉树的后序遍历](./20240511171658-1723797363701-244.png)

**层序遍历**

二叉树的层序遍历：遍历过程是一个广度优先搜索过程。在遍历的时候是按照第 1 层、第 2 层、…… 最后一层依次遍历的，而同一层节点则是按照从左至右的顺序依次访问的。如下图所示，该二叉树的层序遍历顺序为：**A−B−C−D−E−F−G−H−I−J−K**

![二叉树的层序遍历](./20240511175431-1723797363701-245.png)

**二叉树的层序遍历**是通过**队列**实现的，按照从上到下、从左到右的顺序访问树的节点。具体步骤如下：

1. **判断二叉树是否为空**：如果树为空，直接返回。
2. **将根节点入队**：将树的根节点添加到队列中。
3. 循环遍历
   - 当队列不为空时，获取当前队列的长度 `si`，即当前层节点的数量。每层的节点数量是以指数形式增长的，例如，根节点的数量为 `2^0`，第一层为 `2^1`，以此类推，直到叶子节点。
   - 依次从队列中出队 `si` 个节点，并对这些节点进行访问。
   - 对于每个被访问的节点，将其左右子节点（如果存在）入队。
4. **结束遍历**：当队列为空时，遍历结束。

这种方法确保了每一层的节点在被访问时，其顺序是正确的，因为队列遵循先进先出的原则。

```c++
typedef struct Node {
    int key;
    struct Node* left;
    struct Node* right;
} Node;

// 创建新节点
Node* createNode(int key) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}

// 队列节点结构
typedef struct QueueNode {
    Node* treeNode;
    struct QueueNode* next;
} QueueNode;

// 队列结构
typedef struct Queue {
    QueueNode* front;
    QueueNode* rear;
} Queue;

// 初始化队列
Queue* createQueue() {
    Queue* queue = (Queue*)malloc(sizeof(Queue));
    queue->front = queue->rear = NULL;
    return queue;
}

// 入队
void enqueue(Queue* queue, Node* treeNode) {
    QueueNode* newQueueNode = (QueueNode*)malloc(sizeof(QueueNode));
    newQueueNode->treeNode = treeNode;
    newQueueNode->next = NULL;

    if (queue->rear == NULL) {
        // 队列为空时，前后指针都指向新节点
        queue->front = queue->rear = newQueueNode;
        return;
    }
    
    // 将新节点添加到队列的末尾
    queue->rear->next = newQueueNode;
    queue->rear = newQueueNode;
}

// 出队
Node* dequeue(Queue* queue) {
    if (queue->front == NULL) {
        return NULL; // 如果队列为空，返回NULL
    }

    QueueNode* temp = queue->front;
    Node* treeNode = temp->treeNode;
    queue->front = queue->front->next;

    // 如果队列变为空，更新后指针
    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);
    return treeNode;
}

// 判断队列是否为空
int isEmpty(Queue* queue) {
    return queue->front == NULL;
}

// 二叉树的层序遍历
void levelOrder(Node* root) {
    if (root == NULL) return; // 如果根节点为空，直接返回

    Queue* queue = createQueue(); // 创建队列
    enqueue(queue, root); // 将根节点入队

    while (!isEmpty(queue)) { // 当队列不为空时循环
        Node* node = dequeue(queue); // 获取并移除队列头部元素
        printf("%d ", node->key); // 访问节点

        // 将左右孩子节点加入队列
        if (node->left != NULL) {
            enqueue(queue, node->left);
        }
        if (node->right != NULL) {
            enqueue(queue, node->right);
        }
    }

    printf("\n"); // 输出换行以分隔结果
}

// 示例使用
int main() {
    Node* root = createNode(1);
    root->left = createNode(2);
    root->right = createNode(3);
    root->left->left = createNode(4);
    root->left->right = createNode(5);

    printf("层序遍历结果：\n");
    levelOrder(root); // 输出层序遍历结果

    // 释放内存（略，实际应用中应考虑内存管理）

    return 0;
}
```

#### [还原二叉树](https://www.cnblogs.com/lanhaicode/p/10390147.html)

题目是依靠二叉树的前中后序的信息，来推出对应的另一个序列。如果仅仅知道前后的二叉树遍历结果，我们无法确定唯一的根节点位置，或者说节点的值的位置。

- 前序遍历的第一元素是整个二叉树的根节点

- 中序遍历中根节点的左边的元素是左子树，根节点右边的元素是右子树

- 后序遍历的最后一个元素是整个二叉树的根节点

> **前序遍历和中序遍历**

题目：已知，前序遍历：`ABCDEF`。中序遍历：`CBDAEF` 求解构造的数和后序遍历。

**第一步：**先看前序遍历**A**肯定是根节点

![img](./1590962-20190308110049685-131632486.png)

**第二步：**确认了根节点，再来看中序遍历，中序遍历中根节点A的左边是**`CBD`**，右边是**`EF`**，所有可以确定二叉树既有左子树又有右子树

![img](./1590962-20190308111832076-64554868.png)

**第三步：**先来分析左子树**`CBD`，**那么`CBD`谁来做`A`的左子树呢？这个时候**不能**直接用中序遍历的特点（`左->根->右`）得出左子树应该是这个样子

![img](./1590962-20190308104123264-1263028885.png)

因为有两种情况都满足中序遍历为**`CBD`**

![img](./1590962-20190308104526312-43746275.png)

直接根据中序遍历来直接得出左子树的结构，这个时候就要返回到前序遍历中去确认

观察前序遍历**`ABCDEF`，**左子树**`CBD`**在前序遍历中的顺序是**`BCD`，**意味着**`B`**是左子树的根节点（这么说可能不太好理解，换个说法就是B是A的左子树）,得出这个结果是因为如果一个**二叉树的根节点有左子树，那么这个左子树一定在前序遍历中一定紧跟着根节点**（这个是用前序遍历的特点（根->左->右）得出的）,到这里就可以确认**`B`**是左子树的根节点

![img](./1590962-20190308111823897-778383099.png)

**第四步：**再观察中序遍历**`CBDAEF`，**`B`元素左边是**`C`**右边是**`D`**，说明B节点既有左子树又有右子树，**左右子树只有一个元素就可以直接确定了**，不用再返回去观察前序遍历

![img](./1590962-20190308111608228-371713643.png)

**第五步：**到这里左子树的重建就已经完成了，现在重建右子树，因为重建右子树的过程和左子树的过程一模一样，观察中序遍历右子树为**`EF`**，再观察前序遍历**`ABCDEF`**中右子树。

![img](./1590962-20190308112146891-622698790.png)

总结：步骤就是通过**前序序列**确定根节点，然后用**中序序列**确定根节点的左右分布。然后再对分布出来的，子树通过前序序列确定子树节点，然后用中序序列确定这个子树的节点的左右分布。**如此递归**，最终就得到了完整的树。

如果是手写就按照以下步骤：

1. 根据前序序列确定根节点
2. 在**中序序列中分部分**，根节点左侧为左子树部分，右侧为右子树部分。然后根据左右的**字母分布**，在**前序序列中也分**为左子树部分和右子树部分。如果**字母分部不对称**，跳过这一步。
3. 前序序列根节点之后的**第一节点**必是其**左子树节点**（如果前面**划了分布，那么其右子树部分的第一个节点必是根节点的右子树节点**)
4. 然后就是对确定的节点，在**中序遍历上找他们的子树，如果他们子树不是叶子结点就需要重复上面的工作再划分**。也就是递归，一般不会超出三层。试试就行^ ^。

> **中序遍历和后序遍历**

- 中序遍历：`CBDAEF`

- 后序遍历为：`CDBFEA`

其实步骤与已知前序中序求后序差不多，步骤如下

1. 从后序遍历中确定根节点。后序遍历的最后一个元素是树的根节点。
2. 划分左右子树：在中序遍历中，以根节点为界，将序列分为左子树和右子树：
   - 根节点左侧的元素为左子树部分。
   - 根节点右侧的元素为右子树部分。
3. 根据后序遍历中的元素顺序来**确定左右子树的根节点**：
   - 左子树的根节点是后序遍历根节点之前的第一个元素。
   - 右子树的根节点是左子树根节点后的最后一个元素（如果存在右子树）。
4. 对确定的子树进行递归：
   - 在中序遍历中，查找每个子树的子树。
   - 如果子树不是叶子节点，则重复上述步骤，继续划分和重建。

以上面的例子为基础，对这个二叉树进行还原

- **根节点**：`A`（后序遍历的最后一个元素）。

- **左子树**：`CBD`（中序遍历`CBDAEF`中`A`左侧部分）。
  - **左子树根**：`B`（后序遍历`CDB`中，`B`在最后一个`A`之前的第一个元素）
    - **左子树**：`C`（`B`左侧）。
    - **右子树**：`D`（`B`右侧）。
  - **右子树**：`EF`（中序遍历`CBDAEF`中`A`右侧部分）
    - **右子树根**：`E`（后序遍历`EF`中，`E`在`F`之前）
      - **右子树**：`F`（`E`右侧）。

```c
      A
     / \
    B   E
   / \   \
  C   D   F
```

总结：这两种还原二叉树的方法的精髓都是要先找到当前树的根节点，然后在找到这个节点的子树，然后递归这两个操作构造。

#### [并查集](https://algo.itcharge.cn/07.Tree/05.Union-Find/)

并查集用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

并查集的重要思想在于，**用集合中的一个元素代表集合**。我曾看过一个有趣的比喻，把集合比喻成**帮派**，而代表元素则是**帮主**。接下来我们利用这个比喻，看看并查集是如何运作的。

- 对于只有一个元素的集合，代表元素自然是唯一的那个元素

![img](./v2-09fa3fa35e5411444b327d9cb9a31057_1440w.webp)

- 合并1号和3号所在的集合，1号为代表元素

![img](./v2-3bf6c1a6ecf87fa93f4dbab2012446c7_1440w.webp)

- 合并3号和2号所在的集合，合并代表元素，组合成一个新集合。

![img](./v2-be12a6c795572d2acd77dcd49de35127_1440w.webp)

重复上述结果就可以构成一个并查集。并查集是一个**树**状的结构，要寻找集合的代表元素，只需要一层一层往上访问**父节点**（图中箭头所指的圆），直达树的**根节点**（图中橙色的圆）即可。根节点的父节点是它自己。可以直接把它画成一棵树：

![img](./v2-cca3ddf5806a221201ed78caf1d27041_1440w.png)

**初始并查集**

初始化，集合中每个元素都为一个集合。假如有编号为`1, 2, 3, ..., n`的n个元素，我们用一个**数组`fa[]`来存储每个元素的父节点（因为每个元素有且只有一个父节点，所以这是可行的）。一开始，我们先将它们的父节点设为自己。**也就意味着每一个节点都是一个集合。

```c++
int fa[MAXN];
inline void init(int n) //将函数的调用替换为函数体的代码
{
    for (int i = 1; i <= n; ++i)
        // 集合中每个元素都为一个集合
        fa[i] = i;
}
```

**查询**，访问集合代表元素，用递归的写法实现对代表元素的查询：一层一层访问父节点，直至根节点（根节点的标志就是父节点是本身）。要判断两个元素是否属于同一个集合，**只需要看它们的根节点是否相同即可。**

```c++
int find(int x)
{
    if(fa[x] == x) //fa数组中存储的是集合中元素的父节点
        return x;
    else
        return find(fa[x]);
}
```

**合并**，先找到**两个集合的代表元素(初始情况下是自己，处理完成之后就是父节点)**，然后将前者的父节点设为后者即可。当然也可以将后者的父节点设为前者。

```c++
inline void merge(int i, int j)
{
    // find是查找j的根节点
    // 通常根节点的序号和数组的index一一对应,这里的fa[find(i)]就是i的根节点的位置
    fa[find(i)] = find(j);
}
```

**路径压缩优化**

最简单的并查集效率是比较低的。例如，来看下面这个场景：

![img](./v2-49b5dd7af650192373e96d29f9c4b8cf_1440w.webp)

现在我们要`merge(2,3)`，于是从`2`找到`1`，`fa[1]=3`，于是变成了这样：

![img](./v2-6f85fc7c5578aa20400ac56f0da31e37_1440w.webp)

然后我们又找来一个元素`4`，并需要执行`merge(2,4)`：

![img](./v2-1d3ef8a42d424cbec76135ce8a494ff7_1440w.webp)

从`2`找到`1`，再找到`3`，然后`fa[3]=4`，于是变成了这样：

![img](./v2-23c367515ace6fc0603692dfd865849f_1440w.webp)

这样可能会形成一条长长的**链**，随着链越来越长，我们想要从底部找到根节点会变得越来越难。怎么解决呢？我们可以使用**路径压缩**的方法。既然我们只关心一个元素对应的**根节点**，那我们希望每个元素到根节点的路径尽可能短，最好只需要一步，像这样：

![img](./v2-c2f835398a3e54d8209bf5e034ac6820_1440w.png)

其实这说来也很好实现。只要我们在查询的过程中，**把沿途的每个节点的父节点都设为根节点**即可。下一次再查询时，我们就可以省很多事。这用递归的写法很容易实现：

**合并**

```c++
// 函数的作用是找到根节点 - 只要记住这一点
int find(int x)
{
    if(x == fa[x])
        return x;
    else{
        fa[x] = find(fa[x]);  //父节点设为根节点
        return fa[x];         //返回父节点
    }
}
```

**简化**

```c++
int find(int x)
{
    // 三元表达式只是简化了if else
    return x == fa[x] ? x : (fa[x] = find(fa[x]));
}
```

**总的代码**

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAX_N = 500000 + 7;

int n, m, s;
vector<int> adj[MAX_N]; // 邻接表存储树
int parent[MAX_N]; // 并查集中的父节点
int ancestor[MAX_N]; // 记录每个节点的祖先
int visited[MAX_N]; // 记录节点是否被访问过
int lca_res[MAX_N]; // 保存每次查询的结果
vector<pair<int, int>> queries[MAX_N]; // 保存LCA查询

// 并查集的路径压缩
int find(int x) {
    if (x != parent[x]) {
        parent[x] = find(parent[x]);
    }
    return parent[x];
}

// Tarjan's LCA
void tarjan(int u) {
    ancestor[u] = u;
    visited[u] = 1;
    for (int v : adj[u]) {
        if (!visited[v]) {
            tarjan(v);
            parent[v] = u; // 合并子节点到当前节点
        }
    }
    // 处理LCA查询
    for (auto &[v, index] : queries[u]) {
        if (visited[v]) {
            lca_res[index] = ancestor[find(v)];
        }
    }
}

int main() {
    cin >> n >> m >> s;
    
    // 初始化
    for (int i = 1; i <= n; ++i) {
        parent[i] = i;
    }
    
    int a, b;
    for (int i = 1; i < n; ++i) {
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a); // 无向图
    }

    for (int i = 1; i <= m; ++i) {
        cin >> a >> b;
        queries[a].push_back({b, i});
        queries[b].push_back({a, i});
    }

    tarjan(s);

    for (int i = 1; i <= m; ++i) {
        cout << lca_res[i] << endl;
    }

    return 0;
}
```

**倍增法优化**

通过引入倍增法（也称为跳跃表或稀疏表），可以减少查询的时间复杂度。具体来说，倍增法在预处理阶段构建一个祖先表，使得每次查询能够在 `O(log⁡n)` 的时间内完成。

通俗地说，倍增法就是“跳跃式查找”，不再是逐个节点遍历，而是根据层级成倍查找。最初查找间隔为 `2^0`，然后是` 2^1`，一直到 `2^n`。这样，通过构建一棵树来维护每个集合，原本需要线性时间` O(n) `的查找，可以优化到对数时间 `O(log⁡n)`。

```c++
#include<bits/stdc++.h>
using namespace std;

const int MAX_N = 500000+7;
const int LOG_N = 20; // log2(MAX_N) 取上界

int n, m, s;
int d[MAX_N]; // 保存节点深度
int f[MAX_N][LOG_N]; // 保存节点的 2^j 级父节点

int head[MAX_N], cnt = -1;
struct Edge {
    int to, next;
} e[MAX_N * 2];

void add(int u, int v) {
    e[++cnt].to = v;
    e[cnt].next = head[u];
    head[u] = cnt;
}

void dfs(int u, int fa) // u为当前节点, fa为父节点
{
    f[u][0] = fa; // 直接父节点
    d[u] = d[fa] + 1;
    for (int j = 1; j < LOG_N; j++) {
        f[u][j] = f[f[u][j-1]][j-1]; // 预处理所有2^j父节点
    }
    for (int i = head[u]; i != -1; i = e[i].next) {
        int v = e[i].to;
        if (v != fa) {
            dfs(v, u);
        }
    }
}

int lca(int x, int y) {
    if (d[x] > d[y]) // 令y为更深节点
        swap(x, y);

    // 使x和y的深度相同
    for (int j = LOG_N - 1; j >= 0; j--) {
        if (d[f[y][j]] >= d[x]) {
            y = f[y][j];
        }
    }

    if (x == y) return x;

    // 同时向上移动直到找到最近公共祖先
    for (int j = LOG_N - 1; j >= 0; j--) {
        if (f[x][j] != f[y][j]) {
            x = f[x][j];
            y = f[y][j];
        }
    }

    return f[x][0]; // 返回LCA
}

int main() {
    memset(head, -1, sizeof(head));
    memset(f, 0, sizeof(f)); // 初始化 f 数组
    int a, b;
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i < n; i++) {
        scanf("%d%d", &a, &b);
        add(a, b);
        add(b, a); // 无向图，要加两次
    }
    dfs(s, 0);

    for (int i = 1; i <= m; i++) {
        scanf("%d%d", &a, &b);
        printf("%d\n", lca(a, b));
    }

    return 0;
}
```

#### [树与二叉树的转化](https://heptaluan.github.io/2020/04/02/Essay/19/)

**普通树转换为二叉树**

我们借助图片来进行了解，首先下图是一颗普通的树，它有三个结点，所以明显不是二叉树

![img](./19-01.png)

如果将其转换成相应的二叉树分为两个步骤

- 在树中所有的兄弟结点(同层)之间加一连线
- 对每个结点，除了保留与其长子的连线外，去掉该结点与其他孩子的连线

所以我们首先执行『在兄弟结点之间添加连线』

![img](./19-02.png)

然后在去除『非长子外』的连线

![img](./19-03.png)

最后，我们在稍微调整一下位置，就可以得出我们想要的二叉树

![img](./19-04.png)

总结一下，基本的步骤如下

- 加线，在所有兄弟结点之间加一条连线
- 去线，对树中每个结点，只保留**它与第一孩子结点的连线**，删除它与其他孩子结点之间的连线
- 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明

**森林转换为二叉树**

同样的还是借助图片来进行了解，首先下图是三颗普通的树，三棵树构造在一起就成了一个森林

![img](./19-05.png)

如果将其转换成相应的二叉树分为两个步骤

- 先将森林中的每棵树变为二叉树
- 再将各二叉树的根结点视为兄弟从左到右连在一起，就形成了一颗二叉树

所以我们首先将**森林中的每棵树变为二叉树**，方式和我们之前实现的方式是一致的

![img](./19-06.png)

然后将它们的『根结点』依次连在一起

![img](./19-07.png)

最后老规矩，在稍微调整一下位置

![img](./19-08.png)

总结一下，基本的步骤如下

- 把每棵树转换为二叉树
- 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来

**二叉树转换为树、森林**

二叉树转换为普通树本质上就是之前的逆过程，步骤也就是反过来做而已，判断一棵二叉树能够转换成一棵树还是森林，标准很简单，那就是『只要看这棵二叉树的根结点有没有右孩子，有的话就是森林，没有的话就是一棵树』，如下，是一个二叉树

![img](./19-09.png)

第一步，若结点 `x` 是其双亲 `y` 的左孩子，则把 `x` 的右孩子，右孩子的右孩子等等等等，依次都与 `y` 用连连连接起来，如下

![img](./19-10.png)

第二步，去掉所有双亲到右孩子之间到连线（也就是之前到逆向）

![img](./19-11.png)

最后老规矩，调整一下，就变成了我们之前的森林

![img](./19-12.png)

##### 树与森林的遍历

简单来说，树的遍历分为两种方式，一种是先根遍历，另一种是后根遍历

- 先根遍历，先访问树的根结点，然后再依次先根遍历根的每棵子树
- 后根遍历，先依次遍历每棵子树，然后再访问根结点

比如下面这棵树

![img](./19-01-1728821802950-29.png)

我们按照两种遍历方式如下

先根遍历结果为 `A ==> B ==> E ==> F ==> C ==> G ==> D ==> H ==> I ==> J`
后根遍历结果为 `E ==> F ==> B ==> G ==> C ==> H ==> I ==> J ==> D ==> A`

相对于**森林的遍历也分为前序遍历和后序遍历**，其实就是按照树的先根遍历和后根遍历依次访问森林的每一棵树，这里有一个需要注意的地方，注意比较下面两个图，前面一个是一棵树，而后面那颗则是树转换为二叉树以后的模样

![img](./19-01-1728821813926-32.png)

![img](./19-04-1728821859579-35.png)

仔细观察我们可以发现

- 树、森林的前根（序）遍历和二叉树的前序遍历结果相同
- 树、森林的后根（序）遍历和二叉树的中序遍历结果相同

这样一来，我们就可以将对树和森林遍历这种复杂问题转换为一种相对比较简单的处理方式

#### [哈夫曼树](https://heptaluan.github.io/2020/04/02/Essay/19/)

在数据膨胀、信息爆炸的今天，数据压缩的意义不言而喻，谈到数据压缩，就不能不提赫夫曼（`Huffman`）编码，赫夫曼编码是**首个实用的压缩编码方案**，即使在今天的许多知名压缩算法里，依然可以见到赫夫曼编码的影子

另外，在数据通信中，用二进制给每个字符进行编码时不得不面对的一个问题是如何使**电文总长最短且不产生二义性**，根据字符出现频率，利用赫夫曼编码可以构造出一种不等长的二进制，使编码后的电文长度最短，且保证不产生二义性

关于赫夫曼编码的内容会在最后进行介绍，在此之前，我们先来了解一下什么是赫夫曼树，先来看下面这个计算成绩的示例

```c
if(a < 60)
  printf("不及格")
else if(a < 70)
  printf("及格")
else if(a < 90)
  printf("良好")
else
  printf("优秀")
```

如果我们将其转化为**二叉树的显示方式**，是下面这样的

![img](./19-13.png)

如果按照上面这个流程，比如某个同学的成绩是 `85` 分的话，则需要进行三次判断才能得出他的成绩，那么我们是否可以稍微的调整一下，让这个判断流程减少一些呢，那就有了下图这样的二叉树

![img](./19-14.png)

如果我们把判断流程改为像上图这样，那么可以发现效果有比较明显的改善，即我们**只需要两次判断就可以得出我们想要的结果**，但是我们如何区分到底应该采用哪种判断流程呢？所以这种情况要按实际情况来进行考虑，如下图

![img](./19-15.png)

可以发现，一个班级的成绩一般来说，达到良好的人数应该占班级总人数的绝大数，有了这个概念以后，我们就可以先把这两棵二叉树简化成『叶子结点带权』的二叉树（树结点间的连线相关的数叫做权，`Weight`），就是**把我们对应分数的所占比例给带入到二叉树当中**，结果如下图

![img](./19-16.png)

针对于上图，我们需要介绍几个基本的概念，如下

- 结点的路径长度，表示从根结点到该结点的**路径上的连接数**
- 树的路径长度，表示树中每个叶子结点的路径长度之和
- 结点带权路径长度，表示结点的路径长度与结点权值的乘积
- **树的带权路径长度**（`WPL，Weighted Path Length`），表示的是树中所有叶子结点的**带权路径长度之和**
- 如果 `WPL` 的值越小，说明构造出来的二叉树性能越优

有了这些概念以后，我们就可以来分别计算上诉两种情况

针对第一种情况，它的 `WPL` 是 `5 * 1 + 15 * 2 + 70 * 3 + 10 * 3 = 275`

针对第二种情况，它的 `WPL` 是 `10 * 1 + 70 * 2 + 15 * 3 + 5 * 3 = 210`

可以发现，针对成绩的判断流程，采取后面的一种方式是更为合理的，那么现在问题来了，因为在一棵树的所有构成形状当中，有各种各样的构成方式，那么我们如才能何构造出最优的赫夫曼树呢（也就是所谓的最优二叉树）？看下面流程

![img](./19-17.png)

假设有一片森林，如上图所示，有四颗小树（只有一个根结点的树），它们的权也分别标注了出来，然后我们挑选出权值最小的两棵树，小的放左边，大的放右边，然后模拟出一个新的结点作为新二叉树的根，这个新的结点连接着它们两个，如下所示，而新的树的权值为它的左右孩子的权值之和

![img](./19-18.png)

然后同理操作，继续在剩余树林当中挑选出权值最小的那一颗(贪心)，按照我们之前的逻辑继续连接，也就是下面这样

![img](./19-19.png)

依次执行下去，最后的结果如下

![img](./19-20.png)

这样就形成了一颗赫夫曼树，也就是所谓的最优二叉树，因为如果用其他的方式使用 `ABCD` 来进行构造所形成的二叉树的 `WPL` 是不会小于上图当中所实现的方式的。可以看出，赫夫曼算法使用贪心，将权值最大的往上层排列，权值最小的往下排列。这样就会使得`WPL`的值最小。

![img](./alg-tree-hafman-2.png)

##### 赫夫曼编码

在之前的章节当中，我们已经介绍了赫夫曼树的基本原理和构造方式，而赫夫曼编码可以很有效地压缩数据（通常可以节省 `20% ~ 90%` 的空间，具体压缩率依赖于数据的特性），下面我们来看几个经常会遇到的名词

- 定长编码，比如像 `ASCII` 编码就是定长编码，如果我们有一百个字符，并且都是 `A` 的话，那么则需要八百位才能存放的下
- **变长编码**，单个编码的长度不一致，可以根据整体出现频率来调节，比如我们要发生的信息都是 `A`，那么我们可以使用 `0` 或者 `1` 来代表 `A`（因为这个规则我们已经事先约定好了）
- 前缀码，所谓的前缀码，就是没有任何码字是其他码字的前缀，比如我们的赫夫曼编码（其实就是非前缀码，但是业界之中都叫前缀码）

下面我们来看看如何用代码进行实现，我们首先来定义哈夫曼树节点 `HuffmanTreeNode`

```c++
class HuffmanTreeNode {
public:
    HuffmanTreeNode* l;  // 左子树
    HuffmanTreeNode* r;  // 右子树
    int weight;          // 字符的度量值，表示出现频次
    char ch;             // 字符

    // 构造函数
    HuffmanTreeNode(int weight = 0, char ch = '\0') 
        : l(nullptr), r(nullptr), weight(weight), ch(ch) {}
};
```

然后我们再来定义一个最小堆 `heapMin`，主要用于在创建哈夫曼树过程中获取度量值 `weight`（字符出现的频次）最小的节点

```c++
class heapMin {
private:
    std::vector<HuffmanTreeNode*> heap;

    // 调整堆使其满足最小堆性质
    void adjust(int index) {
        int len = heap.size();
        int l = 2 * index + 1;
        int r = 2 * index + 2;
        int min = index;

        if (l < len && heap[min]->weight > heap[l]->weight) {
            min = l;
        }

        if (r < len && heap[min]->weight > heap[r]->weight) {
            min = r;
        }

        if (min != index) {
            std::swap(heap[index], heap[min]);
            adjust(min);
        }
    }

public:
    // 插入一个节点
    void push(HuffmanTreeNode* node) {
        heap.push_back(node);
        for (int i = heap.size() / 2 - 1; i >= 0; i--) {
            adjust(i);
        }
    }

    // 移除最小元素
    HuffmanTreeNode* pop() {
        if (heap.empty()) return nullptr;

        HuffmanTreeNode* node = heap.front();
        heap[0] = heap.back();
        heap.pop_back();
        if (!heap.empty()) {
            adjust(0);
        }

        return node;
    }

    // 获取堆的大小
    int size() const {
        return heap.size();
    }

    // 判断堆是否为空
    bool empty() const {
        return heap.empty();
    }
};
```

再来定义哈夫曼编码对象 `HuffmanCode`

```c++
class HuffmanCode {
public:
    std::vector<std::string> codeTable;  // 编码表
    HuffmanTreeNode* huffmanTree;        // 哈夫曼树

    // 构造函数
    HuffmanCode() : huffmanTree(nullptr) {}

    // 析构函数，用于释放哈夫曼树的内存
    ~HuffmanCode() {
        clearHuffmanTree(huffmanTree);
    }

    // 清空哈夫曼树的内存
    void clearHuffmanTree(HuffmanTreeNode* node) {
        if (node != nullptr) {
            clearHuffmanTree(node->l);
            clearHuffmanTree(node->r);
            delete node;
        }
    }

    // 打印当前的编码表
    void printCodeTable() {
        for (size_t i = 0; i < codeTable.size(); ++i) {
            std::cout << "Char: " << char('a' + i) << ", Code: " << codeTable[i] << std::endl;
        }
    }

    // 示例：插入编码表中的字符编码
    void insertCode(const std::string& code) {
        codeTable.push_back(code);
    }
};
```

生成字符频次最小堆

```c++
class HuffmanCode {
public:
    // 静态方法：根据给定字符串生成字符频次最小堆
    static HeapMin calcHeap(const std::string& str) {
        HeapMin heap;  // 定义一个最小堆
        std::unordered_map<char, int> freqMap;  // 定义一个哈希表来存储字符及其频次

        // 统计字符频次
        for (char ch : str) {
            freqMap[ch]++;  // 对每个字符，增加其在哈希表中的频次
        }

        // 将频次插入最小堆
        for (const auto& entry : freqMap) {
            // 创建哈夫曼树节点，参数是字符的频次和字符本身
            HuffmanTreeNode* node = new HuffmanTreeNode(entry.second, entry.first);
            heap.push(node);  // 将节点插入最小堆
        }

        return heap;  // 返回构建好的最小堆
    }
};
```

**创建哈夫曼树**

```c++
// 之前定义的 HuffmanTreeNode 和 HeapMin 保持不变

class HuffmanCode {
public:
    HuffmanTreeNode* huffmanTree;

    HuffmanCode() : huffmanTree(nullptr) {}

    // 根据输入字符串创建哈夫曼树
    HuffmanTreeNode* createHuffmanTree(const std::string& str) {
        // 生成字符频次的最小堆
        HeapMin heap = calcHeap(str);

        // 当堆中剩余一个元素时停止合并
        while (heap.size() > 1) {
            // 取出最小的两个节点
            HuffmanTreeNode* min1 = heap.pop();
            HuffmanTreeNode* min2 = heap.pop();

            // 创建一个新节点作为这两个节点的父节点
            HuffmanTreeNode* parent = new HuffmanTreeNode(min1->weight + min2->weight, '\0');

            // 将两个节点合并到父节点
            if (min1->weight < min2->weight) {
                parent->l = min1;
                parent->r = min2;
            } else {
                parent->l = min2;
                parent->r = min1;
            }

            // 将新的父节点插入堆中
            heap.push(parent);
        }

        // 剩下的唯一一个节点就是哈夫曼树的根节点
        huffmanTree = heap.pop();
        return huffmanTree;
    }

    // 计算字符频次并返回最小堆（之前已经实现）
    static HeapMin calcHeap(const std::string& str) {
        HeapMin heap;
        std::unordered_map<char, int> freqMap;

        // 统计字符频次
        for (char ch : str) {
            freqMap[ch]++;
        }

        // 将频次插入最小堆
        for (const auto& entry : freqMap) {
            HuffmanTreeNode* node = new HuffmanTreeNode(entry.second, entry.first);
            heap.push(node);
        }

        return heap;
    }
};
```

递归哈夫曼树，生成编码表

```c++
// HuffmanTreeNode 保持不变，假设之前已经定义
// 递归遍历哈夫曼树，生成编码表
class HuffmanCode {
public:
    std::unordered_map<char, std::string> codeTable;  // 编码表

    // 递归生成哈夫曼编码表
    void traverseTree(HuffmanTreeNode* node, const std::string& code) {
        if (node == nullptr) {
            return;
        }

        // 如果当前节点是叶子节点（即没有子节点）
        if (node->l == nullptr && node->r == nullptr) {
            codeTable[node->char] = code;  // 将叶子节点的字符与其编码存入编码表
        }

        // 递归遍历左子树并添加 '0' 到编码
        if (node->l != nullptr) {
            traverseTree(node->l, code + "0");
        }

        // 递归遍历右子树并添加 '1' 到编码
        if (node->r != nullptr) {
            traverseTree(node->r, code + "1");
        }
    }

    // 输出编码表
    void printCodeTable() const {
        for (const auto& entry : codeTable) {
            std::cout << entry.first << ": " << entry.second << std::endl;
        }
    }
};
```

哈夫曼编码

```c++
// 假设 HuffmanTreeNode 和 HuffmanCode 已经定义，并且 traverseTree 方法已经实现

class HuffmanCode {
public:
    std::unordered_map<char, std::string> codeTable;  // 编码表
    HuffmanTreeNode* huffmanTree;

    HuffmanCode() : huffmanTree(nullptr) {}

    // 创建哈夫曼树
    HuffmanTreeNode* createHuffmanTree(const std::string& str) {
        // ... (这里的实现与之前的 createHuffmanTree 方法相同)
    }

    // 递归生成哈夫曼编码表
    void traverseTree(HuffmanTreeNode* node, const std::string& code) {
        // ... (这里的实现与之前的 traverseTree 方法相同)
    }

    // 哈夫曼编码
    std::string encode(const std::string& str) {
        // 创建哈夫曼树
        createHuffmanTree(str);

        // 生成编码表
        codeTable.clear(); // 清空编码表
        traverseTree(huffmanTree, "");

        std::string res;
        // 遍历字符串，将每个字符替换为其哈夫曼编码
        for (char ch : str) {
            res += codeTable[ch]; // 将对应的编码添加到结果字符串中
        }

        return res; // 返回编码后的结果
    }

    // 打印编码表
    void printCodeTable() const {
        for (const auto& entry : codeTable) {
            std::cout << entry.first << ": " << entry.second << std::endl;
        }
    }
};
```

哈夫曼解码

```c++
class HuffmanCode {
public:
    std::unordered_map<char, std::string> codeTable;  // 编码表
    HuffmanTreeNode* huffmanTree;

    HuffmanCode() : huffmanTree(nullptr) {}

    // 创建哈夫曼树
    HuffmanTreeNode* createHuffmanTree(const std::string& str) {
        // ... (与之前相同的实现)
    }

    // 递归生成哈夫曼编码表
    void traverseTree(HuffmanTreeNode* node, const std::string& code) {
        // ... (与之前相同的实现)
    }

    // 哈夫曼编码
    std::string encode(const std::string& str) {
        // ... (与之前相同的实现)
    }

    // 哈夫曼解码
    std::string decode(const std::string& str) {
        if (huffmanTree == nullptr) {
            std::cerr << "Please create HuffmanTree!" << std::endl;
            return "";
        }

        HuffmanTreeNode* node = huffmanTree;
        std::string res;

        // 遍历编码字符串
        for (char ch : str) {
            // 根据编码字符选择左右子树
            if (ch == '0') {
                node = node->l;
            } else {
                node = node->r;
            }

            // 到达叶子节点，表示找到了一个字符
            if (node->l == nullptr && node->r == nullptr) {
                res += node->char;  // 添加字符到结果字符串
                node = huffmanTree;  // 重置到树的根节点
            }
        }

        return res; // 返回解码后的结果
    }

    // 打印编码表
    void printCodeTable() const {
        for (const auto& entry : codeTable) {
            std::cout << entry.first << ": " << entry.second << std::endl;
        }
    }
};
```

完整的代码

```c++
#include <iostream>
#include <unordered_map>
#include <string>
#include <vector>
#include <queue>

// 哈夫曼树节点
class HuffmanTreeNode {
public:
    char ch;                        // 字符
    int weight;                     // 字符的频次
    HuffmanTreeNode* l;            // 左子树
    HuffmanTreeNode* r;            // 右子树

    // 构造函数
    HuffmanTreeNode(char character, int freq) : ch(character), weight(freq), l(nullptr), r(nullptr) {}

    // 自定义比较运算符，用于优先队列
    bool operator>(const HuffmanTreeNode& other) const {
        return weight > other.weight;
    }
};

// 哈夫曼编码类
class HuffmanCode {
public:
    std::unordered_map<char, std::string> codeTable;  // 编码表
    HuffmanTreeNode* huffmanTree;

    HuffmanCode() : huffmanTree(nullptr) {}

    // 创建哈夫曼树
    void createHuffmanTree(const std::string& str) {
        // 统计字符频次
        std::unordered_map<char, int> frequency;
        for (char ch : str) {
            frequency[ch]++;
        }

        // 使用优先队列构建最小堆
        std::priority_queue<HuffmanTreeNode*, std::vector<HuffmanTreeNode*>, std::greater<HuffmanTreeNode*>> minHeap;

        // 将每个字符和频次放入堆中
        for (const auto& pair : frequency) {
            minHeap.push(new HuffmanTreeNode(pair.first, pair.second));
        }

        // 构建哈夫曼树
        while (minHeap.size() > 1) {
            HuffmanTreeNode* min1 = minHeap.top(); minHeap.pop();
            HuffmanTreeNode* min2 = minHeap.top(); minHeap.pop();

            // 创建新父节点
            HuffmanTreeNode* parent = new HuffmanTreeNode('\0', min1->weight + min2->weight);
            parent->l = min1;
            parent->r = min2;

            minHeap.push(parent);
        }

        // 取得最终的哈夫曼树根节点
        if (!minHeap.empty()) {
            huffmanTree = minHeap.top();
        }
    }

    // 递归生成哈夫曼编码表 - 编码表是由给出的字符出现的频率构造的
    void traverseTree(HuffmanTreeNode* node, const std::string& code) {
        if (node->l == nullptr && node->r == nullptr) {
            codeTable[node->ch] = code; // 到达叶子节点，存储编码
            return;
        }
        if (node->l != nullptr) traverseTree(node->l, code + "0"); // 左子树
        if (node->r != nullptr) traverseTree(node->r, code + "1"); // 右子树
    }

    // 哈夫曼编码
    std::string encode(const std::string& str) {
        createHuffmanTree(str); // 创建哈夫曼树
        traverseTree(huffmanTree, ""); // 生成编码表

        std::string res;
        for (char ch : str) {
            res += codeTable[ch]; // 替换为哈夫曼编码
        }
        return res; // 返回编码结果
    }

    // 哈夫曼解码
    std::string decode(const std::string& str) {
        if (huffmanTree == nullptr) {
            std::cerr << "Please create HuffmanTree!" << std::endl;
            return "";
        }

        HuffmanTreeNode* node = huffmanTree;
        std::string res;

        // 遍历编码字符串
        for (char ch : str) {
            node = (ch == '0') ? node->l : node->r; // 根据编码选择子树
            // 到达叶子节点
            if (node->l == nullptr && node->r == nullptr) {
                res += node->ch; // 添加字符到结果字符串
                node = huffmanTree; // 重置到树的根节点
            }
        }

        return res; // 返回解码后的结果
    }

    // 打印编码表
    void printCodeTable() const {
        for (const auto& entry : codeTable) {
            std::cout << entry.first << ": " << entry.second << std::endl;
        }
    }
};

// 示例使用
int main() {
    HuffmanCode hc;
    std::string input = "example string for huffman encoding";

    // 哈夫曼编码
    std::string encoded = hc.encode(input);
    std::cout << "Encoded string: " << encoded << std::endl;

    // 哈夫曼解码
    std::string decoded = hc.decode(encoded);
    std::cout << "Decoded string: " << decoded << std::endl;

    // 输出编码表
    hc.printCodeTable();

    return 0;
}
```

#### [二叉搜索树BST](https://algo.itcharge.cn/07.Tree/02.Binary-Search-Tree/01.Binary-Search-Tree/#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99)

二叉搜索树中，左子树的所有节点值小于父节点，右子树的所有节点值大于父节点。

- 若它的**左⼦树不空**，则**左⼦树上所有结点的值均⼩于它的根结点的值**；
- 若它的**右⼦树不空**，则右⼦树上所有结点的值均⼤于它的根结点的值；
- 它的左、右⼦树也分别为⼆叉搜索树

二叉搜索树的中序遍历是正序输出，例如下面的树输出的是`3 7 9 14 16 18 19`

![二叉搜索树](./20240511171406-1723797363701-240.png)

二叉搜索树的主要优势在于其查找效率。如果树是相对平衡的，即它的深度是对数级别的，那么查找、插入和删除的时间复杂度也都为 `O(log n)`，其中 `n` 是树中的节点数。

具体来说，这是因为在查找过程中，我们**每次都能够根据节点关键字的大小来排除掉一半的搜索空间**。这种二分的思想使得二叉搜索树在处理大规模数据时仍能保持较高的效率。

![img](./f23d8aac8eb754336f05a88e45ec67f7.png)

##### [平衡二叉搜索树AVL](https://zhuanlan.zhihu.com/p/56066942)

二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，例如序列` A = {1，2，3，4，5，6}`，构造二叉搜索树如下图。**依据此序列构造的二叉搜索树为右斜树，同时二叉树退化成单链表，搜索效率降低为 O(n)。**

![img](./v2-f8e97ce8bff6af406ca2e3399be7ad5e_1440w.webp)

在此二叉搜索树中查找元素 `6` 需要查找` 6 `次。二叉搜索树的查找效率取决于**树的高度**，**因此需要保持树的高度最小**，即可保证树的查找效率。同样的序列` A`，将其改为下图的方式存储，查找元素` 6 `时只需比较` 3 `次，查找效率提升一倍。

![img](./v2-fd82c10388b933d1c09d1fbe297984ef_1440w.webp)

可以看出当结点数目一定，保持树的左右两端保持平衡，树的查找效率最高。**这种左右子树的高度相差不超过` 1 `的树为平衡二叉树。**它具有如下几个性质：

1. **可以是空树**。
2. **假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。**

平衡之意，如天平，即两边的分量大约相同。例如下面的图就不是平衡二叉树

![img](./v2-e090a8e3171c8db07e1cda720039e700_1440w.webp)

下面的也不是平衡二叉树，因为虽然任何一个结点的左子树与右子树都是平衡二叉树，但**高度之差已经超过 1 。**

![img](./v2-7b3cbb7cf1d996c072516b7146144e52_1440w.webp)

**平衡因子**

平衡因子的作用是**衡量二叉树中各个节点的平衡程度**，也就是左子树和右子树高度的差值，对于当前节点的关系应该有
$$
平衡因子 = 左子树的高度 - 右子树的高度
$$
平衡二叉树中不存在平衡因子大于` 1 `的节点。在一棵平衡二叉树中，**节点的平衡因子只能取` 0` 、`1 `或者 `-1`** ，分别对应着左右子树等高，左子树比较高，右子树比较高。这里子树高度是从根节点到当前节点的距离。

![img](./v2-6f2e86b1231b5df131813dc45f8f98cb_1440w.webp)

![img](./v2-7e5f77810ff2a3a0ae6ae0c0d9443ac1_1440w.webp)

![img](./v2-ba3929eafa5c6a32b1db0402850a321d_1440w.webp)

**节点结构**

```c++
typedef struct AVLNode *Tree;

typedef int ElementType;

struct AVLNode{

    int depth; //深度，这里计算每个结点的深度，通过深度的比较可得出是否平衡

    Tree parent; //该结点的父节点

    ElementType val; //结点值

    Tree lchild;

    Tree rchild;

    AVLNode(int val=0) {
        parent = NULL;
        depth = 0;
        lchild = rchild = NULL;
        this->val=val;
    }
};
```

**失衡与调整**

在一个平衡二叉树中从底部插入一个节点，原来的平衡二叉树就变成了一个不平衡的二叉树了，这种结果被称之为失衡。我们可以通过**对节点的自旋来将不平衡二叉树转化为平衡二叉树。**

![img](./v2-b783aaef2f74f6edbc789a9c58c3add8_1440w.webp)

例如在此平衡二叉树插入节点 `99` ，树的结构就变了。由于插入一个节点会更新平衡因子，也就导致了根节点的平衡因子大于`2`了，就导致了这个树的平衡性被破坏了。

![动图](./v2-2ddb0f9b832fff594e294dffc299b373_b.webp)

- 节点 `66` 的左子树高度为 `1`，右子树高度为 `3`，此时平衡因子为 `2`，树失去平衡。

- 以节点 `66` 为父节点的那颗树就称为 **最小失衡子树**。

**最小失衡子树**：在新插入的结点向上查找，以第一个平衡因子的**绝对值**超过 `1` 的结点为根的子树称为最小不平衡子树。也就是说，一棵失衡的树，是有可能有多棵子树同时失衡的。而这个时候，我们**只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。**

**平衡二叉树的失衡调整主要是通过旋转最小失衡子树来实现的**。根据旋转的方向有两种处理方式，**左旋** 与 **右旋** 。**旋转的目的就是减少高度，通过降低整棵树的高度来平衡，从而提高查找效率。**哪边的树高，就把那边的树向上旋转，也就是左边的树高，往右边旋。右边的树高，往左边旋转。

> **左旋**

![img](./v2-0a757b848f85f3531b0789fd3d79f0b3_1440w.webp)

为了保证树的平衡性，当节点 `66` 的平衡因子为 `2` 时，说明右子树高度比左子树高，需要对节点 `66` 进行左旋操作。

1. 节点 `66` 的**右子节点**替代 `66` 的位置，成为新的根节点。
2. 该右子节点的**左子树**变为 `66` 的**右子树**。
3. 节点 `66` 本身成为新的根节点的**左子树**。

也就可以简单记为，左旋是将根节点作为新根节点的左子树。需要左旋的树说明其右子树的深度大于左子树的深度

![动图](./v2-db1cdb0da952a71f9b6d64b2608467eb_b.webp)

> **右旋**

平衡二叉树搜索需要右旋，说明左子树的高度大于右子树，需要对这个`66`节点进行右旋操作

1. 结点`66`的左子节点代替`66`的位置，成为新的根节点
2. 该左子节点的右子树变为`66`的右子树
3. 结点`66`本身成为新的根节点的右子树

也就可以简单记为，右旋是将老根节点作为新根节点的右子树。需要右旋的树说明其左子树的深度大于右子树的深度

![动图](./v2-05246384c1c16537ca6176983bdb2627_b.webp)

为什么需要这样旋转，这样旋转会不会破坏二叉树的平衡性，答案是不会。前面提到过，平衡二叉树每个节点都由有这两个特点。

- 平衡因子不会大于`2`
- 左子树大于右子树

这里还是以右旋举例，当**左子树高度大于右子树**，且高度差超过 1 时，会对该节点进行**右旋**，以减少左子树的高度并恢复平衡。**右旋的作用**是将根节点向下调整，新根节点成为原左子树的根节点。这时满足以下几点

1. **根节点必然比新根节点的左节点大**：因为新根节点原本是根节点的左子节点，而根据二叉搜索树的定义，左子节点必然比根节点小。因此，右旋操作不会破坏节点的大小关系。
2. **旧根节点的直接右节点比新根节点的右子树要大**：右旋过程中，旧根节点下移为新根节点的右子树，而新根节点的右子树（如果存在）本身已经是比新根节点小的节点。所以，旧根节点依然比新根节点的右子树中的节点大。

#### [自平衡多路搜索树](https://github.com/wardseptember/notes/blob/master/docs/B%E6%A0%91%E5%92%8CB+%E6%A0%91%E8%AF%A6%E8%A7%A3.md)

##### [红黑树](https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd/blob/master/ebook/zh/03.01.md)

红黑树是一种特化的`AVL`树（平衡二叉树）红黑树也是一种自平衡二叉查找树，它与`AVL`树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。

与`AVL`树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时**较少的旋转**操作，整体来说性能要优于`AVL`树。虽然`RBTree`是复杂的, 但它的**最坏情况运行时间**也是非常良好的,并且在实践中是高效的：

> 它可以在**`O(log n)`**时间内做查找,插入和删除,这里的**n 是树中元素的数目.**

红黑树是实际应用中最常用的平衡二叉查找树，它不严格的具有平衡属性，但平均的使用性能非常良好。在红黑树中，节点被标记为红色和黑色两种颜色。构成红黑树的原则有以下几点：

- 特性1：节点非黑即红
- 特性2：根节点一定是黑色
- 特性3：叶子节点（`NIL`）一定是黑色
- 特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 特性5：从**任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。**

**红色属性** 说明，红色节点的孩子，一定是黑色。 但是，`RBTree` 黑色节点的孩子，可以是红色，也可以是黑色，具体如下图。

**叶子属性** 说明， 叶子节点可以是空`ull` ，`AVL`的叶子节点不是空的，具体如下图。

![img](./20200901114718174.png)

基于上面的原则，我们一般在插入红黑树节点的时候，会将这个节点设置为红色，原因参照最后一条原则： **红色破坏原则的可能性最小**，如果是黑色, 很可能**导致这条支路的黑色节点比其它支路的要多1**，破坏了平衡。

`RBT`有点属于一种**空间换时间**类型的优化，在`avl`的节点上，增加了 **颜色属性的 数据**，相当于 增加了空间的消耗。 通过颜色属性的增加， 换取，后面平衡操作的次数 减少。

红黑树并不是一颗**AVL平衡二叉搜索树**，从图上可以看到，根节点P的左子树显然比右子树高根据 红黑树的特性`5`，从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点， 说明：

`rbt` 的 左子树和右子树的黑节点的层数是相等的。红黑树的平衡条件，不是以整体的高度来约束的，而是以**黑色节点的高度**，来约束的。所以称红黑树这种平衡为**黑色完美平衡**。

![在这里插入图片描述](./20210410220909965.png)

看看**黑色完美平衡**的效果，去掉 `rbt`中的红色节点，会得到 一个四叉树，从根节点到每一个叶子，高度相同，就是`rbt`的`root`到叶子的黑色路径长度。

![在这里插入图片描述](./41804394324546bebdfe22cd1c7a5bcc.png)

**红黑树的恢复平衡过程的三个操作**

一旦红黑树5个原则有不满足的情况，我们视为平衡被打破，如何恢复平衡。靠它的三种操作：**变色、左旋、右旋**。

- **变色**：节点的颜色由红变黑或由黑变红。

- **左旋**：以某个结点作为支点`(pivot)`，其父节点（子树的`root`）旋转为自己的左子树（左旋），`pivot`的原左子树变成 原`root`节点的 右子树，`pivot`的原右子树保持不变。

![在这里插入图片描述](./ba1adc2895cf4b1aaef2e7088d9f6a69.webp)

![img](./dea622e0576539552458e3afcffb1f59.png)

- **右旋**：以某个结点作为支点(`pivot`)，其父节点（子树的`root`）旋转为自己的右子树（**右旋**），`pivot`的原右子树变成 原`root`节点的 左子树，`pivot`的原左子树保持不变。



![在这里插入图片描述](./96a7aa160f13424abb4acd1ada47edbf.webp)

![在这里插入图片描述](./82f3502b5be24051bd7688b1e0f36135.png)

红黑树的左旋、右旋操作，`AVL`树的左旋，右旋操作 差不多。可以往上翻找`AVL`的构造

**红黑树的节点结构**

默认新插入的节点为红色：因为父节点为黑色的概率较大，插入新节点为红色，可以避免颜色冲突

```c++
// 基础节点模板
template<typename K, typename V>
struct Node {
    int hash;
    K key;
    V val;
    Node* next;

    Node(int hash, K key, V val, Node* next = nullptr)
        : hash(hash), key(key), val(val), next(next) {}
};

// 红黑树节点模板
template<typename K, typename V>
struct TreeNode : public Node<K, V> {
    TreeNode* parent;  // 红黑树的父节点
    TreeNode* left;    // 左子节点
    TreeNode* right;   // 右子节点
    TreeNode* prev;    // 在删除时需要用到，指向前一个节点
    bool red;          // 红黑树标志，true表示红色，false表示黑色

    TreeNode(int hash, K key, V val, Node<K, V>* next = nullptr, TreeNode* parent = nullptr)
        : Node<K, V>(hash, key, val, next), parent(parent), left(nullptr), right(nullptr), prev(nullptr), red(true) {}
};
```

**自平衡构造，下面列举了破坏平衡的事件。**

- **红黑树为空树**

直接把插入结点作为根节点就可以了，根据红黑树性质2：根节点是黑色的。还需要把插入节点设置为黑色。

- **插入节点的`Key`已经存在**

更新当前节点的值，为插入节点的值。

![在这里插入图片描述](./20210412094118977.png)

- **插入节点的父节点为黑色**

由于插入的节点是红色的，当插入节点的父节点是黑色时，不会影响红黑树的平衡。**直接插入无需做自平衡**。

![在这里插入图片描述](./20210412094724987.png)

- **插入节点的父节点为红色**

根据性质2：根节点是黑色。如果插入节点的父节点为红色节点，那么该父节点不可能为根节点，所以插入节点总是存在祖父节点(三代关系)。

根据性质4：每个**红色**节点的两个子节点一定是**黑色**的。不能有**两个红色节点相连**。此时会出现两种状态：

1. 父亲和叔叔为红色
2. 父亲为红色，叔叔为黑色

![在这里插入图片描述](./20210412100154174.png)

- **父亲和叔叔为红色节点**

根据性质4：**红色节点不能相连 ==》祖父节点肯定为黑色节点：**父亲为红色，那么此时该插入子树的红黑树层数的情况是：黑红红。因为不可能同时存在两个相连的红色节点，需要进行 变色， 显然处理方式是把其改为：红黑红。

**变色 处理**：黑红红 ==> 红黑红

1. 将`F`和`V`节点改为黑色
2. 将`P`改为红色
3. 将`P`设置为当前节点，进行后续处理

![在这里插入图片描述](./2021041210371914.png)

可以看到，将P设置为红色了，如果**P的父节点是黑色**，那么无需做处理；但如果P的父节点是红色，则违反红黑树性质了，所以需要将P设置为当前节点，继续插入操作, 作自平衡处理，直到整体平衡为止。

- **叔叔为黑色，父亲为红色，并且插在父亲的左节点**

分为两种情况。`LL` 红色插入，叔叔为黑色，或者不存在（`NIL`）也是黑节点，并且节点的父亲节点是祖父节点的左子节点。

注意：单纯从插入来看，叔叔节点非红即黑(`NIL`节点)，否则破坏了红黑树性质5，此时路径会比其他路径多一个黑色节点。

![在这里插入图片描述](./20210412104637494.png)

- **`LL`型失衡**

新插入节点，为其父节点的左子节点(`LL`红色情况)， 插入后 就是`LL `型失衡

![在这里插入图片描述](./watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhbGxpbmdfc3RhcnNf,size_16,color_FFFFFF,t_70.png)

> 自平衡处理

1. 变颜色：将`F`设置为黑色，将P设置为红色
2. 对`F`节点进行**右旋**

![在这里插入图片描述](./watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhbGxpbmdfc3RhcnNf,size_16,color_FFFFFF,t_70-1728877618405-27.png)

**`LR`型失衡**

细分场景 2： 新插入节点，为其父节点的右子节点(LR红色情况)， 插入后 就是LR 型失衡

![在这里插入图片描述](./20210412153113242.png)

> 自平衡处理：

1. 对`F`进行左旋
2. 将`F`设置为当前节点，得到`LL`红色情况
3. 按照`LL`红色情况处理(1.变色 2.右旋P节点)

![在这里插入图片描述](./20210412153954767.png)

- **叔叔为黑节点，父亲为红色，并且父亲节点是祖父节点的右子节点**

![在这里插入图片描述](./watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0ZhbGxpbmdfc3RhcnNf,size_16,color_FFFFFF,t_70-1728877983326-34.png)

- **`RR`型失衡**

新插入节点，为其父节点的右子节点(RR红色情况)

![在这里插入图片描述](./20210412155529702.png)

> 自平衡处理：

1. 变色：将F设置为黑色，将P设置为红色
2. 对P节点进行**左旋**

![在这里插入图片描述](./20210412160829355.png)

- `RL`型失衡

新插入节点，为其父节点的左子节点(`RL`红色情况)

![在这里插入图片描述](./20210412161045393.png)

> 自平衡处理

1. 对F进行右旋
2. 将F设置为当前节点，得到RR红色情况
3. 按照RR红色情况处理(1.变色 2.左旋 P节点)

![在这里插入图片描述](./20210412161924591.png)

```c++
#include <iostream>

// 定义红黑树节点的颜色
enum Color { RED, BLACK };

// 红黑树节点结构
template<typename K, typename V>
struct TreeNode {
    K key;
    V value;
    Color color;
    TreeNode *left, *right, *parent;

    TreeNode(K key, V value) 
        : key(key), value(value), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}
};

// 红黑树类
template<typename K, typename V>
class RedBlackTree {
private:
    TreeNode<K, V>* root;

    // 左旋操作
    void rotateLeft(TreeNode<K, V>*& root, TreeNode<K, V>*& node) {
        TreeNode<K, V>* rightChild = node->right;
        node->right = rightChild->left;

        if (rightChild->left != nullptr) {
            rightChild->left->parent = node;
        }

        rightChild->parent = node->parent;

        if (node->parent == nullptr) {
            root = rightChild;
        } else if (node == node->parent->left) {
            node->parent->left = rightChild;
        } else {
            node->parent->right = rightChild;
        }

        rightChild->left = node;
        node->parent = rightChild;
    }

    // 右旋操作
    void rotateRight(TreeNode<K, V>*& root, TreeNode<K, V>*& node) {
        TreeNode<K, V>* leftChild = node->left;
        node->left = leftChild->right;

        if (leftChild->right != nullptr) {
            leftChild->right->parent = node;
        }

        leftChild->parent = node->parent;

        if (node->parent == nullptr) {
            root = leftChild;
        } else if (node == node->parent->left) {
            node->parent->left = leftChild;
        } else {
            node->parent->right = leftChild;
        }

        leftChild->right = node;
        node->parent = leftChild;
    }

    // 修复红黑树的性质 - 自平衡功能
    void fixViolation(TreeNode<K, V>*& root, TreeNode<K, V>*& node) {
        TreeNode<K, V>* parent = nullptr;
        TreeNode<K, V>* grandparent = nullptr;

        while ((node != root) && (node->color != BLACK) && (node->parent->color == RED)) {
            parent = node->parent;
            grandparent = parent->parent;

            // 父节点是祖父节点的左子节点
            if (parent == grandparent->left) {
                TreeNode<K, V>* uncle = grandparent->right;

                // 情况1: 叔叔节点是红色
                if (uncle != nullptr && uncle->color == RED) {
                    grandparent->color = RED;
                    parent->color = BLACK;
                    uncle->color = BLACK;
                    node = grandparent;
                } else {
                    // 情况2: 当前节点是父节点的右子节点
                    if (node == parent->right) {
                        rotateLeft(root, parent);
                        node = parent;
                        parent = node->parent;
                    }

                    // 情况3: 当前节点是父节点的左子节点
                    rotateRight(root, grandparent);
                    std::swap(parent->color, grandparent->color);
                    node = parent;
                }
            }
            // 父节点是祖父节点的右子节点
            else {
                TreeNode<K, V>* uncle = grandparent->left;

                // 情况1: 叔叔节点是红色
                if (uncle != nullptr && uncle->color == RED) {
                    grandparent->color = RED;
                    parent->color = BLACK;
                    uncle->color = BLACK;
                    node = grandparent;
                } else {
                    // 情况2: 当前节点是父节点的左子节点
                    if (node == parent->left) {
                        rotateRight(root, parent);
                        node = parent;
                        parent = node->parent;
                    }

                    // 情况3: 当前节点是父节点的右子节点
                    rotateLeft(root, grandparent);
                    std::swap(parent->color, grandparent->color);
                    node = parent;
                }
            }
        }

        root->color = BLACK;
    }

    // 插入一个节点到红黑树中
    TreeNode<K, V>* insertBST(TreeNode<K, V>* root, TreeNode<K, V>* node) {
        if (root == nullptr)
            return node;

        if (node->key < root->key) {
            root->left = insertBST(root->left, node);
            root->left->parent = root;
        } else if (node->key > root->key) {
            root->right = insertBST(root->right, node);
            root->right->parent = root;
        }

        return root;
    }

    // 中序遍历
    void inorderHelper(TreeNode<K, V>* root) {
        if (root == nullptr)
            return;

        inorderHelper(root->left);
        std::cout << root->key << " ";
        inorderHelper(root->right);
    }

public:
    RedBlackTree() : root(nullptr) {}

    // 插入函数
    void insert(const K& key, const V& value) {
        TreeNode<K, V>* node = new TreeNode<K, V>(key, value);

        root = insertBST(root, node);

        fixViolation(root, node);
    }

    // 中序遍历
    void inorder() {
        inorderHelper(root);
    }
};

int main() {
    RedBlackTree<int, std::string> tree;

    tree.insert(10, "A");
    tree.insert(20, "B");
    tree.insert(30, "C");
    tree.insert(15, "D");
    tree.insert(25, "E");
    tree.insert(5, "F");

    std::cout << "Inorder Traversal of Created Tree:\n";
    tree.inorder();

    return 0;
}
```

##### 多叉树

二叉树的操作效率较高，但是也存在问题，如下图所示

![image-20201222211717542](./image-20201222211717542.b4ba77d6.png)

当二叉树的节点较少时，不会出现什么问题。但是当节点过多时（海量，如 1 亿），就会出现如下的问题：

1. 构建二叉树时，需要进行多次 I/O 操作。节点较多时，一般会存储在文件或则数据库中，进行多次 I/O 获取到所有的节点，速度有影响
2. 会造成二叉树的高度很大，降低操作速度

为了解决层数过多的问题，就出现了 **多叉树**。在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点，就是 **多叉树（`multiway tree`）**。

多叉树也有一定的规则的，比如后面讲解的 `2-3` 树、`2-3-4` 树，就是多叉树。**多叉树通过重新组织节点，减少树的高度，对二叉树进行优化。**下图则是一颗 `2-3` 的多叉树：

![image-20201222212402348](./image-20201222212402348.0a394a57.png)

在` 2-3` 树中，节点的子节点数量可能为 2 个或 3 个。具有 2 个子节点的节点只包含 1 个键，而具有 3 个子节点的节点则包含 2 个键。通过动态调整节点的大小和重新组织节点，B 树能够减少树的高度，从而降低 I/O 操作次数，提升访问大规模数据时的效率。

![image-20201222213006536](./image-20201222213006536.6ba634ed.png)

- 一个圆圈表示一个数据项
- 相连的数据项，整个表示一个节点

那么它的优点是什么

- 降低树的高度：可以看到，一个节点中有很多数据项，就能大大减少节点数量，从而**降低树的高度**

- 减少 I/O 读写次数

  文件系统及数据库系统的设计者利用了 **磁盘预读原理**，**将一个节点的大小设为等于一个页（通常大小为 4K）**，这样每个节点只需要一次 I/O 就可以完全载入。

  这样说，你可能没有概念，举个例子：将树的度 M 设置为 `1024` ，在 `600` 亿个元素中最多只需要 `4` 次 `I/O` 操作就可以读取到想要的元素。B 树（B+ ）广泛应用于文件存储系统以及数据库系统中。

> 什么是 **度**
>
> - 节点的度：**一个节点下的子树节点个数就是 节点的度。**
> - 树的度：指一颗树中，节点的度最大的那一个值。
>
> B 树其实就是前面所说的 **多叉树**

##### [B树](https://cloud.tencent.com/developer/article/1691641)

**`2-3 `树**是最简单的 B 树结构，具有如下特点：

1. 所有 **叶子节点** 都在同一层只要是 B 树都满足这个条件，就是满树。
2. 有两个子节点的节点叫 **二节点**，二节点要么 **没有子节点**，要么 **必须有两个子节点**。
3. 有三个子节点的节点叫 **三节点**，三节点要么 **没有子节点**，要么 **必须有三个子节点**。
4. `2-3` 树是由 **二节点** 和 **三节点** 构成的树

 **2-3 树构建图解**

对数列 `{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20}` 构建成一个 `2-3` 树，那么它构建的规则要满足前面说的特点。下面进行图解后，你就明白，上面的特点是如何限制的。

有几个额外的注意事项：

1. **一个节点中，最多只允许放 2 个数据**。
2. **构建的树必须是有序的**，也就是按照二叉排序（`BST`）的要求构建有序的树

**下面是图解步骤：**

- **添加 16、24**

![image-20241014124235167](./image-20241014124235167.png)

添加 `16 `时，没有数据，直接新建一个节点，放进去。添加 `24 `时，发现有一个节点了，并且比` 16 `大，此时该节点中只有一个数据，则将 `24 `放在 `16 `的右边。

- **添加 12**

![image-20201222220054922](./image-20201222220054922.4bb0c572.png)

此时会发现，`12` 比 `16 `小，本来应该放在 `16` 的左边，此时发现这个节点 **已经有两个数据了**，那么就只能放在 **左子节点** 。

如果直接将 `12 `放到 `16,24` 的左节点，就会破坏 `2-3` 树的条件：**一个节点，要么没有子节点，要么有两个**。那么此时就只能将 `16,24` 这个节点进行拆分。如上图：`24 `变成 `16 `的右节点，`12` 变成 `16` 的左节点。这时就满足了 `2-3` 的特性。

- **添加 32**

这个就简单了，以现在的树结构，可以直接添加到 `24` 的 右边，变成 `24,32`

![image-20201222220658607](./image-20201222220658607.7e19b48d.png)

- **添加 14**

这个也简单，直接添加到` 12 `的右边，变成 `12,14`

![image-20201222220819603](./image-20201222220819603.47306946.png)

- **添加 26**

此时应该添加到 `24,32` 的中间(`26介于24 - 32`)，但一个节点只能添加两个数据，那么就**需要拆分**。

![image-20201222221007671](./image-20201222221007671.4cd4fac3.png)

为了满足 B 树特点，发现上层的 `16` 只有一个数，那么就补足它。组成 `16,26`。因为此时 `24,32` **这个节点，不满足 BST 的排序了**，`24` 是小于 `26` 的。只有 `32` 满足。

**拆完上层，再拆本层**：由于 `24` 介于 `16,26` 之间，**则将它安排在 3 节点中的中间节点**，`24,32` 把` 24` 拆分出去了，只剩下 `32`，此时完全满足 `B` 树的特点。

- **添加 34**

此时就简单了，添加到 `32,34` 中

![image-20201222221737672](./image-20201222221737672.96aa55f1.png)

- **添加 10**

此时应该添加到 `12,14` 的左侧。但是不满足条件：一个节点最多只能装 2 个数据。放到 `12,14` 的左节点，也不满足条件：**所有叶子节点必须在同一层**、也不满足` 2-3` 节点的数量要求。

那么此时就**需要拆分**，先拆上层再拆下层。先看他的上层 `16,26` 是满的，看下图：

![image-20201222222211562](./image-20201222222211562.e35fc788.png)

左侧的拆分图，上面我们分析过了，不满足 B 树要求。那么就需要拆分成右图这样：

1. 将 `12,14` 中的` 14 `拆分成右子节点，`10` 挂在 左节点。
2. 此时不满足 B 树要求的，则将 `16,26` 中的 `26` 拆分成 右子节点。因为右侧高度不够，将两个键的节点拆除。增高，达到叶节点同层。
3. `24` 这个节点由于上层被拆分了，不满足在中间节点了。调整它的位置
4. 原来的 `32,34` 节点调整为 `16` 的右节点。

- **添加 8**

此时很简单，组成 `8,10` 即可

![image-20201222223140613](./image-20201222223140613.44b569bb.png)

- **添加 28**

![image-20201222223425500](./image-20201222223425500.4f29c845.png)

这里笔者有点小小的疑问，此时 28 不是应该加在 `26,28` 吗？难道说这里还有一个规则：

1. **只有一个数据的节点**，下面只允许 **最多有 2 个节点，要么没有**
2. **有 2 个数据的节点**，下面只允许 **最多有 3 个节点，要么没有**

- **添加 38**

此时就简单，直接组成 `34,38`

![image-20201222223829797](./image-20201222223829797.1834a017.png)

- **添加 20**

这个也简单，直接组成 `20,24`

![image-20201222223916961](./image-20201222223916961.448151e2.png)

**2-3 树添加规则总结**

1. 所有 **叶子节点** 都在同一层：只要是 B 树都满足这个条件，就是满树。
2. 有两个子节点的节点叫 **二节点**：二节点要么 **没有子节点**，要么 **必须有两个子节点**。
3. 有三个子节点的节点叫 **三节点**：三节点要么 **没有子节点**，要么 **必须有三个子节点**。
4. `2-3` 树是由 **二节点** 和 **三节点** 构成的树
5. 构建的树，要满足二叉排序树（`BST`） 的顺序
6. **一个节点中，最多只允许放 2 个数据**。
7. **只有一个数据的节点**，下面只允许 **最多有 2 个节点，要么没有**
8. **有 2 个数据的节点**，下面只允许 **最多有 3 个节点，要么没有**

-----

**`234` 树**

![image-20201223212903438](./image-20201223212903438.4e8c218e.png)

除了 `2-3` 树，还有 `2-3-4` 树，他的特点是在 `2-3` 树的基础上，还多了一个 4 节点，同样，一个节点最多可以装 3 个数据，要么有 4 个节点，要么没有

**B - 树**

`B-tree` 树即 B 树，B 是 `Balanced` 平衡的意思。

> **TIP**
>
> `B-` 树，这个也是 B 树，只是翻译的文本容易产生误解。

![image-20201223214612995](./image-20201223214612995.cbe59331.png)

上图就是一个 B 树，说明如下：

- B 树的阶：节点的最多 **子节点** 个数：2-3 树的阶是 3，2-3-4 树的阶是 4
- B 树的搜索：从 **根节点开始**，对节点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的 **儿子节点**。然后重复，直到所对应的儿子节点指针为空，或则已经是叶子节点。
- 关键字集合分布在整棵树中：**叶子节点和非叶子节点都存放数据**
- 搜索有可能在非叶子节点结束
- 其搜索性能等价于在关键字全集内做一次二分查找

##### B+树

在 `MySQL` 中，有些索引就是用 B 树或则 B+ 树实现的。B+ 树是 B 树的变体，也是一种多路搜索树。

![image-20201223215140821](./image-20201223215140821.2410bce6.png)

**B+树说明：**

1. B+ 树的搜索与 B 树基本相同，区别是 **B+ 树只有到达叶子节点才命中**（B 树可以在非叶子节点命中），其性能也等价于在关键字全集做一次二分查找

2. 所有 **关键字都出现在叶子节点的链表中**

   即：数据只能在叶子节点，也叫 **稠密索引**，且链表中的关键字（数据）恰好是有序的。

3. 不可能在非叶子节点命中

4. **非叶子节点相当于是叶子节点的索引**，也叫 **稀疏索引**，叶子节点相当于是存储（关键字）数据的数据层

5. 更适合文件索引系统

6. B 树和 B+ 树有各自的应用场景，不能说 B+ 树完全比 B 树好。

B+ 树的这种设计，应该是类似分段思想，比如：`5,28,65`，下面存放三个节点：

- `5-28` 的段，为一个节点
- `28-65` 的段，为一个节点
- `65` 以上的段，为一个节点

比如查询 30 ，直接找到在第二个节点中，然后往下一个目录索引找，就很快能定位到数据。

##### [B*树](https://gitlib.com/pages/4ac13a/#%E6%80%BB%E7%BB%93)

**B* 树是 B+ 树的一种变体。**与 B+ 树不同，B* 树在非根和非叶子节点之间增加了指向兄弟节点的指针，并且在节点即将分裂时优先与兄弟节点共享空间，进一步推迟分裂的发生，从而提高了查找效率和减少树的分裂频率。

![image-20201223220236107](./image-20201223220236107.a72d6e7a.png)

- `B*` 树定义了 **非叶子节点** 关键字个数至少为 `(2/3)*M` ，即块的最低使用率为 `2/3`，而 B+ 树的块的最低使用率为 B+ 树的 `1/2`。**M 是指树的度，也就是层。**
- 从第 1 个特点，可以看出 `B*` 树分配新节点的概率比 B+ 树要低，空间使用率更高。

#### [线索树](https://xiuxin.gitbook.io/datastructre/shu-he-er-cha-shu/xian-suo-er-cha-shu)

遍历二叉树以一定规则将二叉树中的结点排列成一个线性序列，得到二叉树结点的各种遍历序列，其实质是对一个**非线性结构进行线性化操作**，使这个访问序列中的每个结点（第一个和最后一个除外）都有一个直接前驱和直接后继。引入线索二叉树是**为了加快查找结点前驱和后继的速度。**在有`n`的结点的二叉树中，有`n+1`个空指针。

在线索二叉树中，原本为空的指针被重新利用，成为存储遍历过程中的**前驱**或**后继**节点的指针。这些指针相当于给节点添加了一种额外的属性，用于指示在某种遍历顺序（例如中序遍历）下，下一个要访问的节点是什么。**也就是把各种遍历的指针变为这个节点的属性了，费空间省时间。**

**在二叉树线索化时，通常规定：若无左子树，令`lchild`指向其前驱结点；若无右子树，令`rchild`指向后继结点。还需要增加两个标志域表明当前指针域所指对象是指向左（右）子结点还是指向直接前驱（后继）。**

线索二叉树的存储结构描述如下：

```c++
typedef struct ThreadNode{
    ElemType data;
    struct ThreadNode *lchild, *rchild;
    int ltag, rtag;
}ThreadNode,*ThreadTree;
```

以这种结点构成的二叉链表作为二叉树的存储结构，称为**线索链表**，其中指向结点前驱和后继的指针称为**线索**。加上线索的二叉树称为**线索二叉树**。对二叉树以某种次序遍历使其变为线索二叉树的过程称为**线索化**。

对二叉树的线索化，实质上就是遍历一次二叉树，只是在遍历的过程中，检查当前节点的左右指针域是否为空，若为空，将它们改为指向前驱结点或指向后继结点的线索。

**线索化的实质就是将二叉链表中的空指针改为指向前驱或后继的线索。由于前驱和后继信息只有在遍历该二叉树时才能得到，所以，线索化的过程就是在遍历的过程中修改空指针的过程。**

> 以中序遍历对二叉树线索化的递归算法为例：

前驱结点：

1. 若左指针为线索，则其指向结点为前驱结点
2. 若左指针为左孩子，则其左子树的最右侧结点为前驱结点

后继结点：

1. 若右指针为线索，则其指向结点为后继结点
2. 若右指针为右孩子，则其右子树的最左侧结点为后继结点

```c++
void InThread(ThreadTree& p, ThreadTree& pre){//线索二叉树的根结点，指向前驱结点的指针
    if( p != NULL){
        InThread(p->lchild,pre);    //递归，线索化左子树
        if( p->lchild == NULL){        //左子树为空，建立前驱线索
            p->lchild == pre;
            p->ltag = 1;
        }
        if( pre != NULL && pre->rchild == NULL){
            pre->rchild = p;        //建立前驱结点的后继线索
            pre->rtag = 1;
        }
        pre = p;                    //标记当前结点成为刚刚访问过得结点
        InThread( p->rchild, pre);    //递归，线索化右子树
    }    
}
```

建立线索二叉树：

```c++
void CreateInThread(ThreadTree T){
    ThreadTree pre = NULL;
    if( T != NULL ){            //非空二叉树线索化
        InThread(T,pre);        //线索化二叉树
        pre->rchild = NULL;        //处理遍历的最后一个结点
        pre->rtag = 1;
    }    
}
```

有时为了方便，仿照线性表的存储结构，在二叉树的线索链表上也添加一个头结点，并令其`lchild`指针指向二叉树的二叉树的根结点，令 `rchild` 指针指向中序遍历时访问的最后一个结点；令中序遍历的第一个节点的`lchild`指针和最后一个结点的`rchild`指针均指向头结点。这就好比为二叉树建立了一个双向线索链表，既可以从第一个结点顺后继进行遍历，也可以从最后一个结点顺前驱进行遍历。

> 线索二叉树的遍历

不含头结点的线索化二叉树的遍历算法：

1. 求中序线索二叉树中中序序列的第一个结点：

   ```c++
   ThreadNode* FirstNode(ThreadNode* p){
       while( p->ltag == 0){
           p = p->lchild;
       }
       return p;   
   }
   ```

2. 求中序线索二叉树中结点p在中序序列下的后继结点：

   ```c++
   ThreadNode* NextNode(ThreadNode* p){
       if( p->rtag == 0 ){
           return FirstNode(p->rchild);
       }else{
           return p->rchild;
       }
   }
   ```

3. 中序遍历

   ```c++
   void InOrder(ThreadNode* T){
       for( ThreadNode* p = FirstNode(T); p != NULL; p = NextNode(p)){
           visit(p);
       }
   }
   ```

   另外添加的函数：

4. 中序线索二叉树的最后一个结点

   ```c++
   ThreadNode* LastNode(ThreadNode* p){
       while( p->rtag == 0 ){
           p = p->rchild;
       }
       return p;
   }
   ```

5. 求中序线索二叉树中结点p在中序序列下的前驱结点：

   ```c++
   ThreadNode* PreNode(ThreadNode* p){
       if( p->ltag == 0){
           return FirstNode(p->lchild);
       }else{
           return p->lchild;
       }    
   }
   ```

### 图

> **图（Graph）**：由顶点的非空有限集合 V （由 n>0 个顶点组成）与边的集合 E（顶点之间的关系）构成的结构。其形式化定义为 G=(V,E)

- **顶点（Vertex）**：图中的数据元素通常称为顶点，在下面的示意图中我们使用圆圈来表示顶点。
- **边（Edge）**：图中两个数据元素之间的关联关系通常称为边，在下面的示意图中我们使用连接两个顶点之间的线段来表示边。边的形式化定义为：e=⟨u,v⟩，表示从 u 到 v 的一条边，其中 u 称为起始点，v 称为终止点。

![img](./20220307145142-1723797363701-246.png)

- **子图（Sub Graph）**：对于图 G=(V,E) 与 G′=(V′,E′)，如果存在 V′⊆V，E′⊆E，则称图 G′ 是图 G 的一个子图。在下面的示意图中我们给出了一个图 *G* 及其一个子图 *G*′。特别的，根据定义，G 也是其自身的子图。

![img](./20220317163120-1723797363701-249.png)

#### 图的分类

##### 有向图与无向图

按照边是否有方向，我们可以将图分为两种类型：「无向图」和「有向图」。

- **无向图（Undirected Graph）**：如果图中的每条边都没有指向性，则称为无向图。例如朋友关系图、路线图都是无向图。
- **有向图（Directed Graph）**：如果图中的每条边都具有指向性，则称为有向图。例如流程图是有向图。

在无向图中，每条边都是由两个顶点组成的无序对。例如下图左侧中的顶点 v1 和顶点 v2 之间的边记为 (v1,v2) 或 (v2,v1)

在有向图中，有向边也被称为弧，每条弧是由两个顶点组成的有序对，例如下图右侧中从顶点 v1 到顶点 *v*2 的弧，记为 ⟨*v*1,*v*2⟩，v1 被称为弧尾，v2 被称为弧头，如下图所示。

![img](./20220307160017-1723797363701-250.png)

如果无向图中有 n 个顶点，则无向图中最多有 n×(n−1)/2n 条边。而具有 n*×(*n−1)/2 条边的无向图称为 **「完全无向图（Completed Undirected Graph）」**。

如果有向图中有 n 个顶点，则有向图中最多有 n×(n−1) 条弧。而具有 n×(n−1) 条弧的有向图称为 **「完全有向图（Completed Directed Graph）」**。

如下图所示，左侧为包含 4 个顶点的完全无向图，右侧为包含 4 个顶点的完全有向图。

![img](./20220308151436-1723797363701-254.png)

下面介绍一下无向图和有向图中一个重要概念 **「顶点的度」**。

- **顶点的度**：与该顶点 vi 相关联的边的条数，记为 TD(vi)

例如上图左侧的完全无向图中，顶点 v3 的度为 3。

而对于有向图，我们可以将顶点的度分为 **「顶点的出度」** 和 **「顶点的入度」**。

- **顶点的出度**：以该顶点 vi 为出发点的边的条数，记为 OD(vi)。
- **顶点的入度**：以该顶点 vi为终止点的边的条数，记为 ID(vi)。
- 有向图中某顶点的度 = 该顶点的出度 + 该顶点的入度，即 TD(vi)=OD(vi)+ID(vi)。

例如上图右侧的完全有向图中，顶点 v3 的出度为 3，入度为 3，顶点 v3 的度为 3+3=6

##### 环形图和无环图

如果顶点 vi0 可以通过一系列的顶点和边，到达顶点 vim，则称顶点 vi0 和顶点 vim 之间有一条路径，其中经过的顶点序列则称为两个顶点之间的路径。

- **环（Circle）**：如果一条路径的起始点和终止点相同（即 vi0==vim），则称这条路径为「回路」或者「环」。
- **简单路径**：顶点序列中顶点不重复出现的路径称为「简单路径」。

而根据图中是否有环，我们可以将图分为「环形图」和「无环图」。

- **环形图（Circular Graph）**：如果图中存在至少一条环路，则该图称为「环形图」。
- **无环图（Acyclic Graph）**：如果图中不存在环路，则该图称为「无环图」。

特别的，在有向图中，如果不存在环路，则将该图称为「有向无环图（Directed Acyclic Graph）」，缩写为 DAG。因为有向无环图拥有为独特的拓扑结构，经常被用于处理动态规划、导航中寻求最短路径、数据压缩等多种算法场景。

如下图所示，分别为：无向无环图、无向环形图、有向无环图和有向环形图。其中有向环形图中的顶点 v1、v2、v3 与相连的边构成了一个环。

![环形图和无环图](./20220317115641-1723797363701-253.png)

##### 连通图和非连通图

在无向图中，如果从顶点 vi 到顶点 vj 有路径，则称顶点 vi 和 vj 是连通的。

- **连通无向图**：在无向图中，如果图中任意两个顶点之间都是连通的，则称该图为连通无向图。
- **非连通无向图**：在无向图中，如果图中至少存在一对顶点之间不存在任何路径，则该图称为非连通无向图。

如下图所示，左侧图中 v1 与 v2、v3、v4、v5、v6 都是连通的，所以该图为连通无向图。右侧图中 v1 与 v2、v3、v4 都是连通的，但是 v1 和 v5、v6 之间不存在任何路径，则该图为非连通无向图。

![img](./20220317163249-1723797363701-251.png)

下面介绍一下无向图的「连通分量」概念。有些无向图可能不是连通无向图，但是其子图可能是连通的。这些子图称为原图的连通子图。而无向图的一个极大连通子图（不存在包含它的更大的连通子图）则称为该图的「连通分量」。

- **连通子图**：如果无向图的子图是连通无向图，则该子图称为原图的连通子图。
- **连通分量**：无向图中的一个极大连通子图（不存在包含它的更大的连通子图）称为该图的连通分量。
- **极⼤连通⼦图**：无向图中的一个连通子图，并且不存在包含它的更大的连通子图。

例如上图中右侧的非连通无向图，其本身是非连通的。但顶点 v1、v2、v3、v4 与其相连的边构成的子图是连通的，并且不存在包含它的更大的连通子图了，所以该子图是原图的一个连通分量。同理，顶点 v5、v6 与其相连的边构成的子图也是原图的一个连通分量。

##### 强连通有向图和强连通分量

在有向图中，如果从顶点 vi 到 vj 有路径，并且从顶点 vj 到 vi 也有路径，则称顶点 vi 与 vj 是连通的。

- **强连通有向图**：如果图中任意两个顶点 vi 和 vj，从 vi 到 vj 和从 vj 到 vi 都有路径，则称该图为强连通有向图。
- **非强连通有向图**：如果图中至少存在一对顶点之间不存在任何路径，则该图称为非强连通有向图。

如下图所示，左侧图中任意两个顶点之间都有路径，则左侧图为强连通有向图。右侧图中顶点 v7 无法通过路径到达其他顶点，则右侧图为非强连通有向图。

![img](./20220317133500-1723797363701-252.png)

与无向图类似，有向图的一个极大强连通子图称为该图的 **强连通分量**。

- **强连通子图**：如果有向图的子图是连通有向图，则该子图称为原图的强连通子图。
- **强连通分量**：有向图中的一个极⼤强连通⼦图，称为该图的强连通分量。
- **极⼤强连通⼦图**：有向图中的一个强连通子图，并且不存在包含它的更大的强连通子图。

例如上图中，右侧的非强连通有向图，其本身不是强连通的（顶点 v7 无法通过路径到达其他顶点）。但顶点 v1、v2、v3、v4、v5、v6 与其相连的边构成的子图（即上图的左侧图）是强连通的，并且不存在包含它的更大的强连通子图了，所以该子图是原图的一个强连通分量（即上图中的左侧图是右侧图的强连通分量）。同理，顶点 v7 构成的子图也是原图的一个强连通分量。

##### 带权图

有时，图不仅需要表示顶点之间是否存在某种关系，还需要表示这一关系的具体细节。这时候我们需要在边上带一些数据信息，这些数据信息被称为 **权**。在具体应用中，权值可以具有某种具体意义，比如权值可以代表距离、时间以及价格等不同属性。

- **带权图**：如果图的每条边都被赋以⼀个权值，这种图称为带权图。
- **网络**：带权的连通⽆向图称为⽹络。

在下面的示意图中，我们给出了一个带权图的例子。

![img](./20220317135207-1723797363701-255.png)

##### 稠密图和稀疏图

根据图中边的稀疏程度，我们可以将图分为「稠密图」和「稀疏图」。这是一个模糊的概念，目前为止还没有给出一个量化的定义。

- **稠密图（Dense Graph）**：有很多条边或弧（边的条数 e 接近于完全图的边数）的图称为稠密图。
- **稀疏图（Sparse Graph）**：有很少条边或弧（边的条数 e 远小于完全图的边数，如 e*<*n×log2n）的图称为稀疏图。

#### 图的存储方式

图的结构比较复杂，我们需要表示顶点和边。一个图可能有任意多个（有限个）顶点，而且任何两个顶点之间都可能存在边。我们在实现图的存储时，重点需要关注边与顶点之间的关联关系，这是图的存储的关键。

图的存储可以通过「顺序存储结构」和「链式存储结构」来实现。其中顺序存储结构包括邻接矩阵和边集数组。链式存储结构包括邻接表、链式前向星、十字链表和邻接多重表。

接下来我们来介绍几个常用的图的存储结构。在下文中，我们约定用 n 代表顶点数目，m代表边数目，TD(vi) 表示顶点 vi 的度。

##### 领接矩阵

邻接矩阵是使用二维数组来存储图像，每一个位置表示一个坐标，对应坐标中的值表示权。权的意思是从一个节点到另一个节点的距离。如果当前节点没有下一个坐标的话，其权的值标记为无穷大，表示不可达。

在下面的示意图中，左侧是一个无向图，右侧则是该无向图对应的邻接矩阵结构。

![img](./20220317144826-1723797363701-256.png)

邻接矩阵的特点：

- 优点：实现简单，并且可以直接查询顶点 vi与 vj 之间是否有边存在，还可以直接查询边的权值。
- 缺点：初始化效率和遍历效率较低，空间开销大，空间利用率低，并且不能存储重复边，也不便于增删节点。如果当顶点数目过大（比如当 n*>105）时，使用邻接矩阵建立一个 n*×*n* 的二维数组不太现实。所有邻接表只适合用于稠密图

![image-20230305080127311](./image-20230305080127311-1721820002717-12-1723797363701-257.png)

```c++
//领接矩阵声明，开一个二维数组； 
//1.二维数组w[u][v],存储u - v的边权（就是这个连线多长）
//2.只能在稠密图上使用（稠密图 就是边和点不是一个数量级的  点小于边）
//应该是 一个数组存储点 一个数组存储边； 用数组下标表示点和边的关系
#include<iostream>
using namespace std;

int w[N][N]; //声明边权数组 - 例如w[a][b] = c; 说明的就是a连上了b 线的长度 = c
int vis[N];//点集

void dfs(int u){
    vis[u] = true;
    for(int v = 1;v<=n;v++){
        printf("%d,%d,%d\n",u,v,w[u][v]);
        if(vis[u]) continue;
        dfs(v);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b;
        w[a][b] = c; //赋予权值（a点 和 b点）（算是连线）
        //w[b][a] = c;
    }
    //遍历打印
    dfs(1);
    return 0;
}
```

##### 边集数组

**边集数组（Edgeset Array）**：使用一个数组来存储存储顶点之间的邻接关系。数组中每个元素都包含一条边的起点 vi、终点 vj 和边的权值 val（如果是带权图）。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的边集数组结构。

![img](./20220317161454-1723797363701-258.png)

采用边集数组计算节点的度或者查找某条边时，需要遍历整个边集数组，时间复杂度为 O(m)，`m` 是边的数量。**除非特殊必要，很少用使用边集数组来存储图。**

一般来说，边集数组适合那些对边依次进行处理的运算，不适合对顶点的运算和对任何一条边的运算。

![image-20230305080154969](./image-20230305080154969-1721820002716-7-1723797363701-259.png)

声明了一个结构体，存储我们两个节点对应的边。好处就是不用按照数组下标开对应大的数组。声明两个变量存储对应的节点序列，然后声明一个变量存储权即可。

```c++
//边集数组
//结构体下标联系三者
#include<iostream>
using namespace std;
struct edge(){
    int u,v,w; //两点 和 权
}e[M]; //边集合
int vis[N]; //点

//理解每个眼神只有一个值
//bfs负责深度 - for负责宽度
void bfs(int u){
    vis[u] = true;
    for(int i = 1;i<=m;i++){
        int v = e[i].v,w = e[i].w; //用结构体中对应的值
        printf("%d,%d,%d",u,v,w);
        if(vis[v]) continue; //这个点到过了
        dfs(e[i].v);//下一个点
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++)
    {
        cin>>a>>b>>c;
        e[i] = {a,b,c};
        //e[i] = {b,a,c}; //无向图就要加上
    }
    dfs(1);
    return 0;
}
```

##### 领接表

**邻接表（Adjacency List）**：使用顺序存储和链式存储相结合的存储结构来存储图的顶点和边。其数据结构包括两个部分，其中一个部分是数组，主要用来存放顶点的数据信息，另一个部分是链表，用来存放边信息。

![image-20230302110544398](./image-20230302110544398-1721820002716-10-1723797363701-260.png)

在邻接表的存储方法中，对于对图中每个顶点 vi 建立一个线性链表，把所有邻接于 vi 的顶点链接到单链表上。这样对于具有 `n` 个顶点的图而言，其邻接表结构由 `n` 个线性链表组成。

然后我们在每个顶点前边设置一个表头节点，称之为「顶点节点」。每个顶点节点由「顶点域」和「指针域」组成。其中顶点域用于存放某个顶点的数据信息，指针域用于指出该顶点第 `1` 条边所对应的链节点。

为了方便随机访问任意顶点的链表，通常我们会使用一组顺序存储结构（数组）存储所有「顶点节点」部分，顺序存储结构（数组）的下标表示该顶点在图中的位置。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的邻接表结构。

![img](./20220317154531-1723797363701-261.png)

```c++
//领接表（将图用dfs序输出） - 父节点和子节点的连接方式
//出边数组e[u][i] 存储u点的所有出边{终点 v,边权 w}。
#include<iostream>
using namespace std;

struct edga{int v,w;}; //声明结构体（代表每个点有的属性）
vector<edga> e[N];//存储的是每一个起点（有n个）

void dfs(int u,int fa)
{
    for(auto ed:e[u]) //遍历当前层的元素
    {
        int v = ed.v,w = ed.w;
        if(v==fa) continue;//(记录父结点)（u和fa是交替使用的）
        printf("%d，%d,%d\n",u,v,w);
        dfs(v,u);//fa算是根节点的父节点（根节点没有父节点所以就归0就ok了）
    }   
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图 两边都要连接
        //{}结构体的插入方式
        e[a].push_back({b,c});
        e[b].push_back({c,b});
    }
    //1.从哪一个点开始深搜  2.当前节点的父节点
    dfs(1,0);
    return 0;   
    
}
```

##### 链式领接表

![image-20230302111110291](./image-20230302111110291-1721820002716-8-1723797363701-262.png)

`h`数组存储插入数据的编号，在这里也就是输入的`e`这些节点编号。`e`数组存储的是两个不同的节点连接的信息。

```c++
//1.表头数据存储读入数据的顺序，然后给边编号 - 节点的出边的索引
//2.边集数组存储的是边的信息
#include<iostream>
using namespace std;

struct edge{int u,v,w};
vector<edge> e; //边集合（边的属性）
vector<int> h[N]; //点的所有出边

void add(int a,int b,int c)
{
    e.push_back({a,b,c}); // 对应边的属性压入
    h[a].push_back(e.size()-1); //边号
}
//u当前节点 fa-父节点
void dfs(int u,int fa)
{
    for(int i = 0;i<h[u].size();i++){
        int j = h[u][i];//输入点编号顺序 - 表示u连i
        int v = e[j].v,w = e[j].w;
        if(v == fa) continue;
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);
    }
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //邻接表存储数据
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);// 1是当前节点 0是当前节点的父节点（由于根没有父节点，初始化为0）
    return 0;
    
    
}
```

##### 链式前向星

**链式前向星（Linked Forward Star）**：也叫做静态邻接表，实质上就是使用静态链表实现的邻接表。链式前向星将边集数组和邻接表相结合，可以快速访问一个节点所有的邻接点，并且使用很少的额外空间。

> 就是用数组模拟链表来实现邻接表

![img](./20220317161217-1723797363701-263.png)

链式前向星采用了一种静态链表的存储方式，可以说是目前建图和遍历效率最高的存储方式。

链式前向星由两种数据结构组成：

- **特殊的边集数组**：`edges`，其中 `edges[i]` 表示第 `i` 条边。`edges[i].vj` 表示第 `i` 条边的终止点，`edges[i].val` 表示第 `i` 条边的权值，`edges[i].next` 表示与第 `i` 条边同起始点的下一条边的存储位置。
- **头节点数组**：`head`，其中 `head[i]` 存储以顶点 `i` 为起始点的第 `1` 条边在数组 `edges` 中的下标。

链式前向星其实并没有改变边集数组原来的存储数学，只是利用 `head` 数组构成静态链表，建立了顶点 vi 和顶点 vi 所连第 `1` 条边的关系。

在下面的示意图中，左侧是一个有向图，右侧则是该有向图对应的链式前向星结构。

如果需要在该图中遍历顶点 v1 的所有边，则步骤如下：

- 找到以顶点 v1 为起始点的的 `1` 条边在数组 `edges` 中的下标，即 `index = head[1] = 1 `。则在 `edges` 数组中找到与顶点 v1 相连的第 `1` 条边为 `edges[1]`，即 ⟨v1,v5⟩，权值为 6。
- 查找 `index = self.edges[1].next = 0 `，则在 `edges` 数组中找到与顶点 v1 相连的第 `2` 条边 `edges[0]`，即 ⟨v1,v2⟩，权值为 5。
- 继续查找 `index = self.edges[0].next = -1`，则不存在其余边，查找结束。

![image-20230302112003101](./image-20230302112003101-1721820002717-31-1723797363701-264.png)

```c++
#include<iostream>
using namespace std;

struct edge{int v,w,ne;};//ne是链接点的编号 - 例如1-4
edge e[M]; // 存储当前节点的出边
int idx,h[N]; //idx是提供编号的变量，h是每个节点的第一条出边的编号


//获取第一个出边
void add(int a,int b,int c){
    //a第一条出边和b连接 - 这里h[a]表示a的出边
    e[idx] = {b,c,h[a]}; 
    //idx给每一个边都搞一个编号 - 让b和a联系
    h[a] = idx++;
}


void dfs(int u,int fa)
{
    //横向遍历产生分支
    for(int i = h[u];~i;i=e[i].ne){ //~i表示i不等于-1
        int v = e[i].v,w = e[i].w;
        if(v == fa) continue;//判重 产生新分支
        printf("%d,%d,%d\n",u,v,w);
        dfs(v,u);//深入
    }    
}

int main()
{
    cin>>n>>m;
    memset(h,-1,sizeof h);//初始化表头
    for(int i = 1;i<=m;i++){
        cin>>a>>b>>c;
        //无向图构图
        add(a,b,c);
        add(b,a,c);
    }
    dfs(1,0);
    return 0;     
}
```

##### 哈希表

哈希表（字典）可以轻松的实现邻接表。哈希表实现邻接表包含两个哈希表：第一个哈希表主要用来存放顶点的数据信息，哈希表的键是顶点，值是该点所有邻接边构成的另一个哈希表。另一个哈希表用来存放顶点相连的边信息，哈希表的键是边的终点，值是边的权重。

哈希表实现邻接表的时间复杂度：

- 图的初始化和创建操作：O(n+m)
- 查询是否存在 vi 到 vj 的边：O(1)。
- 遍历某个点的所有边：O(TD(vi))
- 遍历整张图：O(n+m)

哈希表实现邻接表的空间复杂度：

- 空间复杂度：O(n+m)

```c++
#include <iostream>
#include <unordered_map>
#include <vector>
using namespace std;

// 顶点信息类
class VertexNode {
public:
    int vi;  // 顶点
    unordered_map<int, int> adj_edges;  // 邻接边和权值
    
    VertexNode(int vi) : vi(vi) {}
};

// 图类
class Graph {
public:
    unordered_map<int, VertexNode*> vertices;  // 顶点集合
    
    // 构造函数
    Graph() {}
    
    // 析构函数，释放动态内存
    ~Graph() {
        for (auto it : vertices) {
            delete it.second;
        }
    }
    
    // 图的创建操作，edges为边信息
    void createGraph(const vector<vector<int>>& edges) {
        for (const auto& edge : edges) {
            int vi = edge[0];
            int vj = edge[1];
            int val = edge[2];
            addEdge(vi, vj, val);
        }
    }
    
    // 向图中添加顶点
    void addVertex(int vi) {
        vertices[vi] = new VertexNode(vi);
    }
    
    // 向图的邻接表中添加边：vi - vj，权值为 val
    void addEdge(int vi, int vj, int val) {
        if (vertices.find(vi) == vertices.end()) {
            addVertex(vi);
        }
        if (vertices.find(vj) == vertices.end()) {
            addVertex(vj);
        }
        vertices[vi]->adj_edges[vj] = val;
    }
    
    // 获取 vi - vj 边的权值
    int getEdge(int vi, int vj) {
        if (vertices.find(vi) != vertices.end() && 
            vertices[vi]->adj_edges.find(vj) != vertices[vi]->adj_edges.end()) {
            return vertices[vi]->adj_edges[vj];
        }
        return -1;  // 如果边不存在，返回 -1
    }
    
    // 根据邻接表打印图的边
    void printGraph() {
        for (const auto& vertex : vertices) {
            int vi = vertex.first;
            for (const auto& edge : vertex.second->adj_edges) {
                int vj = edge.first;
                int val = edge.second;
                cout << vi << " - " << vj << " : " << val << endl;
            }
        }
    }
};

int main() {
    Graph graph;
    vector<vector<int>> edges = {{1, 2, 5}, {1, 5, 6}, {2, 4, 7}, 
                                 {4, 3, 9}, {3, 1, 2}, {5, 6, 8}, {6, 4, 3}};
    graph.createGraph(edges);
    cout << "Edge value between 3 and 4: " << graph.getEdge(3, 4) << endl;
    graph.printGraph();
    
    return 0;
}
```

#### [图的遍历](https://algo.itcharge.cn/08.Graph/02.Graph-Traversal/01.Graph-DFS/#_1-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E7%AE%80%E4%BB%8B)

##### 递归遍历

**深度优先搜索算法（Depth First Search）**：英文缩写为 DFS，是一种用于搜索树或图结构的算法。深度优先搜索算法采用了回溯思想，从起始节点开始，沿着一条路径尽可能深入地访问节点，直到无法继续前进时为止，然后回溯到上一个未访问的节点，继续深入搜索，直到完成整个搜索过程。

深度优先搜索算法中所谓的深度优先，就是说优先沿着一条路径走到底，直到无法继续深入时再回头。在深度优先遍历的过程中，**我们需要将当前遍历节点 u 的相邻节点暂时存储起来，以便于在回退的时候可以继续访问它们。**遍历到的节点顺序符合「后进先出」的特点，这正是「递归」和「堆栈」所遵循的规律，所以深度优先搜索可以通过「递归」或者「堆栈」来实现。

接下来我们以一个无向图为例，介绍一下深度优先搜索的算法步骤。

- 选择起始节点 u，并将其标记为已访问。

  ![深度优先搜索 1](./202309042321406-1723797363701-265.png)

- 检查当前节点是否为目标节点（看具体题目要求）。

  ![深度优先搜索 2](./202309042323911.png)

- 如果当前节点 u 是目标节点，则直接返回结果。

  ![深度优先搜索 3](./202309042324370.png)

- 如果当前节点 u 不是目标节点，则遍历当前节点 u 的所有未访问邻接节点。

  ![深度优先搜索 4](./202309042325587.png)

- 对每个未访问的邻接节点 v，从节点 v 出发继续进行深度优先搜索（递归）。

  ![深度优先搜索 5](./202309042325689-1723797363701-266.png)

- 如果节点 u 没有未访问的相邻节点，回溯到上一个节点，继续搜索其他路径。

  ![深度优先搜索 6](./202309042325770-1723797363701-267.png)

- 重复 2∼6步骤，直到遍历完整个图或找到目标节点为止。

```c++
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

class Solution {
public:
    // 深度优先搜索递归函数
    void dfs_recursive(unordered_map<string, vector<string>>& graph, const string& u, unordered_set<string>& visited) {
        cout << u << endl;             // 访问节点
        visited.insert(u);             // 节点 u 标记其已访问

        for (const string& v : graph[u]) {
            if (visited.find(v) == visited.end()) {  // 节点 v 未访问过
                // 递归遍历节点 v
                dfs_recursive(graph, v, visited);
            }
        }
    }
};

int main() {
    // 构建图
    unordered_map<string, vector<string>> graph = {
        {"A", {"B", "C"}},
        {"B", {"A", "C", "D"}},
        {"C", {"A", "B", "D", "E"}},
        {"D", {"B", "C", "E", "F"}},
        {"E", {"C", "D"}},
        {"F", {"D", "G"}},
        {"G", {}}
    };

    // 创建 Solution 对象并调用深度优先搜索
    unordered_set<string> visited;
    Solution().dfs_recursive(graph, "A", visited);

    return 0;
}
```

##### [层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/solutions/244292/tao-mo-ban-bfs-he-dfs-du-ke-yi-jie-jue-by-fuxuemin/)

**广度优先搜索算法（Breadth First Search）**：英文缩写为 BFS，又译作宽度优先搜索 / 横向优先搜索，是一种用于搜索树或图结构的算法。广度优先搜索算法从起始节点开始，逐层扩展，先访问离起始节点最近的节点，后访问离起始节点稍远的节点。以此类推，直到完成整个搜索过程。

因为遍历到的节点顺序符合「先进先出」的特点，所以广度优先搜索可以通过「队列」来实现。接下来我们以一个无向图为例，介绍一下广度优先搜索的算法步骤。

- 将起始节点 u 放入队列中，并标记为已访问。

![广度优先搜索 1](./20230905152316-1723797363701-269.png)

- 从队列中取出一个节点，访问它并将其所有的未访问**邻接节点 v** 放入队列中。

![广度优先搜索 2](./20230905152327-1723797363701-268.png)

- 标记已访问的节点 v，以避免重复访问。

![广度优先搜索 3](./20231009141628-1723797363701-272.png)

- 重复步骤 2∼3，直到队列为空或找到目标节点。

![广度优先搜索 4](./20230905152401-1723797363701-270.png)

- 访问它并将其所有的未访问**邻接节点 v** 放入队列中。

![广度优先搜索 5](./20230905152420-1723797363701-271.png)

- 结点出队

![广度优先搜索 6](./20230905152433-1723797363701-274.png)

- 结点出队，队列为空算法结束

![广度优先搜索 7](./20230905152445-1723797363701-273.png)

```c++
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

// 定义图的节点数据结构
struct Node {
    int value;  // 节点的值
    vector<Node*> neighbors;  // 相邻节点列表
    bool visited;  // 标记节点是否已经访问过

    Node(int val) : value(val), visited(false) {}
};

// BFS遍历函数
void bfs(Node* start) {
    queue<Node*> q;
    q.push(start);

    while (!q.empty()) {
        Node* cur = q.front();
        q.pop();

        if (!cur->visited) {
            cout << "Visiting node with value: " << cur->value << endl;
            cur->visited = true;

            for (Node* neighbor : cur->neighbors) {
                if (neighbor && !neighbor->visited) {
                    q.push(neighbor);
                }
            }
        }
    }
}

int main() {
    // 创建图节点
    Node* node1 = new Node(1);
    Node* node2 = new Node(2);
    Node* node3 = new Node(3);
    Node* node4 = new Node(4);

    // 建立节点之间的连接关系
    node1->neighbors = {node2, node3};
    node2->neighbors = {node1, node4};
    node3->neighbors = {node1, node4};
    node4->neighbors = {node2, node3};

    // 从起始节点开始BFS遍历
    bfs(node1);

    // 释放节点内存
    delete node1;
    delete node2;
    delete node3;
    delete node4;

    return 0;
}
```

#### [拓扑排序](https://zhuanlan.zhihu.com/p/135094687)*

**拓扑排序（Topological Sorting）**：一种对有向无环图（DAG）的所有顶点进行线性排序的方法，使得图中任意一点 u 和 v，如果存在有向边 <u,v>，则 u 必须在 v 之前出现。对有向图进行拓扑排序产生的线性序列称为满足拓扑次序的序列，简称拓扑排序。

图的拓扑排序是针对有向无环图（DAG）来说的，无向图和有向有环图没有拓扑排序，或者说不存在拓扑排序。

![有向无环图](./202405092308713-1723797363701-276.png)

如上图中的有向无环图（DAG）所示，v1→v2→v3→v4→v5→v6 是该图的一个拓扑序列。与此同时，v1→v2→v3→v4→v6→v5 也是该图的一个拓扑序列。也就是说，对于一个有向无环图来说，拓扑序列可能不止一个。

![image-20230302193314874](./image-20230302193314874-1721820002717-18-1723797363701-275.png)

拓扑排序有两种实现方法，分别是「Kahn 算法」和「DFS 深度优先搜索算法」。接下来我们依次来看下它们是如何实现的。

##### KAHN算法*

**Kahn 算法的基本思想**：

1. **不断找寻有向图中入度为 0 的顶点，将其输出**。
2. 然后删除入度为 0 的顶点和从该顶点出发的有向边。
3. 重复上述操作直到图为空，或者找不到入度为 0 的节点为止。

![image-20230302195721755](./image-1723797363701-278.png)

```c++
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 100005;  // 假设最大顶点数为 100000

vector<int> e[N];   // 邻接表存储图
vector<int> tp;     // 存储最终输出的拓扑序列
int din[N];         // 存储每个顶点的入度
int n, m;           // 顶点数和边数

bool toposort() {
    queue<int> q;

    // 初始化：将所有入度为 0 的顶点加入队列
    for (int i = 1; i <= n; i++) {
        if (din[i] == 0) q.push(i);
    }

    while (!q.empty()) {
        int x = q.front();
        q.pop();  // 从队列中取出队头

        tp.push_back(x);  // 加入拓扑序列

        // 删除以 x 为起点的所有边
        for (int y : e[x]) {
            if (--din[y] == 0) q.push(y);  // 如果 y 的入度为 0，加入队列
        }
    }

    // 如果拓扑序列中的顶点数等于图中的顶点数，则返回 true
    return tp.size() == n;
}

int main() {
    cin >> n >> m;

    // 读取图的边信息
    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
        din[b]++;
    }

    if (!toposort()) {
        puts("-1");  // 如果无法形成拓扑序列，输出 -1
    } else {
        for (int x : tp) printf("%d ", x);  // 输出拓扑序列
        puts("");  // 换行
    }

    return 0;
}

```

##### DFS算法

**基于 DFS 实现拓扑排序算法的基本思想**：

1. 对于一个顶点 u，深度优先遍历从该顶点出发的有向边 <u,v>。如果从该顶点 u 出发的所有相邻顶点 v 都已经搜索完毕，则回溯到顶点 u 时，该顶点 u应该位于其所有相邻顶点 v 的前面（拓扑序列中）。
2. 这样一来，当我们对每个顶点进行深度优先搜索，在回溯到该顶点时将其放入栈中，则最终从栈顶到栈底的序列就是一种拓扑排序。

![image-20230302195739338](./image-20230302195739338-1721820002717-20-1723797363701-277.png)

```c++
#include <iostream>
#include <vector>
#include <algorithm>  // 引入 reverse 函数
#include <cstring>    // 引入 memset 函数，用于初始化数组
using namespace std;

const int N = 100005;  // 假设最大顶点数为 100000

vector<int> e[N];   // 邻接表表示的图
vector<int> tp;     // 存储最终的拓扑序列
int c[N];           // 用于染色的数组（0：未访问，-1：正在访问，1：已访问）
int n, m;           // 顶点数和边数

bool dfs(int x) {
    c[x] = -1;  // 将当前节点标记为正在访问

    for (int y : e[x]) {
        if (c[y] < 0) return false;  // 如果 y 正在访问中，说明存在环
        if (c[y] == 0 && !dfs(y)) return false;  // 如果 y 未访问，则继续 DFS
    }

    c[x] = 1;           // 当前节点访问完成，标记为已访问
    tp.push_back(x);    // 将节点加入拓扑序列
    return true;
}

bool toposort() {
    memset(c, 0, sizeof(c));  // 初始化所有节点为未访问状态

    for (int x = 1; x <= n; x++) {
        if (c[x] == 0) {
            if (!dfs(x)) return false;  // 如果发现有环，返回 false
        }
    }

    reverse(tp.begin(), tp.end());  // 翻转拓扑序列，使其为正确的顺序
    return true;
}

int main() {
    cin >> n >> m;

    for (int i = 0; i < m; i++) {
        int a, b;
        cin >> a >> b;
        e[a].push_back(b);
    }

    if (!toposort()) {
        cout << "-1" << endl;  // 如果存在环，输出 -1
    } else {
        for (int x : tp) cout << x << " ";  // 输出拓扑序列
        cout << endl;
    }

    return 0;
}
```

#### 最短路算法

> 顾名思义，从任意顶点出发到另一顶点的最短距离。也就是权重最小。

**单源最短路径（Single Source Shortest Path）**：对于一个带权图 G=(V,E)，其中每条边的权重是一个实数。另外，给定 v 中的一个顶点，称之为源点。则源点到其他所有各个顶点之间的最短路径长度，称为单源最短路径。

这里的路径长度，指的是路径上各边权之和。单源最短路径问题的核心是找到从源点到其他各个顶点的路径，使得路径上边的权重之和最小。

常见的解决单源最短路径问题的算法包括：

1. **Dijkstra 算法**：一种贪心算法，用于解决无负权边的情况。它逐步扩展当前已知最短路径的范围，选择当前距离起始节点最近的节点，并更新与该节点相邻的节点的距离。
2. **Bellman-Ford 算法**：适用于有负权边的情况。它通过多次迭代来逐步逼近最短路径，每次迭代都尝试通过更新边的权重来缩短路径。
3. **SPFA 算法**：优化的 Bellman-Ford 算法，它在每次迭代中不遍历所有的边，而是选择性地更新与当前节点相关的边，从而提高了算法的效率。

##### Dijkstra

基于贪心思想，也就是每次选择的路径权重是最小的，达成局部最小变为全局最小。

- Dijkstra 算法从指定的节点（源节点）出发，寻找它与图中所有其它节点之间的最短路径。
- Dijkstra 算法会记录当前已知的最短路径，并在寻找到更短的路径时更新。
- 一旦找到源节点与其他节点之间的最短路径，那个节点会被标记为“已访问”并添加到路径中。
- 重复寻找过程，直到图中所有节点都已经添加到路径中。这样，就可以得到从源节点出发访问所有其他节点的最短路径方案。
- Dijkstra 只能用在权重为**正**的图中，因为计算过程中需要将边的权重相加来寻找最短路径。如果图中有负权重的边，这个算法就无法正常工作。就会无限循环。

![image-20230302202401928](./image-20230302202401928-1721820002717-23-1723797363701-280.png)

假设要在这个图中寻找最短路，首先要用一个数据结构记录这个图，这个数据结构被称之为权重数组，这里因为数据量比较少所以用邻接矩阵存储。（就是正常的二维数组）

![image-20240817104040294](./image-20240817104040294.png)

用正常的邻接矩阵存储即可

![image-20240817104006732](./image-20240817104006732.png)

确定的A作为算法的源点，我们就可以通过遍历所有节点的方法更新上面的权重矩阵。

- 从源点出发，标记自身的距离为0

  ![image-20240817104421601](./image-20240817104421601.png)

- 检索源点A的邻居，比较其邻居的最小权值，将信息记录到权重矩阵中。

  ![image-20240817104711825](./image-20240817104711825.png)

- 再通过检索到的节点D，比较其邻居的最小权值，并且将D点的权与E点权相加，将信息记录到权重矩阵中。

  ![image-20240817104958555](./image-20240817104958555.png)

对遍历到的节点重复上述操作，就可以得到一个记录从源节点出发到各个点的最短路经了。

![image-20240817105356106](./image-20240817105356106.png)

> 这个矩阵就是描述上面的图

![image-20240817105415145](./image-20240817105415145.png)

用代码实现，这里采用邻接表存储图像

- `e[u]` 存储图像

- `d[u]`记录边权

- `vis[u] `标记是否访问

```c++
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// 定义边的结构体，包含目标顶点v和边的权重w
struct edge {
    int v, w;
};

vector<edge> e[N]; // 邻接表表示的图，e[i]存储从顶点i出发的所有边
int d[N], vis[N];  // d[i]存储从起点到顶点i的最短路径长度，vis[i]表示顶点i是否已被访问

// Dijkstra算法函数，计算从起点s到其他顶点的最短路径
void dijkstra(int s) {
    // 初始化所有顶点的最短路径长度为无穷大
    for(int i = 0; i < n; i++) d[i] = INT_MAX;
    d[s] = 0; // 起点的最短路径长度为0
    
    // 主循环，遍历图中的所有顶点
    for(int i = 1; i <= n; i++) { // 枚举次数
        int u = 0; // 当前未访问的顶点中距离最小的顶点
        
        // 找到当前未访问且距离最小的顶点u
        for(int j = 1; j <= n; j++) { // 枚举点
            if(!vis[j] && d[j] < d[u]) u = j;
        }
        
        vis[u] = 1; // 标记顶点u已被访问
        
        // 更新与顶点u相邻的顶点的最短路径
        for(auto ed : e[u]) { // 枚举边
            int v = ed.v, w = ed.w; // 获取相邻顶点v及边的权重w
            if(d[v] > d[u] + w) { // 如果从u经过到v的路径更短，则更新d[v]
                d[v] = d[u] + w;
            }            
        }
    }    
}

int main() {
    int n, m, s;
    cin >> n >> m >> s; // 输入顶点数n，边数m，以及起点s
    
    // 输入图的边信息
    for(int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c; // 输入边的起点a，终点b，和权重c
        e[a].push_back({b, c}); // 将边添加到邻接表中
    }
    
    dijkstra(s); // 调用Dijkstra算法，计算从起点s到其他顶点的最短路径
    return 0;
}
```

![image-20230302204110774](./image-20230302204110774-1721820002717-25-1723797363701-282.png)

> 堆优化的时间复杂度为O(logn)，

```c++
#include <iostream>
#include <vector>
#include <queue>
#include <limits.h>

using namespace std;

struct edge {
    int v, w;
}; 

vector<edge> e[N]; // 邻接表存储图，e[i]表示从顶点i出发的所有边
int d[N], vis[N];  // d数组存储从源点到每个点的最短距离，vis数组标记点是否被访问过
priority_queue<pair<int, int>> q; // 大根堆，存储负的距离值以实现优先队列

void dijkstra(int s) {
    for(int i = 0; i <= n; i++) d[i] = inf; // 初始化所有点的距离为无穷大
    d[s] = 0; // 源点s的距离初始化为0
    q.push({0, s}); // 将(0, s)入队，注意距离为负值（大根堆）

    while(!q.empty()) { // 当队列不为空时，继续处理
        auto t = q.top(); // 取出队列中的元素，t为pair(-距离, 顶点)
        q.pop(); // 移除队列中的元素
        int u = t.second; // 当前处理的顶点为u

        if(vis[u]) continue; // 如果顶点u已经被访问过，则跳过
        vis[u] = 1; // 标记顶点u为已访问

        for(auto ed : e[u]) { // 枚举顶点u的所有出边
            int v = ed.v; // 获取当前边的目标顶点v
            int w = ed.w; // 获取当前边的权重w

            // 如果从u到v的路径比当前已知的最短路径更短，则更新d[v]
            if(d[v] > d[u] + w) {
                d[v] = d[u] + w;
                q.push({-d[v], v}); // 将(-d[v], v)入队，使用负值实现大根堆
            }
        }
    }
}

int main() {
    int n, m, s;
    // 输入顶点数n、边数m以及起点s
    cin >> n >> m >> s;
    for(int i = 0; i < m; i++) {
        int a, b, c;
        cin >> a >> b >> c;
        e[a].push_back({b, c}); // 将边(b, c)添加到顶点a的邻接表中
    }

    dijkstra(s); // 调用Dijkstra算法计算从源点到其他顶点的最短路径

    return 0;
}

```

<img src="./image-20240817123229639.png" alt="image-20240817123229639" style="zoom:150%;" />

##### [spfa 算法](https://www.cnblogs.com/shadowland/p/5870640.html)

SPFA(Shortest Path Faster Algorithm)算法是求单源最短路径的一种算法，它是Bellman-ford的队列优化，它是一种十分高效的最短路算法。

很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。SPFA的复杂度大约是O(kE),k是每个点的平均进队次数(一般的，k是一个常数，在稀疏图中小于2)。

但是，SPFA算法稳定性较差，在稠密图中SPFA算法时间复杂度会退化。

实现方法：**建立一个队列**，初始时队列里只有起始点，在建立一个表格记录起始点到所有点的最短路径（该表格的初始值要赋为极大值，该点到他本身的路径赋为0）。**然后执行松弛操作**，用队列里有的点去刷新起始点到所有点的最短路，**如果刷新成功且被刷新点不在队列中则把该点加入到队列最后。**重复执行直到队列为空。

> 这个图用三种颜色标注
>
> - 黄色标注入队的点
> - 绿色表示要出队
> - 红色表示已经出队

此外，SPFA算法还可以判断图中是否有负权环，即一个点入队次数超过N。

![image-20230304212218685](./image-20230304212218685-1721820002717-39-1723797363702-294.png)

- 算法大致流程是用一个队列来进行维护。 初始时将源加入队列。 每次从队列中取出一个元素，并对所有与他相邻的点进行[松弛](http://www.nocow.cn/index.php/松弛)，若某个相邻的点松弛成功，如果该点没有在队列中，则将其入队。 直到队列为空时算法结束。
- 判断有无负环：如果某个点进入队列的**次数超过V次**则存在负环（SPFA无法处理带负环的图）

![image-20230304212738052](./image-20230304212738052-1721820002717-41-1723797363702-296.png)

```c++
//堆优化 bellman 算法 - spfa算法
struct edge{int v,w;};
vector<edge> e[N];//点集合
int d[N],cnt[N],vis[N]; //边 边数 开关
queue<int> q; //队列

bool spfa(int s){
    memset(d,inf,sizeof d);
    //开始起点 1.起点到起点的距离 = 0  2.vis是开关 判断这个数据是否使用过 3.d是边集
    d[s] = 0; vis[s] = 1; q.push(s); 
    while(q.size()){
        //这里是将前面初始化的点操作的地方，每次都只操作一个点
        int u = q.front(); q.pop(); vis[u] = 0;
     for(auto ed:e[u]){
            int v = ed.v , w = ed.w;
            //比较枚举点和当前点 的长度 更新最短值
            if(d[v]>d[u]+w){
                d[v] = d[u]+w;
                cnt[v] = cnt[u]+1; //记录边数
                if(cnt[v]>=n) return true;
                if(!vis[v]) q.push(v),vis[v] = 1;
            }
        }
    }
    return false;
}
```

##### Bellman-Ford

> 处理负权图

**Bellman-Ford算法能在更普遍的情况下（存在负权边）解决单源点最短路径问题。**对于给定的带权（有向或无向）图 G=（V,E），其源点为s，加权函数 w是 边集 E 的映射。对图G运行Bellman-Ford算法的结果是一个布尔值，表明图中是否存在着一个从源点s可达的负权回路。若不存在这样的回路，算法将给出从源点s到 图G的任意顶点v的最短路径d[v]。

**Bellman-Ford**算法流程分为三个阶段：

- 初始化：将除源点外的所有顶点的最短距离估计值 d[v] ←+∞, d[s] ←0;
- 迭代求解：反复对边集E中的每条边进行松弛操作，使得顶点集V中的每个顶点v的最短距离估计值逐步逼近其最短距离；运行`V-1`次
- 检验负权回路：判断边集E中的每一条边的两个端点是否收敛。如果存在未收敛的顶点，则算法返回false，表明问题无解；否则算法返回true，并且从源点可达的顶点v的最短距离保存在 d[v]中。

```c++
G:图G
E(G):边的集合 //用边集数组存储
S: 源顶点
Dis[i]:表示s到i的最短距离,初始为+∞
D[s]=0;
for (int i=0;i<|v|-1;i++)
 for each (u,v)∈E(G)
   if(dis[u]+w(u,v)<dis[v]
       dis[v]=dis[u]+w(u,v);
for each (u,v)∈E(G)
 if(d[v]>d[u]+w(u,v)
   return false;//返回false,说明存在负权回路
return true;
```

初始化，更新源点的距离，为之后松弛其他结点的权做准备。

![img](./v2-3253617aa1280adbe911e9fae4133584_720w-1721820002717-29-1723797363701-286.webp)

迭代到源点连接的点上，将无穷松弛为经过的路径，在连接的节点处更新权值，权值为经过路径值的和。

![img](./v2-b79ce7e33dcee4a3e915bd1d1d2866e7_720w-1721820002717-30-1723797363701-285.webp)

对于迭代到的其他结点，重复上序的操作，重复次数为`|V|-1`；V表示当前图的节点个数

![img](./v2-f407fdcc6ac680d357f535258e3f12d8_720w-1721820002717-32-1723797363701-287.webp)

它的时间复杂度为 `O(VE)`，其中 `V` 是顶点数，`E`是边数。`Bellman-Ford` 算法的基本思想是对所有的边进行 `V-1 `轮松弛操作，以求出所有可能的最短路径。如果在第 `V`轮松弛操作中仍然存在松弛的边，则说明图中存在负权环。

![img](./v2-0b8efc7f4fcf5d767fc7b678c1d08c8c_720w-1721820002717-37-1723797363701-289.webp)

**Bellman－Ford算法实现可以大致分为三个部分** ：

- 第一，初始化所有点。每一个点保存一个值，表示从原点到达这个点的距离，将原点的值设为0，其它的点的值设为无穷大（表示不可达）。 
- 第二，进行循环，循环下标为从1到n－1（n等于图中点的个数）。在循环内部，遍历所有的边，进行松弛计算。 
- 第三，遍历途中所有的边（edge（u，v）），判断是否存在这样情况： d（v） > d (u) + w(u,v) 则返回false，表示途中存在从源点可达的权为负的回路。

![image-20230304210834724](./image-20230304210834724-1721820002717-36-1723797363701-291.png)

```c++
const int INF = 1e9;
const int N = 1005; // 根据你的需求设置节点数量上限

struct edge {
    int v, w;
};

vector<edge> e[N];
int d[N];

bool bellmanFord(int n, int s) {
    fill(d, d + n, INF);
    d[s] = 0;

    for (int i = 0; i < n - 1; i++) { // 最多执行 n-1 轮松弛操作
        bool flag = false;
        for (int u = 1; u <= n; u++) {
            if (d[u] == INF) continue;

            for (auto ed : e[u]) {
                int v = ed.v, w = ed.w;
                if (d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    flag = true;
                }
            }
        }
        if (!flag) break; // 如果本轮没有更新，提前退出
    }

    // 检测是否存在负权环
    for (int u = 1; u <= n; u++) {
        if (d[u] == INF) continue;
        for (auto ed : e[u]) {
            int v = ed.v, w = ed.w;
            if (d[v] > d[u] + w) {
                return true; // 存在负权环
            }
        }
    }

    return false; // 不存在负权环
}
```

##### [Floyd算法](https://houbb.github.io/2020/01/23/data-struct-learn-03-graph-floyd)

Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，我们的目标是寻找从点i到点j的最短路径，在经过过度节点的情况。

从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在）

从任意节点`i`到任意节点`j`的最短路径不外乎2种可能：

- 是直接从`i到j`，

- 是从`i`经过若干个节点`k到j`。

所以，我们假设`Dis(i,j)`为节点`u`到节点`v`的最短路径的距离，对于每一个节点`k`，我们检查`Dis(i,k) + Dis(k,j) < Dis(i,j)`是否成立，如果成立，证明从`i到k`再到`j`的路径比`i`直接到j的路径短，我们便设置**`Dis(i,j) = Dis(i,k) + Dis(k,j)`**，这样一来，当我们遍历完所有节点`k`，`Dis(i,j)`中记录的便是`i到j`的最短路径的距离。

![image-20230307160057133](./image-20230307160057133-1721820002717-42-1723797363702-297.png)

初始化和其他最短路算法是一样的，都是通过坐标定位权关系。`i-j`用`a[i][j]`。`j-i`用`a[j][i]`。

![image-20230307160205801](./image-20230307160205801-1721820002717-43-1723797363702-298.png)

> [萌新版本](https://www.cnblogs.com/wangyuliang/p/9216365.html)

![image-20230307160839691](./image-20230307160839691-1721820002718-44-1723797363702-299.png)

```c++
// 求图中两点的最短路（用的是动态规划） - （我感觉更像塔桥）
// 简单来说 就是两点中，构造一个中间点 k（可能有很多也不一定是中间），不断松弛两点之间的距离（刚开始距离全部点的距离都初始化为无穷）

//原始代码（可以优化） - k层一定是在外面的（这就是被称之为插入法的原因）
void floyd(){
    for(int k;k<=n;k++) //以k为桥(k枚举的是所有点)
        for(int i=1 ;i<=n;i++)
            for(int j = 1;j<=n;j++)
                d[i][j] = mid(d[i][j],d[i][k]+d[k][j]); //二维数组理解为 i - j 和 k - j就好 （k的作用是中间桥连接点 - d[i][j]的作用是存储i - j的距离）
}
```

![image-20230307161152125](./image-20230307161152125-1721820002718-45-1723797363702-300.png)

```c++
#include <iostream>
#include <algorithm> // 引入algorithm库，使用min函数
using namespace std;

const int N = 210; // 定义常量N，表示最大节点数
int n, m, k; // n表示节点数，m表示边数，k表示询问次数
int d[N][N]; // 存储最短路径的二维数组

// Floyd-Warshall算法，用于计算任意两点之间的最短路径
void floyd(){
    for(int k = 1; k <= n; k++) // 枚举中间节点k
        for(int i = 1; i <= n; i++) // 枚举起点i
            for(int j = 1; j <= n; j++) // 枚举终点j
                // 更新i到j的最短路径，如果通过k点可以得到更短的路径
                // k点将会遍历所有的点
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}

int main(){
    cin >> n >> m >> k; // 输入节点数n、边数m和询问次数k
    fill(d[0], d[0] + N*N, 0x3f3f3f3f); 

    // 自己到自己的距离为0
    for(int i = 1; i <= n; i++) d[i][i] = 0;

    // 读取m条边的信息
    while(m--){
        int a, b, c; cin >> a >> b >> c; // 输入边的起点a，终点b，以及权重c
        d[a][b] = min(d[a][b], c); // 更新起点到终点的最短路径，防止重边
    }

    // 运行Floyd-Warshall算法
    floyd();

    // 处理k次查询
    while(k--){
        int a, b; cin >> a >> b; // 输入查询的起点a和终点b
        // 如果d[a][b]超过0x3f3f3f3f的一半，表示两点之间不可达
        if(d[a][b] > 0x3f3f3f3f/2) cout << "impossible" << endl;
        else cout << d[a][b] << endl; // 否则输出最短路径
    }
}
```

<img src="./image-20240817141427254.png" alt="image-20240817141427254" style="zoom:150%;" />

#### 最小生成树*

在了解「最小生成树」之前，我们需要要先理解 「生成树」的概念。

**图的生成树（Spanning Tree）**：如果无向连通图 G 的一个子图是一棵包含图 G 所有顶点的树，则称该子图为 G 的生成树。生成树是连通图的包含图中的所有顶点的极小连通子图。图的生成树不惟一。**从不同的顶点出发进行遍历，可以得到不同的生成树。**

换句话说，生成树是原图 G 的一个子图，它包含了原图 G 的所有顶点，并且通过选择图中一部分边连接这些顶点，使得子图中没有环。

生成树有以下特点：

- **包含所有顶点**：生成树中包含了原图的所有顶点。
- **连通性**：生成树是原图的一个连通子图，意味着任意两个顶点之间都存在一条路径。
- **无环图**：生成树一个无环图。
- **边数最少**：在包含所有顶点的情况下，生成树的边数最少，其边数为顶点数减 1。

![img](./20231211100145-1723797363702-302.png)

**最小生成树（Minimum Spanning Tree）**：无向连通图 G 的所有生成树中，边的权值之和最小的生成树，被称为最小生成树。最小生成树除了包含生成树的特点之外，还具有一个特点。

**边的权值之和最小**：在包含所有顶点的情况下，最小生成树的边的权重之和是所有可能的生成树中最小的。

![img](./20231211101937-1723797363702-303.png)

为了找到无向图的最小生成树，常用的算法有「Prim 算法」和「Kruskal 算法」。

- **Prim 算法**：从一个起始顶点出发，逐步选择与已经构建的树连接的最短边，直到包含所有顶点为止。
- **Kruskal 算法**：基于边的排序和并查集数据结构，逐步添加边，并保证所选边不会构成环路，直到构建出最小生成树。

##### prim算法

**Prim 算法的算法思想**：每次选择最短边来扩展最小生成树，从而保证生成树的总权重最小。算法通过不断扩展小生成树的顶点集合 MST，逐步构建出最小生成树。

![image-20230308192754299](./image-20230308192754299-1721820002718-47-1723797363702-304.png)

Prim算法的基本思路：

- 选择一个起始节点（可以是任意节点），将其加入生成树中，初始化生成树为空。
- 在每一步中，从已经在生成树中的节点集合出发，选择一个距离生成树最近的节点（即与生成树中的某个节点相邻且权重最小的节点），将其加入生成树中。
- 这个过程重复执行，直到生成树包含了图中的所有节点为止。最终生成的树就是最小生成树。

```c++
//基于贪心算法
struct edge{int v,w;};
vector<edge> e[N];
int d[N],vis[N];//d是边的长度 

bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf;
    d[s] = 0;
    for(int i = 1;i<=n;i++){
        int u = 0;
        for(int j = 1;j<=n;j++)
            if(!vis[j]&&d[j]<d[u]) u = j; //排除选过的点 - 这里是选领点的（懂了）
        vis[u] = 1;
        ans+=d[u];//边权和（最小生成树的边权和）
        if(d[u]!=inf) cnt++; //判断是否联通
        //遍历到u这个点（u之前的也是一起的，算是连续的）
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w;   
            }
        }
    }
    return cnt == n; //返回true就是有最小生成树的 返回false
}
```

在Prim算法之上，优化其使用的数据结构，把队列替换为优先队列。就是Heap-Prim算法。

<img src="./image-20240817143213186.png" alt="image-20240817143213186" style="zoom:150%;" />

```c++
//简单来说： 起初所有的点都是在队列中，每次取出一个点，将这个点的路径进行选择，选择路径最小的。 更新，重复知道队列中没有点即可。
int n,m,s,a,b,c,ans,cnt;
struct edge{int v,w;}; //构造一个结构体 内部有点和边的属性
vector<edge> e[N];//领点（也算是所有点？）
int d[N],vis[N];
priority_queue<pair<int,int>> q; //这里创一个优先队列（就是堆）
//s是起点
bool prim(int s){
    for(int i = 0;i<=n;i++) d[i] = inf; //先初始化全部的边 - 每个边都是无穷大
    //起点
    d[s] = 0;q.push({0,s});
    while(q.size()){
        //取出q队列的点？ - 后面有进入点？
        int u = q.top().second; q.pop();
        if(vis[u]) continue; 
        vis[u] = 1;
        ans+=d[u]; cnt++;
        //这里应该就是插入 领点的步骤
        for(auto ed:e[u]){
            int v = ed.v,w = ed.w;
            if(d[v]>w){
                d[v] = w; //对应点v边权最小的边
                q.push({-d[v],v});//大根堆
            }
        }
    }
    return cnt == n; //这里判断的是啥？
}
```

<img src="./image-20240817143228949.png" alt="image-20240817143228949" style="zoom:150%;" />

##### Kruskal算法

**Kruskal 算法的算法思想**：通过依次选择权重最小的边并判断其两个端点是否连接在同一集合中，从而逐步构建最小生成树。这个过程保证了最终生成的树是无环的，并且总权重最小。

- 将图中的所有边按照权重从小到大进行排序。

- 初始化一个空的最小生成树。

- 从权重最小的边开始，依次考虑每条边，如果该边不会导致生成树中出现环路（即加入这条边后，两个节点已经在同一个连通分量中），就将这条边加入生成树中。这里会使用并查集，能够高效合并联通分量。

重复步骤3，直到生成树中包含了图中的所有节点，此时最小生成树构建完成。

<img src="./image-20240817143241729.png" alt="image-20240817143241729" style="zoom:150%;" />

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=100010,M=200010;
int n,m;
//结构体存储边的信息
struct edge{
    int a,b,w;
}e[M];
//比较函数 （用来作为排序算法的参数）
bool cmp(edge x,edge y){
    return x.w<y.w;
}
//并查集
int p[N];
int find(int x){
    if(p[x]!=x) p[x]=find(p[x]);
    return p[x];
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].w);
    //排序边权（我们是用贪心来筛选的）
    sort(e+1,e+m+1,cmp);
    //初始化并查集
    for(int i=1;i<=n;i++) p[i]=i;
    int res=0,cnt=0;
    for(int i=1;i<=m;i++){
        //每一个节点初始都是祖宗节点（用边来合并我们的连通块 最终达到组成树的目的）
        int a=find(e[i].a),b=find(e[i].b),w=e[i].w;
        //查一下是否是连通块
        if(a!=b){
            //纳入后宫
            p[a]=b;
            res+=w;
            cnt++;
        }
        if(cnt==n-1) break;  //成树
    }
    printf("%d\n",res);//输出边权
}
```

> 三种方法比较

<img src="./image-20240817143255848.png" alt="image-20240817143255848" style="zoom:150%;" />

#### 二分图

##### 染色法判断二分图

 二分图是节点由两个集合组成，且两个集合内部没有边的图。

<img src="./image-20240817154204395.png" alt="image-20240817154204395" style="zoom:150%;" />

根据二分图不存在奇环的特性，我们可以使用染色法来判断二分图。因为我们不可能在一部之内走回我们同集合的节点，也就是说，我们的相邻节点一定是不同集合的，所以说我们每遍历一格，就标记不同的颜色，只要相邻的节点颜色相同，那么就说明不是二分图。^ ^

- 选择一个起始节点，将其染成颜色A（可以用0和1表示两种颜色）。

- 从起始节点开始，对于与其相邻的节点，将其染成颜色B。

- 继续递归地对与颜色A节点相邻的节点染成颜色B，与颜色B节点相邻的节点染成颜色A。

- 如果在染色的过程中发现相邻的两个节点已经被染成了相同的颜色，那么图不是二分图。

- 如果成功染色完所有节点而没有发现相邻节点颜色相同的情况，那么图是二分图。

<img src="./image-20240817154234887.png" alt="image-20240817154234887" style="zoom:150%;" />

这里用深度优先遍历来实现判断二分图：

```c++
#include<iostream>
#include<cstdio>
using namespace std;

const int M = 1e5+10;
const int N = 2e5+10;
//父结点 - 当前节点 - 出边
struct edge{int v,ne;}e[M];
//h数组存储的是所有的出边 - a节点索引
int h[N],idx;
int n,m;
int color[N];

void add(int a,int b){
    e[++idx] = {b,h[a]};
    h[a] = idx;
}
//分为两种颜色 - 1 - 2 - 0是未上色
//dfs上色的过程中，也在找
//for是找 - dfs是上色
bool dfs(int u,int c){
    color[u] = c;
    for(int i = h[u];i;i = e[i].ne){
        int v = e[i].v;
        //没有上色 - 就上色
        if(!color[v]) {
            if(dfs(v,3-c)) return true;
        }
        else if(color[v] == c) return true;
    }
    return false;
}

int main()
{
    cin>>n>>m;
    for(int i = 1;i<=m;i++){
  int a,b;
        cin>>a>>b;
        add(a,b);
        add(b,a);
    }
    bool flag = false;
    for(int i = 1;i<=n;i++)
        if(!color[i])
            //dfs找到一处就会返回，对于每个点找一下领结的点就行
            if(dfs(i,1)){
                flag = true;
                break;
            }
    if(flag) puts("No");
    else puts("Yes");
    return 0;
    
    
}
```

<img src="./image-20240817154301771.png" alt="image-20240817154301771" style="zoom:150%;" />

##### 匈牙利算法

<img src="./image-20240817154317723.png" alt="image-20240817154317723" style="zoom:150%;" />

解决二分图最大匹配问题：两个集合连线匹配对数最大

- 选择一个未匹配的左侧节点作为起始点，如果所有左侧节点都已经匹配，则说明找到了一个最大匹配。
- 对于选定的起始点，尝试将其与未匹配的右侧节点进行匹配。如果可以找到一个未匹配的右侧节点与起始点相连接，那么建立这个匹配，否则，尝试改变匹配路径。
- 如果可以改变匹配路径，就寻找一条增广路径（alternating path），这是一条交替经过匹配边和非匹配边的路径，以尽量多地增加匹配数目。增广路径的搜索通常使用深度优先搜索`（DFS）`或广度优先搜索`（BFS）`。
- 如果找到了增广路径，就根据这条路径来改变匹配，然后返回步骤1，继续查找下一个未匹配的左侧节点。
- 如果没有找到增广路径，说明已经找到了最大匹配，算法终止。

因为我们需要让两个集合匹配对数最大，所以说需要在两个集合之间不停连线试错，`dfs`帮助我们提供不同的连线方案，让我们达到匹配数最大。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10,M = 2e5+10;
int n,m,k,a,b,ans,idx;
struct edge{int v,ne;}e[M]; //点（对应位置的妹子） ne 另一集合的点
int h[N],idx;
int vis[N],match[M]; //标记 和 匹配

//链式前向星
void add(int a, int b){
    e[++idx] = {b,h[a]};
    h[a] = idx++; //给边编号
}
//男女匹配问题 (boy and girl）
bool bfs(int u){
    //每一个都要匹配看看
    for(int i = h[u]; i;i = e[i].ne){
        int v = e[i].v; //妹子
        if(vis[v]) continue;
        vis[v] = 1; //标记
        if(!match[v]||dfs(match[v])){ //没有匹配 || dfs遍历判断这个方案能不能成功 - 不能就换一个
            match[v] = u;//成对
            return 1;
        }
    }
    return 0;
}

int main()
{
    cin>>n>>m>>k;
    for(int i = 0;i<k;i++) cin>>a>>b,add(a,b); //建图
    for(int i = 1;i<=n;i++){
        memset(vis,0,sizeof vis);
        if(dfs(i)) ans++;
    }
    cout<<ans;
    return 0; 
    
}

```
