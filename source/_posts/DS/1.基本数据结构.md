---
title: 基本数据结构
date: 2023-04-27 14:48:19
description: 包括线性表，队列，堆栈，还有字符串
typora-root-url: 1.基本数据结构
categories: 算法
tags: 数据结构
---

# 数据结构

## 指针

指针在链表和其他使用地址的复杂数据结构（如树、图）中非常常用。**指针的主要作用是存储和访问内存地址**，使程序能够动态地管理数据结构中的元素。关键点在于理解指针的声明和使用是两个独立的概念。同时用于遍历数据结构的指针，也需要**和对应数据结构的类型相同**。就像是量我们的铅笔，我们需要用厘米尺而不是分米尺。

1. **指针的声明**：指针的声明告诉编译器变量是一个指针类型，并指定它将指向的内容类型。这一步只是定义了指针，而没有赋予它实际的地址。
2. **指针的使用**：指针使用的过程中包括为指针分配内存地址和通过指针访问或修改该地址处的数据。指针操作需要小心，因为不正确的操作可能导致内存泄漏或访问非法内存。

```c++
//1.在声明的时候表示声明了一个指针变量
int *p
    
//2.在使用的时候，表示value内存地址的值
int value = *p;
```

在解题和使用数据结构时，经常会看到`->`符号。这个符号实际上是一个复合符号，称为"成员对象访问操作符"。它的作用是通过指针访问结构体或类的成员。

实际上，`->`是对`(*p).`的简化表达。`(*p).`先解引用指针`p`（即获取`p`指向的对象），然后访问该对象的成员。而`->`操作符将这两个步骤合并成一个更直观、更简洁的操作，使代码更易读。也就是说，假设有一个结构体的数据`data`，**被我们指向了，那么就是调用这个结构体指定位置的数据。**

```c++
#include <stdio.h>

struct Point {
    int x;
    int y;
};

int main() {
    struct Point p = {1, 2};
    struct Point *ptr = &p;

    // 使用 `->` 访问结构体成员
    printf("x: %d, y: %d\n", ptr->x, ptr->y);
    return 0;
}
```

**在链表中，当看到`p->next =`这样的代码时，可以直观地理解为“当前`p`指针所指节点的下一个节点是什么。”类似地，`p->prior`这样的代码可以理解为“`p`指针所指节点的上一个节点是什么。”**

具体指定的变量要看指定数据结构的定义。

## 线性表

线性表是具有相同数据类型的数据元素构成的有限序列，如果用`n`表示表长，则`n=0`的时候线性表是一个空表。线性表最主要的特点如下：

- 除了第一个元素，每一个元素都由其直接前驱
- 除了最后一个元素，每个元素都有直接后继
- 由于存储的数据类型都相同，所以说每一个数据元素占据的内存区域大小是一致的
- 逻辑结构决定的线性表数据元素之间的关系，物理结构决定线性表使用内存的能力

常见的线性表有：数组、单链表、双链表、循环链表等等。以上的线性表的差别可能要从逻辑结构和物理结构来讨论

### [单链表](https://blog.51cto.com/u_15018701/2616916)

**链表是一种常见且基础的数据结构，是一种线性表，但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址。**也可以这样理解，链表是通过指针串联在一起的线性结构，每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向`null`。也就是我们所说的空指针。

链表和数组不同的在于他们的索引，数组所用的索引是数组下标，而链表的索引是他们下一个数据的位置。每一个位置存储当前的值和下一个位置的地址。

实际上，数组和链表都使用索引来访问元素，但在物理存储方面有很大不同。数组在内存中分配一块连续的空间存储数据，**因此元素之间的距离很小**，可以直接通过开头位置的索引计算下一个元素的位置，无需使用指针。**而链表的元素在内存中分布是离散的**，难以计算下一个元素的位置，所以说需要使用指针。每个节点通过指针连接到下一个节点，因此需要指针来找到和链接每个数据元素。

![链表看这一篇真的就够了！](./resize,m_fixed,w_1184-1693299787406-13-1723804032864-1.webp)

一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。我们通过上面说到的可视化表示方法，将单链表可视化，如图所示：

![链表看这一篇真的就够了！](./resize,m_fixed,w_1184-1723804032865-2.webp)

**链表头部插入**

**头指针**是链表结构中的一个关键元素，位于链表的头部。引入头指针有以下两个主要优点：

- 头指针存储链表第一个节点的地址，使得我们能够始终找到链表的起点。这是操作链表的基础，无论是遍历、插入、删除等操作，都需要**从头指针开始**。

- 头指针的引入简化了链表操作逻辑。**无论链表是空的还是非空的，头指针始终存在。**对于空表，头指针指向`null`；对于非空表，头指针指向第一个节点。这种设计使得链表的操作更加一致和简洁。例如，**在插入节点时**，无需特别检查链表是否为空，因为操作总是从头指针开始。

**链表头部插入元素**：在链表第` 1 `个链节点之前插入值为` val` 的链节点。

1. 先创建一个值为 `val` 的链节点` node`
2. 然后将 `node` 的 `next` 指针指向链表的头节点 `head`。
3. 再将链表的头节点 `head` 指向 `node`。

**头结点是标注链表中的第一个位置！！！！！头结点只是一个指针变量，把它理解为遍历的起点**

![链表头部插入元素](./202405092231514.png)

```c++
struct Node{
	int data;
    Node* next; //结构体定义指针
}

// 实现单链表
Node* head;
head = null;

// 插入
void insert(int value)
{
    //申请新节点
	Node* newNode = new Node(value);
    newNode->next = head;
	// 更新头指针
    head = newNode; //函数名称表示链表中的第一个节点
}
```

**链表尾部插入元素**：在链表最后 `1 `个链节点之后插入值为` val `的链节点。

1. 先创建一个值为 `val` 的链节点 `node`。
2. 使用指针 `cur `指向链表的头节点` head`
3. 通过链节点的 `next` 指针移动 `cur` 指针，从而遍历链表，直到 `cur.next `为` None`。
4. 令 `cur.next` 指向将新的链节点` node`。这里的尾指针始终指向我们的最后一个结点。

![链表尾部插入元素](./202405092232023.png)

```c++
// 用尾指针维护链表
struct Node{
	int a; //数据域
    Node* next; //指针域
}

Node* tail; //尾指针维护

void insert(int value){
    // 创建节点
	Node* newNode = new Node(value);
    
    // 如果链表是空的,尾指针指向最后一个元素
	if(tail == nullptr){
		tail = newNode;
    }else{
        // 将新节点添加到尾部
        tail ->next = newNode;
        // 更新指向尾部
        tail = newNode;
    }

}
```

#### 插入操作

**链表中间插入元素**：在链表第 `i `个链节点之前插入值为 `val `的链节点。

1. 使用指针变量 `cur `和一个计数器 `count`。令 `cur`指向链表的头节点，`count` 初始值赋值为 `0`。
2. 沿着链节点的 next 指针遍历链表，指针变量 cur 每指向一个链节点，计数器就做一次计数。
3. 当遍历到` index-1` 个链节点时停止遍历。
4. 创建一个值为 `val `的链节点` node`。
5. **将 `node.next `指向 `cur.next`。**
6. **然后令` cur.next` 指向 `node`。**

![链表中间插入元素](./202405092232900.png)

```c++
struct Node{
	int value;
    Node* next; // 指针域
}

// 插入到指定的位置
void insert(int index,int value){
    if(index<0) return 0; // 数据不合法
    
    // 找到这个index前面, 先创建一个节点
    Node newNode = new Node(value);
    Node *cur = head;
    int count = 0;
    while (cur && count < index-1){
        count++;
        cur = cur->next;        
    }    
    // 这两条代码不能交换次序
    cur->next = newNode;
    newNode->next = cur->next; //这里的cur已经赋值了 
    
}
```

#### 改变元素

将链表中第` i `个元素值改为 `val` ：首先要先遍历到第 `i` 个链节点，然后直接更改第 `i` 个链节点的元素值。具体做法如下：

1. 使用指针变量` cur ` 和一个计数器` count`。令 `cur `指向链表的头节点，`count`初始值赋值为 0。
2. 沿着链节点的 `next `指针遍历链表，指针变量 `cur `每指向一个链节点，计数器就做一次计数。
3. 当遍历到第 `index `个链节点时停止遍历。
4. 直接更改 `cur` 的值 `val`。

```c++
// 更改指定位置的数据
void change(int index,int value)
{
    // 声明一个指针变量，获取头结点
    Noed* cur = head;
    int count = 0;
    
    // 遍历链表
    while(cur!=nullptr && count<index)
    {
        cur = cur->next;
        cur++;
    }    
    // 更新数据
    if(cur!=nullptr) cur->data = value;     
}
```

#### 删除操作

链表最大的优点在于可以灵活的添加和删除元素。

- 链表进行访问元素、改变元素操作的时间复杂度为 O(n)。
- 链表进行头部插入、头部删除元素操作的时间复杂度是 O(1)。
- 链表进行尾部插入、尾部删除操作的时间复杂度是 O(n)。
- 链表在普通情况下进行插入、删除元素操作的时间复杂度为 O(n)。

链表的删除元素操作与链表的查找元素操作一样，同样分为三种情况：

- **链表头部删除元素**：删除链表的第 1 个链节点。
- **链表尾部删除元素**：删除链表末尾最后 1 个链节点。
- **链表中间删除元素**：删除链表第` i `个链节点。

接下来我们分别讲解一下。

> **链表头部删除元素**：删除链表的第 `1` 个链节点。
>
> 直接将 `self.head` 沿着 `next` 指针向右移动一步即可。

![链表头部删除元素](./202405092231281.png)

```c++
// 删除头结点的元素
void removeFront()
{
    if(head){
	    Node* temp = head;
        head->next = head;
        free(temp); // 解放数据
    }
}
```

> **链表尾部删除元素**：删除链表末尾最后 1 个链节点。
>
> - 先使用指针变量 `cur` 沿着 next 指针移动到倒数第` 2` 个链节点。
>- 然后将此节点的 `next` 指针指向 `null` 即可。
> - 「链表尾部删除元素」的操作涉及到移动到链表尾部，操作次数为` n−2`次，因此，「链表尾部删除元素」的时间复杂度为` O(n)`。
>

![链表尾部删除元素](./202405092232050.png)

```c++
// 删除链表尾部的数据
void removeRear()
{
	// 1.链表中没有数据的情况
    	if(head == nullptr && head->next == nullptr){
			// 链表为空或者只有一个节点
            if(head!=nullptr)
            {
			   Node* temp = head;
                head = nullptr;
                free(temp);                
            }
            return;
        }
	// 2. 链表中有数据的情况
    	Node* cur = head; // 遍历的变量
    	while(cur->next->next != nullptr) //遍历到前一个节点
        {
            cur = cur->next;            
        }
    	Node* temp = cur->next;
    	cur->next = nullptr;
    	free(temp);  

}
```

> **链表中间删除指定节点**：删除链表第 i 个链节点。
>
> 1. 先使用指针变量` cur` 移动到第 `i−1`个位置的链节点。
> 2. 然后将 `cur` 的 `next` 指针，指向要第 `i `个元素的下一个节点即可。

![链表中间删除元素](./202405092233332.png)

```c++
// 删除中间段落的节点
void removeInside(int value,int index)
{
    //1.合法
    if(index<0) return 0;
    if(index == 0) 
    {
        // 只有一个节点或者为空
        if(head){
            Node* temp = head;
            head = head->next;
            free(temp);            
        }
    }
    // 2.删除中间段落的节点
    Node* cur = head;
    int count = 0;
    
    while(count<index-1 && cur)
    {
        cur = cur->next;
        count ++;
    }
    
    Node* deNode = cur->next; // 存储这个位置方便等等用free
    cur->next = deNode->next;
    free(deNode);  

}
```

总结，通过遍历到链表的目的位置的前一个，来进行删除链和接上链，链表的特殊逻辑结构导致了查找对应位置的数据时间复杂度特别大，主要花费时间在查找和遍历上。但是单纯用头插法和尾插法，还有删除操作效率特别快，而且插入数据是动态更新的。

### 双链表

在单链表的基础上，加一个指向后继的指针。

- 每个节点需要存储两个指针（`next`和`prev`），因此在存储相同数量的元素时，双向链表比单向链表消耗更多的内存。
- 在双向链表中，在任意位置插入或者删除节点时，可以直接调整相邻节点的`next`和`prev`指针，无需访问链表的头部。这使得插入操作更为简便。

![image.png](./7c0d280244b244ae9d46d3e9843c9b1dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1723804032865-5.webp)

依据上图，可以简单得出双链表的节点定义

```c++
// 当然还是可以用头指针来标识这个链表的第一个数据
struct Node()
{
    int left;
    int right;
    int data;
}
```

#### 插入操作

插入操作根据插入的位置不同他们的时间复杂度不同

> 在头部插入节点：
>
> - 创建一个新节点 `new_node`。
> - 设置 `new_node.next` 为当前的头节点 `head`。
> - 如果**头节点** `head` 不为 `None`，将 `head.prev` 设置为 `new_node`。
>
> - 将 `new_node.prev` 设置为 `None`。
>- 更新链表的头节点为 `new_node`。

```c++
// 头插法更新双链表
struct Node{
    Node* left; // 指针变量
    Node* right;
    int value;
 	Node(int val):value(val),left(nullptr),right(nullptr);
}
// 1. 用头指针维护 一开始为空
	Node* head = nullptr ;
void insert(int value)
{  
    // 2.创建链表节点
	Node newNode = new Node(value); 
    
    newNode->right = head;
    // 3.如果链表不为空，更新头节点的左指针指向新节点
    if(head!=nullptr)
    {
        head->left = newNode;
    }
    // head永远指向头结点
    head = newNode;   
    
}
```

> 在指定位置插入节点：
>
> - 创建一个新节点 `new_node`。
> - 设置 `new_node.next` 为 `node.next`。
> - 如果 `node.next` 不为 `None`，将 `node.next.prev` 设置为 `new_node`。
> - 设置 `new_node.prev` 为 `node`。
> - 设置 `node.next` 为 `new_node`。

![image-20240724220805198](./image-20240724220805198-1723804032865-6-1723911810219-15.png)

与单链表相比，双链表的操作需要控制四个指针，具体操作如下。

```c++
// 指定位置插入数据
struct Node{
    Node* prev;
    Node* next;
    int value;
    Node(int val): value(val),left(nullptr),right(nullptr);
}

// 定义的头结点，用于找到这个首位置，那我们默认知道
Node* head = 

// 双链表插入操作,链表结构在上面
void insert(int index,int value)
{
    // 1.准备
    Node* cur = head;
    int count = 0; //计数
    // 前一个位置，这个遍历过程应该是用不到这个prev
    while(cur && count<index-1)
    {
        cur = cur->next;
        count++;
    }
    
    Node newNode = new Node(value);
    //2. 要更新四条链子
    newNode->prev = cur;
    newNode->next = cur->next;
    // 这里newNode还没有安上来
    cur->next->prev = newNode;
    cur->next = newNode;
    
}
```

#### 删除操作

如果是用数组模拟的双链表，删除只是把数据从数组中`隐去`而已，这里还是按照用链表实现的方法。通常链表会有一个指针域和一个数据域。我们需要在解除掉q指针之前交换所有的数据信息。

![image-20240728211551398](./image-20240728211551398-1723804032865-7.png)

```c++
// 1.准备
int count = 0; //用于遍历
Node* cur = head;
// 节点就用上面的
void delete(int index)
{
    // 2. 找到删除点的前一个位置
    while(cur&&count<index -1)
    {
        cur = cur->next;
        count++;        
    }
    // 3.承接删除的节点
    Node* temp = cur->next;
    //4. 断链，用两条覆盖
    cur->next = cur->next->next;
    cur->next->prev = cur
    
    free(temp);
}
```

### [静态链表](https://heptaluan.github.io/2020/02/05/Essay/08/)*

数组来代替指针用来描述单链表，这种用数组来描述的链表就叫做『静态链表』，这种描述的方法叫做『游标实现法』，如下图所示

![img](./08-01.png)

对应的线性表的静态链表存储结构代码如下

```c++
#define MAXSIZE 1000

typedef struct {
  ElemType data;  // 数据
  int cur;        // 游标
} Component, StaticLinkList[MAXSIZE];
```

对静态链表进行初始化相当于初始化数组

```c++
Status InitList(StaticLinkList space) {
  int i;
  for(i = 0; i < MAXSIZE - 1; i++)
    space[i].cur = i + 1; // 游标指向的是下一个的位置
  space [MAXSIZE - 1].cur = 0; // 头结点
  return OK;
}
```

下面是一些需要注意的地方

- 一般对数组的第一个和最后一个元素做特殊处理，他们的 `data` 不存放数据
- 通常把未使用的**数组元素称为备用链表**
- 数组的第一个元素，即下标为 `0` 的那个元素的 `cur` 就存放备用链表的第一个结点的下标
- 数组的最后一个元素，即下标为 `MAXSIZE - 1` 的 `cur` 则存放第一个有数值的元素的下标，相当于**单链表中的头结点作用**

在静态链表中，我们主要解决的就是如何**模拟动态链表结构的存储空间分配**，也就是需要的时候申请，不需要的时候释放，在之前，我们提到过，为了辨明数组中哪些分量未被使用，解决的方法是将所有未被使用过的及已被删除的分量用游标链成一个备用的链表，每当进行插入时， 便可以从备用链表上取得第一个结点作为待插入的新结点，我们以上面第示例来进行说明，比如我们要在 `A` 的后面插入 `B`，如下图

![img](./08-02.png)

我们要做的首先是获得空闲分量的下标

```c++
int Malloc_SLL(StaticLinkList space) {
  int i = space[0].cur;
  if(space[0].cur) {
    space[0].cur = space[i].cur;  // 把它的下一个分量用来作为备用
    return i;
  }
}

/* 在静态链表 L 中第 i 个元素之前插入新第数据元素 */
Status ListInsert(StaticLinkList L, int i, ElemType e) {

  int j, k, l;
  k = MAXSIZE - 1;  // 数组第最后一个元素

  if (i < 1 || i > ListLength(L) + 1) {
    return ERROR;
  }
  
  j = Malloc_SLL(L);

  if (j) {
    L[j].data = e;
    for(l = 1; l <= i - 1; l++) {
      k = L[k].cur;
    }
    L[j].cur = L[k].cur;
    L[k],cur = j
    return OK;
  }
  return ERROR;
}
```

![img](./08-03.png)

接下来完成删除操作以上面的示例为例，这次我们来删掉 `C` 元素

```c++
/* 删除在 L 中的第 i 个数据元素 */
Status ListDelete(StaticLinkList L, int i) {
  int j, k;

  if(i < 1 || i > ListLength(L)) {
    return ERROR;
  }

  k = MAXSIZE - 1;

  for(j = 1; j <= i - 1; j++) {
    k = L[k].cur;
  }

  j = L[k].cur;
  L[k].cur = L[j].cur;

  Free_SLL(L, j) ;
  return OK;
}

/* 将下标为 k 的空闲结点回收到备用链表 */
void Free_SLL(StaticLinklist space, int k) {
  space[k].cur = space[0].cur;
  space[0].cur = k;
}

/* 返回 L 中数据元素个数 */
int ListLength(StaticLinkList L) {
  int j = 0;
  int i = L[MAXSIZE - 1].cur;

  while (i) {
    i = L[i].cur;
    j++;
  }

  return j;
}
```

结果如下

![img](./08-04.png)

静态链表的优点是在插入和删除操作时，**只需要修改游标，不需要移动元素**，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点，而缺点也比较明显，没有解决连续存储分配（数组）带来的**表长难以确定的问题**，**失去了顺序存储结构随机存取的特性，即不能直接使用下标来找到指定的值了**，因为它某些程度上来说，已经具备了一些单链表的特性了

### [循环链表](https://www.dotcpp.com/course/100)*

> 循环链表一般使用尾插法实现

循环链表和非循环链表其实创建的过程以及思路几乎完全一样，唯一不同的是，非循环链表的尾结点指向空（`NULL`），而**循环链表的尾指针指向的是链表的开头**。通过将单链表的尾结点指向头结点的链表称之为循环单链表（`Circular linkedlist`），如图，为一个完整的循环单链表，**最后一个位置的`next`为头指针**

![循环链表](./1562924138210258-1723804032865-8.png)

#### [循环单链表](https://zhuanlan.zhihu.com/p/107808443)

对于循环单链表的结点，可以完全参照于单链表的结点设计，如图：

![单向循环链表结点](./1562924163903311-1723804032865-10.png)

`data`表示数据，其可以是简单的类型，`next`表示指针，它永远指向自身的下一个结点，对于只有一个结点的存在，在循环单链表中`next`指针则永远指向自身，对于循环单链表的尾部结点，`next`永远指向开头。

```c++
struct list{
    int data; //当前位置的值
    struct list* next; //下一个位置的地址
}list;
```

![循环单链表](./%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8-1723804032865-9.png)

在单链表的基础上，循环单链表的最后一个节点的 `next` 指向链表的第一个节点，形成一个环。无论链表中有多少个节点，最后一个节点都会链接到第一个节点。

```c++
// 节点定义
struct Node{
    int data; // 数据域
    Node* next;    
}
```

初始化构造这个循环链表

```c++
// 初始化一个循环链表
struct Node* init()
{
    struct Node* head = malloc(sizeof(struct Node));
    head->data = 0;
    head->next = head;
    return head;
}
```

如果在循环单链表中设的是头指针，那么在**尾部插入**元素需要`O(n)`的时间复杂度，如果设置尾指针，那么插入只需要O(1)。我们可以通过逐步的插入操作，创建一个新的节点，将原有链表尾结点的next指针修改指向到新的结点，新的结点的next指针再重新指向头部结点，然后逐步进行这样的插入操作，最终完成整个单项循环链表的创建。

![循环链表的创建](./1562924267248299-1723804032865-11.png)

这里用尾插法实现循环链表，**将数据从右向左插入链表中**。使用尾插法的原因是，方便将最后一个节点的`next`指针指向头部位置。 

```c++
//定义节点结构
struct Node{
    int data;
    struct Node* next;
}

//初始化构造循环链表
struct Node* init()
{
	return null;	 // 尾指针为空
}

void insertAtTail(struct Node** tail,int value)
{
    // 1.创建新节点
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = value;
    
    //2.判别链表为空
    if(*tail == null){
        // 尾结点指向头结点
		newNode->next = newNode;
        // 尾指针只指向尾部
        *tail = newNode;
    }else{
        //3.如果不为空,指向头结点
		newNode->next = (*tail)->next;
        // 尾指针更新为新的尾部
        (*tail)->next = newNode;
        // 更新尾指针
        *tail = newNode;
    }   
    
}

// 打印循环单链表
void display(struct Node* tail)
{
    if(tail == null){
        return 0;
    }
    // 1. 遍历链表，这里是用尾指针构造头指针，标志第一个位置
    struct Node* temp = tail->next;
    do{
        printf("%d",temp->data);
        temp = temp->next;
    }while(temp!=tail->next); //循环直到回到头结点,表示遍历结束
    
    printf("\n");
}
```

#### [循环双链表](https://blog.csdn.net/sum_TW/article/details/61624039?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8%3D)

循环双向链表是一种更复杂的数据结构类型，它的节点包含指向其前一节点以及下一节点的指针。 循环双向链表在任何节点中都不包含`NULL`。 链表的最后一个节点包含列表的第一个节点的地址。 链表的第一个节点还包含的前一个指针是指向最后一个节点的地址。 

![img](./Center-1723804032865-12.png)

这里是使用尾插法构造循环双链表，和前面循环单链表一样，使用尾插法是更好维护链表。

```c++
// 定义节点
struct Node{
    struct *Node next;
    struct *Node prev;
    int value;
    Node(int val): value(val),next(nullptr),prev(nullptr){}
};
// 初始化
struct Cycle{
    Node* head; // 头指针
    Node* tail; // 尾指针
    
    // 构造函数，初始化为空表
    Cycle():head(nullptr),tail(nullptr){}
};

// 尾插法
void append(int value)
{
    // 1. 先建立节点
    Node* newNode = new Node(value);
    // 2.head不为空
    if(!head){
        // 初始化
        head = newNode;
        tail = newNode;
        // 3. 构造循环
        head->next = head; 
        head->prev = head;        
    }else{
        // 4.链表不为空时,由于是双链表所以说要更新四条链
        newNode->prev = tail;
        newNode->next = head;
		// 这里的tail还是原来的链表的尾部，之后需要更新
        tail->next = newNode;
        head->prev = newNode;
        // 更新tail
        tail = newNode;
    }
    
}
```

> 插入操作

在循环双链表中，插入操作可以分为几种情况：在链表为空时插入、在链表头部插入、在链表尾部插入、以及在链表中间插入。如果链表为空，则插入的节点将成为链表的唯一节点，同时也是头节点和尾节点。

```c++
// 链表为空插入
void insertEmptyList(int value){
	Node* newNode = new Node(value);
    head = newNode;
    tail = newNode;
    head->next = head; // 自环
    head->prev = head; 
}
```

在链表中间插入时，需要遍历到指定位置，然后插入新节点，并更新相邻节点的指针。

```c++
// 双链表中部插入
void insertAtPosition(int value,int index)
{
	//1.汇集条件
    Node* newNode = new Node(value);
    int count = 0; // 遍历计数
    Node* cur = head;
    
    //2.遍历 到前一个位置
    while(cur && count < index-1){
		cur = cur->next;
        index++;
    }
    
    //3.更换节点,加入节点是4条链
    // 先更新newNode
    newNode->next = cur->next;
    newNode->prev = cur;
    // 更新newNode的前和后
    cur->next->prev = newNode;
    cur->next = newNode;
    
    if(current == tail){
		tail = newNode; // 更新尾结点
    }
}
```

> 删除操作

删除操作可以分为几种情况：删除头节点、删除尾节点、删除中间节点，以及在链表为空或只有一个节点时进行删除。在双联表中，删除只需要更新两条链，我们遍历到指定删除的位置，**由于我们只有这个点的信息**，需要用这个`P`指针表示前节点和后节点，`p->prev`为前，`p->next`为后。

那么删除当前这个`P`节点，按照从左到右来也就是`p->prev->next = p->next`。`p->next->prev = cur->prev`。这样就删除完毕了。

![img](./%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4-1723804032865-14.png)

```c++
// 删除头结点
void deleteHead()
{
    // 1.判空
    if(!head){
		return; // 链表为空
    }
    
    // 2. 只有一个节点时
    if(head == tail){
        delete head; // 释放节点内存
        head = nullptr;
        tail = nullptr;
        return;
    }
    // 3. 承接删除的节点，只需要把头指针移后即可
    Node* temp = head;
    head = head->next;
    head->prev = tail;
    tail->next = head;
    
    delete temp; // 释放保持的旧节点
}
```

删除尾节点时，需要更新尾指针，并维护头节点的 `prev` 指针指向新的尾节点，新的尾节点的 `next` 指针指向头节点。

```c++
// 删除尾结点
void delete Tail()
{
    if(!head) return 0 ;
    
    // 1. 只有一个节点
    if(head == tail){
	   delete head; // 释放节点
        head = nullptr;
        tail = nullptr;
        return;
    }
    // 2. 尾结点前移
    Node* temp = tail;
    tail = tail->prev;
    tail->next = head;
    head->prev = tail; // 头结点的前是尾结点
    
    // 3 .拿出的尾结点
    delete temp; // 释放尾结点内存    
}
```

删除中间节点时，需要找到要删除的节点，并将其前驱节点的 `next` 指针指向后继节点，后继节点的 `prev` 指针指向前驱节点。

```c++
void deleteAtPosition(int index)
{
    if(!head) return;
    
    //1.只有一个节点的时候
    if(head == tail){
		delete head;
        head = nullptr;
        prev = nullptr;
        return;
    }
    // 2.遍历指针
    Node* cur = head;
    // 这里用for循环吧,遍历到目的地位置，这里是循环双链表特点，最后一个位置是头前面
    // 双链表就可以遍历到删除的指定位置
    for(int i = 1;i < index && cur->next != head; i++)
    {        
        // 遍历
        cur = cur->next;
    }
    // 3.遍历到当前为止,删除只更新两条
    cur->prev->next = cur->next;
    cur->next->prev = cur->prev; 
    
    free(cur); // 释放节点内存    
}
```

### 顺序表与链表的区别

**数组** 和 **链表** 之间的主要区别在于它们的结构。数组是基于索引的数据结构，其中每个元素与索引相关联。链表依赖于引用，其中每个节点由数据和对前一个和下一个元素的引用组成。引用通常使用指针来实现，他们的具体差别如下

**数组**

- 元素按顺序存储在**连续的内存空间**中，通过**索引访问**。
- 可以通过索引直接**访问任意元素**，访问速度快。**具体访问时间为O(1)**
- 在编译时分配固定大小的内存，扩展大小困难。不过可以通过结构体实现动态数组
- **插入和删除元素时**，需要移动其他元素，效率较低。**时间复杂度O(n)**
- 由于元素连续存储，内存使用紧凑，但大小固定。

**链表**

- 元素（节点）存储在不连续的内存空间，通过指针相互连接。
- 需要从头开始顺序遍历才能访问特定元素，**访问速度较慢。复杂度O(n)**
- 在运行时动态分配内存，大小可灵活调整.
- 只需**调整指针即可插入或删除节点，操作效率高。**
- 每个节点存储数据和指针，使用更多内存，但灵活性高。

<img src="./2019-07-20-difference-between-array-and-linked-list-1693299145961-8-1723804032865-16.jpg" alt="数组和链表的对比" style="zoom:150%;" />

如果**代码对内存的使用非常苛刻，那数组就更适合**。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对**链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，触发语言本身的垃圾回收操作。**如果代码对**增删改查的方式使用的比较多**，那么链表更为合适。因为它方便执行这些操作。

![image-20230829170835292](./image-20230829170835292-1723804032865-17.png)

## [数组与广义表](https://www.cnblogs.com/Ghost3/articles/17607917.html)*

### 数组 

数组：按一定格式排列起来的，具有**相同类型**的数据元素集合。一般都是采用顺序存储结构来表示数组。数组可以是多维的，但存储数据元素的内存单元地址是一维的，因此，在存储数组结构之前，需要解决将多维关系映射到一维关系的问题。

- 结论：**线性表结构是数组结构的一个特例，而数组结构又是线性表结构的扩展。**
- 特点：结构固定——定义后，**维数和维界不再改变**。

**n维数组：若 n-1 维数组中的元素又是一个一维数组结构，则称为n维数组。**

```c
typedef int ElemType; 
typedef struct{
    ElemType *base; /* 数组元素基址，由InitArray分配 */
    int dim;        /* 数组维数 */
    int *bounds;    /* 数组维界基址，由InitArray分配 */
    int *constants; /* 数组映象函数常量基址，由InitArray分配 */
} Array;
```

**一维数组** 

一维数组：若线性表中的数据元素为非结构的简单元素，则称为一维数组。一维数组的逻辑结构是线性结构（定长的线性表）。声明的格式数据类型 变量名称[长度]；各数组元素大小相同，且在**物理**上连续存放。

![img](./3027548-20230805140439283-1972200470.png)

**二维数组**

二维数组可以理解为，一个一维数组中的每一个元素都是一个数组。其逻辑结构是一种非线性结构，可以用矩阵表示二维数组。

![Java 中矩阵 - 二维数组 - 3](./1080.webp)

在内存中由于二维数组的存储结构是线性的，所以说应该将这个矩阵压缩为一维的，有两种方法，**行优先存储和列优先存储**。一个声明的二维数组可以这样理解，前面一个`[]`表示为行，后面一个`[]`可以表示为列。举个例子`a[2][3]`按照行优先存储就是将申请得到的内存块分为两个大部分（注意是始终连续的），内部**按照顺序结构**存储着三个列数组。如果改为列优先，则将申请得到的内存块，分为三部分，按照顺序结构里面存储着两个行数组。

在内存中是连续的区块如果将`a[2][3]`给具现化则为(这里与图片举例子不一样，但是原理是一样的)：

- 行优先 ： `a[0][0] a[0][1] a[0][2] a[1][0] a[1][1] a[1][2]`

![](./3027548-20230805140539848-1796666549.png)

- 列优先： `a[0][0] a[1][0] a[0][1] a[1][1] a[0][2] a[1][2]`

![img](./3027548-20230805140610109-490304831.png)

设二维数组的行下标与列下标的范围`[0,h1]`与`[0,h2]`，当以**行优先的方式**求其存储结构关系，也就是**内存相对位置**的计算公式如下。其中`L`是每个数组元素占据的存储单元。在行优先存储的二维数组中，计算元素地址的公式为 `LOC(a[i][j]) = LOC(a[0][0]) + [i × (h2 + 1) + j] × L`，**其中 `i` 跳过的行数**乘以每行的元素总数（`h2 + 1`），再加上列下标 `j`，表示在当前行中找到特定元素。
$$
LOC(a[i][j])=LOC(a[0][0])+[i×(h2+1)+j]*L
$$
设二维数组的行下标范围为 `[0,h1]`，列下标范围为 `[0,h2]`，每个数组元素占据 `L` 个存储单元。给定二维数组 `a[h1+1][h2+1]`，`i` 表示行下标，`j` 表示列下标，`LOC(a[i][j])` 表示元素 `a[i][j]` 的内存地址。则以**列优先的方式求其存储结构关系**如下。可以简单记忆公式，列下标存储数组，则搜寻指定数组位置可以**跳过列下标数量的数组块`i`**，其中**内部块的个数为`h1+1`**，跳跃完之后**然后用`i`找到行下标**。
$$
LOC(a[i][j])=LOC(a[0][0])+[j×(h1+1)+i]×L
$$
这里的`h2+1`和`h1+1`就是他们的区间的范围，也即是用公式`n-m+1`也就是`m`到`n`的距离

**三维数组**

三维数组：若**二维数组中的元素又是一个一维数组结构**，则称为三维数组。

![image-20241011125412439](./image-20241011125412439.png)

### 特殊矩阵压缩存储

一个由` m × n `个元素排成的`m`行`n`列的表。将矩阵描述为一个二维数组。**矩阵的常规存储的特点：可以对其元素**进行随机存取。数组的下标0与1与矩阵`Aᵢ Aⱼ`的元素下标`i`和`j`的关系就是所谓的映射。对于矩阵内部的元素，如果有多个数据的值相同，就可以用矩阵压缩，只分配一个元素值的空间，用于减少内存的使用。

#### 对称矩阵

对称矩阵是指元素**以主对角线为对称轴对应相等的`n`阶矩阵**，即**`aᵢⱼ=aⱼᵢ`** 。注意，对称矩阵必须要是方阵。根据这个性质可以对矩阵进行压缩，只存储下（或者上）三角（包括主对角线）的数据元素。共占用 `n(n+1) / 2 `个元素空间，也就是矩阵的一半。

![img](./932246-20160723093306544-1405819987.png)

因为是存储下三角，所以是把矩阵中元素`A[i][j](i>=j)`存放到数组`Array`中。也就是从二维变为了一维，那么在这里看一下两者的对应关系。

![img](./932246-20160723102309482-1697628610.png)

上图给出了矩阵中部分元素在一维数组中的存储位置也就是索引，那么怎么确定**其在一维数组中的索引呢**，以上图的元素`2`在原数组的索引为`A[4][3]`，我们分为两个步骤来解决。第一步，我们可以通过计算当前行之上的所有行的元素，也就是使用等差数列的公式（每一行都比下一行少一个元素，公差为`1`）
$$
1 + 2 + 3 + 4 = \frac{4(4 + 1)}{2} = 10
$$


第二步回到这个元素所在行，直接加上它的列索引，即 `10 + 3 = 13`，这就是 `A[4][3]` 在一维数组中的索引位置。

如果换成列优先存储，步骤相同，**但要按列来计算**。由于对称矩阵是方阵，所以行优先和列优先的计算最终是等价的，仅仅是记号上的差异。第一个步骤，计算除当前列以上的其他列中元素个数，还是使用等差数列。第二个步骤，回到这个元素所在列，直接加上它的行索引。其实也就是上面的行列向量的优先表达式的修改版，只不过其维护下标的方式不同。

其重点**就是用`n(n+1)/2`来进行数组下标维护的**。无论是行优先还是列优先，基于对称矩阵的特性，我们可以通过以下公式直接计算 `A[i][j]` 在一维数组中的索引：
$$
SymmetricMatrix[i][j] == Array[\frac{i*(i + 1)}{2}+j]
$$
总体来说，由于对称矩阵的对称性，我们只需要存储下三角或上三角部分，因此在一维数组中存储的元素数量比完整矩阵减少了一半。也就可以推出其上三角和下三角的对应关系
$$
k = \begin{cases} 
\frac{i(i-1)}{2} + (j-1) &  i \geq j \text{(下三角和主对角线元素) } \\ 
\frac{j(j-1)}{2} + (i-1) &  i < j \text{(上三角元素$a_{ij}$ = $a_{ji}$)}
\end{cases}
$$
![img](./3.4.3(2).png)

#### [三角矩阵](https://blog.51cto.com/u_12951861/5695441)

![img](./3027548-20230805140833720-1216306126.png)

三角矩阵在线性代数中常常用于表示行最简或者列最简的方式，如果将其压缩的话其共占用 `n(n+1) / 2 + 1`个元素空间。其中`n(n+1)/2`是存储下或者上三角的，多出来的`1`是用于存储常数`c`的一个一维数组位置。

![img](./3027548-20230805140850242-1365702930.png)

我们将矩阵分为上三角矩阵和下三角矩阵。在上三角矩阵中，下三角元素全为常数 `c`；而在下三角矩阵中，上三角元素全为常数 `c`。以上三角矩阵为例，其压缩规则为：只存储上三角元素，而不存储下三角元素，或仅用一个存储单元保存下三角非零元素。

我们采用一维数组来**储存上三角矩阵**，数组长度为 `n(n+1)2+1` 。一维数组的下标 k 与 n 阶**上三角矩阵的元素** `a(i,j)` 之间的对应关系如下。其中的`2n - i + 1`表示与自身长度`i`对称的位置。
$$
k =
\begin{cases}
\frac{(2n - i + 1)*i}{2} + j - i &  i \leq j \\
\frac{n(n + 1)}2 &  i > j
\end{cases}
$$
**下三角矩阵**的对应关系为：
$$
k =\begin{cases}
\frac{i(i + 1)}{2} + j &  i \geq j  \\
\frac{n(n + 1)}{2} &  i < j 
\end{cases}
$$
其中第` k = n*(n+1)/2 `的位置存放的是常数` c`

```c++
#include <stdio.h>
#define N 5

int main(void) {
    int arry[N][N];  // 定义 N x N 的二维数组
    int arr[N * (N + 1) / 2 + 1] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
    
    int k;  // 用于计算索引
    int totalElements = N * (N + 1) / 2;  // 总的上三角元素个数

    // 填充二维数组
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            if (i <= j) {
                // 计算上三角元素的索引
                k = i * (2 * N - i + 1) / 2 + j - i;
                arry[i][j] = arr[k];  // 存储上三角元素
            } else {
                // 下三角元素存储常数 c
                arry[i][j] = arr[totalElements];  // 存储下三角元素
            }
        }
    }

    // 打印二维数组
    for (int i = 0; i < N; ++i) {
        for (int j = 0; j < N; ++j) {
            printf("%-5d", arry[i][j]);  // 格式化输出
        }
        printf("\n");
    }

    return 0;
}

```

```yaml
输出结果
        1    2    3    4    5
        0    6    7    8    9
        0    0    10   11   12
        0    0    0    13   14
        0    0    0    0    15 
```

**对角矩阵**

也称为带状矩阵，就是所有的非零元素都集中在以对角线为中心的带状区域内（对角线的个数位奇数），即除了主对角线和主对角线上下若干条对角线的元素外，其它元素均为常数 c . 

![img](./3027548-20230805140943405-12949840.png)

```c
# include <stdio.h>
# define N 5

void Trans_To_Original(int arry[N][N], int * arr);
void Trans_To_Compress(int arry[N][N], int * arr);
void Show(int arry[N][N], int * arr1, int * arr2); 

int main(void)
{
    // 创建一个一维数组储存已知的以行为主序压缩后所得元素 
    int B[(N+1)*N/2 + 1] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0};
    int A[N][N] = {0};
    Trans_To_Original(A, B);
    
    // 创建一个一维数组储存以列为主序压缩所得的数据
    int C[(N+1)*N/2 + 1];
    Trans_To_Compress(A, C);
    
    // 将三个数组打印输出 
    Show(A, B, C);
    
    return 0;
}

void Trans_To_Original(int arry[N][N], int * arr)
{
    int i, j, k;
    for (i = 0; i < N; ++i)
    {
        for (j = 0; j < N; ++j)
        {
            if (i <= j)
            {
                k = i*(2*N-i+1)/2 + j -i;
                arry[i][j] = arr[k];
            }
            else
            {
                k = N*(N+1)/2;
                arry[i][j] = arr[k];
            }
        }
    }
    
    return;
}

void Trans_To_Compress(int arry[N][N], int * arr)
{
    int i, j, k = 0;
    // 按列为主序压缩 
    for (i = 0; i < N; ++i)
    {
        for (j = 0; j <= i; ++j)
        {
            arr[k++] = arry[j][i];
        }
    }
    arr[(N+1)*N/2] = 0;
    
    return;
}

void Show(int arry[N][N], int * arr1, int * arr2)
{
    int i, j, k;
    printf("原二维数组为：\n");
    for (i = 0; i < N; ++i)
    {
        printf("              ");
        for (j = 0; j < N; ++j)
        {
            printf("%-5d", arry[i][j]);
        }
        printf("\n");
    }
    printf("以行为主序压缩所得结果为：\n");
    for (k = 0; k < (N+1)*N/2; ++k)
    {
        printf("%-3d", arr1[k]);
    }
    printf("\n以列为主序压缩所得结果为：\n");
    for (k = 0; k < (N+1)*N/2; ++k)
    {
        printf("%-3d", arr2[k]);
    }
    printf("\n");
    
    return;
}
```

#### 稀疏矩阵

稀疏矩阵是指，矩阵中的值的个数远远小于`0`的个数。更精确的定义是非零元素的个数远远少于矩阵元素的个数（一般小于5%）非零元素个数 / 元素总个数 ≤ 0.05 则满足条件。稀疏矩阵有两种压缩存储方式：三元组法和十字链表法

![img](./3027548-20230805141001157-1250135264.png)

**三元组**

用三个元来表示稀疏矩阵中非`0`的数，也就是通过数组下标的映射来找到指定的值。由下图，我们可以知道，**三元组由行标、列标、值**三者构成。但是对这个稀疏矩阵压缩完成之后，其就失去了随机存储的能力。

![img](./3027548-20230805141709852-1625877107.png)

```c
#define MAXSIZE 1000	//非零元素个数最多为1000

//三元组的定义，用于存储一个非零元素
typedef struct{
	int row,col;	//存储该非零元素的行和列
	ElementType e;	//存储该非零元素的值
} Triple;

//三元组表的定义
typedef struct{
	Triple data[MAXSIZE + 1];	//非零元素的三元组表。data[0]未用
	int m, n, len;	//原来矩阵的行数、列数、非零元素的个数
}TSMatrix;
```

**[十字链表](https://blog.csdn.net/weixin_51450101/article/details/122722271)**

**十字链表**是稀疏矩阵的链式存储法。矩阵的每一个非零元素用一个结点表示，该结点除了`（row，col，vaule）`以外，还要**添加两个链域**：`right` 用于**链接同一行**中的下一个非零元素，`down `用于链接同一列中的下一个非零元素。也就是用链式在逻辑上拉进了元素之间的距离。

![十字链表的结点结构](./b93c8af83cf439ca127029d471b85518.jpeg)

![十字链表](./20cb9d289e3e7e38d9e075c7cb1311ba.jpeg)

```c
/*十字链表的存储结构*/
typedef struct OLNode {
	int row, col;						//非零元素的行和列下标
	int vaule;
	struct OLNode* right, * down;		//非零元素所在行表、列表的后继链域
}OLNode, *OLink;

typedef struct {
	OLink* row_head, * col_head;		//行、列链表的头指针向量
	int m, n, len;						//稀疏矩阵的行数、列数、非零元素个数
}CrossList;
```

### [广义表*](https://zhuanlan.zhihu.com/p/554782450)

线性表指的是`n≥0`个元素`a1, a2, a3…`的有序数列，并且线性表的元素具有原子性，即结构上是不可分割的一个整体。广义表`Generalized list `则是**线性表的一种扩展延伸**。相对于线性表，广义表最大的特点在于其元素既可以是一个确定的类型，同时也可以是另一个有不定数量的元素组成的表（广义表）。不难看出从广义表的定义是递归的。**广义表是线性表的递归数据结构**。形式上为：
$$
\text{广义表} = \{ \text{原子} | \text{广义表} \}
$$
我们通常可以用` GL = (a1, a2, a3… an)`来表示一个广义表，其中`n`为表的长度，`n>=0`，当`n==0`时，我们称广义表为空表，`GL`为广义表的名字。为了能更好的区分广义表中的元素我们有以下定义：

- **原子** 如果`ai`是单个元素，我们称之为`GL`的原子
- **子表** 如果`ai`是一个广义表，我们陈之为`GL`的子表

我们通常把广义表中的原子用小写字母表示，而子表用大写字母表示。例如

```c
A=() //空表
B=(e) //只含有一个原子的广义表
C=(a,(b,c,d)) //含有一个原子和一个子表的广义表
D=(A,B,C)=((),(e),(a,(b,c,d))) //含有三个子表的广义表，且第一个表为空表
E=(a,E) //广义表 E 中有两个元素，原子 a 和它本身。这是一个递归广义表，等同于：E = (a,(a,(a,…)))。
```

广义表的深度和长度

- 广义表的**长度**： 广义表中元素的个数（包括原子和子表）
- 广义表的**深度**： 广义表中括号的最大层数叫广义表的深度。

广义表的表头和表尾

- **表头**： 当广义表不为空表时，第一个元素（可能为子表和原子）称为表头
- **表尾**： 除去表头，剩余元素组成的新广义表称为表尾

```c
LS=(1,(1,2,3),5), 其中表头Head(LS)为原子1，表尾为Tail(LS)=((1,2,3),5)
LS=(1), 其中表头Head(LS)为原子1，表尾为空表
```

#### 存储结构

广义表是一种递归的数据结构，它的元素具有两种，**因此很难为广义表分配固定的存储空间**，所以其存储结构**适合用链式存储结构**。为了能使原子和子表在结构上抱持一致，又容易区分我们通常采用如下结构：

![img](./2502785-20221015170244353-1465669609.png)

```c
// ATOM == 0: 表示原子, LIST == 1: 表示子表
typedef enum { ATOM, LIST } ElemTag;

// 广义表结点结构定义
typedef struct GLNode {
    ElemTag tag;  // 公共部分，区分原子结点和子表结点

    union { //union允许在同一内存位置存储不同数据类型
        AtomType atom;  // 原子结点的值，AtomType 是用户定义的类型
        struct {
            struct GLNode *head;  // 指向表头的指针
            struct GLNode *tail;  // 指向表尾的指针
        } ptr;  // 子表结点的指针域
    } content;  // 联合体用于保存原子或子表

} *GList;  // 广义表类型定义为指向 GLNode 结构体的指针
```

![img](./2502785-20221015170310269-471561010.png)

**广义表的第二种存储结构**

![img](./2502785-20221015170329003-1578324482.png)

```c
// ATOM == 0: 表示原子, LIST == 1: 表示子表
typedef enum { ATOM, LIST } ElemTag;

// 广义表结点结构定义
typedef struct GLNode {
    ElemTag tag;  // 公共部分，用以区分原子结点和子表结点

    union {
        AtomType atom;       // 原子结点的值域
        struct GLNode *hp;   // 表结点的表头指针
    } content;  // 联合体用于区分保存原子或表头

    struct GLNode *tp;  // 表尾指针，相当于线性链表的 next 指针
} *GList;  // 广义表类型 GList 是扩展的线性链表
```

![img](./2502785-20221015170751853-737812283.png)

#### 广义表计算

以第二种存储结构为例

```c
int GLLength(GList g) {
    int length = 0;         // 记录广义表的长度
    g = g->content.hp;      // g 指向广义表的第一个元素

    while (g != NULL) {     // 遍历链表，直到到达末尾
        length++;           // 增加计数
        g = g->tp;         // 移动到下一个元素
    }
    
    return length;         // 返回广义表的长度
}
```

**广义表的深度**：对于带头节点的广义表`g`，广义表深度的递归定义是它等于所有子表中表的最大深度加`1`。若`g`为原子,其深度为`0`。

![img](./2502785-20221015170635804-1710377050.png)

```c
int GLDepth(GList g) {
    if (g->tag == ATOM) {
        return 0;  // 如果是原子，深度为 0
    }
    
    int maxDepth = 0;  // 保存当前子表的最大深度
    int currentDepth;
    
    g = g->content.hp;  // g 指向第一个元素
    if (g == NULL) {
        return 1;  // 空表的深度为 1
    }

    while (g != NULL) {  // 遍历广义表的所有元素
        if (g->tag == LIST) {  // 如果是子表
            currentDepth = GLDepth(g);  // 递归计算子表的深度
            if (currentDepth > maxDepth) {
                maxDepth = currentDepth;  // 更新最大深度
            }
        }
        g = g->tp;  // 移动到下一个元素
    }

    return maxDepth + 1;  // 返回深度，+1 表示当前层
}
```

## [队列](https://labuladong.online/algo/data-structure/stack-queue/)*

队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，**允许删除的一端称为队头。**它是一种特殊的线性表，特殊之处在于它只允许**在表的前端进行删除操作，而在表的后端进行插入操作**，和栈一样，队列是一种操作受限制的线性表。

队列是一种先进先出的数据结构，又称为先进先出的线性表，简称` FIFO（First In First Out）`结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。

![img](./%E9%98%9F%E5%88%97-1723804032865-20.png)

这里使用结构体模拟循环队列，引入**循环队列**的主要目的是提高数组的空间利用率，一般用其他数据结构模拟的队列都是循环队列，需要注意的是，队首永远指向即将出队的元素，队尾永远指向队列中新入的数据。

```c++
// 用结构体模拟队列
struct Queue{
    int data; // 数据域
    int front; // 指向队首
    int rear; // 指向队尾
    int size; // 标识队列长度
}

// 初始化队列
void initQueue(Queue &q){
    q.front = 0;
    q.fear = -1;
    q.size = 0;    
}

// 1. 判断队列是否为空
bool isEmpty(Queue &q){ return q.size == 0}

// 2.入队
bool enqueue(Queue &q, int value)
{
    if(isFull(q)) return false; // 队列满
    q.rear = (q.rear+1) % MAX_SIZE; // 循环数组存储
    q.data[q.rear] = value;
    q.size++;
    return true;
}

// 3.出队
bool dequeue(Queue &q,int &value)
{
    if(isEmpty(p)){ return false }
    // 队首 - 队列的队首永远指向将要出队的位置
    value = q.data[q.front];
    q.front = (q.front+1) % MAX_SIZE; // 循环队列
    q.size--;
    return true;
}


// 4.获取队首
bool peek(Queue &q,int &value)
{
	if(isEmpty(q)) return false;
	// 直接取出队首就行    
    value = q.data[q.front];
    return true;
}

```

### 队列结构

一个数据结构由其逻辑结构和物理结构构成。队列可以通过链式和顺序两种方式表示。使用数组表示队列意味着连续分配一段内存，从而具备随机存取能力，能够快速访问指定位置的元素。而链式表示的队列则利用链表的优势，支持快速删除任意位置的元素，避免频繁移动的开销。

逻辑结构方面，队列可以通过不同的拓扑图像实现。例如，可以将队列视作一种循环结构，类似于一条咬着尾巴的蛇；也可以采用顺序结构，与数组类似；或者实现为离散的链式结构。

#### 顺序结构

一个用数组实现的顺序队列如下图所示，从逻辑拓扑图可以看出队内元素都是挨在一起的

![img](./4a614458b22b9907eb7f7b8272a15887.png)

可以看到，要实现一个顺序队列，我们需要以下结构：

- 存储数据的数组 —— `data[]`
- 表示队列的最大容量的值，也就是队头指针和队尾指针的最大距离`F-r+1` —— `MAXSIZE`
- 标识队头端的队头下标 ——` front`
- 标识队尾端的队尾下标 ——` rear`

`front` 和 `rear` 会随着入队和出队操作而变化，为了方便起见，我们规定在非空队列中，队尾下标是队尾元素的下一个元素的下标。

```c
// 1. 队长
#define MAXSIZE 5

// 2.队内元素的结构体
typedef struct{
    int data[MAXSIZE];
    int front; // 队尾
    int front; // 对头
}QueueArray;
```

#### 链式结构

我们使用带头节点的单链表来实现队列，如下图所示：

![img](./0dc37ecfdaa0b7296d453f33a5263e1f.png)

可以看到，要实现一个链队列，需要以下结构：

- 单链表的基本单元结点 —— `QueueNode`
  - 存储数据的数据域 —— `data`
  - 指向下一个结点的指针域 —— `next`
- 指向链表的头指针，只是一个指针变量指向队首—— `head`
- **标识队头端的队头指针 —— `front`**
- **标识队尾端的队尾指针 —— `rear`**

其中，头指针 `head` 和队头指针 `front` 都指向了单链表的第一个结点，所以这个指针可以合二为一，队头指针即头指针。如此一来，我们可以借助链表的尾插法实现队列的入队操作，借助链表的头删法实现队列的出队操作。

```c++
// 1. 节点
typedef struct QueueNode{
	int data; // 数据域
    struct QueueNode *next; // 指针域
}QueueNode;

// 2.链结构的结构体
typedef struct{
    QueueNode *front; // 队头指针
    QueueNode *rear; // 队尾指针
}QueueLink;
```

### [优先队列](https://algo.itcharge.cn/04.Queue/02.Priority-Queue/01.Priority-Queue/#_1-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E7%AE%80%E4%BB%8B)

优先队列是一种特殊的队列。在优先队列中，元素被赋予优先级，当访问队列元素时，具有最高优先级的元素最先删除。与普通队列最大的不同点在于 **出队顺序**。其出队顺序是按照优先级来决定的。

![优先队列](./202405092258900.png)

常见的优先级逻辑数据结构包括**二叉堆**和**哈夫曼树**，以及一些图算法（如 Dijkstra 算法和 Prim 算法）所使用的优先队列。优先队列根据元素的优先级进行排序，二叉堆则是实现优先队列的一种有效方式。因此，二叉堆常被称为优先队列。

#### [二叉堆](https://juejin.cn/post/6958725098081615880)

二叉堆是一个完全二叉树，其内部节点按照一定逻辑进行排列。可以按照数据的大小简单分为两类堆：**最大堆、最小堆**

最大堆的逻辑结构：

- 它的任何一个双亲结点的值，均大于或等于左孩子和右孩子的值；
- 每条分支从根结点开始都是降序排序。

同理最小堆的逻辑结构：

- 它的任意一个双亲节点的值都小于或者等于左右孩子的值
- 每条分支从根节点开始都是升序排序

具体的逻辑结构如下图，我们的目的是将一个无序完全二叉树构造成为一个最大堆或者最小堆。其主要操作就两个，`sink`（下沉）和 `swim`（上浮），用以维护二叉堆的性质。还是举例子吧：下图是一颗普通的二叉树，是无序的

![img](./a019c96e1751472fbaffdec4060f2fa4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

下图是一个二叉堆，为一个最小堆

![最小堆](./bbc75f392e804d519f28238f58f48219tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

这个二叉堆的特点是：

- 它是一颗完全二叉树。事实上，该二叉堆就是由上图的完全二叉树**经过调整转化而来**；
- 任何一个双亲结点的值，均小于或等于左孩子和右孩子的值；
- 每条分支从根结点开始都是升序排序（如分支 `1-2-3-4`）。

与最小堆相对应的是**最大堆**：

- 最大堆是一颗完全二叉树；
- 它的任何一个双亲结点的值，均大于或等于左孩子和右孩子的值；
- 每条分支从根结点开始都是降序排序。

最大堆的堆顶，是整棵树的最大值。我们将上图中的普通二叉树转化为最大堆，如下图：

![最大堆](./d8aebaf53d5140559c2b5a4c019940c8tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

----

**构造二叉堆**

给你一颗完全二叉树，如何调整结点，构造出一个二叉堆？下面是一颗无序的完全二叉树：

![img](./0879081329134b1b999294cea8af2772tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

现在我们想要构造出一个**最小堆**，首先找到这颗完全二叉树中所有的**非叶子结点**（绿色标记）：

![img](./efb0d423290444078bf2b75ccf6674f1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

我们要对每个非叶子节点进行最小堆的**下沉调整**。什么是最小堆的**下沉调整**呢？

- 对于某个非叶子节点，如果**它的值大于其子节点中最小**的那个，则将**它与该子节点交换位置**。这一过程表现为**非叶子节点（即较大值节点）**下沉一个层次，同时较小值节点则相应地上浮。需要注意的是，有时一次下沉并不足够，我们**需要多次下沉**，直到该节点不再大于其子节点。

- 为了构造最小堆，我们从最后一个非叶子节点开始，按照从右到左、从下到上的顺序进行多次下沉调整。

例如，对于值为 `4` 的非叶子节点，它可能在下沉到第三层后仍然大于其子节点，因此还需继续下沉，直到完全下沉到底。这样，在分支 `2-4-3-1` 上，节点 `4 `才算下沉到底。

- 对非叶子结点 7，它小于其孩子结点 10， 不用下沉；

![img](./f110f91043a647988ebc7ff61f3ceb40tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

- 对非叶子结点 3，它大于其孩子结点中较大的结点 1，结点 3 要“下沉”，和结点 1 交换。显然，结点 3 沉到底了。

![img](./01c6a8d90a78479baaff38135c41844atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

- 对非叶子结点 6，它大于其孩子结点中较小的结点 5，结点 6 要下沉， 和结点 5 交换位置。显然，结点 6 沉到底了。

![img](./ea19a3e360ae496a8c962668a3f5f820tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

- 对非叶子结点 4，它大于其孩子结点中最小的结点 1，结点 4 要 “下沉”，和结点 1 交换位置。**显然，结点 4 并未沉到底。**

![img](./f4d88658ef7145999954206c56938b4atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

- 仍对结点 4，它大于其孩子结点中最小的结点 3，结点 4 要“下沉”， 和结点 3 交换位置。此时，结点 4 算是沉底了。

![img](./069d82c5490f4cb6ba1af7e27a4a3790tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

对非叶子结点 2，它大于其孩子结点中最小的结点 1，结点 2 要“下沉”，和结点 1 交换位置。显然，结点 2 算是沉到底了。

![img](./e95e706798584f92a45e40055d829d82tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

至此，我们将一颗无序的完全二叉树调整改造成了最小二叉堆，你可以检查一下，最小堆中的所有结点皆满足双亲的值小于孩子的值。并且，5 条分支上都是有序的。

构造最大堆的步骤类似，不过最大堆的下沉调整是：如果某结点小于其孩子结点中最大的那个，则交换二者位置，在图上表现为非叶子结点（即小值结点）“下沉”一个层次。通过多次下沉调整，使该结点不再小于其孩子。

下图把一个无序完全二叉树调成为最大堆：

![image-20210503221946159](./1c068641c82f4f0bb6da0a561cbab6f1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

----

**插入结点**

二叉堆是一个完全二叉树，要向其中插入结点，插入到完全二叉树的最后一个结点的下一个位置即可。

比如向下面的一个最大堆中插入结点 11，要插到最后一个结点 4 的下一个位置。当最大堆新插入一个结点 11 时，它就不再是最大堆了，因为**结点 11 破坏了原堆的结构**。所以，我们应当将其看作一个新的完全二叉树，然后调整新完全二叉树再次构造出最大堆。（调整过程见上）

![插入过程](./bcf6ae72fbc84a798ad0ced7e26abaa4tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

**删除结点**

删除操作与插入操作相反，是删除**第一个位置**的元素，即删除**堆顶**。我们以删除上图最大堆的堆顶 11 为例。当删除堆顶 11 后，二叉堆原结构被破坏，甚至不是一颗二叉树了（变成两颗）：

![img](./b3875efed1a546ee8c3a61e3b1fe1ac9tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

为了保持完全二叉树的形态，我们把最后一个结点 7 补到根结点去，顶替被删除的根结点 11。如此一来，我们又得到了一个新完全二叉树（不是二叉堆），然后我们根据这颗新完全二叉树再次构造出最大堆即可。

![删除过程](./756fde2a7a4647d59d51220e1a8c4052tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

---

**存储结构**

因为二叉堆是一颗完全二叉树，完全二叉树适合使用顺序存储结构来实现。下图是一个最大堆，红色方框是对结点的编号，和数组下标一一对应。

![二叉堆的顺序存储](./11e448a4c07049a58ec252baa2ff9e59tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

链式存储结构能够清晰而形象地为我们展现出二叉堆中双亲结点和左右孩子的关系。但是数组中没有指针，只有数组下标，怎么表示双亲和孩子的关系呢？其实对于完全二叉树来说，数组下标足矣！

现假设二叉堆中双亲结点的数组下标为 `parent_index`，左孩子的数组下标为 `left_child_index`，右孩子的数组下标为 `right_child_index`，那么它们之间有如下关系：

（一）`left_child_index = 2 × parent_index + 1`

（二）`right_child_index = 2 × parent_index + 2`

（三）`parent_index = (left_child_index - 1) ÷ 2`

（四）`parent_index = (right_child_index - 2) ÷ 2`

（五）`right_child_index = left_child_index + 1`

比如：结点 3 的下标为 3 ，则其左孩子 2 的下标为 `2 × 3 + 1 = 7`、右孩子 1 的下标为 `2 × 3 + 2 = 8`；结点 7 的下标为 4，作为右孩子，其双亲下标为 `(4 - 2) ÷ 2 = 1`；

假设某结点的数组下标为 `child_index`，你不知道该结点是左孩子还是右孩子，要求其双亲的下标，有

（六）`parent_index = (child_index - 1) ÷ 2`

比如：你不知道结点 5（下标为 5）、结点 6（下标为 6）是左孩子还是右孩子，则结点 5 和结点 6 的双亲下标分别为 `(5 - 1) ÷ 2 = 2` 、`(6 - 1) ÷ 2 = 2`。（注意，编程语言中的整型运算，所以结果不是小数）

这里，我们使用结构体实现二叉堆：

```c
#define MAXSIZE 20 // 数组的最大存储空间

typedef struct {
    int array[MAXSIZE]; // 存储数组
    int length; // 当前堆长度（结点数）
} BinaryHeap;
```

在进行实际操作之前，需要初始化二叉堆，即对数组及堆长度赋值：

```c
/**
 * @description: 初始化二叉堆
 * @param {BinaryHeap} *heap 二叉堆
 * @param {int} *array 数组首地址，该数组是一个无序完全二叉树
 * @param {int} arr_length 数组长度
 * @return {*} 无
 */
void init_heap(BinaryHeap *heap, int *array, int arr_length)
{
    // array 拷贝到 heap 中
    memcpy(heap->array, array, arr_length * sizeof(int));
    // 设置堆长度
    heap->length = arr_length;
}
```

----

**二叉堆的具体实现**

这里以构造最小堆为例。要构造一个最小堆，就得调整所有的非叶子结点。而调整的依据就是比较非叶子结点和其孩子的大小。我们约定 `parent` 为非叶子结点， `parent_index` 为其下标。`child` 为其孩子中较小的那个，`child_index`为其下标。

`child` 开始默认标识左孩子，那么右孩子的下标即为 `child_index + 1`。当左孩子小于等于右孩子时，`child` 不需要改变；当左孩子大于右孩子时，就得更新 `child_index` ，使`child` 标识右孩子。下面结合下图中值为 4 的非叶子结点为例，讲述代码如何实现。

![img](./bc855388d3254577aa2f7735b3934a18tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

先比较 `parent` 的左右孩子，左孩子较小，则 `child` 为左孩子，不需要更新 `child_index`。

`parent` 和 `child` 各就各位，发现 `parent` 大于 `child`，可以交换位置。在交换之前，先保存一下 `parent` 的值，即 `parent_value = 4`：

![img](./90c12105cee14c2ba68e47fe08300a65tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

交换位置：先把 `child`的值赋给 `parent`，从而达到 值1 上浮的效果：

![img](./f01ccf03a5eb43c895fa56fdb4090500tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

然后更新 `parent_index` 和 `child_index`，二者都往下走一层次：

![img](./9d642cb1470048be9fb68f2a8f97ef74tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

然后将之前保存的 `value` 赋给现在的 `parent`，从而达到 值4 下沉的效果：

![img](./b101aca7e552461fae3c0025cf424389tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

一次调整完成，但对于 值4 来说，并没有结束，因为 值4 还没有沉到底。比较此时 `parent` 的左右孩子，发现右孩子较小，则 `child` 为右子树，需要更新 `child_index`，使 `child` 标识右孩子：

![img](./1b75750c0b234ddc9d14447fdd82115atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

现在可以交换位置了，把 `child` 的值赋给 `parent`，达到 值3 的上浮：

![img](./1fc33ed07ec14f008355b2772c85e5b5tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

然后，更新 `parent_index` 和 `child_index` 的值，二者向下走一个层次：

![img](./029e961fd5764522ab8873ee4ebf1af3tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

把 `value` 赋给 `parent`，达到 值4 的下沉：

![img](./ee3aaf6d5e454b46aab6b9f1817327a7tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

此时，`child_index` 已超过了二叉堆的长度，即 值4 已经到底了。

```c
void adjust_for_min_heap(BinaryHeap *heap, int parent_index)
{
    // value 保存非叶子结点的值
    int value = heap->array[parent_index];
    // child_index 标识左孩子
    int child_index = parent_index * 2 + 1;
    // 最后一个结点的下标
    int last_child_index = heap->length - 1;

    // 双亲结点 parent 至少有一个孩子
    while (child_index <= last_child_index) {
        // 如果双亲结点 parent 有左孩子和右孩子
        if (child_index < last_child_index) {
            // 比较左孩子和右孩子谁小，如果右孩子小，
            if (heap->array[child_index] > heap->array[child_index + 1]) {
                // 则 child_index 标识右孩子
                child_index = child_index + 1;
            }
        }
        // 如果双亲的值大于 child 的值
        if (value > heap->array[child_index]) {
            heap->array[parent_index] = heap->array[child_index]; // 小节点上浮
            parent_index = child_index; // 更新双亲下标
            child_index = parent_index * 2 + 1; // 更新孩子下标
        } else { // 不做操作，跳出循环
            break;
        }
        // 大节点下沉
        heap->array[parent_index] = value;
    }
}
```

构造代码如下：

```c
/**
 * @description: 构造最小堆
 * @param {BinaryHeap} *heap 二叉堆（无序）
 * @return {*} 无
 */
void create_min_heap(BinaryHeap *heap)
{
    // 每个非叶子结点都调整
    for (int i = (heap->length - 2) / 2; i >= 0; i--) {
        adjust_for_min_heap(heap, i);
    }
}
```

**插入结点**

```c
/**
 * @description: 向最小堆中插入一个元素
 * @param {BinaryHeap} *heap 最小堆指针
 * @param {int} elem 新元素
 * @return {*} 无
 */
void insert_into_min_heap(BinaryHeap *heap, int elem)
{
    if (heap->length == MAXSIZE) {
        printf("二叉堆已满，无法插入。\n");
        return;
    }
    heap->array[heap->length] = elem; // 插入
    heap->length++; // 更新长度
    create_min_heap(heap); // 重新构造
}
```

**删除结点**

将最后一个结点移动（赋值）到堆顶，然后重新构造二叉堆。

```c
/**
 * @description: 删除最小堆的堆顶
 * @param {BinaryHeap} *heap 最小堆指针
 * @param {int} *elem 保存变量指针
 * @return {*} 无
 */
void delete_from_min_heap(BinaryHeap *heap, int *elem)
{
    if (heap->length == 0) {
        printf("二叉堆空，无元素可删。\n");
        return;
    }
    *elem = heap->array[0];
    heap->array[0] = heap->array[heap->length - 1]; // 移动到堆顶
    heap->length--; // 更新长度
    create_min_heap(heap); //重新构造
}
```

- 构造最大堆的本质是：将每颗子树的“大”结点上浮作为双亲，“小”结点下沉作为孩子。

- 构造最小堆的本质是：将每颗子树的“小”结点上浮作为双亲，“大”结点下沉作为孩子。

插入结点的本质是：插入新结点至二叉堆末尾，破坏了原二叉堆的结构，然后调整新得到的完全二叉树，重新构造二叉堆。

删除结点的本质是：删除堆顶，破坏了原完全二叉树的结构，然后使用最后一个结点，重新构造完全二叉树，再调整新得到的完全二叉树，重新构造二叉堆。

用四个字概括就是——**破而后立**。至于代码实现，关键在于结点的调整，把这个搞明白，剩下的就简单了。对于构造完成的二叉堆，我们将至层序遍历出来，就是**优先队列的出队操作了**

### 循环队列

循环队列是一种逻辑拓扑为环的一种队列，其中有两个指针标识很重要

- `front` 指针指向队列中的第一个进入的元素，即将要被移除的元素。每次出队时，`front` 指针向后移动一格，以指向下一个元素。

- `rear` 指针指向队列中的下一个插入位置，即队列的尾部。每次插入新元素时，`rear` 指针会向后移动一格。

为了突出循环二字，我们将这种顺序队列画成一个圆：

![img](./300f6e7526bc4f620e43668e33f9ccf9.png)

**循环队列的 rear 和 front 能够在队列中一圈一圈地转，像钟表的时针和分针一样。**不会再出现不能利用的空间了。顺序队列的形式从“直的”变成这种可循环的之后，对于状态的判断也改变了。

> 空队列：队列中没有元素，如上图。

请注意，空队列的条件并不是` front = rear = 0`，比如一个空队列经过 `3 `次入队和` 3 `次出队操作后仍为空队列：

![img](./84204ab02a7c76d0597460187eebf1a9.png)

所以为了避免混淆，循环队列为空队列时，条件应该为` front == rear`

> 满队列：队列中没有空闲空间

![img](./d5e40b972004e73c5cf918c2dd917e8e.png)

上图是一个最大容量为 `8` 的空队列，入队 `7` 个元素后，队列中还剩 `1` 个空闲位置，如果此时我们再入队` 1` 个元素：

![img](./6c3644400e619b0ff5a9a877f40ba7a9.png)

此时队列中确实没有空闲空间了，但注意，此时队列满足了 `rear = front` ，但满足 `rear = front`的队列不应该是空队列吗?这就产生误会了。

不如我们退一步海阔天空，**少用一个元素**，借此来消除误会。如下图，规定这样是一个满队列。

![img](./6c77e7eb1bace0e175026d3d4b5d6979.png)

我们规定，**`front` 出现在 `rear` 的下一个位置时，队列为满队列。**比如在上图的满队列中，` front = 3` 在` rear = 2 `的下一个位置。所以队列为满队列的判定条件为：`rear + 1 = front`，但这的条件是不准确的。

因为循环队列中的` front` 和 `rear` 都是循环使用的，就像钟表的时针一样，所以我们仅根据下标的大小来判断位置是不合理的。下面两个均是满队列，右图不满足`rear + 1 = front`：

![img](./c2e22fd7edd50e0add455cf2d03a1fa4.png)

就像钟表的时针满 `12` 归零一样，`front` 和 `rear` 也应该满某个数后归零，这个数就是 `MAXSIZE`，就是约束这个循环一周的块个数也就是队列长度。比如` rear = 7` 时，如果按平常做法来 ，下一步应该是` rear = 8`，但在这里，我们让其归零，所以下一步应该是` rear = 0`。用数学公式来表示上面的归零过程就是：`rear % MAXSIZE = 0`

**所以满队列的判断条件应该为：`(rear + 1) % MAXSIZE = front`**

-----

**入队操作**

前面我们规定，顺序队列的队尾下标为队尾元素的下一个元素，所以直接将待入队元素放入队尾下标处，然后队尾下标加一(注意：循环队列中的加一要对 MAXSIZE 取模)当 `(rear + 1) % MAXSIZE == front` 时队列就满

- 塞入数据，队尾是不断远离队头的

- 弹出数据，对头是不断接近队尾的

![img](./7a880d24e6f8b52f921dc430753ab461.png)

```c++
/** 
 * 入队操作 
 * queue: 指向队列的指针 
 * elem: 入队的数据 
 * return: 0失败，1成功 
 */ 
int en_queue(QueueArray *queue, int elem) 
{ 
    //判断队列是否已满 
    if ((queue->rear + 1) % MAXSIZE == queue->front) { 
        printf("队列已满，无法继续入队。\n"); 
        return 0; 
    } 
    //元素入队 
    queue->data[queue->rear] = elem; 
    //队尾下标加一 
    queue->rear = (queue->rear + 1) % MAXSIZE; 
    return 1; 
} 
```

**链式队列**

链队列的入队操作本质是单链表的尾插法：

```c++
/** * 入队操作 
 * queue: 指向队列的指针 
 * elem: 入队的数据 
 */ 
void en_queue(QueueLink *queue, int elem) 
{ 
    //创造新结点 
    QueueNode *new = create_node(elem); 
    //入队（尾插法） 
    queue->rear->next = new; 
    queue->rear = new; 
} 
```

**出队操作**

出队操作只允许元素从队头出。将队头下标处的元素出队，然后将队头下标“加一”(对 MAXSIZE 取模)。

![img](./d12fb715dd05f298118a4c72f1f8f582.png)

```c++
/** 
 * 出队操作 
 * queue: 指向队列的指针 
 * elem: 指向保存出队数据的变量 
 * return: 0失败，1成功 
 */ 
int de_queue(QueueArray *queue, int *elem) 
{ 
    //判读队列是否为空 
    if (queue->front == queue->rear) { 
        printf("队列空，无元素可出。\n"); 
        return 0; 
    } 
    //元素出队 
    *elem = queue->data[queue->front]; 
    //队头下标加一 
    queue->front = (queue->front + 1) % MAXSIZE; 
    return 1; 
} 
```

**链式队列**

链队列的出队操作本质上是单链表的头删法。注意，如果出队的是队列中最后一个元素，需要在出队后，将队尾指针重新指向头结点，重新形成空队列。

```c++
/** 
 * 出队操作 
 * queue: 指向队列的指针 
 * elem: 指向保存变量的指针 
 * return: 0失败，1成功 
 */ 
int de_queue(QueueLink *queue, int *elem) 
{ 
    //判读队列是否为空 
    if (queue->front == queue->rear) { 
        printf("队列空，无元素可出。\n"); 
        return 0; 
    } 
    QueueNode *front_node = queue->front->next; //队头元素 
    //保存数据 
    *elem = front_node->data; 
    //队头元素出队（头删法） 
    queue->front->next = front_node->next; 
    //如果元素出完，队尾指针重新指向头结点 
    if (front_node == queue->rear) 
        queue->rear = queue->front; 
    free(front_node); 
} 
```

---

**遍历队列**

判断队列为空的是`rear==front`，借助临时变量 `i`，从队头下标开始逐个加一直到队尾下标结束。开始标志为：`i = front`、加一操作为：`i = (i + 1) % MAXSIZE`、结束标志为：`i % MAXSIZE = rear`

```c++
/** 
 * 打印队列 
 */ 
void output(QueueArray queue) 
{ 
    int i = queue.front; 
    while (i % MAXSIZE != queue.rear) { 
        printf("%d ", queue.data[i]); 
        i = (i + 1) % MAXSIZE; 
    } 
    printf("\n"); 
} 
```

如何计算顺序队列的长度。当然你可以遍历队列然后借助计数变量来存储长度，这样比较麻烦。因为顺序队列是使用数组实现的，所以顺序队列的长度我们可以直接根据下标计算出来。如果是一个非循环队列，那很简单，直接 `rear - front` 就是队列的长度了。

但求循环队列的长度就不能这样直接减了，**因为 `rear` 和 `front` 之间的位置关系是不确定的**。

![img](./35360e7b4a697063bf8ae0a74078e1bf.png)

左图 `rear < front`，我们可以将其长度看成两部分组成：

- 下标 `0` 到 `rear`，长度为` rear - 0`
- 下标 `MAXSIZE - 1 `到 `rear`，长度为` MAXSIZE - front`

所以长度为 `rear - front + MAXSIZE`。为了满足右图` rear > front `的情况，如果按照上式，则此时多加了一个 `MAXSIZE`，所以需要对其再对 `MAXIZE` 取余。所以循环队列的长度为` (rear - front + MAXSIZE) % MAXSIZE`(空队列也满足)。

**遍历链队列**

借助指针 p 从队头元素遍历至队尾元素即可。

```c++
/** 
 * 打印队列 
 */ 
void output(QueueLink *queue) 
{ 
    QueueNode *p = queue->front->next; //p指向队头元素 
    while (p != NULL) { 
        printf("%d ", p->data); 
        p = p->next; 
    } 
    printf("\n"); 
} 
```



## [栈](https://zhuanlan.zhihu.com/p/346164833)

栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于**它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。**

而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 `LIFO（Last In First Out）`结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），**我们首先要移开压在它上面的物体（放进去比较晚的物体）**。

堆栈中定义了一些操作。两个最重要的是`PUSH和POP`。`PUSH`操作在堆栈的顶部加入一个元素。`POP`操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。

![stack](./stack_1.png)

用数组实现栈的关键在于：我们可以直接使用一个数组来存储数据，并通过控制指针或索引来实现栈的先进后出（LIFO）功能。

- 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中直到子程序执行完后再将地址取出，以回到原来的程序中。  
- 递归的调用：可以用来在**函数调用的时候存储断点**， 储存下一个指令的地址外，也将参数、区域变量等数据存入栈中。  
- 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。  
- 二叉树的遍历。  
- 图形的深度优先搜索法。  

```c++
#include <iostream>
using namespace std;

const int N = 100; // 假设栈的最大容量为 100
int stk[N];        // 栈数组
int tt = -1;       // 栈顶指针，初始化为 -1，表示栈为空

// 插入数据到栈中
void push(int x) {
    if (tt + 1 >= N) {
        cout << "栈已满，无法插入新元素。" << endl;
    } else {
        stk[++tt] = x; // 先增加栈顶指针，再插入数据
    }
}

// 弹出栈顶数据
int pop() {
    if (tt < 0) {
        cout << "栈为空，无法弹出数据。" << endl;
        return -1; // 可以根据实际需求调整返回值
    } else {
        int topData = stk[tt]; // 保存栈顶数据
        tt--;                  // 栈顶指针减1
        return topData;        // 返回弹出的数据
    }
}

// 判断栈是否为空
bool isEmpty() {
    return tt < 0; // 如果栈顶指针小于0，表示栈为空
}

// 获取栈顶数据
int top() {
    if (tt < 0) {
        cout << "栈为空，无法获取栈顶数据。" << endl;
        return -1; // 可以根据实际需求调整返回值
    } else {
        return stk[tt]; // 返回栈顶数据
    }
}
```

### [括号配对](https://www.cnblogs.com/lonely-wolf/p/15783968.html)*

利用栈来验证一个字符串中的括号是否完全配对会非常简单，因为右括号一定是和最靠近自己的一个左括号配对的，这就满足了后进先出的特性。所以我们可以直接遍历字符串，遇到左括号就入栈，遇到右括号就看看是否和当前栈顶的括号匹配，如果不匹配则不合法，如果匹配则将栈顶元素出栈，并继续循环，直到循环完整个字符串之后，如果栈为空就说明括号恰好全部配对，当前字符串是有效的。

给定一个只包括` '('，')'，'{'，'}'，'['，']' `的字符串 s ，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合；左括号必须以正确的顺序闭合。

```c
// 定义栈结构
#define MAX_STACK_SIZE 1000

typedef struct {
    char data[MAX_STACK_SIZE];
    int top;
} Stack;

// 初始化栈
void initStack(Stack *stack) {
    stack->top = -1;
}

// 判断栈是否为空
bool isEmpty(Stack *stack) {
    return stack->top == -1;
}

// 入栈
void push(Stack *stack, char c) {
    if (stack->top < MAX_STACK_SIZE - 1) {
        stack->data[++(stack->top)] = c;
    }
}

// 出栈
void pop(Stack *stack) {
    if (!isEmpty(stack)) {
        stack->top--;
    }
}

// 获取栈顶元素
char peek(Stack *stack) {
    if (!isEmpty(stack)) {
        return stack->data[stack->top];
    }
    return '\0'; // 返回空字符，防止访问空栈
}

// 检查括号是否匹配
bool isValid(char *s) {
    if (s == NULL || strlen(s) == 0) {
        return false;
    }

    Stack stack;
    initStack(&stack);

    for (int i = 0; i < strlen(s); i++) {
        char c = s[i];
        if (c == '(' || c == '[' || c == '{') {
            // 左括号入栈
            push(&stack, c);
        } else {
            // 检查栈是否为空或是否匹配
            if (isEmpty(&stack)) {
                return false;
            }
            char top = peek(&stack);
            if ((c == ')' && top == '(') || 
                (c == ']' && top == '[') || 
                (c == '}' && top == '{')) {
                pop(&stack); // 配对成功则出栈
            } else {
                return false;
            }
        }
    }
    return isEmpty(&stack); // 若最终栈为空，说明所有括号匹配
}
```

### 表达式求值

算法表达式也是栈的一个经典应用场景，为了方便讲解，我们假设表达式中只有 `+、-、*、/` 四种符号，然后我们要对表示式 `18-12/3+5*4` 进行求解应该如何做呢？

其实这道题也可以利用两个栈来实现，其中一个用来保存操作数，称之为操作数栈，另一个栈用来保存运算符，称之为运算符栈。具体思路如下：

1. 遍历表达式，当遇到操作数，将其压入操作数栈。
2. 遇到运算符时，如果运算符栈为空，则直接将其压入运算符栈。
3. 如果运算符栈不为空，那就与运算符栈顶元素进行比较：如果当前运算符优先级比栈顶运算符高，则继续将其压入运算符栈，如果当前运算符优先级比栈顶运算符低或者相等，则从操作数符栈顶取两个元素，从栈顶取出运算符进行运算，并将运算结果压入操作数栈。
4. 继续将当前运算符与运算符栈顶元素比较。
5. 继续按照以上步骤进行遍历，当遍历结束之后，则将当前两个栈内元素取出来进行运算即可得到最终结果。

![img](./2232223-20220110125119483-1704837982.png)

给你一个有效的字符串表达式 s，请你实现一个基本计算器来计算并返回它的值，整数除法仅保留整数部分，s 由整数和算符 `('+', '-', '*', '/') `组成，中间由一些空格隔开。

```c
// 定义数字栈和运算符栈
typedef struct {
    int data[MAX_STACK_SIZE];
    int top;
} IntStack;

typedef struct {
    char data[MAX_STACK_SIZE];
    int top;
} CharStack;

// 初始化栈
void initIntStack(IntStack* stack) {
    stack->top = -1;
}

void initCharStack(CharStack* stack) {
    stack->top = -1;
}

// 判断栈是否为空
bool isIntStackEmpty(IntStack* stack) {
    return stack->top == -1;
}

bool isCharStackEmpty(CharStack* stack) {
    return stack->top == -1;
}

// 入栈
void pushInt(IntStack* stack, int value) {
    if (stack->top < MAX_STACK_SIZE - 1) {
        stack->data[++(stack->top)] = value;
    }
}

void pushChar(CharStack* stack, char value) {
    if (stack->top < MAX_STACK_SIZE - 1) {
        stack->data[++(stack->top)] = value;
    }
}

// 出栈
int popInt(IntStack* stack) {
    if (!isIntStackEmpty(stack)) {
        return stack->data[stack->top--];
    }
    return 0; // 空栈返回0作为默认值
}

char popChar(CharStack* stack) {
    if (!isCharStackEmpty(stack)) {
        return stack->data[stack->top--];
    }
    return '\0'; // 空栈返回空字符
}

// 获取栈顶元素
int peekInt(IntStack* stack) {
    if (!isIntStackEmpty(stack)) {
        return stack->data[stack->top];
    }
    return 0;
}

char peekChar(CharStack* stack) {
    if (!isCharStackEmpty(stack)) {
        return stack->data[stack->top];
    }
    return '\0';
}

// 定义运算符优先级
int precedence(char operator) {
    if (operator == '*' || operator == '/') {
        return 2;
    } else if (operator == '+' || operator == '-') {
        return 1;
    }
    return 0;
}

// 计算操作
int calculate(IntStack* numStack, char operator) {
    int num1 = popInt(numStack);
    int num2 = popInt(numStack);
    switch (operator) {
        case '+':
            return num2 + num1;
        case '-':
            return num2 - num1;
        case '*':
            return num2 * num1;
        case '/':
            return num2 / num1;
        default:
            return 0;
    }
}

// 解析并计算表达式
int calculateByTwoStack(const char* s) {
    IntStack numStack;
    CharStack operatorStack;
    initIntStack(&numStack);
    initCharStack(&operatorStack);
    
    int num = 0;
    int i = 0;
    while (s[i] != '\0') {
        char c = s[i];

        // 处理数字
        if (isdigit(c)) {
            num = num * 10 + (c - '0');
            if (s[i+1] == '\0' || !isdigit(s[i+1])) {
                pushInt(&numStack, num);
                num = 0;
            }
        }

        // 处理运算符
        if (c == '+' || c == '-' || c == '*' || c == '/') {
            while (!isCharStackEmpty(&operatorStack) && 
                   precedence(c) <= precedence(peekChar(&operatorStack))) {
                pushInt(&numStack, calculate(&numStack, popChar(&operatorStack)));
            }
            pushChar(&operatorStack, c);
        }
        i++;
    }

    // 处理剩余的运算
    while (!isCharStackEmpty(&operatorStack)) {
        pushInt(&numStack, calculate(&numStack, popChar(&operatorStack)));
    }

    return popInt(&numStack);
}
```

## [堆](https://juejin.cn/post/7134880984528814110)

堆是一种特殊的树，广泛应用于排序，搜索，优先级队列，求中位数等场景。堆总是一棵完全二叉树。标准定义上，我们认为**一颗树满足以下的两点**，就是一个堆

1. 一颗完全二叉树
2. 每个节点的值大于等于（或小于等于）其子树中每个节点的值

根据子节点与父节点值的大小关系，可以把堆分为，

1. 最大堆（也叫大根堆，大顶堆），任意父节点都比其子节点的值要大
2. 最小堆（也叫小根堆，小顶堆），任意父节点都比其子节点的值要小

![image](./186048020-a0087b3f-9e5e-437a-91ad-3381fecf5a08.png)

比如上图中， 1、2 为最大堆，3 是最小堆，4 不是堆。

**堆的实现**

要实现一个堆，我们可以先思考，**如何存储一个堆**。

树的存储方式一般有**链式存储**和**线性存储**，分别对应我们常见的**链表**和**数组**两种方式，对于完全二叉树而言，用**数组来存储是非常节省存储空间的**，因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点，所以堆我们一般也用**数组**来存储。

![img](./ee9432fcc1984c96afb5628c1ffc8ce1tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

假设我们从数组下标 `1` 开始存储，不难发现，对于下标为 `i` 的任意节点，存在以下关系，

```js
// 其左子节点的索引满足
var leftIndex = 2 * i;
// 其右子节点的索引满足
var rightIndex = 2 * i + 1;
// 其父节点的索引满足
var parentIndex = i / 2;
```

**为什么我们要从数组下标 1 开始存储，从 0 开始不行吗？**

当然可以，如果从 0 开始存储，在代码的实现上，只是计算子节点和父节点的下标的公式改变了，对于下标为 i 的任意节点，

```js
// 其左子节点的索引满足
var leftIndex = 2 * i + 1;
// 其右子节点的索引满足
var rightIndex = 2 * i + 2;
// 其父节点的索引满足
var parentIndex = i - 1 / 2;
```

那为什么我们不从下标 0 开始存储呢？我想你应该已经猜到答案了，这里与 **数组下标从 0 开始计数，而不是 1 开始** 有着异曲同工之妙，我们从下标 1 开始存储，每次计算子节点和父节点时，都可以**减少一次加法操作**，本质是为了提高代码的性能。

知道了如何存储一个堆后，我们接着来看**堆都支持哪些操作？**一般来说，堆有几个核心的操作，比如往堆中插入一个元素，删除堆顶元素。

**堆的插入**

往堆中插入一个元素后，为了保持堆的特性，我们需要对插入元素的位置进行调整，这个过程叫做**堆化（heapify）**，以最大堆为例，

![img](./186048214-0923059b-e1e6-4286-a518-8e8f5a1f1d07.png)

堆化的过程其实非常简单，比如上图中我们往最大堆中插入一个元素 “22”，为了保持堆的特性，只需要顺着节点所在的路径，向上与其父节点进行对比交换，直到满足大小关系即可，

![image](./186048354-e7a58d07-0dd6-4e47-8cde-0273dd0482ec.png)

```js
class Heap {
  constructor(n) {
    this.a = new Array(n); // 存储堆的数组，从下标 1 开始存储数据
    this.n = n; // 堆可以存储的最大数据个数
    this.count = 0; // 堆中已经存储的数据个数
  }

  insert(data) {
    // 堆满直接返回
    if (this.count >= this.n) return;
    // 为了最大性能的存储堆，并保证堆中节点与数组下标的关系，我们从下标 1 开始存储数据，所以这里是 ++count
    ++this.count;
    // 从数组末尾插入，然后开始堆化（heapify），这里是最大堆，我们从下往上堆化
    // 堆化的过程就是：用当前节点与父节点做比较，大于父节点就交换，直到小于父节点为止
    this.a[count] = data;
    var i = count;
    while (i / 2 > 0 && this.a[i] > this.a[Math.floor(i / 2)]) {
      swap(this.a, i, Math.floor(i / 2));
      i = Math.floor(i / 2);
    }
  }
}

// 交换数组 a 中下标为 i 和 j 的元素
function swap(a, i, j) {
  var temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}
```

往堆中插入数据我们解决了，如何从堆中删除数据呢？

**堆的删除**

堆中数据的删除我们可以先考虑**删除堆顶元素**。

从堆定义的第二条我们发现，堆顶元素存储的就是堆中数据的**最大值**或者**最小值**，以最大堆为例，最容易想到的是：删除堆顶元素后，把子节点中较大的元素放到堆顶，然后迭代地删除第二大节点，以此类推直到叶子节点被删除，

![image](./186048523-e9456484-29f7-44fd-b296-3aa7271f2f80.png)

这种方式有没有什么问题呢？

从上图我们发现，删除后可能会出现数组空洞，而且最后堆化出来的堆并不满足完全二叉树的特性，有没有更好的办法呢？这里我们可以尝试换一种思路，**先删除叶子节点**（最后一个元素），把它放到堆顶（与堆顶元素交换），然后**从上往下进行堆化**，

![image](./186048609-1623b054-3ec9-4cad-a57b-512a6bc393e4.png)

因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是**交换操作**，不会出现数组中的`空洞`，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。

```js
// 从上往下堆化
function heapify(a, n, i) {
  while (true) {
    var maxPos = i;
    // 找到左右子节点中的最大值
    if (i * 2 <= n && a[i] < a[i * 2]) maxPos = i * 2;
    if (i * 2 + 1 <= n && a[maxPos] < a[i * 2 + 1]) maxPos = i * 2 + 1;
    if (maxPos === i) break;
    // 交换堆顶元素和最大值，保证堆顶元素最大
    swap(a, i, maxPos);
    i = maxPos;
  }
}
```

这样一来，删除堆顶元素就很简单了

```js
function removeMax() {
  if (count === 0) return -1;
  // 交换叶子节点和堆顶元素，然后从上到下进行堆化
  a[1] = a[count];
  --count;
  heapify(a, n, 1);
}
```

如果我们要删除堆中的任意一个节点的元素，应该怎么做呢？

类似的，我们只需要将**数组的最后一个元素与要删除的节点元素互换**，然后从要删除的节点开始从上往下堆化即可，这里你可以试着实现一下。我们来讨论一下上面两个核心操作的时间复杂度。

首先，对于一个包含 `n `个节点的完全二叉树，树的高度不会超过 `log⁡2n`，堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，用大 O 复杂度表示法就是 `O(logn)`；**我们发现插入和删除主要逻辑就是堆化，其他操作都是常数级别的**

所以**往堆中插入一个元素和删除堆顶元素的时间复杂度都是**` O(log⁡n)`。

### **堆排序**

我们知道 [堆排序](https://link.juejin.cn/?target=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FHeapsort) 是时间复杂度为 `O(nlogn) `的原地排序算法，具体是怎么实现的呢？

堆排序的过程大致可以分为两步，**建堆**和**排序**。

**堆的构建**

建堆意味着我们需要将数组原地构建成一个堆，一般有两种思路，

1. 往堆中依次插入元素，我们假设起始堆中只包含一个数据，就是下标为 1 的数据，然后将下标从 2 到 n 的数据依次插入到堆中
2. 从最后一个非叶子节点开始，从上往下进行堆化

第一种思路是最容易想到的，我们需要遍历整个数组然后对每个数据进行插入操作，但时间复杂度较高，为 `O(nlog⁡n)`；第二种思路不太好理解，这里我们展开一下，

前面我们提到，对于完全二叉树，根据数组存储规律，不难发现**下标 `n/2+1` 到 `n` 的是叶子节点，下标 `1` 到 `n/2` 是非叶子节点**，叶子节点不需要堆化，这里我们只需要对非叶子节点进行堆化就可以构建堆， 还是以最大堆为例，

我们从最后一个非叶子节点开始，从上往下进行堆化

![image](./186048638-830a03c9-8860-473c-99bb-f186d95f8005.png)

![image](./186048645-2114a944-6850-4b88-b992-1eda8f0ef261.png)

```js
// 构建最大堆
function buildHeap(a, n) {
  // 根据完全二叉树数组存储的规律，下标为 1 到 n/2 的为非叶子节点
  // 为了保证堆的特性，我们从最后一个非叶子节点开始堆化
  for (var i = Math.floor(n / 2); i >= 1; --i) {
    heapify(a, n, i);
  }
}

// 从上往下堆化
function heapify(a, n, i) {
  while (true) {
    var maxPos = i;
    // 找到左右子节点中最大的元素，与当前节点交换
    if (i * 2 <= n && a[i] < a[i * 2]) maxPos = i * 2;
    if (i * 2 + 1 <= n && a[maxPos] < a[i * 2 + 1]) maxPos = i * 2 + 1;
    // 循环退出条件，当前节点已经是最大，不能继续往下堆化
    if (maxPos === i) break;
    swap(a, i, maxPos);
    i = maxPos;
  }
}

// 交换 a[i] 和 a[j]
function swap(a, i, j) {
  var temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}
```

我们知道每个节点堆化的时间复杂度是 `O(log⁡n)`，那 `n2+1` 个节点堆化的总时间复杂度是不是就是 `O(nlog⁡n)` 呢？

实际上，**建堆的时间复杂度是 O(n)**，为什么？我们来分析一下。

建堆的过程中叶子节点是不需要堆化的，所以需要堆化的节点是从倒数第二层开始，每一层我们需要比较和交换的次数，**和树的高度成正比**，

![image](./186048697-fbd4579f-d358-47f7-ba39-fd3f2cc0c0fb.png)

所以建堆的时间复杂度，就是除最后一层外，每层节点比较和交换的次数之和，

![image](./186048712-5ac371ec-8fde-459a-9f6b-26c94a2c8ed3.png)

这个公式的求解非常简单，我们把公式左右都乘以 2 得到另一个公式 `S2`，然后将 `S1` 和 `S2` 错位对齐求差值得到，

![image](./186048725-84f15b30-e502-458f-bcb7-f89a5652afac.png)

`S` 的后面部分是等比数列，带入等比数列的求和公式

![image](./2771fd2733a64180983eb22a97d2d94atplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

前面提到树的高度 `h=log⁡2n`，代入公式` S`，就能得到 `S=O(n)`，所以，建堆的时间复杂度是 `O(n)`。

**堆排序**

构建好堆后，排序就很简单了，我们发现数组中的第一个元素就是堆顶，也就是最大的元素，假设我们要从小到大对数据进行排序，应该怎么做呢？

是不是只需要把堆顶元素与最后一个元素（下标为 n 的元素）进行交换，这样最大的元素就排到了数组末尾，接着通过堆化的方法，将剩下的 n−1 个元素重新构建成堆；然后再取堆顶的元素，与倒数第二个元素（下标是 n−1 的元素）交换，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了，

![image](./186048763-5b2fc35a-e8ce-434b-be00-c4f42c6e9fbf.png)

```js
// 堆排序
function heapSort(a, n) {
  buildHeap(a, n);
  var k = n;
  while (k > 1) {
    // 交换堆顶和最后一个元素
    swap(a, 1, k);
    --k;
    // 交换后只有堆顶元素不符合堆的特性，这里我们只需要对堆顶节点堆化即可，而不用重新构建整个堆
    heapify(a, k, 1);
  }
}
```

我们来分析一下堆排序的空间，时间复杂度和稳定性，

- **堆排序是原地排序吗**？是，堆排序只需要存储极个别的变量，空间复杂度是 `O(1)`
- **堆排序的时间复杂度是多少**？前面我们提到，堆排序分为建堆和排序两个过程，建堆是 `O(n)`，排序是 `O(nlogn)`，根据加法法则，堆排序整体的时间复杂度为 `O(nlog⁡n)`
- **堆排序是稳定的排序算法吗**？不是，排序的过程我们会将堆顶元素与最后一个元素交换，这里是有可能改变值相同数据的原始相对顺序的

### Top K 问题

求 Top K 问题可以抽象为两类，**静态数据集合**和**动态数据集合**。针对静态数据，最经典的是，**如何在包含 n 个数据的数组中，查找前 k 大的数据呢？**

这里如果用堆来解决，思路是什么样的呢？我们可以维护一个大小为 k 的最小堆，然后顺序遍历数组，从下标为 k + 1 的元素开始，与堆顶元素进行比较，

- 如果比堆顶元素大，我们把堆顶元素删除，将这个元素插入到堆中
- 如果比堆顶元素小，则不做处理

这样数组遍历完后，堆中就是前 k 大的数据，

```js
// 交换元素
function swap(a, i, j) {
  var temp = a[i];
  a[i] = a[j];
  a[j] = temp;
}

// 堆化
function heapify(a, n, i) {
  while (true) {
    var minPos = i;
    if (2 * i <= n && a[i] > a[2 * i]) minPos = 2 * i;
    if (2 * i + 1 <= n && a[minPos] > a[2 * i + 1]) minPos = 2 * i + 1;
    if (minPos === i) break;
    swap(a, i, minPos);
    i = minPos;
  }
}

// 构建堆
function buildHeap(a, n) {
  for (var i = Math.floor(n / 2); i >= 1; --i) {
    heapify(a, n, i);
  }
  return a;
}

// 利用堆求 Top K 问题
function findTopK(a, k) {
  // 从数组下标 1 开始构建堆，减少一次获取节点时的加法操作
  a.unshift(null);
  var len = a.length;
  // 构建 k 个元素的最小堆
  var minHeap = buildHeap(a, k);
  // 从第 k + 1 个元素开始比较，如果大于堆顶元素，替换堆顶元素，再次构建堆
  // 这里和之前思路一样，替换堆顶元素后只有堆顶元素不符合堆的特性，所以我们不需要重新构建整个堆，只需要对堆顶元素再次堆化即可
  for (var i = k + 1; i < len; i++) {
    if (a[i] > minHeap[1]) {
      swap(minHeap, i, 1);
      heapify(minHeap, k, 1);
    }
  }
  // 当前堆的 (1, k + 1) 元素就是 topk
  var topk = minHeap.slice(1, k + 1);
  return topk;
}

// var a = [7, 5, 19, 8, 4, 1, 20, 13, 16, 33, 44, 5, 3, 1, 2, 23];
// var topk = findTopK(a, 5);
// console.log(topk);
```

上面利用堆求 Top K 的时间复杂度是多少呢？我们来简单分析一下，

首先这里我们只对 k 个元素构建了最小堆，每次堆化的时间复杂度为 `O(logk)`，建堆 `(0,k)`和遍历数组 `(k+1,n)` 整体的时间复杂度为 `O(n)`，所以通过上述方式求 `Top K` 的时间复杂度为 `O(nlog⁡k)`，其中 `n` 是静态数据的大小。

当然，实际的应用场景中我们可能会遇到动态数据集合，**如何针对动态数据求 Top K 呢？**

动态数据求 Top K 其实就是求实时 Top K，想象一下，如果我们每次都基于当前动态数据重新去计算的话，那时间复杂度就是` O(nlog⁡k)`；有没有什么办法能更高效地查询 `Top K `呢？

有。实际上，我们可以**一直维护一个大小为 k 的最小堆**，当有数据被添加到集合中时，我们就拿它与堆顶元素进行对比，跟前面类似的，

- 如果比堆顶元素大，把堆顶元素删除，将这个元素插入到堆中
- 如果比堆顶元素小，则不做处理

这样，每次数据添加的时候，其实只做了一次常数级别的堆化处理，带来的好处是，无论任何时候查询 Top K，我们都可以在 `O(1)` 的时间复杂度内立即返回。

## 字符串

搜索引擎常用的自动补全功能就是一种字符串匹配的应用，因此我们需要理解字符串这一数据结构。**字符串（串）是由零个或多个字符组成的有限序列，通常记作：s = "a₁a₂...aₙ"，其中 n 为字符串的长度，n≥0。如果 n=0，则称为空串**，用 `""` 表示。

需要注意的是，**空格串**虽然只包含一个或多个空格字符，但它与空串不同，空格串是有实际内容的

### 串的存储结构

在计算机中，字符串通常存储在一组地址连续的存储单元中。使用定长数组定义字符串是常见的做法，**这样的数组有一个固定的最大长度，但实际字符串的长度通常小于这个最大值。为了处理这个问题，我们需要记录实际字符串的长度，有时这个长度信息存储在数组的第一个元素（索引 0）处**，或者存储在最后一个元素的位置。字符串通常以 `'\0'`（空字符）结尾，以标示字符串的结束。

然而，使用 `'\0'` 来标记字符串结束存在潜在的风险：如果不慎遗漏了 `'\0'`，会导致指针越界，从而引发不可预期的错误或安全隐患。为了避免这种情况，**在 C 语言中，我们通常将字符串封装到结构体中。**这个结构体通常包含两个元素：

1. **字符数组**：用于存储字符串内容。
2. **长度信息**：用于记录字符串的实际长度。

#### 定长顺序存储

采用字符数组将串中的字符序列一次连续存存储在数组中的相邻但愿中，常量串和变量串的存储结构不同，数组容量`length`分半等于或者大于串长度`n.`

![img](./319374-20190616213752038-575686437.png)

顺序存储的串具有随机存取特效，存取指定位置字符的时间复杂度为` O(1)` ，**缺点是插入和删除元素时需要移动元素，平均移动数据量是串长度的一半**，当数组容量不够时，需要重新申请一个更大的数组，并复制原来数组中的所有元素，插入和删除操作的时间复杂度为`O(n)`

#### 链式存储结构

串的链式存储结构：**有单字符串链表和块链表两种，但字符串链表是每个节点的数据域只包含一个字符的单链表，块链表是每个节点的数据域包含若干个字符的单链表。**链式存储的串，存取指定位置字符的时间复杂度为 O(n)，单字符链表虽然插入/删除操作不需要移动元素，**但是占用存储空间太多，块链表的插入和删除操作需要移动元素，效率低。**

![img](./319374-20190616213819903-893272696.png)

### 字符串匹配

在进行文本编辑时候，我们经常查找和替换，在文档的指定范围内查找一个单词的位置，用另一个单词替换，**替换操作的前提是查找操作，如果查找到指定单词，则确定了操作位置，可以将指定单词用另一个单词替换掉，否则不能进行替换操作**，每进行一次替换操作，都需要执行一次查找操作，那么如何快速查找指定单词在文档中的位置呢，就是**串的模式匹配算法**需要解决的问题，

设有2个串，目标串`target `和模式串 `pattern` ,在目标串`target`中查找与模式串`pattern`相等的一个子串并确定该子串的操作称为 串的模式匹配，两个子串相等指的是：长度相等且对应各个字符相同，匹配结果有两种 如果target存在pattern相等的子串，则匹配成功 获得该子串在target中的位置，否则匹配失败给出失败信息。

#### [BF算法](https://juejin.cn/post/6854573219106521101)

BF 算法，亦即 `Brute Force` 暴力算法，是普通的模式匹配算法。BF 算法的思想就是将文本串 `s` 的第一个字符与模式串 `p` 的第一个字符进行匹配：

- 若相等，则继续比较 `s` 的第二个字符和 `p` 的第二个字符
- 若不相等，则比较 `s` 的第二个字符和 `p` 的第一个字符

依次比较下去，直到得出最后的匹配的结果。

BF 算法是一种蛮力算法，没有任何优化，就是用两层循环的比较，当字符串比较大的时候，**执行效率就非常低下**，不适合比较非常大的字符串。

```c++
#include <iostream>
#include <string>

using namespace std;

// Brute-Force算法实现字符串匹配
int bruteForceSearch(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();

    for (int i = 0; i <= n - m; i++) {
        int j;
        for (j = 0; j < m; j++) {
            if (text[i + j] != pattern[j])
                break;
        }
        if (j == m) // 找到完全匹配
            return i;
    }

    return -1; // 未找到匹配
}

```

#### [KMP算法](https://www.xdull.cn/kmp.html)

在 KMP 算法中，当发现字符不匹配时，不会重新从头开始比较，因为之前已经匹配的部分提供了有用的信息。利用这些信息，子串可以直接移动到合适的位置继续比较，从而避免了重复操作。**KMP 的时间复杂度为 `O(m+n)`**，即与两个字符串长度之和成线性关系。接下来我们来讨论着**有用的信息是什么**

1. **字符串的前缀后缀**

字符串匹配的过程就是模式串指针不断移动的过程，在BF算法中，通过两个指针分别维护目标串和模式串。匹配成功两个串的指针就向右移动一格。**匹配失败，则模式串指针归`0`**，目标串的指针前进一格。记录这个前后缀的**目的就是让模式串的指针不会一下就掉到0**，而是采用`next`数组回跳到一个大于模式串起点的位置。这个`next`数组就是采用前缀后缀构成的。

对于字符串 `ababc` 来说，它的前缀有 `[a,ab,aba,abab]`，也就是以字符串第一个字符作为开头，**同时不包括最后一个字符的所有子串**，同理它的后缀有 `[c,bc,abc,babc]`，也就是以字符串**最后一个字符作为结尾，同时不包括第一个字符的所有字串**。

了解了这个，我们再来说什么是字符串的**最长公共前后缀**，说白了，也就是前缀和后缀这 `2` 个集合中的相同部分，同时取最长的那个，就是这个字符串的**最长公共前后缀**。显然，在这个例子中，`ababc` 是没有公共前后缀的。但是对于 `abab`，它的前缀和后缀分别是 `[a,ab,aba]` 和 `[b,ab,bab]`，那么它的**最长公共前后缀**就是 `ab`。

现在，我们的目标就是取得 `ababc` 所有子串 `[a,ab,aba,abab,ababc]` 的**最长公共前后缀**的长度，分别保存在 `next` 数组中，我们**只要知道最大长度即可**，并不用关心串具体是什么，而我们目前通过观察即可得出 `next` 数组这里是 `[0,0,1,2,0]`。

2. **next数组的作用**

得到这个数组有什么用，当我们第一次碰到不匹配时（`i` 和 `j` 都等于 3 的时候）

![img](./2.jpg)

此时` i` 和 `j` 之前的` 3` 个字符 `aba` 必然完全匹配的，因为只有前面匹配成功了 `j` 才能走到 3，**这样我们就知道了主串的后缀信息**，而我们又知道 `aba` 的最长公共前后缀是 `a`，这可以给我们一个很好的提示，**主串**中的 `aba` **的后缀**和**子串**中的 `aba` **前缀**有最长的公共部分 `a`，这样一来，我们就没必要**让重新比较了，直接将相同部分对齐就好了**，也就是说让` j `退回到位置 `1 `就可以了，而 `i `保持不变。

> 前后缀的目的是通过比较目标串的后缀和模式串的前缀来优化匹配过程。也就是匹配失败的时候，**子串的前缀位置退回到与主串相同后缀位置**。

![img](./7.jpg)

分析一下，为什么` j `知道应该**退回**到位置 `1`：

1. 我们知道` j` 是在位置 `3 `不匹配的，那么` j `前面的字符串我们可以知道是 `aba`
2. 前面我们已经得到了 `next` 数组，知道 `aba` 的最长公共前后缀长度是 `1`
3. 也就是说，我们可以知道` i `之前 `1 `个位置（**主串的后缀**）和子串开头之后 `1 `个位置（**子串的前缀**）是相同的
4. **进而我们可以让相同部分对齐，也就是让 `j=next[j-1]`**

接下来，我们发现` i `和` j `仍然不匹配，而 `j `之前的字符 `a` 最长公共前后缀是 `0`，此时` j `退到位置 `0`（模式串前进一步），`i `仍然保持不变。

![img](./8.jpg)

`i `和` j `匹配，同时右移一格

![img](./18.jpg)

此时` i` 和`j `不匹配，`j=next[j-1]` 回退到 `0`，然后我们发现 i 和 j 仍然不匹配，同时 `j `已经是 `0` 了，那么我们就让` i `往右移动一格。这里就和`BF`算法一样了。

![img](./9.jpg)

可以看到，相比于暴力解法，`i` 始终在前进，并没有后退（顶多保持不变），然后我们通过 `next` 数组来改变` j `的值，使得主串的后缀和匹配串的前缀相同的位置拟合。

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// 计算模式串的 next 数组
vector<int> computeNext(const string &pattern) {
    int m = pattern.size();
    vector<int> next(m, 0);
    int j = 0; // 前缀指针
    for (int i = 1; i < m; i++) {
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            j++;
        }
        next[i] = j;
    }
    return next;
}

// KMP 字符串匹配函数
int strStr(const string &text, const string &pattern) {
    vector<int> next = computeNext(pattern); // 获取 next 数组
    int n1 = text.size();
    int n2 = pattern.size();

    if (n2 == 0) {
        return 0; // 如果模式串为空，返回 0
    }

    int i = 0, j = 0; // i 指向文本串，j 指向模式串
    while (i < n1) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        } else {
            if (j > 0) {
                j = next[j - 1]; // 根据 next 数组更新模式串指针
            } else {
                i++;
            }
        }
        if (j == n2) {
            return i - n2; // 找到匹配，返回匹配的起始位置
        }
    }
    return -1; // 如果未找到匹配，返回 -1
}

int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";
    int index = strStr(text, pattern);
    cout << "Pattern found at index " << index << endl;
    return 0;
}
```

**求解`next`数组**

最后，我们还剩下一个问题，如何求` next` 数组，也就是求模式字符串各个子串的最长公共前后缀长度。

我们先初始化一个和模式字符串长度相等的 `next` 数组，在` next `数组中，第 `1` 位默认为 `0`，因为我们规定只有一个字符的字符串没有前缀和后缀，自然公共前后缀长度只能是 `0`。我们依然设定 `2 `个指针` i` 和` j`，`j` 指向位置 `0`，`i `从位置 `1 `开始依次为 `next `数组进行赋值

![img](./11.jpg)

我们可以把这个过程依然看作是 2 个字符串的比较，`j` 指向的是**模式**字符串的**前缀**，而 `i `指向的是**模式**字符串的**后缀**

![img](./12.jpg)

**和上面的字符串匹配一样，我们执行同样的处理：**

1. 当 `i` 和` j` 匹配时，`i` 和 `j` 同时右移一格
2. 当` i `和` j `不匹配时，如果` j `不在字符串开头（位置 `0`），**就回退到上一个能匹配到的位置**
3. 当` i `和` j `不匹配时，如果` j `在字符串开头（位置 0），那么 `i `就右移一格

对` next [1]` 赋值：`i `和 `j `不匹配，同时` j `已经是字符串开头，赋值 0

![img](./13.jpg)

对 `next [2] `赋值，`i `和` j` 匹配，此时` j` 为` 0`，代表只有 `1` 个字符匹配 (`j+1`)，赋值 `1`

![img](./14.jpg)

对 `next [3]` 赋值，`i` 和` j` 匹配，此时` j` 为` 1`，代表有 `2 `个字符匹配 **`(`j+1`)`**，赋值 `2`

![img](./15.jpg)

对 `next [4]` 赋值，`i` 和 `j` 不匹配，此时 `j` 为 `2`，可以得知 `j` 前面的字符是 `ab`，而 `ab` 的最长公共前后缀长度就是 `next[1]`，这个值我们前面已经求得了结果是 `0`，所以` j `回退到位置 `0`，用代码表示就是 `j=next[j-1]`

![img](./16.jpg)

此时 `i `和` j `仍然不匹配，但是` j `已为` 0`，无法继续回退，所以直接对 `next [4]` 赋值为` 0`

![img](./17.jpg)

实际上，我们在求解模式字符串 `ababc` 的最长公共前后缀长度的时候，不可避免的会对它的子串进行求解，这样可以方便在不匹配时进行回退，这也是动态规划的思想，要求的结果可以用先前已经求得的结果得出。而我们本身就是要对模式字符串的各个子串进行求解，所以可谓一举两得。

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// 计算模式串的 next 数组
vector<int> computeNext(const string &pattern) {
    int n = pattern.size();
    vector<int> next(n, 0);
    int i = 1, j = 0; // i 用于遍历模式串，j 记录最长前缀也是后缀的长度

    while (i < n) {
        if (pattern[i] == pattern[j]) {
            j++;
            next[i] = j; // 更新 next 数组
            i++;
        } else {
            if (j > 0) {
                j = next[j - 1]; // 根据 next 数组回退
            } else {
                next[i] = 0; // 如果 j 为 0，设置 next[i] 为 0
                i++;
            }
        }
    }
    return next;
}

int main() {
    string pattern = "ABABCABAB";
    vector<int> next = computeNext(pattern);

    // 输出 next 数组
    cout << "Next array: ";
    for (int val : next) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

对比一下上一段的字符串匹配代码，可以发现，2 段代码的执行逻辑几乎一模一样，不同之处只是我们在比较过程中插入了对 `next` 数组进行赋值的代码。

可以这样理解，在字符串匹配中，`i `指向的是主串，`j `指向的子串，比较的是主串和子串。而在求公共前后缀的时候，**我们相当于把模式字符串拆成了前后两部分**，同样是对这 2 部分进行字符串匹配，**相当于自己比自己**。

以上就是 KMP 算法的核心原理及实现，当然，实现方式并不是只有这一种，KMP 的实现算法多种多样，包括生成的 `next` 数组都会不一样.

1. KMP 通过**计算模式字符串自身得到 next 数组；**
2. 不匹配时**通过 next 数组信息进行回退**，而**不用再从头开始比较**；
3. 原理就是利用模式字符串的公共前后缀信息，所以算法是奏效的。

![KMP算法拟人化演示](./1460000022642186-1723804032866-34.gif)
