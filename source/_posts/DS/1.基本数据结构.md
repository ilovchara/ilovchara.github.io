---
title: 基本数据结构
date: 2023-04-27 14:48:19
description: 包括线性表，队列，堆栈，还有字符串
typora-root-url: 1.基本数据结构
categories: 算法
tags: 数据结构
---

# 数据结构

## 指针

指针在链表和其他使用地址的复杂数据结构（如树、图）中非常常用。指针的主要作用是存储和访问内存地址，使程序能够动态地管理数据结构中的元素。关键点在于理解指针的声明和使用是两个独立的概念：

> 用于遍历数据结构的指针，也需要和对应数据结构的类型相同。就像是量我们的铅笔，我们需要用厘米尺而不是分米尺。

1. **指针的声明**：指针的声明告诉编译器变量是一个指针类型，并指定它将指向的内容类型。这一步只是定义了指针，而没有赋予它实际的地址。
2. **指针的使用**：指针使用的过程中包括为指针分配内存地址和通过指针访问或修改该地址处的数据。指针操作需要小心，因为不正确的操作可能导致内存泄漏或访问非法内存。

```c++
//1.在声明的时候表示声明了一个指针变量
int *p
    
//2.在使用的时候，表示value内存地址的值
int value = *p;
```

在解题和使用数据结构时，经常会看到`->`符号。这个符号实际上是一个复合符号，称为"成员对象访问操作符"。它的作用是通过指针访问结构体或类的成员。

实际上，`->`是对`(*p).`的简化表达。`(*p).`先解引用指针`p`（即获取`p`指向的对象），然后访问该对象的成员。而`->`操作符将这两个步骤合并成一个更直观、更简洁的操作，使代码更易读。也就是说，假设有一个结构体的数据`data`，**被我们指向了，那么就是调用这个结构体指定位置的数据。**

```c++
#include <stdio.h>

struct Point {
    int x;
    int y;
};

int main() {
    struct Point p = {1, 2};
    struct Point *ptr = &p;

    // 使用 `->` 访问结构体成员
    printf("x: %d, y: %d\n", ptr->x, ptr->y);
    return 0;
}
```

**在链表中，当看到`p->next =`这样的代码时，可以直观地理解为“当前`p`指针所指节点的下一个节点是什么。”类似地，`p->prior`这样的代码可以理解为“`p`指针所指节点的上一个节点是什么。”**

具体指定的变量要看指定数据结构的定义。

## 线性表

线性表是具有相同数据类型的数据元素构成的有限序列，如果用n表示表长，则`n=0`的时候线性表是一个空表。线性表最主要的特点如下：

- 除了第一个元素，每一个元素都由其直接前驱
- 除了最后一个元素，每个元素都有直接后继
- 由于存储的数据类型都相同，所以说每一个数据元素占据的内存区域大小是一致的
- 逻辑结构决定的线性表数据元素之间的关系，物理结构决定线性表使用内存的能力

常见的线性表有：数组、单链表、双链表、循环链表等等

> 以上的线性表的差别可能要从逻辑结构和物理结构来讨论

### [单链表](https://blog.51cto.com/u_15018701/2616916)

**链表是一种常见且基础的数据结构，是一种线性表，但是他不是按线性顺序存取数据，而是在每一个节点里存到下一个节点的地址。**也可以这样理解，链表是通过指针串联在一起的线性结构，每一个链表结点由两部分组成，数据域及指针域，链表的最后一个结点指向`null`。也就是我们所说的空指针。

链表和数组不同的在于他们的索引，数组所用的索引是数组下标，而链表的索引是他们下一个数据的位置。每一个位置存储当前的值和下一个位置的地址。

> 实际上，数组和链表都使用索引来访问元素，但在物理存储方面有很大不同。数组在内存中分配一块连续的空间存储数据，**因此元素之间的距离很小**，可以直接通过开头位置的索引计算下一个元素的位置，无需使用指针。**而链表的元素在内存中分布是离散的**，难以计算下一个元素的位置，所以说需要使用指针。每个节点通过指针连接到下一个节点，因此需要指针来找到和链接每个数据元素。

![链表看这一篇真的就够了！](./resize,m_fixed,w_1184-1693299787406-13-1723804032864-1.webp)

一个单向链表包含两个值: 当前节点的值和一个指向下一个节点的链接。我们通过上面说到的可视化表示方法，将单链表可视化，如图所示：

![链表看这一篇真的就够了！](./resize,m_fixed,w_1184-1723804032865-2.webp)

#### 链表头部插入

**头指针**是链表结构中的一个关键元素，位于链表的头部。引入头指针有以下两个主要优点

- 头指针存储链表第一个节点的地址，使得我们能够始终找到链表的起点。这是操作链表的基础，无论是遍历、插入、删除等操作，都需要**从头指针开始**。

- 头指针的引入简化了链表操作逻辑。**无论链表是空的还是非空的，头指针始终存在。**对于空表，头指针指向`null`；对于非空表，头指针指向第一个节点。这种设计使得链表的操作更加一致和简洁。例如，**在插入节点时**，无需特别检查链表是否为空，因为操作总是从头指针开始。

**链表头部插入元素**：在链表第 1 个链节点之前插入值为 val 的链节点。

1. 先创建一个值为 val 的链节点 node
2. 然后将 node 的 next 指针指向链表的头节点 head。
3. 再将链表的头节点 head 指向 node。

> 头结点是标注链表中的第一个位置！！！！！头结点只是一个指针变量，把它理解为遍历的起点

![链表头部插入元素](./202405092231514.png)

```c++
struct Node {
    int data;
    Node* next;
};

class LinkedList {
private:
    Node* head; // 头指针声明在这里
public:
    LinkedList() : head(nullptr) {} // 初始化head为nullptr

    void insert(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        // newNode 是一个指针变量
        head = newNode; // 头指针变为第一个节点
    }
};
```

#### 链表尾部插入

**链表尾部插入元素**：在链表最后 1 个链节点之后插入值为 val 的链节点。

1. 先创建一个值为 val 的链节点 node。
2. 使用指针 cur 指向链表的头节点 head
3. 通过链节点的 next 指针移动 cur 指针，从而遍历链表，直到 cur.next 为 None。
4. 令 cur.next 指向将新的链节点 node。

![链表尾部插入元素](./202405092232023.png)

```c++
struct Node {
    int data;
    Node* next;
};

class LinkedList {
private:
    Node* tail; // 尾指针声明在这里
public:
    LinkedList() : tail(nullptr) {} // 初始化tail为nullptr

    void insert(int value) {
        Node* newNode = new Node(value);

        // 如果链表为空
        if (tail == nullptr) { 
            // 尾指针指向newNode - Node是一个指针变量
            tail = newNode;
        } else {
            tail->next = newNode; // 将新节点添加到链表末尾
            tail = newNode;       // 更新尾指针
        }
    }
};
```

#### 插入操作

**链表中间插入元素**：在链表第 i 个链节点之前插入值为 val 的链节点。

1. 使用指针变量 cur 和一个计数器 count。令 cur指向链表的头节点，count 初始值赋值为 0。
2. 沿着链节点的 next 指针遍历链表，指针变量 cur 每指向一个链节点，计数器就做一次计数。
3. 当遍历到` index-1` 个链节点时停止遍历。
4. 创建一个值为 val 的链节点 node。
5. **将 node.next 指向 cur.next。**
6. **然后令 cur.next 指向 node。**

![链表中间插入元素](./202405092232900.png)

```c++
    // 插入指定位置的元素
    void insert(int index, int value) {
        if (index < 0) {
            cout << "Error: Index out of bounds." << endl;
            return;
        }
	   // 标注节点的位置
        Node* newNode = new Node(value);

        Node* cur = head;
        int count = 0;
	   // cur表示表的位置必须要存在
        while (cur && count < index - 1) {
            count++;
            cur = cur->next;
        }
	   // cur遍历到的位置是index-1
        newNode->next = cur->next; // 这两条代码不能交换次序，原因是需要先收集cur的信息
        cur->next = newNode;
    }
```

#### 改变元素

将链表中第 i 个元素值改为 val ：首先要先遍历到第 i 个链节点，然后直接更改第 i 个链节点的元素值。具体做法如下：

1. 使用指针变量 cur  和一个计数器 count。令 cur 指向链表的头节点，count初始值赋值为 0。
2. 沿着链节点的 next 指针遍历链表，指针变量 cur 每指向一个链节点，计数器就做一次计数。
3. 当遍历到第 index 个链节点时停止遍历。
4. 直接更改 cur 的值 val。

```c++
// 更改指定位置的节点数据
    void change(int index, int value) {
        // 第一个位置
        Node* cur = head;
        int count = 0;

        // 用指针变量遍历链表
        while (cur != nullptr && count < index) {
            cur = cur->next;
            count++;
        }

        // 如果找到目标节点，更新其数据
        if (cur != nullptr) cur->data = value;
        
    }
```

#### 删除操作

链表的删除元素操作与链表的查找元素操作一样，同样分为三种情况：

- **链表头部删除元素**：删除链表的第 1 个链节点。
- **链表尾部删除元素**：删除链表末尾最后 1 个链节点。
- **链表中间删除元素**：删除链表第` i `个链节点。

接下来我们分别讲解一下。

> **链表头部删除元素**：删除链表的第 1 个链节点。
>
> 直接将 self.head 沿着 next 指针向右移动一步即可。

![链表头部删除元素](./202405092231281.png)

```c++
    // 删除链表头部的元素
    void removeFront() {
        if (head) {
            Node* temp = head; // 临时指针保存头节点
            head = head->next; // 更新头指针为下一个节点
            delete temp;        // 释放原头节点的内存
        }
    }
```

> **链表尾部删除元素**：删除链表末尾最后 1 个链节点。
>
> - 先使用指针变量 cur 沿着 next 指针移动到倒数第 2 个链节点。
>- 然后将此节点的 next 指针指向 null 即可。
> - 「链表尾部删除元素」的操作涉及到移动到链表尾部，操作次数为 n−2次，因此，「链表尾部删除元素」的时间复杂度为 O(n)。
>

![链表尾部删除元素](./202405092232050.png)

```c++
// 删除链表尾部的元素
    void removeRear() {
        if (head == nullptr || head->next == nullptr) {
            // 链表为空或只有一个节点
            if (head != nullptr) {
                delete head; // 释放唯一节点的内存
                head = nullptr;
            }
            return;
        }

        Node* cur = head;
        // 遍历到倒数第二个节点
        while (cur->next->next != nullptr) {
            cur = cur->next;
        }

        // 删除最后一个节点
        Node* temp = cur->next;
        cur->next = nullptr; // 更新倒数第二个节点的 next 指针
        delete temp; // 释放最后一个节点的内存
    }
```

> **链表中间删除指定节点**：删除链表第 i 个链节点。
>
> 1. 先使用指针变量 cur 移动到第 i−1个位置的链节点。
> 2. 然后将 cur 的 next 指针，指向要第 i 个元素的下一个节点即可。

![链表中间删除元素](./202405092233332.png)

```c++
    // 删除指定位置的节点
    void removeInside(int index) {
        if (index < 0) {
            cout << "Error: Index out of bounds." << endl;
            return;
        }

        if (index == 0) { // 删除头部节点的特殊情况
            if (head) {
                Node* temp = head;
                head = head->next;
                delete temp;
            }
            return;
        }

        Node* cur = head;
        int count = 0;

        // 遍历到删除节点的前一个节点
        while (cur != nullptr && count < index - 1) {
            cur = cur->next;
            count++;
        }

        if (cur == nullptr || cur->next == nullptr) {
            cout << "Error: Index out of bounds." << endl;
            return;
        }

        Node* delNode = cur->next;
        cur->next = delNode->next;
        delete delNode;
    }
```

链表是最基础、最简单的数据结构。**「链表」** 是实现线性表的链式存储结构的基础。它使用一组任意的存储单元（可以是连续的，也可以是不连续的），来存储一组具有相同类型的数据。

链表最大的优点在于可以灵活的添加和删除元素。

- 链表进行访问元素、改变元素操作的时间复杂度为 O(n)。
- 链表进行头部插入、头部删除元素操作的时间复杂度是 O(1)。
- 链表进行尾部插入、尾部删除操作的时间复杂度是 O(n)。
- 链表在普通情况下进行插入、删除元素操作的时间复杂度为 O(n)。

### 双链表

> 只需要知道就很好理解
>
> - 头指针指向第一个位置，尾指针指向最后一个位置
>
> - 对于声明的新节点，需要声明其指针变量，好标注它的位置

在单链表的基础上，加一个指向后继的指针。

- 每个节点需要存储两个指针（`next`和`prev`），因此在存储相同数量的元素时，双向链表比单向链表消耗更多的内存。
- 在双向链表中，在任意位置插入或者删除节点时，可以直接调整相邻节点的`next`和`prev`指针，无需访问链表的头部。这使得插入操作更为简便。

![image.png](./7c0d280244b244ae9d46d3e9843c9b1dtplv-k3u1fbpfcp-zoom-in-crop-mark1512000-1723804032865-5.webp)

依据上图，可以简单得出双链表的节点定义

```c++
struct Node {
    int data;
    // 下一个位置
    Node* next;
    // 前一个位置
    Node* prev;

    Node(int value) : data(value), next(nullptr), prev(nullptr) {}
};
```

#### 插入操作

插入操作根据插入的位置不同他们的时间复杂度不同

> 在头部插入节点：
>
> - 创建一个新节点 `new_node`。
> - 设置 `new_node.next` 为当前的头节点 `head`。
> - 如果**头节点** `head` 不为 `None`，将 `head.prev` 设置为 `new_node`。
>
> > 头指针尾Node表示这个链表为空
>
> - 将 `new_node.prev` 设置为 `None`。
> - 更新链表的头节点为 `new_node`。

```c++
class DoublyLinkedList {
public:
    Node* head;

    DoublyLinkedList() : head(nullptr) {}

    // 用头插法给链表加入数据
    void insertAtHead(int data) {
        // 指针变量 - 标注位置信息
        Node* newNode = new Node(data);
        newNode->next = head; // 新节点的 next 指向当前头节点
	    newNode->prev = nullptr; // 新节点的 prev 应该指向 nullptr，因为它是新的头节点
        
        // 判别链表为空
        if (head != nullptr) {
            // 如果当前头节点不为空，则将其 prev 指向新节点
            head->prev = newNode;
        }
        // head永远指向第一个节点
        head = newNode; 
    }
};
```

> 在指定位置插入节点：
>
> - 创建一个新节点 `new_node`。
> - 设置 `new_node.next` 为 `node.next`。
> - 如果 `node.next` 不为 `None`，将 `node.next.prev` 设置为 `new_node`。
> - 设置 `new_node.prev` 为 `node`。
> - 设置 `node.next` 为 `new_node`。

![image-20240724220805198](./image-20240724220805198-1723804032865-6-1723911810219-15.png)

与单链表相比，双链表的操作需要控制四个指针，具体操作如下。

```c++
// 指定位置 插入数据
void insertAtPosition(int position, int data) {
    if (position <= 0) {
        return;  // 无效位置
    }
    
    Node* newNode = new Node(data);
    Node* current = head;

    // 如果插入的是第一个位置，直接调用 insertAtHead 方法
    if (position == 1) {
        insertAtHead(data);
        return;
    }

    // 遍历到指定位置的前一个节点，前一个节点！！！
    for (int i = 1; i < position - 1; i++) {
        if (current == nullptr) {
            delete newNode;  // 位置超出链表长度，释放新节点
            return;
        }
        current = current->next;
    }

    // 在指定位置插入新节点，这里的current是指定位置前一个节点
    newNode->next = current->next;
    if (current->next != nullptr) {
        current->next->prev = newNode;
    }
    current->next = newNode;
    newNode->prev = current;
}
```

#### 删除操作

如果是用数组模拟的双链表，删除只是把数据从数组中`隐去`而已，这里还是按照用链表实现的方法。通常链表会有一个指针域和一个数据域。我们需要在解除掉q指针之前交换所有的数据信息。

![image-20240728211551398](./image-20240728211551398-1723804032865-7.png)

```c++
class DoublyLinkedList {
public:
    Node* head;

    DoublyLinkedList() : head(nullptr) {}

    // 删除指定节点
    void deleteNode(Node* node) {
        if (node == nullptr) {
            // 如果节点为空，则什么都不做
            return;
        }

        // 如果要删除的节点是头节点
        if (node == head) {
            head = node->next; // 更新头节点
            if (head != nullptr) {
                head->prev = nullptr; // 如果头节点不为空，则更新新头节点的 prev 指针
            }
        } else {
            // 如果要删除的节点不是头节点，这里可以理解为把node节点的信息利用收集起来
            if (node->prev != nullptr) {
                node->prev->next = node->next; // 更新前一个节点的 next 指针
            }
            if (node->next != nullptr) {
                node->next->prev = node->prev; // 更新下一个节点的 prev 指针
            }
        }

        // 删除节点
        delete node;
    }
};
```

#### 静态实现

用数组来模拟链表，不过应该用链式前向星比较好理解

![image-20240728214112358](./image-20240728214112358-1723804032865-15.png)

```c++
// 数组实现 - 静态链表
#include <iostream>
using namespace std;

const int N = 1e5 + 10;

int l[N], r[N], idx, e[N];

// 初始化，设置虚拟头节点
void init() {
    l[0] = -1;      // 虚拟头节点的左指针为-1，表示不存在左边节点
    r[0] = 0;       // 虚拟头节点的右指针指向自身，表示链表为空
    idx = 1;        // 当前可用的节点索引从1开始（0已被虚拟头节点占用）
}

// 在k的右边插入数据
void add_right(int k, int x) {
    e[idx] = x;     // 新节点的值为x
    r[idx] = r[k];  // 新节点的右指针指向k节点原来的右边节点
    l[idx] = k;     // 新节点的左指针指向k节点
    l[r[k]] = idx;  // k节点原来的右边节点的左指针指向新节点
    r[k] = idx;     // k节点的右指针指向新节点，完成插入
    idx++;          // 更新节点索引
}

// 往k的左边插入数据
void add_left(int k, int x) {
    e[idx] = x;     // 新节点的值为x
    if (l[k] != -1) {
        r[idx] = k;     // 新节点的右指针指向k节点
        l[idx] = l[k];  // 新节点的左指针指向k节点原来的左边节点
        r[l[k]] = idx;  // k节点原来的左边节点的右指针指向新节点
        l[k] = idx;     // k节点的左指针指向新节点，完成插入
    } else {
        r[idx] = k;     // 新节点的右指针指向k节点
        l[idx] = -1;    // 新节点的左指针指向虚拟头节点
        l[k] = idx;     // k节点的左指针指向新节点，完成插入
    }
    idx++;          // 更新节点索引
}

int main() {
    init();         // 初始化链表

    add_right(0, 1); // 在虚拟头节点右边插入1，链表变为：0 -> 1  0是虚拟节点 
    add_left(1, 2);  // 在节点1的左边插入2，链表变为：2 -> 1

    // 输出链表的值 
    for (int i = r[0]; i != 0; i = r[i]) {
        cout << e[i] << " ";
    }
    // 输出：2 1

    return 0;
}
```

### [循环链表](https://www.dotcpp.com/course/100)

> 循环链表一般使用尾插法实现

循环链表和非循环链表其实创建的过程以及思路几乎完全一样，唯一不同的是，非循环链表的尾结点指向空（`NULL`），而**循环链表的尾指针指向的是链表的开头**。通过将单链表的尾结点指向头结点的链表称之为循环单链表（`Circular linkedlist`），如图，为一个完整的循环单链表

> 最后一个位置的`next`为头指针

![循环链表](./1562924138210258-1723804032865-8.png)

#### [循环单链表](https://zhuanlan.zhihu.com/p/107808443)

对于循环单链表的结点，可以完全参照于单链表的结点设计，如图：

![单向循环链表结点](./1562924163903311-1723804032865-10.png)

`data`表示数据，其可以是简单的类型，`next`表示指针，它永远指向自身的下一个结点，对于只有一个结点的存在，在循环单链表中`next`指针则永远指向自身，对于循环单链表的尾部结点，`next`永远指向开头。

其代码可以表示为：

```c++
struct list{
    int data; //当前位置的值
    struct list* next; //下一个位置的地址
}list;
```

![循环单链表](./%E5%BE%AA%E7%8E%AF%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8-1723804032865-9.png)

如同单链表的创建，我们需要先创建一个头结点并且给其开辟内存空间，**但与单链表不同的是，我们需要在开辟内存空间成功之后将头结点的`next指向head`自身**，我们可以创建一个`init`函数来完成这件事情，为了以后的重复创建和插入，我们可以考虑在`init`重创建的结点next指向空，而在主函数调用创建之后手动将head头结点的next指针指向自身。

```c++
// 链表节点定义
typedef struct list {
    int data;        // 节点数据
    struct list *next; // 指向下一个节点的指针
} list;

// 初始化链表
list *initlist() {
    // 分配内存并检查是否成功
    list *head = (list *)malloc(sizeof(list));
    // 这是空链表
    head->next = head;
    return head;
}
```

如果在循环单链表中设的是头指针，那么在尾部插入元素需要O(n)的时间复杂度，如果设置尾指针，那么插入只需要O(1)。

> 尾指针插入数据的方向是`<-`
>
> 头指针插入数据的方向是`->`
>
> 插入的起点以头尾指针为主

我们可以通过逐步的插入操作，创建一个新的节点，将原有链表尾结点的next指针修改指向到新的结点，新的结点的next指针再重新指向头部结点，然后逐步进行这样的插入操作，最终完成整个单项循环链表的创建。

![循环链表的创建](./1562924267248299-1723804032865-11.png)

这里用尾插法实现循环链表，将数据从右向左插入链表中。使用尾插法的原因是，方便将最后一个节点的`next`指针指向头部位置。 下面的代码没有声明尾指针，只是使用了头指针遍历得到尾指针，如果使用两个指针就不是单链表了，所以说循环链表还是得用双链表实现好些。

```c++
#include <stdio.h>
#include <stdlib.h>

// 链表节点定义
typedef struct list {
    int data;          // 节点数据
    struct list *next; // 指向下一个节点的指针
} list;

// 初始化链表，创建一个只有一个节点的循环链表
list* initlist(int data) {
    list *head = (list *)malloc(sizeof(list));
    head->data = data;
    head->next = head; // 头节点的 next 指向自身，形成循环
    return head;
}

// 在循环链表中使用尾插法插入新节点 - 头结点不再指向自身
void insert_list_tail(list *head) {
    int data;
    printf("请输入要插入的元素：");
    scanf("%d", &data);

    // 创建新节点
    list *newNode = (list *)malloc(sizeof(list));
    newNode->data = data;

    // 找到尾节点（尾节点是当前头节点的前一个节点）
    // 通过 tail 对这个节点的数据或 next 指针进行修改，head 所指向的节点内容也会改变。
    // 目的是把head变为尾指针
    list *tail = head;
    while (tail->next != head) {
        tail = tail->next;
    }

    // 插入新节点
    newNode->next = head; // 新节点的 next 指向头节点
    tail->next = newNode; // 当前尾节点的 next 指向新节点
}

int main() {
    list *head = initlist(0); // 初始化链表，创建第一个节点
    insert_list_tail(head);   // 尾插法插入节点
    return 0;
}
```

> 需要注意的是，由于 `tail` 和 `head` 都指向同一个节点，通过 `tail` 对这个节点的数据或 `next` 指针进行修改，`head` 所指向的节点内容也会改变。因为它们指向的实际上是同一个内存位置。

#### [循环双链表](https://blog.csdn.net/sum_TW/article/details/61624039?ydreferer=aHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS8%3D)

循环双向链表是一种更复杂的数据结构类型，它的节点包含指向其前一节点以及下一节点的指针。 循环双向链表在任何节点中都不包含`NULL`。 链表的最后一个节点包含列表的第一个节点的地址。 链表的第一个节点还包含的前一个指针是指向最后一个节点的地址。 

![img](./Center-1723804032865-12.png)

> 结点构造，包括头指针和尾指针
>
> - 头指针既指向前也指向最后
>
> - 尾结点的尾指针指向最前的一个

这里是使用尾插法实现的循环双链表，和前面循环单链表一样，使用尾插法是更好维护链表。

```c++
struct Node {
    int data;     // 数据域
    Node* prev;   // 前驱指针，指向前一个节点
    Node* next;   // 后继指针，指向下一个节点

    // 构造函数
    Node(int val) : data(val), prev(nullptr), next(nullptr) {}
};

struct CircularDoublyLinkedList {
    Node* head;  // 头指针
    Node* tail;  // 尾指针

    // 构造函数，初始化为空表
    CircularDoublyLinkedList() : head(nullptr), tail(nullptr) {}
};

// 尾插法
void append(int value) {
    Node* newNode = new Node(value);
    if (!head) {
        // 链表为空时，初始化头尾指针
        head = newNode;
        tail = newNode;
        head->next = head;
        head->prev = head;
    } else {
		   // 链表不为空时的操作
            newNode->prev = tail;  // 新节点的 prev 指向当前尾节点
            newNode->next = head;  // 新节点的 next 指向头节点
            tail->next = newNode;  // 当前尾节点的 next 指向新节点
            head->prev = newNode;  // 头节点的 prev 指向新节点
            tail = newNode;        // 更新尾指针为新节点
    }
}
```

> 插入操作

在循环双链表中，插入操作可以分为几种情况：在链表为空时插入、在链表头部插入、在链表尾部插入、以及在链表中间插入。

如果链表为空，则插入的节点将成为链表的唯一节点，同时也是头节点和尾节点。

```c++
// 链表为空插入
void insertInEmptyList(int value) {
    Node* newNode = new Node(value);
    head = newNode;
    tail = newNode;
    head->next = head; // 自环
    head->prev = head; // 自环
}
```

在头部插入时，新节点将成为新的头节点，并且需要更新尾节点的 `next` 指针和新头节点的 `prev` 指针以维持循环性质。(尾插法)

```c++
// 链表头部插入
void insertAtHead(int value) {
    if (!head) {
        // 如果链表为空，插入第一个节点
        insertInEmptyList(value);
        return;
    }

    Node* newNode = new Node(value);
    newNode->next = head;      // 新节点的后继指向原来的头节点
    newNode->prev = tail;      // 新节点的前驱指向尾节点
    tail->next = newNode;      // 尾节点的后继更新为新节点
    head->prev = newNode;      // 原头节点的前驱指向新节点
    head = newNode;            // 更新头节点为新节点
}
```

在尾部插入时，新节点将成为新的尾节点，类似地，需要更新头节点的 `prev` 指针和新尾节点的 `next` 指针以维持循环性质。

```c++
// 链表尾部插入
void insertAtTail(int value) {
    if (!head) {
        // 如果链表为空，插入第一个节点
        insertInEmptyList(value);
        return;
    }

    Node* newNode = new Node(value);
    newNode->next = head;      // 新节点的后继指向头节点
    newNode->prev = tail;      // 新节点的前驱指向原来的尾节点
    tail->next = newNode;      // 原尾节点的后继指向新节点
    head->prev = newNode;      // 头节点的前驱指向新节点
    tail = newNode;            // 更新尾节点为新节点
}
```

在链表中间插入时，需要遍历到指定位置，然后插入新节点，并更新相邻节点的指针。

```c++
// 链表中部插入
void insertAtPosition(int value, int position) {
    if (!head) {
        // 如果链表为空，插入第一个节点
        insertInEmptyList(value);
        return;
    }

    Node* newNode = new Node(value);
    Node* current = head;

    // 遍历到指定位置的前一个节点
    for (int i = 1; i < position - 1 && current->next != head; ++i) {
        current = current->next;
    }

    // 插入新节点
    newNode->next = current->next;
    newNode->prev = current;
    current->next->prev = newNode;
    current->next = newNode;

    // 如果新节点插入在尾节点后面，需要更新尾节点指针
    if (current == tail) {
        tail = newNode;
    }
}
```

> 删除操作

删除操作可以分为几种情况：删除头节点、删除尾节点、删除中间节点，以及在链表为空或只有一个节点时进行删除。

![img](./%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4-1723804032865-14.png)

删除头节点时，需要更新头指针，同时维护尾节点的 `next` 指针指向新的头节点，新的头节点的 `prev` 指针指向尾节点。

```c++
//删除头结点
void deleteHead() {
    if (!head) {
        // 链表为空，无需删除
        return;
    }

    // 链表中只有一个节点时
    if (head == tail) {
        delete head;   // 释放节点内存
        head = nullptr;
        tail = nullptr;
        return;
    }

    Node* temp = head;
    head = head->next;      // 更新头节点为原头节点的后继节点
    head->prev = tail;      // 新头节点的前驱指向尾节点
    tail->next = head;      // 尾节点的后继指向新头节点

    delete temp;  // 释放原头节点内存
}
```

删除尾节点时，需要更新尾指针，并维护头节点的 `prev` 指针指向新的尾节点，新的尾节点的 `next` 指针指向头节点。

```c++
// 删除尾结点
void deleteTail() {
    if (!head) {
        // 链表为空，无需删除
        return;
    }

    // 链表中只有一个节点时
    if (head == tail) {
        delete head;   // 释放节点内存
        head = nullptr;
        tail = nullptr;
        return;
    }

    Node* temp = tail;
    tail = tail->prev;      // 更新尾节点为原尾节点的前驱节点
    tail->next = head;      // 新尾节点的后继指向头节点
    head->prev = tail;      // 头节点的前驱指向新尾节点

    delete temp;  // 释放原尾节点内存
}

```

删除中间节点时，需要找到要删除的节点，并将其前驱节点的 `next` 指针指向后继节点，后继节点的 `prev` 指针指向前驱节点。

```c++
void deleteAtPosition(int position) {
    if (!head) {
        // 链表为空，无需删除
        return;
    }

    // 链表中只有一个节点时
    if (head == tail) {
        delete head;   // 释放节点内存
        head = nullptr;
        tail = nullptr;
        return;
    }

    Node* current = head;

    // 遍历到指定位置的节点
    for (int i = 1; i < position && current->next != head; ++i) {
        current = current->next;
    }

    // 如果删除的是头节点或尾节点，调用对应删除函数
    if (current == head) {
        deleteHead();
        return;
    } else if (current == tail) {
        deleteTail();
        return;
    }

    // 更新前驱和后继指针
    current->prev->next = current->next;
    current->next->prev = current->prev;

    delete current;  // 释放当前节点内存
}
```

### 顺序表与链表的区别

**数组** 和 **链表** 之间的主要区别在于它们的结构。数组是基于索引的数据结构，其中每个元素与索引相关联。链表依赖于引用，其中每个节点由数据和对前一个和下一个元素的引用组成。引用通常使用指针来实现，他们的具体差别如下

- 数组
  - 元素按顺序存储在**连续的内存空间**中，通过**索引访问**。
  - 可以通过索引直接**访问任意元素**，访问速度快。**具体访问时间为O(1)**
  - 在编译时分配固定大小的内存，扩展大小困难。不过可以通过结构体实现动态数组
  - **插入和删除元素时**，需要移动其他元素，效率较低。**时间复杂度O(n)**
  - 由于元素连续存储，内存使用紧凑，但大小固定。
- 链表
  - 元素（节点）存储在不连续的内存空间，通过指针相互连接。
  - 需要从头开始顺序遍历才能访问特定元素，**访问速度较慢。复杂度O(n)**
  - 在运行时动态分配内存，大小可灵活调整.
  - 只需**调整指针即可插入或删除节点，操作效率高。**
  - 每个节点存储数据和指针，使用更多内存，但灵活性高。

<img src="./2019-07-20-difference-between-array-and-linked-list-1693299145961-8-1723804032865-16.jpg" alt="数组和链表的对比" style="zoom:150%;" />

如果**代码对内存的使用非常苛刻，那数组就更适合**。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对**链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，触发语言本身的垃圾回收操作。**

如果代码对**增删改查的方式使用的比较多**，那么链表更为合适。因为它方便执行这些操作。

![image-20230829170835292](./image-20230829170835292-1723804032865-17.png)

## [队列](https://www.51cto.com/article/656335.html)

队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。允许插入的一端称为队尾，**允许删除的一端称为队头。**它是一种特殊的线性表，特殊之处在于它只允许**在表的前端进行删除操作，而在表的后端进行插入操作**，和栈一样，队列是一种操作受限制的线性表。

队列是一种先进先出的数据结构，又称为先进先出的线性表，简称 FIFO（First In First Out）结构。也就是说先放的先取，后放的后取，就如同行李过安检的时候，先放进去的行李在另一端总是先出来，后放入的行李会在最后面出来。

![img](./%E9%98%9F%E5%88%97-1723804032865-20.png)

**这里实现的线性队列，需要注意的是，对头是终点也就是出口处，队尾是起点也就是塞入数据的起点，先进先出**。也可以理解为队头永远指向第一个塞入队列中的数据，队尾都是指向最后一个数据的位置。

```c++
const int N = 1000; // 假设队列最大长度为 1000
// hh表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 插入数据
void enqueue(int value) {
    if (tt - hh + 1 >= N) {
        // 如果队列已满，可以根据需求选择处理方法：扩容、循环利用、或报错
        // 这里简单报错，提示队列已满
        std::cout << "Queue is full!" << std::endl;
        return;
    }
    q[++tt] = value; // 插入新数据到队尾
}

// 弹出队头元素
void dequeue() {
    if (hh > tt) {
        // 如果队列为空
        std::cout << "Queue is empty!" << std::endl;
        return;
    }
    hh++; // 移动头指针，弹出队头元素
}

// 判断队列是否为空
bool isEmpty() {
    return hh > tt;
}

// 取出队头元素
int front() {
    if (isEmpty()) {
        std::cout << "Queue is empty!" << std::endl;
        return -1; // 根据需求选择如何处理空队列，返回一个无效值或抛出异常
    }
    // hh是对头
    return q[hh];
}
```

### 实现队列

#### 顺序结构

一个用数组实现的顺序队列如下图所示：

![img](./4a614458b22b9907eb7f7b8272a15887.png)

可以看到，要实现一个顺序队列，我们需要以下结构：

- 存储数据的数组 —— data[]
- 表示队列的最大容量的值 —— MAXSIZE
- 标识队头端的队头下标 —— front
- 标识队尾端的队尾下标 —— rear

front 和 rear 会随着入队和出队操作而变化，为了方便起见，我们规定在非空队列中，队尾下标是队尾元素的下一个元素的下标。

```c
#define MAXSIZE 5 //顺序队列的最大存储容量 
/*顺序队列的结构体*/ 
typedef struct { 
    int data[MAXSIZE]; 
    int front; //队头下标 
    int rear; //队尾下标 
} QueueArray; 
```

#### 链式结构

我们使用带头节点的单链表来实现队列，如下图所示：

![img](./0dc37ecfdaa0b7296d453f33a5263e1f.png)

可以看到，要实现一个链队列，需要以下结构：

- 单链表的基本单元结点 —— QueueNode
  - 存储数据的数据域 —— data
  - 指向下一个结点的指针域 —— next
- 指向链表的头指针 —— head
- **标识队头端的队头指针 —— front**
- **标识队尾端的队尾指针 —— rear**

其中，头指针 head 和队头指针 front 都指向了单链表的第一个结点，所以这个指针可以合二为一，队头指针即头指针。

如此一来，我们可以借助链表的尾插法实现队列的入队操作，借助链表的头删法实现队列的出队操作。

```c++
/*单链表的结点的结构体*/ 
typedef struct QueueNode { 
    int data; //数据域 
    struct QueueNode *next; //指针域 
} QueueNode; 
 
/*链队列的结构体*/ 
typedef struct { 
    QueueNode *front; //队头指针 
    QueueNode *rear; //队尾指针 
} QueueLink; 
```

### 队列状态

空队列：空队列中没有元素，此时，队头下标和队尾下标均为 0，即front = rear = 0：

![img](./019126723f63106934e4d19e4edbebf9.png)

非空非满队列：队列不是空队列且有剩余空间：

![img](./b502bd08347df76d270059fa37d3e699.png)

满队列：顺序队列分配的固定空间用尽，没有多余空间，不能再插入元素，此时 front = 0，rear = MAXSIZE：

![img](./43175b9f25ce866ce91b4b8234fb037b.png)

从上图中可以看出，非空队列的队尾下标 rear 始终是队尾元素的下一个元素的下标。

#### 假溢出

以上是用数组实现的顺序队列的三种状态，但上图中三种队列是存在问题的，那就是队列的存储问题!

先再次明确队列的两条重要特性：

- 队列只允许在队头删除元素，在队尾插入元素
- 我们规定：front 是队头元素的下标，rear 是队尾元素的下标，**二者会随着出队和入队操作而变化**

由于上面的三幅图中 front 都在下标 0 处，所以不容易看出问题，请看下面的过程图：

> 不断出队，队头会往队尾方向移动
>
> - 每次出队时，队头指针会前移一格，指向下一个元素。
> - 随着出队操作，队头指针逐步接近队尾指针。
>
> 不断入队，队尾**会向队列的“远端”移动，而不是向**队头的方向移动。
>
> - 每次入队时，队尾指针会后移一格，指向下一个可插入新元素的位置。
> - 随着入队操作，队尾指针逐渐远离队头指针。

![img](./c6e2348f01e65974e85ffdab6a3b441c.png)

之所以假满队列存在问题，是因为顺序队列的空间是有限的，通过若干入队操作之后，我们的 `rear队尾 `跑到数组外从而导致越界了。**尾指针移动到我们可以进行队列操作的范围之外去了，我们称呼作为队列用的存储区还没有满,但队列却发生了溢出,我们把这种现象称为"假溢出"。**

怎么解决呢？报错是 rear 越界导致，而队列的前大部分都是空闲的，所以当 rear 越界时，我们可不可以将其移动到下标 0 处呢？

![img](./d21721fdea64040aeece5b1e8c24026e.png)

显然是可以的，这样就构成了一个循环，我们称这种 front 和 rear可以循环利用的队列为循环队列。

> 队列插入数据移动状态
>
> ![入队动画](./35201f24b15241838c81e54cb5ead610tplv-k3u1fbpfcp-zoom-in-crop-mark1512000.webp)

#### 循环队列

> - `front` 指针指向队列中的第一个元素，即将要被移除的元素。每次出队时，`front` 指针向后移动一格，以指向下一个元素。
> - `rear` 指针指向队列中的下一个插入位置，即队列的尾部。每次插入新元素时，`rear` 指针会向后移动一格。

为了突出循环二字，我们将这种顺序队列画成一个圆：

![img](./300f6e7526bc4f620e43668e33f9ccf9.png)

**循环队列的 rear 和 front 能够在队列中一圈一圈地转，像钟表的时针和分针一样。**不会再出现不能利用的空间了。顺序队列的形式从“直的”变成这种可循环的之后，对于状态的判断也改变了。

>  空队列：队列中没有元素，如上图。

请注意，空队列的条件并不是` front = rear = 0`，比如一个空队列经过 3 次入队和 3 次出队操作后仍为空队列：

![img](./84204ab02a7c76d0597460187eebf1a9.png)

所以，循环队列为空队列时，条件应该为` front == rear`

> 满队列：队列中没有空闲空间

![img](./d5e40b972004e73c5cf918c2dd917e8e.png)

上图是一个最大容量为 8 的空队列，入队 7 个元素后，队列中还剩 1 个空闲位置，如果此时我们再入队 1 个元素：

![img](./6c3644400e619b0ff5a9a877f40ba7a9.png)

此时队列中确实没有空闲空间了，但注意，此时队列满足了 rear = front ，但满足 rear = front的队列不应该是空队列吗?

这就产生误会了。

不如我们退一步海阔天空，少用一个元素，借此来消除误会。如下图，规定这样是一个满队列。

![img](./6c77e7eb1bace0e175026d3d4b5d6979.png)

我们规定，**`front` 出现在 `rear` 的下一个位置时，队列为满队列。**

比如在上图的满队列中，` front = 3` 在` rear = 2 `的下一个位置。

所以队列为满队列的判定条件为：`rear + 1 = front`，但这的条件是不准确的。

因为循环队列中的` front` 和 `rear` 都是循环使用的，就像钟表的时针一样，所以我们仅根据下标的大小来判断位置是不合理的。下面两个均是满队列，右图不满足`rear + 1 = front`：

![img](./c2e22fd7edd50e0add455cf2d03a1fa4.png)

就像钟表的时针满 12 归零一样，front 和 rear 也应该满某个数后归零，这个数就是 MAXSIZE，也就是队列长度。

比如 rear = 7 时，如果按平常做法来 ，下一步应该是 rear = 8，但在这里，我们让其归零，所以下一步应该是 rear = 0。

用数学公式来表示上面的归零过程就是：`rear % MAXSIZE = 0`

**所以满队列的判断条件应该为：`(rear + 1) % MAXSIZE = front`**

### 入队操作

#### 顺序队列

前面我们规定，顺序队列的队尾下标为队尾元素的下一个元素，所以直接将待入队元素放入队尾下标处，然后队尾下标“加一”。(注意：循环队列中的加一要对 MAXSIZE 取模)

> 当 `(rear + 1) % MAXSIZE == front` 时队列就满
>
> - 塞入数据，队尾是不断远离队头的
> - 弹出数据，对头是不断接近队尾的

![img](./7a880d24e6f8b52f921dc430753ab461.png)

```c++
/** 
 * 入队操作 
 * queue: 指向队列的指针 
 * elem: 入队的数据 
 * return: 0失败，1成功 
 */ 
int en_queue(QueueArray *queue, int elem) 
{ 
    //判断队列是否已满 
    if ((queue->rear + 1) % MAXSIZE == queue->front) { 
        printf("队列已满，无法继续入队。\n"); 
        return 0; 
    } 
    //元素入队 
    queue->data[queue->rear] = elem; 
    //队尾下标加一 
    queue->rear = (queue->rear + 1) % MAXSIZE; 
    return 1; 
} 
```

#### 链式队列

链队列的入队操作本质是单链表的尾插法：

```c++
/** * 入队操作 
 * queue: 指向队列的指针 
 * elem: 入队的数据 
 */ 
void en_queue(QueueLink *queue, int elem) 
{ 
    //创造新结点 
    QueueNode *new = create_node(elem); 
    //入队（尾插法） 
    queue->rear->next = new; 
    queue->rear = new; 
} 
```

### 出队操作

出队操作只允许元素从队头出。

#### 顺序队列

将队头下标处的元素出队，然后将队头下标“加一”(对 MAXSIZE 取模)。

![img](./d12fb715dd05f298118a4c72f1f8f582.png)

```c++
/** 
 * 出队操作 
 * queue: 指向队列的指针 
 * elem: 指向保存出队数据的变量 
 * return: 0失败，1成功 
 */ 
int de_queue(QueueArray *queue, int *elem) 
{ 
    //判读队列是否为空 
    if (queue->front == queue->rear) { 
        printf("队列空，无元素可出。\n"); 
        return 0; 
    } 
    //元素出队 
    *elem = queue->data[queue->front]; 
    //队头下标加一 
    queue->front = (queue->front + 1) % MAXSIZE; 
    return 1; 
} 
```

#### 链式队列

链队列的出队操作本质上是单链表的头删法。注意，如果出队的是队列中最后一个元素，需要在出队后，将队尾指针重新指向头结点，重新形成空队列。

```c++
/** 
 * 出队操作 
 * queue: 指向队列的指针 
 * elem: 指向保存变量的指针 
 * return: 0失败，1成功 
 */ 
int de_queue(QueueLink *queue, int *elem) 
{ 
    //判读队列是否为空 
    if (queue->front == queue->rear) { 
        printf("队列空，无元素可出。\n"); 
        return 0; 
    } 
    QueueNode *front_node = queue->front->next; //队头元素 
    //保存数据 
    *elem = front_node->data; 
    //队头元素出队（头删法） 
    queue->front->next = front_node->next; 
    //如果元素出完，队尾指针重新指向头结点 
    if (front_node == queue->rear) 
        queue->rear = queue->front; 
    free(front_node); 
} 
```

### 遍历队列

> 判断队列为空的是`rear==front`

借助临时变量 `i`，从队头下标开始逐个“加一”直到队尾下标结束。

开始标志为：`i = front`

加一操作为：`i = (i + 1) % MAXSIZE`

结束标志为：`i % MAXSIZE = rear`

```c++
/** 
 * 打印队列 
 */ 
void output(QueueArray queue) 
{ 
    int i = queue.front; 
    while (i % MAXSIZE != queue.rear) { 
        printf("%d ", queue.data[i]); 
        i = (i + 1) % MAXSIZE; 
    } 
    printf("\n"); 
} 
```

如何计算顺序队列的长度?当然你可以遍历队列然后借助计数变量来存储长度，这样比较麻烦。因为顺序队列是使用数组实现的，所以顺序队列的长度我们可以直接根据下标计算出来。

如果是一个**非循环队列，那很简单，直接 rear - front 就是队列的长度了。**

但循环队列不能这样直接减了，因为 rear 和 front 之间的位置关系是不确定的。

![img](./35360e7b4a697063bf8ae0a74078e1bf.png)

左图 `rear < front`，我们可以将其长度看成两部分组成：

- 下标 0 到 rear，长度为` rear - 0`
- 下标 `MAXSIZE - 1 `到 rear，长度为` MAXSIZE - front`

所以长度为 `rear - front + MAXSIZE`

为了满足右图` rear > front `的情况，如果按照上式，则此时多加了一个 MAXSIZE，所以需要对其再对 MAXIZE 取余。

所以循环队列的长度为` (rear - front + MAXSIZE) % MAXSIZE`(空队列也满足)。

> 遍历链队列

借助指针 p 从队头元素遍历至队尾元素即可。

```c++
/** 
 * 打印队列 
 */ 
void output(QueueLink *queue) 
{ 
    QueueNode *p = queue->front->next; //p指向队头元素 
    while (p != NULL) { 
        printf("%d ", p->data); 
        p = p->next; 
    } 
    printf("\n"); 
} 
```

## 堆和栈

### [栈](https://zhuanlan.zhihu.com/p/346164833)

栈是限定仅在表尾进行插入和删除操作的线性表。我们把允许插入和删除的一端称为栈顶，另一端称为栈底，不含任何数据元素的栈称为空栈。栈的特殊之处在于**它限制了这个线性表的插入和删除位置，它始终只在栈顶进行。**

而且栈是一种具有后进先出的数据结构，又称为后进先出的线性表，简称 `LIFO（Last In First Out）`结构。也就是说后存放的先取，先存放的后取，这就类似于我们要在取放在箱子底部的东西（放进去比较早的物体），**我们首先要移开压在它上面的物体（放进去比较晚的物体）**。

堆栈中定义了一些操作。两个最重要的是`PUSH和POP`。`PUSH`操作在堆栈的顶部加入一个元素。`POP`操作相反，在堆栈顶部移去一个元素，并将堆栈的大小减一。

![stack](./stack_1.png)

用数组实现栈的关键在于：我们可以直接使用一个数组来存储数据，并通过控制指针或索引来实现栈的先进后出（LIFO）功能。

- 子程序的调用：在跳往子程序前，会先将下个指令的地址存到堆栈中直到子程序执行完后再将地址取出，以回到原来的程序中。  
- 递归的调用：可以用来在函数调用的时候存储断点， 储存下一个指令的地址外，也将参数、区域变量等数据存入栈中。  
- 表达式的转换[中缀表达式转后缀表达式]与求值(实际解决)。  
- 二叉树的遍历。  
- 图形的深度优先(depth一first)搜索法。  

```c++
#include <iostream>
using namespace std;

const int N = 100; // 假设栈的最大容量为 100
int stk[N];        // 栈数组
int tt = -1;       // 栈顶指针，初始化为 -1，表示栈为空

// 插入数据到栈中
void push(int x) {
    if (tt + 1 >= N) {
        cout << "栈已满，无法插入新元素。" << endl;
    } else {
        stk[++tt] = x; // 先增加栈顶指针，再插入数据
    }
}

// 弹出栈顶数据
int pop() {
    if (tt < 0) {
        cout << "栈为空，无法弹出数据。" << endl;
        return -1; // 可以根据实际需求调整返回值
    } else {
        int topData = stk[tt]; // 保存栈顶数据
        tt--;                  // 栈顶指针减1
        return topData;        // 返回弹出的数据
    }
}

// 判断栈是否为空
bool isEmpty() {
    return tt < 0; // 如果栈顶指针小于0，表示栈为空
}

// 获取栈顶数据
int top() {
    if (tt < 0) {
        cout << "栈为空，无法获取栈顶数据。" << endl;
        return -1; // 可以根据实际需求调整返回值
    } else {
        return stk[tt]; // 返回栈顶数据
    }
}
```

### [堆](https://juejin.cn/post/7134880984528814110)

堆是一种经过排序的树形数据结构，每个节点都有一个值，通常我们所说的堆的数据结构是指二叉堆。所以堆在数据结构中通常可以被看做是一棵树的数组对象。而且堆需要满足一下两个性质：

-    堆中某个节点的值总是不大于或不小于其父节点的值；
-    堆总是一棵完全二叉树。

堆的一个经典的实现是完全二叉树。完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。

![heap](./heap_1.png)

- 元素42的索引(`2 = i`) 

- 元素31的索引(`4 = 2i`) 
- 元素19的索引(`5 = 2i + 1`)

从图中可以看到，数组中下标为i的节点的左子节点，就是**下标为`2i`的节点**，右子节点就是**下标为`2i+1`的节点**，父节点就是**下标为`i/2`的节点**

![heap](./heap_2.png)

```c++
#include <iostream> 
using namespace std; 
// 定义堆的最大容量 
const int MAX_SIZE = 100; 
// 定义堆的数据结构 
int heap[MAX_SIZE]; 
int heapSize; 
// 向堆中插入一个元素 
void insert(int data) 
{ 
    // 如果堆已满，则不能插入 
    if (heapSize == MAX_SIZE) 
        return; 
    // 将新元素插入到堆的末尾 
    heap[heapSize] = data; 
    heapSize++; 
    // 将新元素上浮到正确的位置 
    int current = heapSize - 1; 
    while (current != 0 && heap[current] > heap[(current - 1) / 2]) 
    { 
        int temp = heap[(current - 1) / 2]; 
        heap[(current - 1) / 2] = heap[current]; 
        heap[current] = temp; 
        current = (current - 1) / 2; 
    } 
} 
// 从堆中删除一个元素 
void deleteElement() 
{ 
    // 如果堆为空，则不能删除 
    if (heapSize == 0) 
        return; 
    // 将堆的最后一个元素放到堆顶 
    heap[0] = heap[heapSize - 1]; 
    heapSize--; 
    // 将堆顶元素下沉到正确的位置 
    int current = 0; 
    while (current * 2 + 1 < heapSize) 
    { 
        int largest = current; 
        if (heap[largest] < heap[current * 2 + 1]) 
            largest = current * 2 + 1; 
        if (current * 2 + 2 < heapSize && heap[largest] < heap[current * 2 + 2]) 
            largest = current * 2 + 2; 
        if (largest == current) 
            break; 
        int temp = heap[current]; 
        heap[current] = heap[largest]; 
        heap[largest] = temp; 
        current = largest; 
    } 
} 
```

## 字符串

我们现在常用的搜索引擎，当我们在文本框中输入“数据”时，它已经把我们想要的“数据结构”列在下面了，这个显然就是一个字符串查找匹配的工作。

所以我们就要好好分析字符串这样的数据结构，来看看《大话数据结构》是怎么定义的： **串是由零个或多个字符组成的有限序列，又名叫字符串**

**一般记为s="a~~1~~a~~2~~......a~~n~~" (n≥0)**

a就是一个一个的字符，然后把n个字符拼接起来就是字符串，n是字符串的长度，是有限长度的，n也可能为0，为0是就是空串，可以用“”这个表示。

特别注意的是，有一种字符串叫空格串，空格串是有内容的，里面包含着空格，可能不止一个空格。

### 串的存储结构

在计算机中，字符串通常存储在一组地址连续的存储单元中。使用定长数组定义字符串是常见的做法，**这样的数组有一个固定的最大长度，但实际字符串的长度通常小于这个最大值。为了处理这个问题，我们需要记录实际字符串的长度，有时这个长度信息存储在数组的第一个元素（索引 0）处**，或者存储在最后一个元素的位置。字符串通常以 `'\0'`（空字符）结尾，以标示字符串的结束。

然而，使用 `'\0'` 来标记字符串结束存在潜在的风险：如果不慎遗漏了 `'\0'`，会导致指针越界，从而引发不可预期的错误或安全隐患。为了避免这种情况，**在 C 语言中，我们通常将字符串封装到结构体中。**这个结构体通常包含两个元素：

1. **字符数组**：用于存储字符串内容。
2. **长度信息**：用于记录字符串的实际长度。

#### 定长顺序存储

采用字符数组将串中的字符序列一次连续存存储在数组中的相邻但愿中，常量串和变量串的存储结构不同，数组容量`length`分半等于或者大于串长度`n.`

![img](./319374-20190616213752038-575686437.png)

顺序存储的串具有随机存取特效，存取指定位置字符的时间复杂度为` O(1)` ，**缺点是插入和删除元素时需要移动元素，平均移动数据量是串长度的一半**，当数组容量不够时，需要重新申请一个更大的数组，并复制原来数组中的所有元素，插入和删除操作的时间复杂度为`O(n)`

#### 链式存储结构

串的链式存储结构：**有单字符串链表和块链表两种，但字符串链表是每个节点的数据域只包含一个字符的单链表，块链表是每个节点的数据域包含若干个字符的单链表。**链式存储的串，存取指定位置字符的时间复杂度为 O(n),单字符链表虽然插入/删除操作不需要移动元素，**但是占用存储空间太多，块链表的插入和删除操作需要移动元素，效率低。**

![img](./319374-20190616213819903-893272696.png)

### 字符串匹配

在进行文本编辑时候，我们经常查找和替换，在文档的指定范围内查找一个单词的位置，用另一个单词替换，**替换操作的前提是查找操作，如果查找到指定单词，则确定了操作位置，可以将指定单词用另一个单词替换掉，否则不能进行替换操作**，每进行一次替换操作，都需要执行一次查找操作，那么如何快速查找指定单词在文档中的位置呢，就是串的模式匹配算法需要解决的问题，

设有2个串，目标串target 和模式串 pattern ,在目标串target中查找与模式串pattern相等的一个子串并确定该子串的操作称为 串的模式匹配，两个子串相等指的是：长度相等且对应各个字符相同，匹配结果有两种 如果target存在pattern相等的子串，则匹配成功 获得该子串在target中的位置，否则匹配失败给出失败信息。

#### [BF算法](https://juejin.cn/post/6854573219106521101)

**BF算法（Brute-Force，暴力匹配算法）**的基本思想是简单而直接的。其实现方法如下：

- **初始化**：定义两个索引`i`和`j`，分别指示主串`Tag`和子串`Ptn`当前比较的字符位置。

- **匹配过程**：

  - 从主串`Tag`的第`pos`个字符开始，与子串`Ptn`的第一个字符进行比较。

  - 如果字符匹配，则继续逐个比较后续字符。
  - 如果字符不匹配，则从主串的下一个字符开始重新进行比较。

- **终止条件**：

  - 如果子串`Ptn`的所有字符都与主串`Tag`中某个连续子串的字符匹配成功，则返回匹配成功的位置。

  - 如果主串`Tag`中的所有可能位置都尝试过后仍未找到匹配，则返回`-1`表示匹配失败。

最坏情况下，BF算法的时间复杂度为 O((n−m+1)⋅m)，其中 `n` 是主串的长度，`m` 是子串的长度。

```c++
#include <iostream>
#include <string>

using namespace std;

// Brute-Force算法实现字符串匹配
int bruteForceSearch(const string& text, const string& pattern) {
    int n = text.length();
    int m = pattern.length();

    for (int i = 0; i <= n - m; i++) {
        int j;
        for (j = 0; j < m; j++) {
            if (text[i + j] != pattern[j])
                break;
        }
        if (j == m) // 找到完全匹配
            return i;
    }

    return -1; // 未找到匹配
}

int main() {
    string text, pattern;
    cout << "请输入文本串：" << endl;
    getline(cin, text);

    cout << "请输入模式串：" << endl;
    getline(cin, pattern);

    int position = bruteForceSearch(text, pattern);
    if (position != -1)
        cout << "在位置 " << position << " 处找到匹配。" << endl;
    else
        cout << "未找到匹配。" << endl;

    return 0;
}
```

#### [KMP算法](https://www.xdull.cn/kmp.html)

> https://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html

KMP 算法则用了一种聪明的办法，**当发现字符串不匹配的时候，并不会从头开始比较，因为之前已经匹配成功的字符可以给我们提供一些有用的信息，利用这个信息我们可以将子串移动到某个位置，并从这个位置直接开始比较，**它的时间复杂度降到了O(m+n)，也就是 2 个字符串的长度之和。

> - 模式串（在原始文本中查找的字段）
> - 匹配串（搜索的目标字符串，原始文本串）
> - `next`串控制模式串的移动距离
> - `j`指针指向`next`数组的位置，**指向位置和匹配相同位置一样**
> - `I`指向模式串的指针会一直前进
>
> 匹配失败就按照`next`数组中记录的距离移动，也就是移动`next[j]`
>
> 同时，**`j`指针**也会回退到`next[j-1]`位置

有很多关于 KMP 的代码，大体知道是通过计算子串（模式串）自身来获得一个 next 数组，然后在匹配过程中通过 next 数组来决定下一个匹配位置，代码虽然不复杂，然而知其然不知其所以然，如果不明白其中原理，那么很难将这个算法写出来。

##### 字符串的前缀后缀

首先我们需要知道字符串的前缀和后缀：

对于字符串 `ababc` 来说，它的前缀有 `[a,ab,aba,abab]`，也就是以字符串第一个字符作为开头，**同时不包括最后一个字符的所有子串**，同理它的后缀有 `[c,bc,abc,babc]`，也就是以字符串**最后一个字符作为结尾，同时不包括第一个字符的所有字串**。

> 字符串的最长公共前后缀

了解了这个，我们再来说什么是字符串的**最长公共前后缀**，说白了，也就是前缀和后缀这 2 个集合中的相同部分，同时取最长的那个，就是这个字符串的**最长公共前后缀**。显然，在这个例子中，`ababc` 是没有公共前后缀的。但是对于 `abab`，它的前缀和后缀分别是 `[a,ab,aba]` 和 `[b,ab,bab]`，那么它的**最长公共前后缀**就是 `ab`。

现在，我们的目标就是取得 `ababc` 所有子串 `[a,ab,aba,abab,ababc]` 的**最长公共前后缀**的长度，分别保存在 `next` 数组中，我们**只要知道最大长度即可**，并不用关心串具体是什么，而我们目前通过观察即可得出 `next` 数组这里是 `[0,0,1,2,0]`，我们先知道这个结果即可，此计算方法后续会说明。

##### 思路分析

得到这个有什么用，回到刚刚的例子，当我们第一次碰到不匹配时（i 和 j 都等于 3 的时候）：

![img](./2.jpg)

此时 i 和 j 之前的 3 个字符 `aba` 必然完全匹配的，因为只有前面匹配成功了 j 才能走到 3，而我们又知道 `aba` 的**最长公共前后缀**是 `a`，这可以给我们一个很好的提示，**主串中的 `aba` 的后缀和字串中的 `aba` 前缀有最长的公共部分 `a`**，这样一来，我们就**没必要让重新比较了**，直接将相同部分对齐就好了，也就是说让 j 退回到位置 1 就可以了，而 i 保持不变。

![img](./7.jpg)

分析一下，为什么 j 知道应该**退回**到位置 1：

1. 我们知道 j 是在位置 3 不匹配的，那么 j 前面的字符串我们可以知道是 `aba`
2. 前面我们已经得到了 next 数组，知道 `aba` 的最长公共前后缀长度是 **1**
3. 也就是说，我们可以知道 i 之前 **1** 个位置（主串的后缀）和子串开头之后 **1** 个位置（子串的前缀）是相同的
4. **进而我们可以让相同部分对齐，也就是让 `j=next[j-1]`**

接下来，我们发现 i 和 j 仍然不匹配，而 j 之前的字符 `a` 最长公共前后缀是 0，此时 j 退到位置 0（模式串前进一步），i 仍然保持不变。

![img](./8.jpg)

i 和 j 匹配，同时右移一格

![img](./18.jpg)

此时 i 和 j 不匹配，`j=next[j-1]` 回退到 0，然后我们发现 i 和 j 仍然不匹配，**同时 j 已经是 0 了，那么我们就让 i 往右移动一格。**

![img](./9.jpg)

可以看到，相比于暴力解法，**i 始终在前进，并没有后退（顶多保持不变）**，然后我们通过 next 数组来改变 j 的值。

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// 计算模式串的 next 数组
vector<int> computeNext(const string &pattern) {
    int m = pattern.size();
    vector<int> next(m, 0);
    int j = 0; // 前缀指针
    for (int i = 1; i < m; i++) {
        while (j > 0 && pattern[i] != pattern[j]) {
            j = next[j - 1];
        }
        if (pattern[i] == pattern[j]) {
            j++;
        }
        next[i] = j;
    }
    return next;
}

// KMP 字符串匹配函数
int strStr(const string &text, const string &pattern) {
    vector<int> next = computeNext(pattern); // 获取 next 数组
    int n1 = text.size();
    int n2 = pattern.size();

    if (n2 == 0) {
        return 0; // 如果模式串为空，返回 0
    }

    int i = 0, j = 0; // i 指向文本串，j 指向模式串
    while (i < n1) {
        if (text[i] == pattern[j]) {
            i++;
            j++;
        } else {
            if (j > 0) {
                j = next[j - 1]; // 根据 next 数组更新模式串指针
            } else {
                i++;
            }
        }
        if (j == n2) {
            return i - n2; // 找到匹配，返回匹配的起始位置
        }
    }
    return -1; // 如果未找到匹配，返回 -1
}

int main() {
    string text = "ABABDABACDABABCABAB";
    string pattern = "ABABCABAB";
    int index = strStr(text, pattern);
    cout << "Pattern found at index " << index << endl;
    return 0;
}
```

##### 求解字符串最长公共前后缀

最后，我们还剩下一个问题，如何求 next 数组，也就是求模式字符串各个子串的最长公共前后缀长度。

我们先初始化一个和模式字符串长度相等的 next 数组，在 next 数组中，第 1 位默认为 0，因为我们规定只有一个字符的字符串没有前缀和后缀，自然公共前后缀长度只能是 0。我们依然设定 2 个指针 i 和 j，j 指向位置 0，i 从位置 1 开始依次为 next 数组进行赋值

![img](./11.jpg)

我们可以把这个过程依然看作是 2 个字符串的比较，**j 指向的是模式字符串的前缀，而 i 指向的是模式字符串的后缀**

> 前缀不包括最后一个，后缀不包括第一个

![img](./12.jpg)

**和上面的字符串匹配一样，我们执行同样的处理：**

> 匹配有一种情况，`ij`同时移动
>
> 不匹配有两种情况，`j`是否为`0`则`i`移动和`j`跳回上一匹配位置

1. 当 i 和 j 匹配时，i 和 j 同时右移一格
2. 当 i 和 j 不匹配时，如果 j 不在字符串开头（位置 0），**就回退到上一个能匹配到的位置**
3. 当 i 和 j 不匹配时，如果 j 在字符串开头（位置 0），那么 i 就右移一格

对` next [1]` 赋值：`i `和 `j `不匹配，同时` j `已经是字符串开头，赋值 0

![img](./13.jpg)

对 next [2] 赋值，i 和 j 匹配，此时 j 为 0，代表只有 1 个字符匹配 (j+1)，赋值 1

![img](./14.jpg)

对 next [3] 赋值，i 和 j 匹配，此时 j 为 1，代表有 2 个字符匹配 **`(j+1)`**，赋值 2

![img](./15.jpg)

对 next [4] 赋值，i 和 j 不匹配，此时 j 为 2，可以得知 j 前面的字符是 `ab`，而 `ab` 的最长公共前后缀长度就是 `next[1]`，这个值我们前面已经求得了结果是 0，所以 j 回退到位置 0，用代码表示就是 `j=next[j-1]`

![img](./16.jpg)

此时 i 和 j 仍然不匹配，但是 j 已为 0，无法继续回退，所以直接对 next [4] 赋值为 0

![img](./17.jpg)

实际上，我们在求解模式字符串 `ababc` 的最长公共前后缀长度的时候，**不可避免的会对它的子串进行求解，这样可以方便在不匹配时进行回退**，这也是动态规划的思想，**要求的结果可以用先前已经求得的结果得出**。而我们本身就是要对模式字符串的各个子串进行求解，所以可谓一举两得。

```c++
#include <iostream>
#include <vector>
#include <string>

using namespace std;

// 计算模式串的 next 数组
vector<int> computeNext(const string &pattern) {
    int n = pattern.size();
    vector<int> next(n, 0);
    int i = 1, j = 0; // i 用于遍历模式串，j 记录最长前缀也是后缀的长度

    while (i < n) {
        if (pattern[i] == pattern[j]) {
            j++;
            next[i] = j; // 更新 next 数组
            i++;
        } else {
            if (j > 0) {
                j = next[j - 1]; // 根据 next 数组回退
            } else {
                next[i] = 0; // 如果 j 为 0，设置 next[i] 为 0
                i++;
            }
        }
    }
    return next;
}

int main() {
    string pattern = "ABABCABAB";
    vector<int> next = computeNext(pattern);

    // 输出 next 数组
    cout << "Next array: ";
    for (int val : next) {
        cout << val << " ";
    }
    cout << endl;

    return 0;
}
```

对比一下上一段的字符串匹配代码，可以发现，2 段代码的执行逻辑几乎一模一样，不同之处只是我们在比较过程中插入了对 next 数组进行赋值的代码。

可以这样理解，在字符串匹配中，i 指向的是主串，j 指向的子串，比较的是主串和子串。而在求公共前后缀的时候，**我们相当于把模式字符串拆成了前后两部分**，同样是对这 2 部分进行字符串匹配，相当于自己比自己。

以上就是 KMP 算法的核心原理及实现，当然，实现方式并不是只有这一种，KMP 的实现算法多种多样，包括生成的 next 数组都会不一样，而我这里的代码只是希望能够把 KMP 的思路表述清楚：

1. KMP 通过**计算模式字符串自身得到 next 数组；**
2. 不匹配时**通过 next 数组信息进行回退**，而**不用再从头开始比较**；
3. 原理就是利用模式字符串的公共前后缀信息，所以算法是奏效的。

![KMP算法拟人化演示](./1460000022642186-1723804032866-34.gif)

