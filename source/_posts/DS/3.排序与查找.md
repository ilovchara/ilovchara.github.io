---
title: 排序与查找
date: 2023-04-26 08:20:07
categories: 算法
tags: 数据结构
typora-root-url: 3.排序与查找
---

## [排序](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

排序是重新排列表中的元素，输入一个随机排序的数列，输出一个有序的数列。基本所有的排序都是如此，通常需要输入对应表的长度，对应表的引用即可进行排序。

其中**稳定性**是描述排序过程中数据变动的情况，举个例子排序一个结构体

```c++
struct RA{
    int key;
    int value;
}
```

对于结构体的`value`进行排序，如果有两个不同的`key`映射的值`value`相同，在排序完之后数据映射依旧，那么可以说明这个排序稳定。

考虑以下待排序数组，其中元素的格式为`(key, value)`：

```c++
(4, A), (2, B), (3, C), (2, D), (4, E)
```

排序完成之后变为，映射依旧。

```c++
(2, B), (2, D), (3, C), (4, A), (4, E)
```

> 内部排序和外部排序的区分

其中内部排序和外部排序的区分，是在于数据是否完全存储于内存中。最显著的区分就是他们的运算速度和运算范围。

内部排序的特点就是运算速度快，但是限于内存的大小，只能运算小数量级的排序。符合内部排序的有：冒泡排序，插入排序，选择排序，快速排序，归并排序，堆排序，希尔排序。

外部排序一般会在名字上备注，且通常会使用IO流来控制数据的导入与导出(磁盘-内存)。以下介绍的基本排序函数，都不属于外部排序。

> 执行过程

任何排序的核心思想就是将序列分为两个部分，第一部分是有序序列，其中存储的都是有序的数；另部分就是无序的数据，是尚未遍历到是未知顺序的数据。

通常排序过程中，都会涉及到获取数据 - 移动数据；其中的时间复杂度基本上取决于这两者。预测排序算法的时间复杂度通常会使用概率等工具构造其复杂度函数。

![sort](./sort-1721820673446-3-1723804171932-3.png)

### 交换排序

#### 冒泡排序

冒泡排序的基本思想是，从前往后或者从后往前遍历数组，过程中两两交换其中的数据。根据使用的要求，可以让数据从大到小`A[i-1]<A[i]`，或者从小到大`A[i-1]>A[i]`。

所以说实现冒泡排序的关键是：交换和遍历

![冒泡排序](./%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-1721820673446-5-1723804171931-1.gif)

```c++
//数组记得用引用类似 - 可以改变数组的值不仅仅只是参数变量
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

//从小到大
void sort(int array[],int length)
{
    //有无数据
    if(length>0){
        //遍历一次，排序完全区域就增加一个数据
        for(int i = 1;i<length;i++){
            //未排数据就少一个位置
            //以确保从未排序区域的第一个元素开始进行比较和交换
            for(int j = 0;j<=lenth-i;j++){ //为了给第一个数据位置
                if(array[j]>array[j+1]){
                    swap(array[j],array[j+1]);
                }
            }
        }
    }
}
```

教科书上实现的冒泡排序，比较简单

```c++
void BubbleSOrt(ElemType A[],int n){
    for(int i = 0;i<n-1;i++){
        bool flag = false;
        // 这里改为正序也可以
        for(int j=n-1;j>i;j--){
            if(A[j-1]>A[j]) {
                swap(A[j-1],j[j]); //逆序交换
            	flag = true;
            }
		}
         if(flag==false) return;
    }   
}
```

冒泡排序是一种稳定的排序手法，其时间复杂度是`O(n^2)`，平均时间复杂度是`O(n^2)`。冒泡排序产生的有序子序列一定是**全局有序**的。全局有序通常指的是一个数据集合中所有元素都按照某种排序规则排列好。

#### 快速排序

![快速排序](./quickSort-1721820673447-13-1723804171931-2.gif)

快速排序是基于分治法，分治法的意思是将一个大问题转化为几个小问题，通过解决完成全部小问题然后返回值构成大问题的解而成。由于每个小问题的解决方法都是一致的，所以选择使用递归来实现这些操作。

具体实现快速排序是这样的，每一次都在当前分好的序列中执行这些操作。

- 首先选举出一个基准值，对基准值的操作具体要看你的要求，这里假设要从小到大
- 将小于当前基准值的数据放在数据左侧
- 将大于当前基准值的数据放在数据右侧

由于快速排序每次递归将序列分为两个子序列，递归的深度决定了其空间复杂度。在理想情况下，递归深度为 `log(n)`，因此快速排序的空间复杂度为 `O(log(n))`。但在最坏情况下，递归深度为 `n`，此时的空间复杂度会增加到 `O(n)`。

```c++
// 快速排序
void QuickSort(ElemType A[], int low, int high) {
    // 如果子数组的元素个数大于1，则继续递归排序
    if (low < high) {
        // 划分区间，并获取基准值的位置
        int pivotpos = Partition(A, low, high);
        // 对基准值左侧的子数组递归排序
        QuickSort(A, low, pivotpos - 1);
        // 对基准值右侧的子数组递归排序
        QuickSort(A, pivotpos + 1, high);
    }
}

// 划分区间 - 返回基准值的位置
int Partition(ElemType A[], int low, int high) {
    ElemType pivot = A[low]; // 将第一个元素设为基准值
    while (low < high) {
        // 从右侧开始，找到第一个小于基准值的元素
        while (low < high && A[high] >= pivot) --high;
        A[low] = A[high]; // 将这个元素移动到左侧
        // 从左侧开始，找到第一个大于基准值的元素
        while (low < high && A[low] <= pivot) ++low;
        A[high] = A[low]; // 将这个元素移动到右侧
    }
    A[low] = pivot; // 将基准值放回正确的位置
    // 返回基准值的位置
    return low;
}
```

### 插入排序

前面说过，任何排序的核心思想就是将序列分为两个部分，第一部分是有序序列，其中存储的都是有序的数；另部分就是无序的数据，是尚未遍历到是未知顺序的数据。

插入排序的核心思想于斗地主抓牌类似，假设发牌员将无序的牌堆在牌桌上，为了区分，我们认为手中的牌是有序的。每次从无序的牌堆接收到一个新的牌，将之插入到有序的序列当中，也就是抓牌整理排序。直接插入排序的时间复杂度是`O(n^2)`，因为有两层循环。第一层从无序的位置找到一张牌，第二层将这个牌插入到有序的位置。

码牌的时候将无序的牌插入到手中的牌，每次插完有序+1，无序-1。直到无序部分没有牌为止。**如果在无序牌堆中，所有的牌是正序的时候**，其时间复杂度会降低到O(n)，也就是仅仅插入而不用进行比较。（但是正序序列为什么需要排序呢？）

![插入排序](./insertionSort-1721820673447-8-1723804171932-4.gif)

具体操作如下，声明一个单指针`i`来遍历我们的数组，然后使用一个`j`内循环指针，对排序完成的区域进行一次遍历移动，然后将对应的`i`指针的数据插入到对应的位置即可。

```c++
void sort(int array[],int length){
    for(int i = 1;i<length;i++){
        //1.从无序牌堆中找到的牌
        int key = array[i];
        //2.变量指向的是有序牌堆
        int j = i-1;
	   //3.从有序牌堆中找到适合key的位置插入
        while(j>=0 && array[j]>key){
            //插入位置设置为j的前面
            array[j+1] = array[j];
            j--;
        }
        //插入正确位置 - 完工
        array[j+1] = key;
    }
}
```

有关于王道中的直接插入排序代码如下，采用了用变量暂时记录数据

```c++
void InsertSort(ET A[],int n)
{
    int i,j;
    for(int i = 2;i<=n;i++)
    {
        //边查找边排序
        if(A[i]<A[i-1])
        {
		   A[0] = A[i]; //A[0]位置充当过度变量
            //j指向的是有序序列，循环是挪动比较位置
            for(int j = i-1;A[0]<A[j];--j) A[j+1] = A[j];
            //插入到有序序列第一个大于的位置
            A[j+1] = A[0];            
        }
    }
}
```

其中的空间复杂度为O(1)，最坏时间复杂度是O(n)

#### 折半插入排序

普通插入排序是将比较和移动集中在一起，这里将比较和移动操作分离就成了折半插入排序。对于线性表来说，可以在有序序列中确定当前`key`要插入的位置，然后将`key`插入

也就是优化了查找数据的时间复杂度，减少了比较元素的个数`n`。为原来的`O(nlg2)`，但是元素的移动次数没有改变，故时间复杂度还是`O(n)`。

折半插入排序函数是一种稳定的排序方法。

```c++
void InsertSort(ElemType A[],int n)
{
    int i,j,low,high,mid;
    //i记录的是新加入的牌
    for(int i = 2;i<=n;i++)
    {
        A[0] = A[i]; //记录当前插入的无序
        low=1,high=i-1;
        //二分找插入点
        while(low<=high)
        {
            mid=(low+high)/2;
            if(A[mid]>low) high = mid-1;
            else low=mid+1;                      
        }
        for(int j = i-1;j>=high+1;--j){
            A[j+1]=A{j];
		}
         A[high+1] = A[0]; //插入
    }   
    
}
```

#### [希尔排序操作](https://blog.csdn.net/qq_43473694/article/details/112197066)

![希尔排序](./Sorting_shellsort_anim-1721820673447-11-1723804171932-5.gif)

希尔排序是对插入排序的优化，如果我们插入的`无序牌`有序的话，可以减少大量的时间。举个例子，你手上`2 3 4 5 6`然后来了`7 8 9 10`是不是直接插就行了。希尔排序就是为了尽量构造这样的结构来达到优化的结果。

在希尔排序中，我们将一个大的排序序列根据定义的步长 `d` 分割成多个子序列，并对每个子序列进行插入排序。需要注意的是，这些子序列是交错的，也就是说，分组之间存在重叠。当对所有子序列完成排序后，整个数组将逐渐变得部分有序。

![image-20240814115601815](./image-20240814115601815-1723796451329-6-1723804171932-6.png)

由于在步长较大的情况下，希尔排序已经对数组进行了初步排序，减少了无序的元素，因此在最终步长为 1 时，最后一轮的插入排序将变得非常高效，时间复杂度可以降至`O(n)`。这种方法之所以有效，是因为在排序过程中，数组的无序程度逐步降低，使得后续的排序操作更快完成。

需要注意的是步长的定义，这个决定了每一个分组中比较和交换的时间复杂度。希尔排序的时间复杂度大约在`O(nlogn)` 和 `O(n^2)`之间，最坏情况下和普通的插入排序的时间复杂度是一样的。最坏情况通常出现在选择的增量（gap）与输入数据的排列方式导致在每个子序列中都需要大量的比较和交换。

```c++
void ShellSort(ElemType A[], int n) {
    int dk, i, j;
    // 外层循环处理不同的步长
    for (dk = n / 2; dk >= 1; dk = dk / 2) {
        // 内层循环对每个分组进行插入排序
        // i的作用是确定每个子序列的起点
        for (int i = dk; i < n; i++) {
            if (A[i] < A[i - dk]) {
                A[0] = A[i]; // 临时存储当前元素
                for (j = i - dk; j >= 0 && A[0] < A[j]; j -= dk) {
                    A[j + dk] = A[j]; // 移动元素
                }
                A[j + dk] = A[0]; // 插入到正确位置
            }
        }
    }
}
```

需要注意的是，**希尔排序并不是稳定的排序**，也就是其中相同的对应元素会发生改变。本质上是对插入排序的优化，所以说最坏情况和插入排序挂钩。

### 选择排序

![选择排序](./selectionSort-1721820673447-7-1723804171932-7.gif)

插入排序一样，选择排序也分为两个部分，已经排序和排序完全的部分。

具体实现是使用双指针算法，假设我们需要排序从小到大的数组，第一个位置用`i`指向，用`j`指向`i`之后的其他数据，在查询的过程中比较`A[i],A[j]`，如果`A[j]<A[i]`则执行交换，交换完成之后`i`前移，重复这个过程直到未排序序列为空。

选择排序的时间复杂度为`o(n^2)`，且选择排序是一种不稳定的排序算法。

```c++
void SelectSort(ElemType A[],int n){
    for(int i = 0;i<n-1;i++)
    {
        // 最小值位置 - 相对于未排序部分来说
        int min = i;
        for(int j = i+1;j<n;j++)
        {
            if(A[j]<A[min]) min = j; // 记录最小值位置
        }
        if(min!=i) swap(A[i],A[min]); // 与最小值位置交换
    }
}
```

#### [堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

堆排序是使用完全二叉树对数据进行处理，具体流程是

- 先将所有排序数据组合成一个完全二叉树
- 然后根据要大根堆还是小根堆，对这个二叉树进行重组
- 最后对大根堆和小跟堆进行交换数据，最后用数组顺序输出即可

![img](./1024555-20161217182750011-675658660-1723796455282-9-1723804171932-8.png)

通常堆都是用数组来模拟的，用数组下标的关系来表示各个节点。具体映射图像是这样的

![img](./1024555-20161217182857323-2092264199-1723796457244-11-1723804171932-9.png)

那解决堆排序的重点就有两个

- 构成大根堆或者小根堆
- 对大根堆和小跟堆进行调整输出回数组中

以大根堆为例，用数组`A[0]`作为根节点。那么对于这个堆的左节点符合`2i+1`，右节点符合`2i+2`。对于堆中的每一个节点，查找其子节点并进行比较，将较大值置于该节点位置。

```c++
void HeadAdjust(ElemType A[], int k, int len) {
    A[0] = A[k]; // 将根节点的值存入 A[0] 作为临时变量
    for(int i = 2 * k; i <= len; i *= 2) { // 遍历当前节点的子节点
        if(i < len && A[i] < A[i + 1]) i++; // 如果右子节点比左子节点大，选择右子节点
        if(A[0] >= A[i]) break; // 如果根节点比子节点大，停止调整
        else {
            A[k] = A[i]; // 子节点的值上移
            k = i; // 更新 k，使其指向下一个子节点
        }
    }
    A[k] = A[0]; // 将原根节点的值放入最终位置
}
```

然后对大根堆进行调整，实现堆排序

- 在大根堆构造完成后，最大元素位于堆顶（即数组的第一个元素）。
- 将堆顶元素（最大值）与堆的最后一个元素交换，然后减少堆的大小（忽略最后一个元素，因为它已经排好序）。
- 调整剩余的堆，再次进行堆化。

重复上序的操作，就可以实现堆排序.

```c++
void HeapSort(ElemType A[], int len) {
    // Step 1: 构造初始大根堆
    for(int i = len / 2; i > 0; i--) {
        HeadAdjust(A, i, len);
    }

    // Step 2: 进行排序
    for(int i = len; i > 1; i--) {
        swap(A[1], A[i]);   // 将堆顶元素（最大值）交换到数组末尾
        HeadAdjust(A, 1, i - 1); // 调整剩余部分为大根堆
    }
}

void HeadAdjust(ElemType A[], int k, int len) {
    A[0] = A[k];
    for(int i = 2 * k; i <= len; i *= 2) {
        if(i < len && A[i] < A[i + 1]) i++;
        if(A[0] >= A[i]) break;
        else {
            A[k] = A[i];
            k = i;
        }
    }
    A[k] = A[0];
}
```

最后顺序输出的数组，就是排完序的数组。堆排序的时间复杂度为`O(nlogn)`，建立堆的时间花费`O(n)`，对每个堆调整的时间为`O(logn)`。

### 归并排序

![归并排序](./mergeSort-1721820673447-12-1723804171932-10.gif)

归并排序的核心思想是分治，将一个大问题分为许多小问题再总和起来。由于这些小问题完成的操作都是一样的，所以用递归的操作实现这个排序算法。每一个小块的操作如下

- 先分当前块分为两个部分，分为左子序列和右子序列
- 对左子序列和右子序列分别调用归并排序函数进行处理，直到子序列的长度为1，此时子序列本身就是有序的。
- 当两个子序列都排序完成后，将它们合并为一个有序的序列。在合并的过程中，比较两个子序列的元素，将较小的元素放入到新的序列中，并依次进行，直到所有元素都合并完成。

```c++
//tmp是辅助数组 - q是原数组
int tmp[N],q[N];

void qsort(int q[],int l,int r){
    if(l == r) return; //合并完成
    
    int mid = l+r>>1;
    //分的左边
    qsort(q,l,mid);
    //分的右边
    qsort(q,mid+1,r);
    
    //这一部分不会立即执行 - 需要执行完成上面的分子序列才行。直到每一个元素都分为一个子序列
    //k是并的维护指针
    int i = l,j = mid+1,k = 0;
    
    while(i<=mid && j<=r){
        //i和j不在同一个区间 - 在两个不同的区间
        if(q[i]<q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while(i<=mid) tmp[k++] = q[i++];
    while(j<=r) tmp[k++] = q[j++];
    
    //最后拼回去
    for(int i = l,j = 0;i<=r;i++,j++) q[i] = tmp[j];
    
}
```

归并排序是稳定算法，且其空间复杂度为`O(nlogn)`。每次归并的时间复杂度为`O(n)`，需要执行`logn`次。

### 基数排序

基数排序（Radix sort）是一种非比较型整数排序算法。

原理是将整数**按位数切割成不同的数字**，然后**按每个位数分别比较**。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

- **MSD**：先从高位开始进行排序，在每个关键字上，可采用计数排序
- **LSD**：先从低位开始进行排序，在每个关键字上，可采用桶排序

实现逻辑是：

- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
- 从最低位开始，依次进行一次排序。
- 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

分步图示说明：设有数组 array = {53, 3, 542, 748, 14, 214, 154, 63, 616}，对其进行基数排序：

![img](./v2-5ae4857fa248035ecec780583c5e3303_720w-1723796493039-14-1723804171932-11.webp)

在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。

- 按照个位数进行排序。
- 按照十位数进行排序。
- 按照百位数进行排序。

排序后，数列就变成了一个有序序列。

> 时间复杂度：O(k*N)
> 空间复杂度：O(k + N)
> 稳定性：稳定

```c++
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];      ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
```

#### 计数排序

![计数排序](./countingSort-1721820673447-15-1723804171932-12.gif)

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序的时间复杂度是`o(n+K)`，低时间复杂度但是高空间。

简单说，就是用我们"需要排序的序列的值",创建一个标记数组，只要序列出现过的值，都标记成1，就说明它出现了。但是，这种方法只对数来说比较方便。可以说是数组下标和排序序列有映射关系。

> 算法步骤
> （1）找出待排序的数组中最大和最小的元素
> （2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
> （3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
> （4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
>
> 但是这种方法排序离散的数据就不靠谱了。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 计数排序函数，将排序结果存储在sorted_arr中
void counting_sort(int *arr, int n) {
    int max = 0;

    // 找到数组中的最大值，以确定计数数组的大小
    for (int i = 0; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    // 创建计数数组和排序后的数组
    int *count_arr = (int *)malloc(sizeof(int) * (max + 1));
    int *sorted_arr = (int *)malloc(sizeof(int) * n);

    // 初始化计数数组为0
    for (int i = 0; i <= max; i++) {
        count_arr[i] = 0;
    }

    // 计算每个元素出现的次数
    for (int i = 0; i < n; i++) {
        count_arr[arr[i]]++;
    }

    int index = 0;

    // 从计数数组中构建排序后的数组
    for (int i = 0; i <= max; i++) {
        while (count_arr[i] > 0) {
            sorted_arr[index] = i;
            index++;
            count_arr[i]--;
        }
    }

    free(count_arr);

    // 打印排序后的数组
    printf("sorted_array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", sorted_arr[i]);
    }
    printf("\n");

    free(sorted_arr);
}

int main(int argc, char **argv) {
    int n = 10;
    int *arr = (int *)malloc(sizeof(int) * n);
    srand(time(0));

    // 生成随机数组
    for (int i = 0; i < n; i++) {
        arr[i] = rand() % 100;
    }

    // 打印初始数组
    printf("ini_array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 调用计数排序函数
    counting_sort(arr, n);
    free(arr);

    return 0;
}
```

#### 桶排序

元素分布在桶中：

![桶](./Bucket_sort_1.svg_-1721820673447-21-1723804171932-13.png)

然后，元素在每个桶中排序：

![桶](./Bucket_sort_2.svg_-1721820673447-16-1723804171932-14.png)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n;
int a[N], b[N];

int main()
{
    cin >> n;
    // 输入数据
    for (int i = 0; i < n; i++) 
        cin >> a[i];

    // 找到数组中的最大值
    int maxv = *max_element(a, a + n);

    // 统计每个元素出现的次数
    for (int i = 0; i < n; i++)
        b[a[i]]++;

    int j = 0; // 辅助指针j，用于更新原数组a
    // 从0到最大值遍历，按照计数数组b的信息重建原数组a
    for (int i = 0; i <= maxv; i++)
    {
        while (b[i]--) // 每个元素出现的次数减少一个
            a[j++] = i; // 更新原数组
    }

    // 输出排序后的数组
    for (int i = 0; i < n; i++)
        cout << a[i] << ' ';

    return 0;
}
      
```

## [查找](https://www.dotcpp.com/course/157)

查找操作是指在给定的数据集合中，根据特定的条件找到一个特定的数据项。这个数据项可能是一个值、一个键或一个属性。查找操作的时间复杂度是衡量查找效率的重要指标，它表示了查找操作所需的时间与数据项数量的关系。

常用的查找算法

- 线性查找：这是最基本的查找算法，它按照顺序逐个比较数据项，直到找到目标数据项或遍历完整个数据集合。线性查找的时间复杂度为O(n)，其中n为数据集合的大小。
- 二分查找：二分查找是一种高效的查找算法，适用于已排序的数据集合。它将数据集合分成两半，然后根据目标值与中间值的比较结果，排除一半的数据，继续在另一半数据中进行查找。二分查找的时间复杂度为O(log n)。
- 哈希查找：哈希查找利用哈希表数据结构进行查找。它将数据项的键通过哈希函数转换为对应的地址，然后在该地址处存储该数据项的值。哈希查找的时间复杂度一般为O(1)，但在哈希冲突严重的情况下，时间复杂度可能会退化到O(n)。
- B树查找：B树是一种平衡的多路搜索树，它能够保持数据的有序性，并支持快速的插入、删除和查找操作。B树查找的时间复杂度为O(log n)。
- 散列查找：散列查找是一种利用哈希函数将键映射到桶中的数据结构进行查找的方法。它能够快速地定位到目标数据项的桶，然后在桶中继续进行线性查找。散列查找的时间复杂度一般为O(1)。

### 顺序查找

顺序查找（Sequential Search）又叫线性查找，是**最基本的查找技术**，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

```c++
int Sequential_Search(int *a,int n,int key)    //a为数组，n为要查找数组长度，key为待查找关键词
{
    int i;
    for(i = 1;i <= n;i++)    //遍历数组内的每一条记录,元素记录是从1开始
    {
        if(a[i] == key)    //如果查找到，则返回记录所在位置
            return i;
    }
    return 0;    //如果未查找到，则返回0
}
```

### 折半查找

二分查找的思路简单，我们需要找的数据都是在数组中，只要将这个数组分为两个部分，然后在左边找不到就到右边找，然后再把剩下的数组分为两部分，以此类推。

二分查找采用双指针的形式，来对我们数组序列进行遍历。二分查找只使用于排好序的数组，不适用于其他。掌握二分查找的关键是，要明白数组是怎么分成两部分，两部分的边界是什么组成的。

如果按照顺序查找的话就是按照对应序列一个一个找，直到找到目标为止，没有找到就返回`-1`

```c++
int a[N];
int ans;
for(int i = 1;i<N;i++){
    if(a[i] == ans) return true;
  else break;
}
if(a[N]!=ans) return false;    
```

这可以用蓝红划分数组来解释，假设我们数组开始全是灰色(没有被遍历)，设计一个蓝色指针指向数组的最左边，从左往右扫到蓝红边界，知道扫到目标值。

![image-20230923182039153](./image-20230923182039153-1721820537011-32.png)

然后也同样，也可以在最右边设计一个红色指针，从右往左扫直到扫到蓝红边界，直到扫到我们的目标值。

![image-20230923182210667](./image-20230923182210667-1721820537011-33.png)

这样的算法是十分低效的，原因是因为指针移动速度缓慢，每次只能在数组中搜索到一个值的信息。

在上面的基础上，我们用蓝红表示二分数组中两个不同的区域：

![image-20230923181905524](./image-20230923181905524-1721820537011-34.png)

如果我们在数组中间发现一个指针为蓝色，那么很显然这个指针之前的颜色全为蓝色：

![image-20230923182618450](./image-20230923182618450-1721820537011-35.png)

同样的我们在右侧发现了一个红色区域块，就可以推断出其右侧区域都是红色

![image-20230923184049459](./image-20230923184049459-1721820537011-37.png)

通过这样不断操作，直到找到我们的蓝红边界：

![image-20230923184222698](./image-20230923184222698-1721820537011-36.png)

我们为什么要找蓝红边界，因为二分有几个常见的问题需要我们解决，假设ans是我们需要找到的二分值，对这个值我们有如下问题：

- 找到第一个`>=ans`的元素
- 找到最后一个`<ans`的元素
- 找到第一个`>ans`的元素
- 找到最后一个`<=ans`的元素

对于这个值暂时不去讨论，我们先搞定拓展红蓝色的代码：

```c++
//伪代码
l = -1,r = N;
while(l+1!=r){//直到达到边界
    m = (l+R)/2; //这里需要向下取整
    if(isBlue(m)) l = m; //蓝色边界蔓延至我们的m
    else r = m; //反之就红色边界蔓延
    return l or r //缩小到最后就是我们要找的目标值
}
```

开始`l`指针指向蓝色区域，`r`指针指向红色区域，循环直到达到边界，**保持`l,r`颜色不发生改变**，遍历结束`l,r`就达到了蓝红边界处。二分查找的时间复杂度是`o(log n)`，也就是一直在折半。

为什么`l`区域初始化为`-1`，这是因为我们需要再数组中分蓝和红区域，如果将`l`初始化为1，恰好数组中全是红色区域，这样就矛盾了。同理，`r`也不可以取`r-1`这个位置，也会导致矛盾。

![image-20230923224009827](./image-20230923224009827-1721820537011-39.png)

同时验证一下m是否都在数组中，因为`l`最小值是`-1`,`r`最小值是`1`(这里r最小值是因为 `l+1 = r` 的时候会直接退出，如果`r = 0`那么就会直接跳出循环) ，m的最小值也就为 `(1 + 1 )/2= 0`。以此类推，`l`的最大值应该是`N-2`（`N1`跳出循环体循环），那么`r`的最大值也是为`N`(边界嘛)。所以说最大值是`(N-2+N-1)/2 = N/2`

![image-20230923224046736](./image-20230923224046736-1721820537011-38.png)

更新指针的时候，都是指向蓝红边界的位置，如果我们改变为`l = m+1`会导致区域发生错误，我们就用更新为`m和r`的模版就行，不会搞乱自己。

![image-20230923224929897](./image-20230923224929897-1721820537011-40.png)

死循环问题：全部问题都会归类为第一种退出循环的方式

![image-20230923225144185](./image-20230923225144185-1721820537011-43.png)

### [分块查找](https://www.dotcpp.com/course/156)

分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况，其核心有二索引表，二是分块处理。

分块查找要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。假设是按关键码值非递减的，那么这种块与块之间必须满足已排序要求，实际上就是对于任意的i，第i块中的所有节点的关键码值都必须小于第i+1块中的所有节点的关键码值。此外，还要建立一个索引表，把每块中的最大关键码值作为索引表的关键码值，按块的顺序存放到一个辅助数组中，显然这个辅助数组是按关键码值费递减排序的。查找时，首先在索引表中进行查找，确定要找的节点所在的块。由于索引表是排序的，因此，对索引表的查找可以采用顺序查找或折半查找；然后，在相应的块中采用顺序查找，即可找到对应的节点。

![分块查找](./1576383331428606.png)

假设要查找关键字 38 的具体位置。首先将 38 依次和索引表中各最大关键字进行比较，因为 22 < 38 < 48，所以可以确定 38 如果存在，肯定在第二个子表中。

由于索引表中显示第二子表的起始位置在查找表的第 7 的位置上，所以从该位置开始进行顺序查找，一直查找到该子表最后一个关键字（一般将查找表进行等分，具体子表个数根据实际情况而定）。结果在第 10 的位置上确定该关键字即为所找。

```c++
#include <stdio.h>
#include <stdlib.h>
  
struct index 
{ 
　　//定义块的结构
　　int key;
　　int start;
  
} newIndex[3];  //定义结构体数组
int search(int key, int a[]);
  
int cmp(const void *a,const void* b)
{
　　return (*(struct index*)a).key>(*(struct index*)b).key?1:-1;
}
  
int main()
{
　　int i, j=-1, k, key;
　　int a[] = {33,42,44,38,24,48, 22,12,13,8,9,20, 60,58,74,49,86,53};
　　//确认模块的起始值和最大值
　　for (i=0; i<3; i++) 
　　{
　　　　newIndex[i].start = j+1; //确定每个块范围的起始值
　　　　j += 6;
　　　　for (int k=newIndex[i].start; k<=j; k++) 
　　　　{
　　　　　　if (newIndex[i].key<a[k]) 
　　　　　　{
　　　　　　　　newIndex[i].key = a[k];
　　　　　　}
　　　　}
　　}
　　//对结构体按照 key 值进行排序
　　qsort(newIndex,3, sizeof(newIndex[0]), cmp);
　　//输入要查询的数，并调用函数进行查找
　　printf("请输入您想要查找的数：\n");
　　scanf("%d", &key);
　　k = search(key, a);
　　//输出查找的结果
　　if (k>0) 
　　{
　　　　printf("查找成功！您要找的数在数组中的位置是：%d\n",k+1);
　　}
　　else
　　{
　　　　printf("查找失败！您要找的数不在数组中。\n");
　　}
  
　　return 0;
}
  
int search(int key, int a[])
{
　　int i, startValue;
　　i = 0;
　　while (i<3 && key>newIndex[i].key) 
　　{ 
　　　　// 确定在哪个块中，遍历每个块，确定key在哪个块中
　　　　i++;
　　}
　　if (i>=3) 
　　{ 
　　　　//大于分得的块数，则返回0
　　　　return -1;
　　}
　　startValue = newIndex[i].start; //startValue等于块范围的起始值
　　while (startValue <= startValue+5 && a[startValue]!=key)
　　{
　　　　startValue++;
　　}
　　if (startValue>startValue+5) 
　　{ 
　　　　//如果大于块范围的结束值，则说明没有要查找的数
　　　　return -1;
　　}
  
　　return startValue;
}
```

分块查找在现实生活中也很常用。

例如，一个学校有很多个班级，每个班级有几十个学生。给定一个学生的学号，要求查找这个学生的相关资料。显然，每个班级的学生档案是分开存放的，没有任何两个班级的学生的学号是交叉重叠的，那么最好的查找方法实现确定这个学生所在的班级，然后再在这个学生所在班级的学生档案中查找这个学生的资料。上述查找学生资料的过程，实际上就是一个典型的分块查找。

### 树形查找

#### 二叉排序树

**二叉排序树**（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。该树属于一种输入数据就默认产生一种顺序的数据结构，这不像本章前面的内容所描述的静态的在某一个数据段内进行查找，动态查找是一种输入时就会自动对其进行排序的数据结构，前文学过的STL中的set集合其底层就是一个类似的树形结构红黑树。

> 二叉排序树有以下性质：

- 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也分别为二叉排序树；

即对于每一个根结点，其左孩子永远小于根，右孩子永远大于根。

如果树是空的，则查找结束，无匹配。如果被查找的值和根结点的值相等，查找成功。**否则就在子树中继续查找。如果被查找的值小于根结点的值就选择左子树，大于根结点的值就选择右子树。**

```c++
typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */ 
  
/* 二叉树的二叉链表结点结构定义 */
typedef  struct BiTNode /* 结点结构 */
{
    int data;   /* 结点数据 */
    struct BiTNode *lchild, *rchild;    /* 左右孩子指针 */
} BiTNode, *BiTree;
  
/* 递归查找二叉排序树T中是否存在key, */
/* 指针f指向T的双亲，其初始调用值为NULL */
/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */
/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */
Status SearchBST(BiTree t, int key, BiTree f, BiTree *p) 
{  
    if (!t) /*  查找不成功 */
    { 
        *p = f;  
        return FALSE; 
    }
    else if (key == t->data) /*  查找成功 */
    { 
        *p = t;  
        return TRUE; 
    } 
    else if (key < t->data) 
        return SearchBST(t->lchild, key, t, p);  /*  在左子树中继续查找 */
    else  
        return SearchBST(t->rchild, key, t, p);  /*  在右子树中继续查找 */
}
```

二叉排序的插入是建立在二叉排序的查找之上的，插入一个结点，就是通过查找发现该结点合适插入位置，把结点直接放进去。 其实在2.2节中一步步构造二叉排序树的过程中就是结点插入过程，并考虑查找的关键字已经有在树中，则指向该数据结点，若查找的关键字没有在树中，则指向查找路径上最后一个结点。

```c++
struct BiTree {
    int data;
    BiTree *lchild;
    BiTree *rchild;
};
  
//在二叉排序树中插入查找关键字key
BiTree* InsertBST(BiTree *t,int key)
{
    if (t == NULL)
    {
        t = new BiTree();
        t->lchild = t->rchild = NULL;
        t->data = key;
        return t;
    }
  
    if (key < t->data) 
        t->lchild = InsertBST(t->lchild, key);
    else
        t->rchild = InsertBST(t->rchild, key);
  
    return t;
}
  
//n个数据在数组d中，tree为二叉排序树根
BiTree* CreateBiTree(BiTree *tree, int d[], int n)
{
    for (int i = 0; i < n; i++)
        tree = InsertBST(tree, d[i]);
}
```

二叉树的删除可不再像二叉树的插入那么容易了，以为删除某个结点以后，会影响到树的其它部分的结构。删除的时候需要考虑以下几种情况：

- 删除结点为叶子结点；
- 删除的结点只有左子树；
- 删除的结点只有右子树
- 删除的结点既有左子树又有右子树。

```c++
/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */
/* 并返回TRUE；否则返回FALSE。 */
Status DeleteBST(BiTree *T,int key)
{ 
    if(!*T) /* 不存在关键字等于key的数据元素 */ 
        return FALSE;
    else
    {
        if (key==(*T)->data) /* 找到关键字等于key的数据元素 */ 
            return Delete(T);
        else if (key<(*T)->data)
            return DeleteBST(&(*T)->lchild,key);
        else
            return DeleteBST(&(*T)->rchild,key);
  
    }
}
/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */
Status Delete(BiTree *p)
{
    BiTree q,s;
    if((*p)->rchild==NULL) /* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */
    {
        q=*p; *p=(*p)->lchild; free(q);
    }
    else if((*p)->lchild==NULL) /* 只需重接它的右子树 */
    {
        q=*p; *p=(*p)->rchild; free(q);
    }
    else /* 左右子树均不空 */
    {
        q=*p; s=(*p)->lchild;
        while(s->rchild) /* 转左，然后向右到尽头（找待删结点的前驱） */
        {
            q=s;
            s=s->rchild;
        }
        (*p)->data=s->data; /*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */
        if(q!=*p)
            q->rchild=s->lchild; /*  重接q的右子树 */ 
        else
            q->lchild=s->lchild; /*  重接q的左子树 */
        free(s);
    }
    return TRUE;
}
```

#### [二叉平衡树](https://www.dotcpp.com/course/158)

平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 其中最为经典当属AVL树，我们

总计而言就是：平衡二叉树是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。

> AVL树具有下列性质的二叉树（注意，空树也属于一种平衡二叉树）：

- 它必须是一颗二叉查找树
- 它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。
- 若将二叉树节点的平衡因子BF定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有节点的平衡因子只可能为-1,0,1.
- 只要二叉树上有一个节点的平衡因子的绝对值大于1，那么这颗平衡二叉树就失去了平衡。

> 实现

AVL树的构建我们需要明白一个核心的操作，整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。各个调整的方法分为LL型、RR型、LR型和RL型4种类型，其余的操作与一般的树进行插入和修改数据无异，这里由于篇幅关系不做过多缀数，以其中一种LR型调整为例说明，其余各种也都是举一反三思考：

![动态查找-平衡二叉树](./1576542552902246.png)

由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。

- 将B的左孩子C提升为新的根结点
- 将原来的根结点A降为C的右孩子
- 各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。

```c++
#include<stdio.h>
#include<stdlib.h>
  
//结点设计 
typedef struct Node {
    int key;
    struct Node *left;
    struct Node *right;
    int height;
} BTNode;
  
int height(struct Node *N) {
    if (N == NULL)
        return 0;
    return N->height;
}
  
int max(int a, int b) {
    return (a > b) ? a : b;
}
  
BTNode* newNode(int key) {
    struct Node* node = (BTNode*)malloc(sizeof(struct Node));
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;
    return(node);
}
  
//ll型调整 
BTNode* ll_rotate(BTNode* y) {
    BTNode *x = y->left;
    y->left = x->right;
    x->right = y;
  
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
  
    return x;
}
  
//rr型调整 
BTNode* rr_rotate(BTNode* y) {
    BTNode *x = y->right;
    y->right = x->left;
    x->left = y;
  
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
  
    return x;
}
  
//判断平衡
int getBalance(BTNode* N) {
    if (N == NULL)
        return 0;
    return height(N->left) - height(N->right);
}
  
//插入结点&数据
BTNode* insert(BTNode* node, int key) {
    if (node == NULL)
        return newNode(key);
  
    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else
        return node;
  
    node->height = 1 + max(height(node->left), height(node->right));
  
    int balance = getBalance(node);
  
    if (balance > 1 && key < node->left->key) //LL型
        return ll_rotate(node);
  
    if (balance < -1 && key > node->right->key)     //RR型
        return rr_rotate(node);
  
    if (balance > 1 && key > node->left->key) {   //LR型
        node->left = rr_rotate(node->left);
        return ll_rotate(node);
    }
  
    if (balance < -1 && key < node->right->key) {   //RL型
        node->right = ll_rotate(node->right);
        return rr_rotate(node);
    }
  
    return node;
}
  
//遍历
void preOrder(struct Node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        preOrder(root->left);
        preOrder(root->right);
    }
}
  
int main() {
    BTNode *root = NULL;
  
    root = insert(root, 2);
    root = insert(root, 1);
    root = insert(root, 0);
    root = insert(root, 3);
    root = insert(root, 4);
    root = insert(root, 4);
    root = insert(root, 5);
    root = insert(root, 6);
    root = insert(root, 9);
    root = insert(root, 8);
    root = insert(root, 7);
  
    printf("前序遍历：");
    preOrder(root);
    return 0;
}
```

#### [B树](https://www.cnblogs.com/wxiaotong/p/14781753.html)

在计算机科学中，B树是一种自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数量级的时间复杂度内完成。B树，其实是一颗特殊的二叉查找树（binary search tree），可以拥有多于2个子节点。与自平衡二叉查找树不同，B树为系统大块数据的读写操作做了优化。B树减少定位记录时所经历的中间过程，从而加快存取速度，其实B树主要解决的就是数据IO的问题。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。

一个m阶的B树特点如下：

1. 所有叶子节点都在同一层级；
2. 除了根节点以外的其他节点包含的key值数量在[m/2]-1到m-1的数据范围；
3. 除了根节点和叶子节点外，所有中间节点至少有m/2个孩子节点；
4. 根节点如果不是叶子节点的话，它必须包含至少2个孩子节点；
5. 拥有n-1个key值非叶子节点必须有n个孩子节点；
6. 一个节点的所有key值必须是升序排序的；
   以上六点就是B树的全部特性

在B树种，检索操作类类似于二叉查找树。在二叉查找树中，检索开始于树的根节点，因为是二叉树所以每次有两种选择。在B树种检索中，也是开始于根节点，但每次需要比较n次（n是当前节点的所有子节点的数量）。在B树中，检索操作执行的时间复杂度是O(log n)，检索操作执行如下：

1. 从输入获取读取检索元素；
2. 和根节点的第一个元素进行比较；
3. 如果匹配上，返回元素找到并且终止函数；
4. 如果未匹配上，检查元数据与key值的大小；
5. 如果小于待查元素，继续检索B树的左子树；
6. 如果大于的话，比较相同节点中下一个key值并且重复3、4、5、6步，直到找到指定元素或者在树的叶子节点的最后一个结束；

在B树种的插入操作，新元素一定是新添加在叶子节点的，具体操作流程如下：

1. 检查树是否为空；
2. 如果树为空，用新的插入元素创建一个新的节点并插入到树中并作为树的根节点；
3. 如果树不为空，使用二叉查找树的逻辑为新元素找到一个叶子节点；
4. 如果叶子节点中key有空位置，直接按照叶子节点内key值升序的原则将节点插入；
5. 如果叶子节点中key已经满了，通过发送中间值到父节点，然后分裂叶子节点；重复这个操作，直到发送的中间值存储在一个节点中；
6. 如果分裂发生在根节点，中间值将会成为树的新的根节点，树的高度将会加 1；

![img](./btreebuild.gif)

1. 如果当前需要删除的key位于非叶子节点上，则用后继key（后继key，即右边叶子节点最左侧即为后继节点）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。此时后继key一定位于叶子节点上，这个过程和二叉搜索树删除节点的方式类似。删除这个记录后执行第2步；
2. 该节点key个数大于等于Math.ceil(m/2)-1（向下取整），结束删除操作，否则执行第3步；
3. 如果兄弟节点key个数大于Math.ceil(m/2)-1，则父节点中的key下移到该节点，兄弟节点中的一个key上移，删除操作结束，即从兄弟节点中借一个元素过来；否则，将父节点中的key下移与当前节点及它的兄弟节点中的key合并，形成一个新的节点。原父节点中的key的两个孩子指针就变成了一个孩子指针，指向这个新节点。然后当前节点的指针指向父节点，重复上第2步。

有些节点它可能即有左兄弟，又有右兄弟，那么我们任意选择一个兄弟节点进行操作即可。
下面以5阶B树为例，介绍B树的删除操作，5阶B树中，节点最多有4个key,最少有2个key

![img](./834468-20180406232752206-912030342.png)

#### [红黑树](https://www.cnblogs.com/wxiaotong/p/14781753.html)

红黑树也是一种自平衡二叉查找树，它与AVL树类似，都在添加和删除的时候通过旋转操作保持二叉树的平衡，以求更高效的查询性能。

与AVL树相比，红黑树牺牲了部分平衡性，以换取插入/删除操作时**较少的旋转**操作，整体来说性能要优于AVL树。

虽然RBTree是复杂的, 但它的**最坏情况运行时间**也是非常良好的,并且在实践中是高效的：

> 它可以在**O(log n)**时间内做查找,插入和删除,这里的**n 是树中元素的数目.**

红黑树是实际应用中最常用的平衡二叉查找树，它不严格的具有平衡属性，但平均的使用性能非常良好。

在红黑树中，节点被标记为红色和黑色两种颜色。

**红黑树的原则有以下几点：**

- 特性1：节点非黑即红
- 特性2：根节点一定是黑色
- 特性3：叶子节点（NIL）一定是黑色
- 特性4：每个红色节点的两个子节点都为黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
- 特性5：从任一节点到其每个叶子的所有路径，都包含相同数目的黑色节点。

**红色属性** 说明，红色节点的孩子，一定是黑色。 但是，RBTree 黑色节点的孩子，可以是红色，也可以是黑色，具体如下图。

**叶子属性** 说明， 叶子节点可以是空nil ，AVL的叶子节点不是空的，具体如下图。

![img](./20200901114718174.png)

基于上面的原则，我们一般在插入红黑树节点的时候，会将这个节点设置为红色，

原因参照最后一条原则： **红色破坏原则的可能性最小**，如果是黑色, 很可能**导致这条支路的黑色节点比其它支路的要多1**，破坏了平衡。

## 散列表
