---
title: 排序与查找
date: 2023-04-26 08:20:07
categories: 算法
tags: 数据结构
typora-root-url: 3.排序与查找
---

## [排序](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)*

排序（Sorting）是计算机科学中最基础和常用的算法之一，它是将一组数据按照某种规则重新排列的过程。排序算法通常用于解决大规模数据的分类、归纳和分析问题。排序算法涉及到许多细节，包括算法的复杂度、稳定性、内存占用等方面。因此，要理解排序算法，需要从多个角度进行分析。

**一、时间复杂度**

排序算法的时间复杂度是判断其效率的重要指标，它通常用大O记法（Big O notation）来表示。常见的排序算法有冒泡排序、插入排序、选择排序、归并排序、快速排序、堆排序等等。每种排序算法都有不同的时间复杂度，其中最优的时间复杂度为O(nlogn)。归并排序、快速排序、堆排序均实现了O(nlogn)的复杂度，而其他排序算法的时间复杂度则相对较高。

**二、稳定性**

在排序算法中，稳定性是指排序前和排序后具有相同值的元素之间的顺序是否保持不变。例如，在学生成绩表中，如果有多个学生的分数相同，那么**排序后他们之间的排名是否保持不变。**稳定性对于实际应用非常重要，比如在对英文文本排序时，要求相同的字符串顺序不变，以保持原有的语义。插入排序、冒泡排序、归并排序、基数排序等算法是稳定的，而选择排序、快速排序、希尔排序、堆排序等算法则是不稳定的。

其中**稳定性**是描述排序过程中数据变动的情况，举个例子排序一个结构体

```c++
struct RA{
    int key;
    int value;
}
```

对于结构体的`value`进行排序，如果有两个不同的`key`映射的值`value`相同，在排序完之后数据映射依旧，那么可以说明这个排序稳定。

考虑以下待排序数组，其中元素的格式为`(key, value)`：

```c++
(4, A), (2, B), (3, C), (2, D), (4, E)
```

排序完成之后变为，映射依旧。

```c++
(2, B), (2, D), (3, C), (4, A), (4, E)
```

**三、内存占用**

排序算法的效率不仅取决于时间复杂度，还受到内存占用的影响。某些排序算法需要额外的内存空间来完成排序操作，而其他算法则可以在原有的内存空间中就地完成排序。此外，一些排序算法在最坏情况下的内存占用量可能非常大，甚至超出可接受范围。插入排序、归并排序、基数排序等算法通常需要额外的内存空间，而选择排序、冒泡排序、快速排序、堆排序则不需要额外的内存空间。

**四、内部排序和外部排序的区分**

其中内部排序和外部排序的区分，是在于数据是否完全存储于内存中。最显著的区分就是他们的运算速度和运算范围。内部排序的特点就是运算速度快，但是**限于内存的大小**，只能运算小数量级的排序。符合内部排序的有：冒泡排序，插入排序，选择排序，快速排序，归并排序，堆排序，希尔排序。

外部排序一般会在名字上备注，且通常会使用IO流来控制数据的导入与导出(磁盘-内存)。以下介绍的基本排序函数，都不属于外部排序。

任何排序的核心思想就是将序列分为两个部分，第一部分是有序序列，其中存储的都是有序的数；另部分就是无序的数据，是尚未遍历到是未知顺序的数据。通常排序过程中，都会涉及到获取数据 - 移动数据；其中的时间复杂度基本上取决于这两者。预测排序算法的时间复杂度通常会使用概率等工具构造其复杂度函数。

![sort](./sort-1721820673446-3-1723804171932-3.png)

### [交换排序](https://developer.aliyun.com/article/1195163)

基本思想：所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。其中冒泡排序是稳定的，而快速排序通常是不稳定的。

#### 冒泡排序

冒泡排序（`Bubble Sort`）基本思想：类似于水中冒泡，**较大的数沉下去，较小的数慢慢冒起来(当然也可以反着来)**，假设从小到大，即为较大的数慢慢往后排，较小的数慢慢往前排。直观表达，每一趟遍历，将一个最大的数移到序列末尾。也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，将他们之间小的，或者大的值交换过来。**遍历数列的工作是重复地进行，直到没有再需要交换的**，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢"浮"到数列的顶端。总结有三个步骤

1. 比较相邻的元素，如果前一个比后一个大，交换之。
2. 第一趟排序第`i`个和第`i+1`个比较与交换，随后第`i+1`个和第`i+2`个一对比较交换，这样直到倒数第`n-1`个和最后`n`个，将最大的数移动到最后一位。
3. 第二趟将第二大的数移动至倒数第二位

![冒泡排序](./%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-1721820673446-5-1723804171931-1.gif)

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
#define N 10
// 1.交换操作
Swap(int *p1, int * p2)
{
    int tmp = *p1;
    *p1 = *p2;
    *p2 = tmp;
}
void Print(int *a)
{
    for (int i=0;i<N;i++)
    {
        printf("%d ",a[i]);
    }
}
// 2. 冒泡排序
void BubbleSort(int* a, int n)
{
    // 外部循环，维护排序区块和未排序区块
    for (int j=0;j<n;++j)
    {
        int size = 0;
        // 在未排序区块中，比较和交换直到最大值排列在排序完成的区块中
        for (int i=1;i<N-j;++i)
        {
            // 比较和交换
            if (a[i-1]>a[i])
            {
                Swap(&a[i-1],&a[i]);
                size =1;
            }
        }
        // 3.标记是否执行排序，未执行则提前跳出
        if (size==0)
        {
            break;
        }
    }
}
int main()
{
    int a[N] = {0};
    for (int i=0;i<N;++i)
    {
        a[i] = rand();
    }
    BubbleSort(a,N);
    Print(a);
    
    return 0;
}
```

教科书上实现的冒泡排序，比较工整

```c++
void BubbleSort(ElemType A[],int n){
    for(int i = 0;i<n-1;i++){
        bool flag = false;
        // 这里改为正序也可以
        for(int j=n-1;j>i;j--){
            if(A[j-1]>A[j]) {
                swap(A[j-1],j[j]); //逆序交换
            	flag = true;
            }
		}
         if(flag==false) return;
    }   
}
```

冒泡排序是一种稳定的排序手法，其时间复杂度是`O(n^2)`，平均时间复杂度是`O(n^2)`。冒泡排序产生的有序子序列一定是**全局有序**的。全局有序通常指的是一个数据集合中所有元素都按照某种排序规则排列好。

#### 快速排序

快速排序`(Quicksort)`是`Hoare`于`1962`年提出的一种二叉树结构的交换排序方法，有时候也叫做划分交换排序，是一个高效的算法，其基本思想为：任取待排序 元素序列中的某元素作为基准值，按照该排序码将待排序集合分割成两子序列，左子序列中所有 元素均小于基准值，右子序列中所有元素均大于基准值，然后最左右子序列重复该过程，直到所有元素都排列在相应位置上为止。这是一个分治算法，**而且它就在原地交换数据排序。**

![快速排序](./quickSort-1721820673447-13-1723804171931-2.gif)

分治法的意思是将一个大问题转化为几个小问题，通过解决完成全部小问题然后返回值构成大问题的解而成。由于每个小问题的解决方法都是一致的，所以选择使用递归来实现这些操作。具体实现快速排序是这样的，用基准值将序列分为两部分，左部分小于基准值，右部分大于基准值。然后在这两个部分都执行下述操作。

- 首先选举出一个基准值，对基准值的操作具体要看你的要求，这里假设要从小到大
- 将小于当前基准值的数据放在数据左侧
- 将大于当前基准值的数据放在数据右侧

由于快速排序每次递归将序列分为两个子序列，递归的深度决定了其空间复杂度。在理想情况下，递归深度为 `log(n)`，因此快速排序的空间复杂度为 `O(log(n))`。但在最坏情况下，递归深度为 `n`，此时的空间复杂度会增加到 `O(n)`。

![img](./836c517a01264e0d9e7fb6b36b3aed3b.webp)

![img](./9071ea10754f466eaa6e9efea555fcb0.webp)

```c++
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>
//打印
void Print(int *a,int n)
{
    for (int i=0;i<n;++i)
    {
        printf("%d ",a[i]);
    }
}
//挖坑法
void QuickSort(int* a,int left,int right)//升序
{
    if (left < right)
    {
        int begin = left;
        int end = right;
        int pivot = begin;//记录坑位的下标
        int key = a[begin];//坑值
        while (begin < end)
        {
            //右边找小，放到左边
            while (begin < end && a[end] >= key)//与坑值比较
            {
                --end;
            }
            //小的放在左边的坑里，自己形成了新的坑位
            a[pivot] = a[end];
            pivot = end;
            //左边找大，放在右边
            while (begin < end && a[begin] <= key)//与坑值比较
            {
                ++begin;
            }
            //大的放在右边的坑里，自己形成了新的坑位
            a[pivot] = a[begin];
            pivot = begin;
        }
        //最后将坑值给到坑位
        a[pivot] = key;
        //[left,right]
        //[left,pivot-1]  [pivot+1,right]
        //左子区间和右子区间有序，我们就有序了，如何让他们有序？分治递归
        QuickSort(a, left, pivot - 1);
        QuickSort(a, pivot + 1, right);
    }
    else
    {
        return;
    }
}
int main()
{
    int a[10] = {0,9,5,6,3,2,1,7,8,4};
    //挖坑法
    QuickSort(a,0,sizeof(a)/sizeof(a[0])-1);
    //打印
    Print(a,sizeof(a) / sizeof(a[0]));
    return 0;
}
```

**快排的缺点**

根据上面的代码，我们来分析一下快排的缺点：

![img](./1515d2a583c949f8a922d76f16fa6a7b.webp)

**如何解决快排对有序数据排序效率很差的方法？**：三数取中法

![img](./56902b1531ea4ef191b1f401a7e0ea36.webp)

所谓三数取中，不是取最大值，最小值，以及他们的中间值，而是取左边`（begin）`、右边`（end）`和中间`（begin+end）/2`。在有序的情况下中间的值刚好就是二分，将取出的值作为坑位，就不会出现最差的这种情况。我们依旧使用区间的开头作为坑值，但是要使用三数取中的逻辑。

```c++
int begin = left;
int end = right;
//使用三数取中选“坑值”，用mid存储其下标
int mid = GetMidIndex(a, begin, end);
//将区间首值当作坑位
//坑值与首值交换，避免算法混乱
//一般我们会将区间首值作为坑值
Swap(&a[begin], &a[mid]);//传地址调用
//存储坑值
int key = a[begin];
```

```c++
int GetMidIndex(int *a,int left,int right)
{
    //二分
    int mid = (right - left) / 2;
    if (a[left]<a[mid])
    {
        if (a[left]<a[right])
        {
            if (a[mid]<a[right])
            {
                return mid;
            }
            else  //a[mid]>=a[right]
            {
                return right;
            }
        }
        else   //a[left]>=a[right]
        {
            return left;
        }
    }
    else  //a[left]>=a[mid]
    {
        if (a[mid]<a[right])
        {
            if (a[left]<a[right])
            {
                return left;
            }
            else  //a[left]>=a[right]
            {
                return right;
            }
        }
        else  //a[mid]>=a[right]
        {
            return mid;
        }
    }
}
```

经过三数取中的处理，就不会出现快排的最坏情况，但也几乎不会成为最好的情况，有利有弊，我们在面试的过程中只需要写基础版的快排即可，以防时间不够。

----

**小区间优化：**

**关于如果处理数据多，相应的递归次数多，会不会影响操作快排的性能？**

![img](./fe2d2bf16ee84e9c9e66407b347082be.webp)

当我们在使用快排对大量数据进行排序时，我们可以采用小区间优化，减少递归次数，达到优化程序得到目的。

- 对当待处理数据大于10的子序列进行快排递归。
- 对当待处理数据低于10的子序列进行直接插入排序进行排序，避免递归次数过多。
- 这个10不是固定的，可以根据处理的数据量调整。

```c++
//区间[left,right]
//左区间[left,pivot-1]  右区间[pivot+1,right]
//左子区间和右子区间有序，我们就有序了，如何让他们有序？分治递归
// 小区间优化
if (pivot - 1 - left > 10)//对当待处理数据大于于10的子序列进行快排递归排序
{
    //快排
    QuickSort(a,left,pivot-1);
}
else
{
    //采用直接插入排序，对当待处理数据低于10的子序列进行排序，避免递归
    InsertSort(a+left,pivot-1-left+1);//为什么最后要加1,例如：区间[0,9]实际上有10个数
}
if (right - (pivot + 1) > 10)
{
    QuickSort(a,pivot+1,right);
}
else
{
    InsertSort(a + pivot+1, right-(pivot+1)+1);
}
```

##### 左右指针法*

![img](./f3d224c6360f4231b8b3d8a4490e3f8f.webp)

根据上图的示例我们应该能够理解左右指针法是什么样的逻辑，跟挖坑法是一样的思想，单趟排序完毕实现左边比坑位小，右边比坑位大。但是即使左右指针法跟挖坑法的思想是一样的，但是他们单趟的运算结果是不一样的。

![img](./1da38e925eb04c8c9d44e17f0d880ed4.webp)

```c++
void QuickSort(int* a, int left, int right)
{
	if (left < right)
	{
		int begin = left;
		int end = right;
		//选坑位
		int mid = GetMidIndex(a, begin, end);//三数取中
		Swap(&a[begin], &a[mid]);
		int key = begin;
		while (begin < end)
		{
			while (begin < end && a[end] <= a[key])
				--end;
			while (begin < end && a[begin] >= a[key])
				++begin;
			Swap(&a[begin], &a[end]);
		}
		Swap(&a[begin], &a[key]);
		//分治递归
		QuickSort(a, left, begin - 1);
		QuickSort(a, begin + 1, right);
	}
}
```

##### 前后指针法

1. 采用`perv`记录区间第一个元素的下标，采用`cur`记录区间第二个元素的下标。
2. `cur`找小，每次遇到比`key`(坑值)小的值就停下来，`++prev`。
3. 交换`prev`和`cur`位置的值

![img](./88430f8244ae4aba86fa304a2b527294.webp)

```c++
//左右指针法
void QuickSort(int* a, int left, int right)
{
	if (left < right)
	{
		//选坑位
		int mid = GetMidIndex(a, left,right);//三数取中
		Swap(&a[left], &a[mid]);
		int key = left;
		//初始化指向
		int prev = left, cur = left + 1;
		while (cur<=right)
		{
			if (a[cur] <= a[key])//&&++prev!=cur
			{
				++prev;
				//避免无效操作
				if(cur!=prev)
				Swap(&a[prev],&a[cur]);
			}
			++cur;
		}
		Swap(&a[key], &a[prev]);
		//分治递归
		QuickSort(a, left, prev - 1);
		QuickSort(a, prev + 1, right);
	}
}
```

### [插入排序](https://www.51cto.com/article/768572.html)

前面说过，任何排序的核心思想就是将序列分为两个部分，第一部分是有序序列，其中存储的都是有序的数；另部分就是无序的数据，是尚未遍历到是未知顺序的数据。

插入排序的核心思想与斗地主抓牌类似，假设发牌员将无序的牌堆在牌桌上，为了区分，我们认为手中的牌是有序的。每次从**无序的牌堆接收到一个新的牌**，将之插入到有序的序列当中，也就是抓牌整理排序。直接插入排序的时间复杂度是`O(n^2)`，因为有两层循环。第一层从无序的位置找到一张牌，第二层将这个牌插入到有序的位置。

![图片](./45ae9610592ef324156205a2c65ba3ec8270ef.png)

码牌的时候将无序的牌插入到手中的牌，每次插完有序`+1`，无序`-1`。直到无序部分没有牌为止。**如果在无序牌堆中，所有的牌是正序的时候**，其时间复杂度会降低到`O(n)`，也就是仅仅插入而不用进行比较。（但是正序序列为什么需要排序呢？）

![插入排序](./insertionSort-1721820673447-8-1723804171932-4.gif)

插入排序的步骤可以简单概括为以下几个阶段：

1. 初始状态：将数组的第一个元素视为已排序部分，其余部分为未排序部分。
2. 逐个插入：从未排序部分选择一个元素，将其插入到已排序部分的正确位置。为了插入，将已排序部分中大于待插入元素的元素向右移动一个位置。
3. 重复：重复上述插入步骤，直到所有元素都被插入到已排序部分。
4. 完成：当算法完成时，整个数组就被排序了。

![图片](./674f5c1782b16ecd5e95943f0a0b377fbf7089.png)

具体代码如下，声明一个单指针`i`来遍历我们的数组，然后使用一个`j`内循环指针，对排序完成的区域进行一次遍历移动，然后将对应的`i`指针的数据插入到对应的位置即可。

```c++
void sort(int array[],int length){
    for(int i = 1;i<length;i++){
        //1.从无序牌堆中找到的牌
        int key = array[i];
        //2.变量指向的是有序牌堆
        int j = i-1;
	   //3.从有序牌堆中找到适合key的位置插入
        while(j>=0 && array[j]>key){
            //插入位置设置为j的前面
            array[j+1] = array[j];
            j--;
        }
        //插入正确位置 - 完工
        array[j+1] = key;
    }
}
```

#### 折半插入排序

折半插入排序是对直接插入排序的一种优化。在直接插入排序中，待排序元素需要从后向前逐个与已排序序列的元素比较，以确定插入位置。这对基本有序的数列效率较高，但在乱序情况下，比较次数较多。

折半插入排序通过**二分查找**来确定插入位置，从而减少了查找过程中的比较次数。相比普通插入排序，折半插入排序将比较和移动操作分离，使用二分查找降低了查找部分的时间复杂度至`O(log n)`，但元素的移动次数仍然保持在`O(n)`，因此总的时间复杂度仍为`O(n^2)`。折半插入排序是一种**稳定排序算法**，因为相等元素的相对顺序不会改变。

**算法步骤**

设数组为`a[0…n]`。 

1. 将原序列分成有序区和无序区。`a[0…i-1]`为有序区，`a[i…n] `为无序区。（`i`从`1`开始） 
2. 从无序区中取出第一个元素，即`a[i]`，使用二分查找算法在有序区中查找要插入的位置索引`j`。 
3. 将`a[j]`到`a[i-1]`的元素后移，并将`a[i]`赋值给`a[j]`。 
4. 重复步骤`2~3`，直到无序区元素为`0`。

![这里写图片描述](./70.png)

![img](./728328-20190509210223941-1073086585.png)

```c++
void InsertSort(ElemType A[],int n)
{
    int i,j,low,high,mid;
    //i记录的是新加入的牌
    for(int i = 2;i<=n;i++)
    {
        A[0] = A[i]; //记录当前插入的无序
        low=1,high=i-1;
        //二分找插入点
        while(low<=high)
        {
            mid=(low+high)/2;
            if(A[mid]>low) high = mid-1;
            else low=mid+1;                      
        }
        for(int j = i-1;j>=high+1;--j){
            A[j+1]=A{j];
		}
         A[high+1] = A[0]; //插入
    }   
    
}
```

不难看出，折半插入排序仅仅是减少了比较元素的次数，约为`O(nlogn)`，而且该比较次数与待排序表的初始状态无关，仅取决于表中的元素个数`n`；而元素的移动次数没有改变，它依赖于待排序表的初始状态。因此，折半插入排序的时间复杂度仍然为`O(n²)`，但它的效果还是比直接插入排序要好。 

- 最好时间复杂度`O(n)`
- 平均时间复杂度`O(n²)`
- 最坏时间复杂度`O(n²)`

#### [希尔排序操作](https://www.cnblogs.com/chengxiao/p/6104371.html)*

希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为**缩小增量排序**，同时该算法是冲破`O(n^2）`的第一批算法之一。本文会以图解的方式详细介绍希尔排序的基本思想及其代码实现。

![希尔排序](./Sorting_shellsort_anim-1721820673447-11-1723804171932-5.gif)

**希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至`1`时，整个文件恰被分成一组，算法便终止。**

简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如`[5,4,3,2,1,0]`这种倒序序列，数组末端的`0`要回到首位置很是费劲，比较和移动元素均需`n-1`次。而希尔排序在数组中采用**跳跃式分组的策略**，通过某个增量将数组元素划分为**若干组，然后分组进行插入排序，随后**逐步缩小增量。继续按组进行插入排序操作**，直至增量为`1`。希尔排序通过这种策略使得整个数组在**初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为`1`时，其实多数情况下只需微调即可，不会涉及过多的数据移动。

我们来看下希尔排序的基本步骤，在此我们选择增量`gap=length/2`，缩小增量继续以`gap = gap/2`的方式，这种增量选择我们可以用一个序列来表示，`{n/2,(n/2)/2...1}`，称为**增量序列**。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。

![img](./1024555-20161128110416068-1421707828.png)

在希尔排序的理解时，我们倾向于对于每一个分组，逐组进行处理，但在代码实现中，我们可以不用这么按部就班地处理完一组再调转回来处理下一组（这样还得加个`for`循环去处理分组）比如`[5,4,3,2,1,0]` ，首次增量设`gap=length/2=3`，则为3组`[5,2]` `[4,1]` `[3,0]`，实现时不用循环按组处理，我们可以从第`gap`个元素开始，逐个跨组处理。同时，在插入数据时，可以采用元素交换法寻找最终位置，也可以采用数组元素移动法寻觅。希尔排序的代码比较简单，如下：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

// 交换数组元素
void swap(std::vector<int>& arr, int a, int b) {
    arr[a] = arr[a] + arr[b];
    arr[b] = arr[a] - arr[b];
    arr[a] = arr[a] - arr[b];
}

// 希尔排序 针对有序序列在插入时采用交换法
void shellSortSwap(std::vector<int>& arr) {
    int n = arr.size();
    // 增量 gap，并逐步缩小增量
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 从第 gap 个元素，逐个对其所在组进行直接插入排序操作
        for (int i = gap; i < n; i++) {
            int j = i;
            while (j - gap >= 0 && arr[j] < arr[j - gap]) {
                // 插入排序采用交换法
                swap(arr, j, j - gap);
                j -= gap;
            }
        }
    }
}

// 希尔排序 针对有序序列在插入时采用移动法
void shellSortMove(std::vector<int>& arr) {
    int n = arr.size();
    // 增量 gap，并逐步缩小增量
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 从第 gap 个元素，逐个对其所在组进行直接插入排序操作
        for (int i = gap; i < n; i++) {
            int j = i;
            int temp = arr[j];
            if (arr[j] < arr[j - gap]) {
                while (j - gap >= 0 && temp < arr[j - gap]) {
                    // 移动法
                    arr[j] = arr[j - gap];
                    j -= gap;
                }
                arr[j] = temp;
            }
        }
    }
}

int main() {
    std::vector<int> arr = {1, 4, 2, 7, 9, 8, 3, 6};
    shellSortSwap(arr);
    std::cout << "Using Swap Method: ";
    for (int i : arr) {
        std::cout << i << " ";
    }
    std::cout << std::endl;

    std::vector<int> arr1 = {1, 4, 2, 7, 9, 8, 3, 6};
    shellSortMove(arr1);
    std::cout << "Using Move Method: ";
    for (int i : arr1) {
        std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列`{n/2,(n/2)/2...1}`(希尔增量)，其最坏时间复杂度依然为`O(n2)`，一些经过优化的增量序列如`Hibbard`经过复杂证明可使得最坏时间复杂度为`O(n3/2)`。

### [选择排序](https://www.cnblogs.com/cciejh/p/14161067.html)

首先，找到数组中最小的那个元素，其次，将它和数组的第一个元素交换位置(如果第一个元素就是最小元素那么它就和自己交换)。其次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此往复，直到将整个数组排序。这种方法我们称之为**选择排序**。

选择排序是一种简单直观的排序算法，无论什么数据进去都是` O(n²)` 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。同时选择排序是不稳定的排序方法。

![选择排序](./selectionSort-1721820673447-7-1723804171932-7.gif)

**那如何选出最小的一个元素呢**。很容易想到：先随便选一个元素假设它为最小的元素（默认为无序区间第一个元素），然后让这个元素与无序区间中的每一个元素进行比较，如果遇到比自己小的元素，那更新最小值下标，直到把无序区间遍历完，那最后的最小值就是这个无序区间的最小值。

```c++
void SelectSort(ElemType A[],int n){
    for(int i = 0;i<n-1;i++)
    {
        // 最小值位置 - 相对于未排序部分来说
        int min = i;
        for(int j = i+1;j<n;j++)
        {
            if(A[j]<A[min]) min = j; // 记录最小值位置
        }
        if(min!=i) swap(A[i],A[min]); // 与最小值位置交换
    }
}
```

选择排序的交换操作介于` 0 `和 `(n - 1)`次之间。选择排序的比较操作为` n(n - 1)/2 `次。选择排序的赋值操作介于` 0`和 `3(n - 1)` 次之间，`1`次交换对应三次赋值。

比较次数`O(n^2) `，比较次数与关键字的初始状态无关，总的比较次数`N = (n-1) + (n-2) + ... +1 = n*(n-1)/2`。

交换次数比冒泡排序少多了，由于**交换所需CPU时间比比较所需的CPU时间多**，`n`值较小时，选择排序比冒泡排序快。选择排序每交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对`n`个元素的表进行排序总共进行至多`(n-1)`次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。

- 最好时间复杂度：最好情况是输入序列已经升序排列，需要比较`n*(n-1)/2`次，但不需要交换元素，即交换次数为：`0`；所以**最好时间复杂度**为`О(n²)`。
- 最坏时间复杂度：最坏情况是输入序列是逆序的，则每一趟都需要交换。即需要比较`n*(n-1)/2`次，元素交换次数为：`n-1`次。所以**最坏时间复杂度**还是`*О(n²)`。

原地操作几乎是选择排序的唯一优点，当空间复杂度要求较高时，可以考虑选择排序；选择排序实际适用的场合非常罕见。

#### [堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

堆排序是利用**堆**这种数据结构而设计的一种排序算法，堆排序是一种**选择排序，**它的最坏，最好，平均时间复杂度均为`O(nlogn)`，它也是不稳定排序。首先简单了解下堆结构。

**堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。如下图：**

![img](./1024555-20161217182750011-675658660-1729065869787-30.png)

同时，我们对堆中的结点按层进行编号，将这种逻辑结构映射到数组中就是下面这个样子

![img](./1024555-20161217182857323-2092264199-1729065876999-33.png)

该数组从逻辑上讲就是一个堆结构，我们用简单的公式来描述一下堆的定义就是：

**大顶堆：`arr[i] >= arr[2i+1] && arr[i] >= arr[2i+2]`**  

**小顶堆：`arr[i] <= arr[2i+1] && arr[i] <= arr[2i+2]`**  

了解了这些定义。接下来，我们来看看堆排序的基本思想及基本步骤：

> **堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了**

**第一步、**构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。

- 假设给定无序序列结构如下

![img](./1024555-20161217192038651-934327647.png)

- 此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点 `arr.length/2-1=5/2-1=1`，也就是下面的6结点），从左至右，从下至上进行调整。

![img](./1024555-20161217192209433-270379236.png)

- 找到第二个非叶节点`4`，由于`[4,9,8]`中`9`元素最大，`4`和`9`交换。

![img](./1024555-20161217192854636-1823585260.png)

- 这时，交换导致了子根`[4,5,6]`结构混乱，继续调整，`[4,5,6]`中6最大，交换4和6。

![img](./1024555-20161217193347886-1142194411.png)

此时，我们就将一个无需序列构造成了一个大顶堆。

**第二步、**将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。

- 将堆顶元素`9`和末尾元素`4`进行交换

![img](./1024555-20161217194207620-1455153342.png)

- 重新调整结构，使其继续满足堆定义

![img](./1024555-20161218153110495-1280388728.png)

- 再将堆顶元素8与末尾元素5进行交换，得到第二大元素8.

![img](./1024555-20161218152929339-1114983222.png)

后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序

![img](./1024555-20161218152348229-935654830.png)

再简单总结下堆排序的基本思路：

1. 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
2. 将堆顶元素与末尾元素交换，将最大元素沉到数组末端;
3. 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

```java
#include <iostream>
#include <vector>
#include <algorithm>

// 交换元素
void swap(std::vector<int>& arr, int a, int b) {
    int temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}

// 调整大顶堆（仅调整过程，基于已经构建的大顶堆）
void adjustHeap(std::vector<int>& arr, int i, int length) {
    int temp = arr[i];  // 取出当前元素i
    for (int k = i * 2 + 1; k < length; k = k * 2 + 1) {  // 从i节点的左子节点开始，也就是2i+1处
        if (k + 1 < length && arr[k] < arr[k + 1]) {  // 如果左子结点小于右子结点，k指向右子结点
            k++;
        }
        if (arr[k] > temp) {  // 如果子节点大于父节点，将子节点值赋给父节点（不用交换）
            arr[i] = arr[k];
            i = k;
        } else {
            break;
        }
    }
    arr[i] = temp;  // 将temp值放到最终的位置
}

// 堆排序
void heapSort(std::vector<int>& arr) {
    int n = arr.size();
    // 1. 构建大顶堆
    for (int i = n / 2 - 1; i >= 0; i--) {
        // 从第一个非叶子节点从下至上，从右至左调整结构
        adjustHeap(arr, i, n);
    }
    // 2. 调整堆结构+交换堆顶元素与末尾元素
    for (int j = n - 1; j > 0; j--) {
        swap(arr, 0, j);  // 将堆顶元素与末尾元素进行交换
        adjustHeap(arr, 0, j);  // 重新对堆进行调整
    }
}

int main() {
    std::vector<int> arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    heapSort(arr);
    
    // 输出排序后的数组
    std::cout << "Sorted array: ";
    for (int i : arr) {
        std::cout << i << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### [归并排序](https://www.cnblogs.com/chengxiao/p/6194356.html)

归并排序（`MERGE-SORT`）是利用**归并**的思想实现的排序方法，该算法采用经典的**分治**（`divide-and-conquer`）策略（分治法将问题**分**(`divide)`成一些小的问题然后递归求解，而**治(`conquer`)**的阶段则将分的阶段得到的各答案"**修补**"在一起，即分而治之)。

![img](./1024555-20161218163120151-452283750.png)

可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。**分**阶段可以理解为就是递归拆分子序列的过程，递归深度为`log2n`。

再来看看**治**阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将`[4,5,7,8]`和`[1,2,3,6]`两个已经有序的子序列，合并为最终序列`[1,2,3,4,5,6,7,8]`，来看下实现步骤。

![img](./1024555-20161218194508761-468169540.png)

```c++
#include <iostream>
#include <vector>
using namespace std;

// 归并排序函数声明
void mergeSort(vector<int>& arr, int left, int right, vector<int>& temp);
void merge(vector<int>& arr, int left, int mid, int right, vector<int>& temp);

int main() {
    // 初始化待排序数组
    vector<int> arr = {9, 8, 7, 6, 5, 4, 3, 2, 1};
    
    // 临时数组，用于在归并过程中存放临时结果，长度与原数组相同
    vector<int> temp(arr.size());

    // 对数组进行归并排序
    mergeSort(arr, 0, arr.size() - 1, temp);

    // 输出排序后的数组
    for (int num : arr) {
        cout << num << " ";
    }
    cout << endl;

    return 0;
}

// 归并排序函数
// 参数：arr为待排序数组，left为左边界，right为右边界，temp为临时数组
void mergeSort(vector<int>& arr, int left, int right, vector<int>& temp) {
    if (left < right) {
        // 防止(left + right)溢出，等效于 (left + right) / 2
        int mid = left + (right - left) / 2;

        // 递归对左半部分进行归并排序
        mergeSort(arr, left, mid, temp);

        // 递归对右半部分进行归并排序
        mergeSort(arr, mid + 1, right, temp);

        // 将排好序的左右两部分合并
        merge(arr, left, mid, right, temp);
    }
}

// 合并两个有序子数组
// 参数：arr为待合并数组，left为左边界，mid为中间位置，right为右边界，temp为临时数组
void merge(vector<int>& arr, int left, int mid, int right, vector<int>& temp) {
    int i = left;      // 左半部分的起始索引
    int j = mid + 1;   // 右半部分的起始索引
    int t = 0;         // 临时数组的索引

    // 按大小顺序将左右两部分的元素依次放入temp
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[t++] = arr[i++];  // 左半部分当前元素较小，存入temp
        } else {
            temp[t++] = arr[j++];  // 右半部分当前元素较小，存入temp
        }
    }

    // 如果左半部分还有剩余元素，依次放入temp
    while (i <= mid) {
        temp[t++] = arr[i++];
    }

    // 如果右半部分还有剩余元素，依次放入temp
    while (j <= right) {
        temp[t++] = arr[j++];
    }

    // 将临时数组中的元素拷贝回原数组
    t = 0;
    while (left <= right) {
        arr[left++] = temp[t++];
    }
}
```

堆排序是一种选择排序，整体主要由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。其中构建初始堆经推导复杂度为`O(n)`，在交换并重建堆的过程中，需交换`n-1`次，而重建堆的过程中，根据完全二叉树的性质`[log2(n-1),log2(n-2)...1]`逐步递减，近似为`nlogn`。所以堆排序时间复杂度一般认为就是`O(nlogn)`级。

```c++
//tmp是辅助数组 - q是原数组
int tmp[N],q[N];

void qsort(int q[],int l,int r){
    if(l == r) return; //合并完成
    // 1. 分
    int mid = l+r>>1;
    //分的左边
    qsort(q,l,mid);
    //分的右边
    qsort(q,mid+1,r);
    
    //这一部分不会立即执行 - 需要执行完成上面的分子序列才行。直到每一个元素都分为一个子序列
    //k是并的维护指针
    int i = l,j = mid+1,k = 0;
    
    while(i<=mid && j<=r){
        //i和j不在同一个区间 - 在两个不同的区间
        if(q[i]<q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while(i<=mid) tmp[k++] = q[i++];
    while(j<=r) tmp[k++] = q[j++];
    
    //最后拼回去
    for(int i = l,j = 0;i<=r;i++,j++) q[i] = tmp[j];
    
}
```

### 基数排序

基数排序（`Radix sort`）是一种非比较型整数排序算法。

原理是将整数**按位数切割成不同的数字**，然后**按每个位数分别比较**。基数排序的方式可以采用`LSD（Least significant digital）`或`MSD（Most significant digital）`，`LSD`的排序方式由键值的最右边开始，而`MSD`则相反，由键值的最左边开始。

- **`MSD`**：先从高位开始进行排序，在每个关键字上，可采用计数排序
- **`LSD`**：先从低位开始进行排序，在每个关键字上，可采用桶排序

实现逻辑是：

- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
- 从最低位开始，依次进行一次排序。
- 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

分步图示说明：设有数组 `array = {53, 3, 542, 748, 14, 214, 154, 63, 616}`，对其进行基数排序：

![img](./v2-5ae4857fa248035ecec780583c5e3303_720w-1723796493039-14-1723804171932-11.webp)

在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。

- 按照个位数进行排序。
- 按照十位数进行排序。
- 按照百位数进行排序。

排序后，数列就变成了一个有序序列。其中基数排序的特点如下

- 时间复杂度：O(k*N)
- 空间复杂度：O(k + N)
- 稳定性：稳定

```c++
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];      ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
```

#### 计数排序

![计数排序](./countingSort-1721820673447-15-1723804171932-12.gif)

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序的时间复杂度是`o(n+K)`，低时间复杂度但是高空间。

简单说，就是用我们需要排序的序列的值**创建一个标记数组**，只要序列出现过的值，都标记成`1`，就说明它出现了。但是，这种方法只对数来说比较方便。可以说是数组下标和排序序列有映射关系。

算法步骤

- 找出待排序的数组中最大和最小的元素
- 统计数组中每个值为i的元素出现的次数，存入数组C的第i项
- 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
- 反向填充目标数组：将每个元素i放在新数组的第`C(i)`项，每放一个元素就将`C(i)`减去1

> 但是这种方法排序离散的数据就不靠谱了。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 计数排序函数，将排序结果存储在sorted_arr中
void counting_sort(int *arr, int n) {
    int max = 0;

    // 找到数组中的最大值，以确定计数数组的大小
    for (int i = 0; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    // 创建计数数组和排序后的数组
    int *count_arr = (int *)malloc(sizeof(int) * (max + 1));
    int *sorted_arr = (int *)malloc(sizeof(int) * n);

    // 初始化计数数组为0
    for (int i = 0; i <= max; i++) {
        count_arr[i] = 0;
    }

    // 计算每个元素出现的次数
    for (int i = 0; i < n; i++) {
        count_arr[arr[i]]++;
    }

    int index = 0;

    // 从计数数组中构建排序后的数组
    for (int i = 0; i <= max; i++) {
        while (count_arr[i] > 0) {
            sorted_arr[index] = i;
            index++;
            count_arr[i]--;
        }
    }

    free(count_arr);

    // 打印排序后的数组
    printf("sorted_array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", sorted_arr[i]);
    }
    printf("\n");

    free(sorted_arr);
}

int main(int argc, char **argv) {
    int n = 10;
    int *arr = (int *)malloc(sizeof(int) * n);
    srand(time(0));

    // 生成随机数组
    for (int i = 0; i < n; i++) {
        arr[i] = rand() % 100;
    }

    // 打印初始数组
    printf("ini_array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 调用计数排序函数
    counting_sort(arr, n);
    free(arr);

    return 0;
}
```

#### 桶排序

元素分布在桶中：

![桶](./Bucket_sort_1.svg_-1721820673447-21-1723804171932-13.png)

然后，元素在每个桶中排序：

![桶](./Bucket_sort_2.svg_-1721820673447-16-1723804171932-14.png)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n;
int a[N], b[N];

int main()
{
    cin >> n;
    // 输入数据
    for (int i = 0; i < n; i++) 
        cin >> a[i];

    // 找到数组中的最大值
    int maxv = *max_element(a, a + n);

    // 统计每个元素出现的次数
    for (int i = 0; i < n; i++)
        b[a[i]]++;

    int j = 0; // 辅助指针j，用于更新原数组a
    // 从0到最大值遍历，按照计数数组b的信息重建原数组a
    for (int i = 0; i <= maxv; i++)
    {
        while (b[i]--) // 每个元素出现的次数减少一个
            a[j++] = i; // 更新原数组
    }

    // 输出排序后的数组
    for (int i = 0; i < n; i++)
        cout << a[i] << ' ';

    return 0;
}
      
```

## [查找](https://www.dotcpp.com/course/157)

查找操作是指在给定的数据集合中，根据特定的条件找到一个特定的数据项。这个数据项可能是一个值、一个键或一个属性。查找操作的时间复杂度是衡量查找效率的重要指标，它表示了查找操作所需的时间与数据项数量的关系。常用的查找算法

- 线性查找：这是最基本的查找算法，它按照顺序逐个比较数据项，直到找到目标数据项或遍历完整个数据集合。线性查找的时间复杂度为`O(n)`，其中n为数据集合的大小。
- 二分查找：二分查找是一种高效的查找算法，适用于已排序的数据集合。它将数据集合分成两半，然后根据目标值与中间值的比较结果，排除一半的数据，继续在另一半数据中进行查找。二分查找的时间复杂度为`O(log n)`。
- 哈希查找：哈希查找利用哈希表数据结构进行查找。它将数据项的键通过哈希函数转换为对应的地址，然后在该地址处存储该数据项的值。哈希查找的时间复杂度一般为O(1)，但在哈希冲突严重的情况下，时间复杂度可能会退化到`O(n)`。
- B树查找：B树是一种平衡的多路搜索树，它能够保持数据的有序性，并支持快速的插入、删除和查找操作。B树查找的时间复杂度为`O(log n)`。
- 散列查找：散列查找是一种利用哈希函数将键映射到桶中的数据结构进行查找的方法。它能够快速地定位到目标数据项的桶，然后在桶中继续进行线性查找。散列查找的时间复杂度一般为`O(1)`。

### 顺序查找

**顺序查找**（Sequential Search）又叫线性查找，是**最基本的查找技术**，它的查找过程是：从表中第一个（或最后一个）记录开始，逐个进行记录的关键字和给定值比较，若某个记录的关键字和给定值相等，则查找成功，找到所查的记录；如果直到最后一个（或第一个）记录，其关键字和给定值比较都不等时，则表中没有所查的记录，查找不成功。

```c++
int Sequential_Search(int *a,int n,int key)    //a为数组，n为要查找数组长度，key为待查找关键词
{
    int i;
    for(i = 1;i <= n;i++)    //遍历数组内的每一条记录,元素记录是从1开始
    {
        if(a[i] == key)    //如果查找到，则返回记录所在位置
            return i;
    }
    return 0;    //如果未查找到，则返回0
}
```

### 二分查找*

> 二分查找的实现方式有很多种，大多数都是通过修改维护两端的指针构造的。

二分查找的思路简单，我们需要找的数据都是在数组中，只要将这个数组分为两个部分，然后在左边找不到就到右边找，然后再把剩下的数组分为两部分，以此类推。

二分查找采用双指针的形式，来对我们数组序列进行遍历。二分查找只使用于排好序的数组，不适用于其他。掌握二分查找的关键是，要明白数组是怎么分成两部分，两部分的边界是什么组成的。如果按照顺序查找的话就是按照对应序列一个一个找，直到找到目标为止，没有找到就返回`-1`

```c++
int a[N];
int ans;
for(int i = 1;i<N;i++){
    if(a[i] == ans) return true;
  else break;
}
if(a[N]!=ans) return false;    
```

这可以用**蓝红划分**数组来解释，假设我们数组开始全是**灰色(没有被遍历)**，设计一个蓝色指针指向数组的最左边，从左往右扫到蓝红边界，直到扫到目标值。

![image-20230923182039153](./image-20230923182039153-1721820537011-32.png)

然后也同样，也可以在最右边设计一个红色指针，从右往左扫直到扫到蓝红边界，直到扫到我们的目标值。

![image-20230923182210667](./image-20230923182210667-1721820537011-33.png)

这样的算法是十分低效的，原因是因为指针移动速度缓慢，每次只能在数组中搜索到一个值的信息。在上面的基础上，我们用蓝红表示二分数组中两个不同的区域：

![image-20230923181905524](./image-20230923181905524-1721820537011-34.png)

如果我们在数组中间发现一个指针为蓝色，那么很显然这个指针之前的颜色全为蓝色：

![image-20230923182618450](./image-20230923182618450-1721820537011-35.png)

同样的我们在右侧发现了一个红色区域块，就可以推断出其右侧区域都是红色

![image-20230923184049459](./image-20230923184049459-1721820537011-37.png)

通过这样不断操作，直到找到我们的**蓝红边界**：

![image-20230923184222698](./image-20230923184222698-1721820537011-36.png)

我们为什么要找蓝红边界，因为二分有几个常见的问题需要我们解决，假设`ans`是我们需要找到的二分值，**对这个值我们有如下问题**：

- 找到第一个`>=ans`的元素
- 找到最后一个`<ans`的元素
- 找到第一个`>ans`的元素
- 找到最后一个`<=ans`的元素

经过蓝红区块的分类，我们可以把问题转化为每一次找`ans`时，**与`ans`比较的`m`是属于蓝色区块的还是红色区块的**。例如

- 找到第一个`>=ans`的元素：`m`在红色位置
- 找到最后一个`<ans`的元素：`m`在蓝色位置
- 找到第一个`>ans`的元素：`m`在红色位置
- 找到最后一个`<=ans`的元素：`m`在蓝色位置

> 注意未遍历的位置都是灰色！！！！我们的目的是将这个数组染色，让它只有红蓝两种颜色，这个对于理解红蓝分区二分很重要！！！

```c++
//1.定义双指针维护区域
l = -1,r = N; // 这里的数组是0-n-1的
while(l+1!=r) //l+1 = r的时候说明红蓝区域相融了
{
    m = (l+r)/2;
    // 2.如果m节点是蓝色节点
    if(isBlue(m)) l = m; // m节点是蓝色节点，其左侧都是蓝色
    else r = m; // m是红色节点，其右侧都是红色
}

return l or r // 最终找到的位置处，需要区分
```

开始`l`指针指向蓝色区域，`r`指针指向红色区域，循环直到达到边界，**保持`l,r`颜色不发生改变**，遍历结束`l,r`就达到了蓝红边界处。二分查找的时间复杂度是`o(log n)`，也就是一直在折半。为什么`l`区域初始化为`-1`，这是因为我们需要在数组中分蓝和红区域，**如果将`l`初始化为`1`，恰好数组中全是红色区域**，这样就矛盾了。同理，`r`也不可以取`r-1`这个位置，也会导致矛盾。

那么就可以根据不同的问题来构造这个`isBlue`函数，从而实现我们的二分查找。这里实现的二分查找有两个需要完成**重点**

1. 指定红蓝边界(已经完成)
2. 返回目标位置

这里的返回目标位置，关键在于直接把 `m` 的值当作目标值进行比较：如果大于目标值，则 `m` 在红色区域；如果小于目标值，则 `m` 在蓝色区域。下面就开始构造**模版**(下面代码可运行)

- 找到第一个`>=ans`的元素：`m`在红色区域(`ans`的右边)，最终返回的是`r`

```c++
#include <iostream>
#include <vector>
// 判断蓝色区域，反之就是红色区域
bool isBlue(const std::vector<int>& array, int m, int ans) {
	return array[m] < ans; 
}
// 目的是填色找到《红蓝边界》
int binarySearch(const std::vector<int>& array, int ans) {
    int l = -1, r = array.size(); 

    while (l + 1 != r) {
        int m = (l + r) / 2;
        
        if (isBlue(array, m, ans)) {
            l = m;  // m左边都是蓝色
        } else {
            r = m;  // m右边都是红色
        }
    }

    return r;// 第一个大于或等于ans的元素，是红色
}

int main() {
    std::vector<int> array = {2,3,4,5,5,5,5,5,6}; // Sorted array
    int ans = 5; // The target value

    int index = binarySearch(array, ans);
    if (index != -1) {
        std::cout << "找到了值第一个>= " << ans << " 位置是: " << index 
                  << " (值是: " << array[index] << ")" << std::endl;
    } else {
        std::cout << "找不到或者是输入有误" << ans << std::endl;
    }

    return 0;
}
```

- 找到最后一个`<ans`的元素：`m`在蓝色位置(比对的左边)，最终返回`l`

```c++
#include <iostream>
#include <vector>
// 判断蓝色区域，反之就是红色区域
bool isBlue(const std::vector<int>& array, int m, int ans) {
	return array[m] < ans; 
}
// 目的是填色找到《红蓝边界》
int binarySearch(const std::vector<int>& array, int ans) {
    int l = -1, r = array.size(); 

    while (l + 1 != r) {
        int m = (l + r) / 2;
        
        if (isBlue(array, m, ans)) {
            l = m;  // m左边都是蓝色
        } else {
            r = m;  // m右边都是红色
        }
    }

    return l; //最后一个<ans的元素，是蓝色
}

int main() {
    std::vector<int> array = {2,3,4,5,5,5,5,5,6}; // Sorted array
    int ans = 5; // The target value

    int index = binarySearch(array, ans);
    if (index != -1) {
        std::cout << "找到了值最后一个< " << ans << " 位置是: " << index 
                  << " (值是: " << array[index] << ")" << std::endl;
    } else {
        std::cout << "找不到或者是输入有误" << ans << std::endl;
    }

    return 0;
}
```

- 找到第一个`>ans`的元素：`m`在红色区域，最终返回的是`r`

```c++
#include <iostream>
#include <vector>
// 判断蓝色区域，反之就是红色区域
bool isBlue(const std::vector<int>& array, int m, int ans) {
	return array[m] <= ans; 
}
// 目的是填色找到《红蓝边界》
int binarySearch(const std::vector<int>& array, int ans) {
    int l = -1, r = array.size(); 

    while (l + 1 != r) {
        int m = (l + r) / 2;
        
        if (isBlue(array, m, ans)) {
            l = m;  // m左边都是蓝色
        } else {
            r = m;  // m右边都是红色
        }
    }

    return r; 
}

int main() {
    std::vector<int> array = {2,3,4,5,5,5,5,5,6}; // Sorted array
    int ans = 5; // The target value

    int index = binarySearch(array, ans);
    if (index != -1) {
        std::cout << "找到了第一个> " << ans << " 位置是: " << index 
                  << " (值是: " << array[index] << ")" << std::endl;
    } else {
        std::cout << "找不到或者是输入有误" << ans << std::endl;
    }

    return 0;
}
```

- 找到最后一个`<=ans`的元素：`m`在蓝色位置，返回的是`l`

```c++
#include <iostream>
#include <vector>
// 判断蓝色区域，反之就是红色区域
bool isBlue(const std::vector<int>& array, int m, int ans) {
	return array[m] <= ans; 
}
// 目的是填色找到《红蓝边界》
int binarySearch(const std::vector<int>& array, int ans) {
    int l = -1, r = array.size(); 

    while (l + 1 != r) {
        int m = (l + r) / 2;
        
        if (isBlue(array, m, ans)) {
            l = m;  // m左边都是蓝色
        } else {
            r = m;  // m右边都是红色
        }
    }

    return l; 
}

int main() {
    std::vector<int> array = {2,3,4,5,5,5,5,5,6}; // Sorted array
    int ans = 5; // The target value

    int index = binarySearch(array, ans);
    if (index != -1) {
        std::cout << "找到了最后一个<= " << ans << " 位置是: " << index 
                  << " (值是: " << array[index] << ")" << std::endl;
    } else {
        std::cout << "找不到或者是输入有误" << ans << std::endl;
    }

    return 0;
}
```

> 这里的初始数组需要定义在`0-n-1`，也就是从索引`0`开始，一共`n-1-0+1= n`个数据

![image-20230923224009827](./image-20230923224009827-1721820537011-39.png)

我们需要检查 `m`（二分值）是否始终落在数组的有效范围内。初始时，`l`（左边界）和 `r`（右边界）的最小值分别为 `0` 和 `1`。此时，`m` 的最小值为 `(0 + 1) / 2 = 0`，即索引为 `0` 的元素。根据循环退出条件，当 `l + 1 == r` 时，循环退出。因此，`l` 的最大值为 `N-2`，`r` 的最大值为 `N-1`。

相应的，`m` 的最大值为 `(N-2 + N-1) / 2 = (2N-3) / 2`，近似为 `N/2`。**确保 `m` 始终在数组范围内**是通过这些边界值控制的。

![image-20230923224046736](./image-20230923224046736-1721820537011-38.png)

更新指针的时候，都是指向蓝红边界的位置，如果我们改变为`l = m+1`会导致区域发生错误，我们就用更新为`m和r`的模版就行，不会搞乱自己。

![image-20230923224929897](./image-20230923224929897-1721820537011-40.png)

死循环问题：全部问题都会归类为第一种退出循环的方式

![image-20230923225144185](./image-20230923225144185-1721820537011-43.png)

### [分块查找](https://www.dotcpp.com/course/156)

分块查找是折半查找和顺序查找的一种改进方法，分块查找由于只要求索引表是有序的，对块内节点没有排序要求，因此特别适合于节点动态变化的情况，其核心有二索引表，二是分块处理。

分块查找要求把一个大的线性表分解成若干块，每块中的节点可以任意存放，但块与块之间必须排序。假设是按关键码值非递减的，那么这种块与块之间必须满足已排序要求，实际上就是对于任意的i，第i块中的所有节点的关键码值都必须小于第i+1块中的所有节点的关键码值。此外，还要建立一个索引表，把每块中的最大关键码值作为索引表的关键码值，按块的顺序存放到一个辅助数组中，显然这个辅助数组是按关键码值费递减排序的。查找时，首先在索引表中进行查找，确定要找的节点所在的块。由于索引表是排序的，因此，对索引表的查找可以采用顺序查找或折半查找；然后，在相应的块中采用顺序查找，即可找到对应的节点。

![分块查找](./1576383331428606.png)

假设要查找关键字 38 的具体位置。首先将 38 依次和索引表中各最大关键字进行比较，因为 22 < 38 < 48，所以可以确定 38 如果存在，肯定在第二个子表中。

由于索引表中显示第二子表的起始位置在查找表的第 7 的位置上，所以从该位置开始进行顺序查找，一直查找到该子表最后一个关键字（一般将查找表进行等分，具体子表个数根据实际情况而定）。结果在第 10 的位置上确定该关键字即为所找。

```c++
#include <stdio.h>
#include <stdlib.h>
  
struct index 
{ 
　　//定义块的结构
　　int key;
　　int start;
  
} newIndex[3];  //定义结构体数组
int search(int key, int a[]);
  
int cmp(const void *a,const void* b)
{
　　return (*(struct index*)a).key>(*(struct index*)b).key?1:-1;
}
  
int main()
{
　　int i, j=-1, k, key;
　　int a[] = {33,42,44,38,24,48, 22,12,13,8,9,20, 60,58,74,49,86,53};
　　//确认模块的起始值和最大值
　　for (i=0; i<3; i++) 
　　{
　　　　newIndex[i].start = j+1; //确定每个块范围的起始值
　　　　j += 6;
　　　　for (int k=newIndex[i].start; k<=j; k++) 
　　　　{
　　　　　　if (newIndex[i].key<a[k]) 
　　　　　　{
　　　　　　　　newIndex[i].key = a[k];
　　　　　　}
　　　　}
　　}
　　//对结构体按照 key 值进行排序
　　qsort(newIndex,3, sizeof(newIndex[0]), cmp);
　　//输入要查询的数，并调用函数进行查找
　　printf("请输入您想要查找的数：\n");
　　scanf("%d", &key);
　　k = search(key, a);
　　//输出查找的结果
　　if (k>0) 
　　{
　　　　printf("查找成功！您要找的数在数组中的位置是：%d\n",k+1);
　　}
　　else
　　{
　　　　printf("查找失败！您要找的数不在数组中。\n");
　　}
  
　　return 0;
}
  
int search(int key, int a[])
{
　　int i, startValue;
　　i = 0;
　　while (i<3 && key>newIndex[i].key) 
　　{ 
　　　　// 确定在哪个块中，遍历每个块，确定key在哪个块中
　　　　i++;
　　}
　　if (i>=3) 
　　{ 
　　　　//大于分得的块数，则返回0
　　　　return -1;
　　}
　　startValue = newIndex[i].start; //startValue等于块范围的起始值
　　while (startValue <= startValue+5 && a[startValue]!=key)
　　{
　　　　startValue++;
　　}
　　if (startValue>startValue+5) 
　　{ 
　　　　//如果大于块范围的结束值，则说明没有要查找的数
　　　　return -1;
　　}
  
　　return startValue;
}
```

分块查找在现实生活中也很常用。

例如，一个学校有很多个班级，每个班级有几十个学生。给定一个学生的学号，要求查找这个学生的相关资料。显然，每个班级的学生档案是分开存放的，没有任何两个班级的学生的学号是交叉重叠的，那么最好的查找方法实现确定这个学生所在的班级，然后再在这个学生所在班级的学生档案中查找这个学生的资料。上述查找学生资料的过程，实际上就是一个典型的分块查找。

### 树形查找

#### 二叉排序树

**二叉排序树**（Binary Sort Tree），又称二叉查找树（Binary Search Tree），亦称二叉搜索树。该树属于一种输入数据就默认产生一种顺序的数据结构，这不像本章前面的内容所描述的静态的在某一个数据段内进行查找，动态查找是一种输入时就会自动对其进行排序的数据结构，前文学过的STL中的set集合其底层就是一个类似的树形结构红黑树。

> 二叉排序树有以下性质：

- 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
- 左、右子树也分别为二叉排序树；

即对于每一个根结点，其左孩子永远小于根，右孩子永远大于根。

如果树是空的，则查找结束，无匹配。如果被查找的值和根结点的值相等，查找成功。**否则就在子树中继续查找。如果被查找的值小于根结点的值就选择左子树，大于根结点的值就选择右子树。**

```c++
typedef int Status; /* Status是函数的类型,其值是函数结果状态代码，如OK等 */ 
  
/* 二叉树的二叉链表结点结构定义 */
typedef  struct BiTNode /* 结点结构 */
{
    int data;   /* 结点数据 */
    struct BiTNode *lchild, *rchild;    /* 左右孩子指针 */
} BiTNode, *BiTree;
  
/* 递归查找二叉排序树T中是否存在key, */
/* 指针f指向T的双亲，其初始调用值为NULL */
/* 若查找成功，则指针p指向该数据元素结点，并返回TRUE */
/* 否则指针p指向查找路径上访问的最后一个结点并返回FALSE */
Status SearchBST(BiTree t, int key, BiTree f, BiTree *p) 
{  
    if (!t) /*  查找不成功 */
    { 
        *p = f;  
        return FALSE; 
    }
    else if (key == t->data) /*  查找成功 */
    { 
        *p = t;  
        return TRUE; 
    } 
    else if (key < t->data) 
        return SearchBST(t->lchild, key, t, p);  /*  在左子树中继续查找 */
    else  
        return SearchBST(t->rchild, key, t, p);  /*  在右子树中继续查找 */
}
```

二叉排序的插入是建立在二叉排序的查找之上的，插入一个结点，就是通过查找发现该结点合适插入位置，把结点直接放进去。 其实在2.2节中一步步构造二叉排序树的过程中就是结点插入过程，并考虑查找的关键字已经有在树中，则指向该数据结点，若查找的关键字没有在树中，则指向查找路径上最后一个结点。

```c++
struct BiTree {
    int data;
    BiTree *lchild;
    BiTree *rchild;
};
  
//在二叉排序树中插入查找关键字key
BiTree* InsertBST(BiTree *t,int key)
{
    if (t == NULL)
    {
        t = new BiTree();
        t->lchild = t->rchild = NULL;
        t->data = key;
        return t;
    }
  
    if (key < t->data) 
        t->lchild = InsertBST(t->lchild, key);
    else
        t->rchild = InsertBST(t->rchild, key);
  
    return t;
}
  
//n个数据在数组d中，tree为二叉排序树根
BiTree* CreateBiTree(BiTree *tree, int d[], int n)
{
    for (int i = 0; i < n; i++)
        tree = InsertBST(tree, d[i]);
}
```

二叉树的删除可不再像二叉树的插入那么容易了，以为删除某个结点以后，会影响到树的其它部分的结构。删除的时候需要考虑以下几种情况：

- 删除结点为叶子结点；
- 删除的结点只有左子树；
- 删除的结点只有右子树
- 删除的结点既有左子树又有右子树。

```c++
/* 若二叉排序树T中存在关键字等于key的数据元素时，则删除该数据元素结点, */
/* 并返回TRUE；否则返回FALSE。 */
Status DeleteBST(BiTree *T,int key)
{ 
    if(!*T) /* 不存在关键字等于key的数据元素 */ 
        return FALSE;
    else
    {
        if (key==(*T)->data) /* 找到关键字等于key的数据元素 */ 
            return Delete(T);
        else if (key<(*T)->data)
            return DeleteBST(&(*T)->lchild,key);
        else
            return DeleteBST(&(*T)->rchild,key);
  
    }
}
/* 从二叉排序树中删除结点p，并重接它的左或右子树。 */
Status Delete(BiTree *p)
{
    BiTree q,s;
    if((*p)->rchild==NULL) /* 右子树空则只需重接它的左子树（待删结点是叶子也走此分支) */
    {
        q=*p; *p=(*p)->lchild; free(q);
    }
    else if((*p)->lchild==NULL) /* 只需重接它的右子树 */
    {
        q=*p; *p=(*p)->rchild; free(q);
    }
    else /* 左右子树均不空 */
    {
        q=*p; s=(*p)->lchild;
        while(s->rchild) /* 转左，然后向右到尽头（找待删结点的前驱） */
        {
            q=s;
            s=s->rchild;
        }
        (*p)->data=s->data; /*  s指向被删结点的直接前驱（将被删结点前驱的值取代被删结点的值） */
        if(q!=*p)
            q->rchild=s->lchild; /*  重接q的右子树 */ 
        else
            q->lchild=s->lchild; /*  重接q的左子树 */
        free(s);
    }
    return TRUE;
}
```

#### [二叉平衡树](https://www.dotcpp.com/course/158)

平衡二叉树（Balanced Binary Tree）具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 其中最为经典当属AVL树，我们

总计而言就是：平衡二叉树是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。

> AVL树具有下列性质的二叉树（注意，空树也属于一种平衡二叉树）：

- 它必须是一颗二叉查找树
- 它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。
- 若将二叉树节点的平衡因子BF定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有节点的平衡因子只可能为-1,0,1.
- 只要二叉树上有一个节点的平衡因子的绝对值大于1，那么这颗平衡二叉树就失去了平衡。

> 实现

AVL树的构建我们需要明白一个核心的操作，整个实现过程是通过在一棵平衡二叉树中依次插入元素(按照二叉排序树的方式)，若出现不平衡，则要根据新插入的结点与最低不平衡结点的位置关系进行相应的调整。各个调整的方法分为LL型、RR型、LR型和RL型4种类型，其余的操作与一般的树进行插入和修改数据无异，这里由于篇幅关系不做过多缀数，以其中一种LR型调整为例说明，其余各种也都是举一反三思考：

![动态查找-平衡二叉树](./1576542552902246.png)

由于在A的左孩子(L)的右子树(R)上插入新结点，使原来平衡二叉树变得不平衡，此时A的平衡因子由1变为2。图5是LR型的最简单形式。显然，按照大小关系，结点C应作为新的根结点，其余两个节点分别作为左右孩子节点才能平衡。

- 将B的左孩子C提升为新的根结点
- 将原来的根结点A降为C的右孩子
- 各子树按大小关系连接(BL和AR不变，CL和CR分别调整为B的右子树和A的左子树)。

```c++
#include<stdio.h>
#include<stdlib.h>
  
//结点设计 
typedef struct Node {
    int key;
    struct Node *left;
    struct Node *right;
    int height;
} BTNode;
  
int height(struct Node *N) {
    if (N == NULL)
        return 0;
    return N->height;
}
  
int max(int a, int b) {
    return (a > b) ? a : b;
}
  
BTNode* newNode(int key) {
    struct Node* node = (BTNode*)malloc(sizeof(struct Node));
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    node->height = 1;
    return(node);
}
  
//ll型调整 
BTNode* ll_rotate(BTNode* y) {
    BTNode *x = y->left;
    y->left = x->right;
    x->right = y;
  
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
  
    return x;
}
  
//rr型调整 
BTNode* rr_rotate(BTNode* y) {
    BTNode *x = y->right;
    y->right = x->left;
    x->left = y;
  
    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;
  
    return x;
}
  
//判断平衡
int getBalance(BTNode* N) {
    if (N == NULL)
        return 0;
    return height(N->left) - height(N->right);
}
  
//插入结点&数据
BTNode* insert(BTNode* node, int key) {
    if (node == NULL)
        return newNode(key);
  
    if (key < node->key)
        node->left = insert(node->left, key);
    else if (key > node->key)
        node->right = insert(node->right, key);
    else
        return node;
  
    node->height = 1 + max(height(node->left), height(node->right));
  
    int balance = getBalance(node);
  
    if (balance > 1 && key < node->left->key) //LL型
        return ll_rotate(node);
  
    if (balance < -1 && key > node->right->key)     //RR型
        return rr_rotate(node);
  
    if (balance > 1 && key > node->left->key) {   //LR型
        node->left = rr_rotate(node->left);
        return ll_rotate(node);
    }
  
    if (balance < -1 && key < node->right->key) {   //RL型
        node->right = ll_rotate(node->right);
        return rr_rotate(node);
    }
  
    return node;
}
  
//遍历
void preOrder(struct Node *root) {
    if (root != NULL) {
        printf("%d ", root->key);
        preOrder(root->left);
        preOrder(root->right);
    }
}
  
int main() {
    BTNode *root = NULL;
  
    root = insert(root, 2);
    root = insert(root, 1);
    root = insert(root, 0);
    root = insert(root, 3);
    root = insert(root, 4);
    root = insert(root, 4);
    root = insert(root, 5);
    root = insert(root, 6);
    root = insert(root, 9);
    root = insert(root, 8);
    root = insert(root, 7);
  
    printf("前序遍历：");
    preOrder(root);
    return 0;
}
```

### [索引顺序查找](https://book.itheima.net/course/223/1276707762369208322/1276709680369901571)

## [散列表](https://www.cnblogs.com/shaoxx333/p/17127169.html)

散列表（Hash Table），又称哈希表或杂凑表，是一种通过**直接映射关键字**进行查找的数据结构。与线性表和树表需要**通过比较关键字**来查找不同，散列表通过散列函数将关键字**映射**到存储地址，实现了关键字与存储地址之间的直接对应关系。因此，散列表具有高效的**随机查找能力**，能够快速定位所需数据。使用散列表通常**意味着采用哈希查找这一特点。**

例如：关键字集key = (17, 24, 48, 25)，散列函数H(key) = key % 5，散列函数将关键字映射到存储地址下标，将关键字存储到散列表的对应位置。

![img](./1734568-20230315220304475-1885216365.jpg)

理想情况下，散列表查找的时间复杂度是O(1)。但是，散列函数可能会把两个或两个以上的关键字映射到同一地址，发生“**冲突**”**，**发生冲突的不同关键字称为“**同义词**”，也就是具有相同函数值的关键字。接上例，如果13也要存入散列表，就会和48产生冲突：

**![img](./1734568-20230315221429528-837434745.jpg)**

所以，使用散列表需要解决好两个问题：构造合适的散列函数，以及制定一个好的解决冲突的方案。

### 散列函数的构造

在构造散列函数时需要考虑诸多因素：执行速度、关键字长度、散列表大小、关键字的分布情况、查找频率等。

根据元素集合的特性构造，我们对散列函数有以下要求：

1. n的数据源仅占n个地址，虽然散列查找是以空间换时间，但仍希望散列的**地址空间尽量小**。
2. 无论用什么方法存储，目的都是尽量**均匀**地存放元素，以避免冲突。

常见的构造方法有：直接定址法、除留余数法、数字分析法、平方取中法、折叠法、随机数法。

#### **直接定址法**

以关键码key的某个线性函数值作为散列地址

　　**Hash(key) = a \* key + b (a，b为常数)**

优点是线性关系，不会产生冲突。但是要占用连续的地址空间，空间效率低下。**适合查找表较小且连续的情况。**

例如：使用直接定址法存储序列 `{100, 300, 500, 700, 800, 900}`，选择散列函数` Hash(key) = key / 100 (a=1/100, b=0)`

![img](./1734568-20230314210839039-656693456.jpg)

#### 除留余数法

此方法是最常用的散列函数构造方法：**Hash(key) = key mod p  (p是一个整数)**

- 关键：如何选取合适的p?

- 技巧：设表长为m，取p≤m，且p为**质数**

例：{15, 23, 27, 38, 53, 61, 70}，散列函数 Hash(key) = key mod 7

![img](./1734568-20230314212441428-1394682943.jpg)

####  数字分析法

如果**关键字是位数较多的数字**（比如手机号），且这些数字部分存在相同规律，则可以采用**抽取剩余不同规律部分作为散列地址。**

比如手机号前三位是接入号，中间四位是 HLR 识别号，只有**后四位才是真正的用户号**。也就是说，如果手机号作为关键字，那么极有可能前 7 位是相同的，此时我们选择后四位作为散列地址就是不错的选择。**同时，对于抽取出来的数字，还可以再进行反转、右环位移、左环位移等操作，目的就是为了提供一个能够尽量合理地将关键字分配到散列表的各个位置的散列函数。**

数字分析法通常适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。

#### 平方取中法

以关键字平方的中间位数作为散列地址。比如假设关键字是 4321，那么它的平方就是 18671041，抽取中间的 3 位就可以是 671，也可以是 710，用做散列地址。

![img](./1734568-20230315223936859-80664489.jpg)

**适合于不知道关键字的分布，而位数又不是很大的情况。**

##### 折叠法

折叠法是将**关键字从左到右分割成位数相等的几部分**（注意最后一部分位数不够时可以短些），然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。比如假设关键字是 9876543210，散列表表长为三位。

![img](./1734568-20230315224617502-1136713374.jpg)

有时可能这还不能够保证分布均匀，那么也可以尝试从一端到另一端来回折叠后对齐相加，比如将 `987 `和 `321` 反转，再与 `654 `和 `0` 相加，变成` 789+654+123+0=1566`，此时散列地址为 `566`。**折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。**

##### 随机数法

选择一个随机数，取关键字的随机函数值作为它的散列地址：**hash(key) = random(key)**。当**关键字的长度不等**时采用这个方法构造散列函数是比较适合的。

### 处理哈希冲突

#### 开放定址法

**基本思想：**有冲突时就去寻找**下一个**空的散列地址，只要散列表足够大，空的散列地址总能找到，并将数据元素存入。常用的开放定址法有线性探测法、二次探测法、伪随机探测法等。

> **线性探测法**

**Hi = (Hash(key) + di) mod m，（1 ≤ i ≤ m）**

其中，m为散列表长度，**di = i（i为1,2，...，m-1 线性序列）**

例：关键码集为{47, 7, 29, 11, 16, 92, 22, 8, 3}，散列表长度为m=11，散列函数为Hash(key)=key mod 11，使用线性探测法处理冲突，存入过程如下：

![img](./1734568-20230314221855877-466124663.jpg)

> **二次探测法**

增量序列`di`为`12，-12，22，-22，...，q2 `二次序列，同样是上边的例子，使用二次探测法处理冲突，存入过程如下：

![img](./1734568-20230314221733936-1526430758.jpg)

注意：二次探测法是跳跃式探测，效率较高，但是会出现命名有有空间却探测不到的情况，因而存储失败，而线性探测只要有空间就一定能探测到。

> **伪随机探测法**

增量序列`di`为伪随机数。其存入原理和上边两种方法一致，这里不多做介绍。

#### 链地址法

**基本思想：**将相同散列地址的记录（即同义词）链成一单链表。m个散列地址就是m个单链表，然后用一个数组将m个单链表的表头指针存储起来，**形成一个动态的结构。**

例如：关键字为`{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}`，散列函数为`Hash(key) = key mod 13`，使用链地址法存储如下所示：

![img](./1734568-20230314224228107-78785297.jpg)

链地址法建立散列表的步骤：

- 取数组元素的关键字key，计算其散列函数值（地址）。若该地址对应的链表为空，则将该元素插入此链表；否则执行下一步解决冲突；

- 根据选择的冲突处理方式，计算关键字key的下一个存储地址。若改地址对应的链表不为空，则利用链表的前插法或后插法将该元素插入此链表。

优点：

- 非同义词（同义词是指具有相同函数值的关键字）不会冲突，无“聚集”现象；

- 链表上结点空间**动态申请**，更适合于表长不确定的情况

#### 再散列法

就是同时构造多个不同的哈希函数：**Hi = Hashi (key)  i= 1,2,3 ... k；**

当`H1 = Hash1 (key) `发生冲突时，再用`H2 = Hash2 (key) `进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。

#### 建立公共溢出区

将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一存放到溢出区。

### 散列表的查找

给定查找值k，查找过程如图所示：

![img](./1734568-20230314225542171-252331886.jpg)

[**散列表的查找效率分析**](https://huosk.github.io/2019/02/21/algorithm11-hashmap/)

一般我们使用**平均查找长度ASL**来衡量查找效率，散列表ASL的值取决于：**散列函数、处理冲突的方法、散列表的装填因子α**（α = 表中填入的记录数 / 哈希表的长度，α越大，表中记录数越多，发生冲突的可能性就越大，查找对比次数就越多）。

　　线性探测法：ASL ≈ 1 / 2 * (1 + 1 / (1 - α))

　　拉链法：ASL ≈ 1 + α / 2

　　随机探测法：ASL ≈ -1 / α * ln(1 - α)

**例：**对于关键字集{19, 14, 23, 1, 68, 20, 84, 27, 55, 11, 10, 79}，n=12，散列函数为：H(key) = key mod 13，散列表表长为m = 16，设每个记录的查找概率相等。则使用不同查找算法的平均查找效率如下：

　　线性探测法：ASL ≈ 1 / 2 * (1 + 1 / (1 - 0.75)) = 2.5  (装填因子α = n / m = 0.75)

　　拉链法：ASL ≈ 1 + 0.75 / 2 = 1.375

　　随机探测法：ASL ≈ -1 / α * ln(1 - α) = 1.85

对比无序表查找和有序表折半查找：

　　无序表：ASL = (n +1) / 2 = 6.5

　　有序表折半查找：ASL = lg2(n + 1) - 1 = 2.7

**总结以下几点：**

1. 散列表技术具有很好的平均性能；
2. 链地址法优于开地址法；
3. 除留取余法做散列函数优于其它类型函数。
