---
title: 排序与查找
date: 2023-04-26 08:20:07
categories: 算法
tags: 数据结构
typora-root-url: ./3.排序与查找
---

## [排序](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

排序是重新排列表中的元素，输入一个随机排序的数列，输出一个有序的数列。基本所有的排序都是如此，通常需要输入对应表的长度，对应表的引用即可进行排序。

其中**稳定性**是描述排序过程中数据变动的情况，举个例子排序一个结构体

```c++
struct RA{
    int key;
    int value;
}
```

对于结构体的`value`进行排序，如果有两个不同的`key`映射的值`value`相同，在排序完之后数据映射依旧，那么可以说明这个排序稳定。

考虑以下待排序数组，其中元素的格式为`(key, value)`：

```c++
(4, A), (2, B), (3, C), (2, D), (4, E)
```

排序完成之后变为，映射依旧。

```c++
(2, B), (2, D), (3, C), (4, A), (4, E)
```

> 内部排序和外部排序的区分

其中内部排序和外部排序的区分，是在于数据是否完全存储于内存中。最显著的区分就是他们的运算速度和运算范围。

内部排序的特点就是运算速度快，但是限于内存的大小，只能运算小数量级的排序。符合内部排序的有：冒泡排序，插入排序，选择排序，快速排序，归并排序，堆排序，希尔排序。

外部排序一般会在名字上备注，且通常会使用IO流来控制数据的导入与导出(磁盘-内存)。以下介绍的基本排序函数，都不属于外部排序。

> 执行过程

任何排序的核心思想就是将序列分为两个部分，第一部分是有序序列，其中存储的都是有序的数；另部分就是无序的数据，是尚未遍历到是未知顺序的数据。

通常排序过程中，都会涉及到获取数据 - 移动数据；其中的时间复杂度基本上取决于这两者。预测排序算法的时间复杂度通常会使用概率等工具构造其复杂度函数。

![sort](/../3.排序与查找/sort-1721820673446-3.png)

### 交换排序

#### 冒泡排序

冒泡排序的基本思想是，从前往后或者从后往前遍历数组，过程中两两交换其中的数据。根据使用的要求，可以让数据从大到小`A[i-1]<A[i]`，或者从小到大`A[i-1]>A[i]`。

所以说实现冒泡排序的关键是：交换和遍历

![冒泡排序](/../3.排序与查找/冒泡排序-1721820673446-5.gif)

```c++
//数组记得用引用类似 - 可以改变数组的值不仅仅只是参数变量
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

//从小到大
void sort(int array[],int length)
{
    //有无数据
    if(length>0){
        //遍历一次，排序完全区域就增加一个数据
        for(int i = 1;i<length;i++){
            //未排数据就少一个位置
            //以确保从未排序区域的第一个元素开始进行比较和交换
            for(int j = 0;j<=lenth-i;j++){ //为了给第一个数据位置
                if(array[j]>array[j+1]){
                    swap(array[j],array[j+1]);
                }
            }
        }
    }
}
```

教科书上实现的冒泡排序，比较简单

```c++
void BubbleSOrt(ElemType A[],int n){
    for(int i = 0;i<n-1;i++){
        bool flag = false;
        // 这里改为正序也可以
        for(int j=n-1;j>i;j--){
            if(A[j-1]>A[j]) {
                swap(A[j-1],j[j]); //逆序交换
            	flag = true;
            }
		}
         if(flag==false) return;
    }   
}
```

冒泡排序是一种稳定的排序手法，其时间复杂度是`O(n^2)`，平均时间复杂度是`O(n^2)`。冒泡排序产生的有序子序列一定是**全局有序**的。全局有序通常指的是一个数据集合中所有元素都按照某种排序规则排列好。

#### 快速排序

![快速排序](/../3.排序与查找/quickSort-1721820673447-13.gif)

快速排序是基于分治法，分治法的意思是将一个大问题转化为几个小问题，通过解决完成全部小问题然后返回值构成大问题的解而成。由于每个小问题的解决方法都是一致的，所以选择使用递归来实现这些操作。

具体实现快速排序是这样的，每一次都在当前分好的序列中执行这些操作。

- 首先选举出一个基准值，对基准值的操作具体要看你的要求，这里假设要从小到大
- 将小于当前基准值的数据放在数据左侧
- 将大于当前基准值的数据放在数据右侧

由于快速排序每次递归将序列分为两个子序列，递归的深度决定了其空间复杂度。在理想情况下，递归深度为 `log(n)`，因此快速排序的空间复杂度为 `O(log(n))`。但在最坏情况下，递归深度为 `n`，此时的空间复杂度会增加到 `O(n)`。

```c++
// 快速排序
void QuickSort(ElemType A[], int low, int high) {
    // 如果子数组的元素个数大于1，则继续递归排序
    if (low < high) {
        // 划分区间，并获取基准值的位置
        int pivotpos = Partition(A, low, high);
        // 对基准值左侧的子数组递归排序
        QuickSort(A, low, pivotpos - 1);
        // 对基准值右侧的子数组递归排序
        QuickSort(A, pivotpos + 1, high);
    }
}

// 划分区间 - 返回基准值的位置
int Partition(ElemType A[], int low, int high) {
    ElemType pivot = A[low]; // 将第一个元素设为基准值
    while (low < high) {
        // 从右侧开始，找到第一个小于基准值的元素
        while (low < high && A[high] >= pivot) --high;
        A[low] = A[high]; // 将这个元素移动到左侧
        // 从左侧开始，找到第一个大于基准值的元素
        while (low < high && A[low] <= pivot) ++low;
        A[high] = A[low]; // 将这个元素移动到右侧
    }
    A[low] = pivot; // 将基准值放回正确的位置
    // 返回基准值的位置
    return low;
}
```

### 插入排序

前面说过，任何排序的核心思想就是将序列分为两个部分，第一部分是有序序列，其中存储的都是有序的数；另部分就是无序的数据，是尚未遍历到是未知顺序的数据。

插入排序的核心思想于斗地主抓牌类似，假设发牌员将无序的牌堆在牌桌上，为了区分，我们认为手中的牌是有序的。每次从无序的牌堆接收到一个新的牌，将之插入到有序的序列当中，也就是抓牌整理排序。直接插入排序的时间复杂度是`O(n^2)`，因为有两层循环。第一层从无序的位置找到一张牌，第二层将这个牌插入到有序的位置。

码牌的时候将无序的牌插入到手中的牌，每次插完有序+1，无序-1。直到无序部分没有牌为止。**如果在无序牌堆中，所有的牌是正序的时候**，其时间复杂度会降低到O(n)，也就是仅仅插入而不用进行比较。（但是正序序列为什么需要排序呢？）

![插入排序](/../3.排序与查找/insertionSort-1721820673447-8.gif)

具体操作如下，声明一个单指针`i`来遍历我们的数组，然后使用一个`j`内循环指针，对排序完成的区域进行一次遍历移动，然后将对应的`i`指针的数据插入到对应的位置即可。

```c++
void sort(int array[],int length){
    for(int i = 1;i<length;i++){
        //1.从无序牌堆中找到的牌
        int key = array[i];
        //2.变量指向的是有序牌堆
        int j = i-1;
	   //3.从有序牌堆中找到适合key的位置插入
        while(j>=0 && array[j]>key){
            //插入位置设置为j的前面
            array[j+1] = array[j];
            j--;
        }
        //插入正确位置 - 完工
        array[j+1] = key;
    }
}
```

有关于王道中的直接插入排序代码如下，采用了用变量暂时记录数据

```c++
void InsertSort(ET A[],int n)
{
    int i,j;
    for(int i = 2;i<=n;i++)
    {
        //边查找边排序
        if(A[i]<A[i-1])
        {
		   A[0] = A[i]; //A[0]位置充当过度变量
            //j指向的是有序序列，循环是挪动比较位置
            for(int j = i-1;A[0]<A[j];--j) A[j+1] = A[j];
            //插入到有序序列第一个大于的位置
            A[j+1] = A[0];            
        }
    }
}
```

其中的空间复杂度为O(1)，最坏时间复杂度是O(n)

#### 折半插入排序

普通插入排序是将比较和移动集中在一起，这里将比较和移动操作分离就成了折半插入排序。对于线性表来说，可以在有序序列中确定当前`key`要插入的位置，然后将`key`插入

也就是优化了查找数据的时间复杂度，减少了比较元素的个数`n`。为原来的`O(nlg2)`，但是元素的移动次数没有改变，故时间复杂度还是`O(n)`。

折半插入排序函数是一种稳定的排序方法。

```c++
void InsertSort(ElemType A[],int n)
{
    int i,j,low,high,mid;
    //i记录的是新加入的牌
    for(int i = 2;i<=n;i++)
    {
        A[0] = A[i]; //记录当前插入的无序
        low=1,high=i-1;
        //二分找插入点
        while(low<=high)
        {
            mid=(low+high)/2;
            if(A[mid]>low) high = mid-1;
            else low=mid+1;                      
        }
        for(int j = i-1;j>=high+1;--j){
            A[j+1]=A{j];
		}
         A[high+1] = A[0]; //插入
    }   
    
}
```

#### [希尔排序操作](https://blog.csdn.net/qq_43473694/article/details/112197066)

![希尔排序](/../3.排序与查找/Sorting_shellsort_anim-1721820673447-11.gif)

希尔排序是对插入排序的优化，如果我们插入的`无序牌`有序的话，可以减少大量的时间。举个例子，你手上`2 3 4 5 6`然后来了`7 8 9 10`是不是直接插就行了。希尔排序就是为了尽量构造这样的结构来达到优化的结果。

在希尔排序中，我们将一个大的排序序列根据定义的步长 `d` 分割成多个子序列，并对每个子序列进行插入排序。需要注意的是，这些子序列是交错的，也就是说，分组之间存在重叠。当对所有子序列完成排序后，整个数组将逐渐变得部分有序。

![image-20240814115601815](/../3.排序与查找/image-20240814115601815-1723796451329-6.png)

由于在步长较大的情况下，希尔排序已经对数组进行了初步排序，减少了无序的元素，因此在最终步长为 1 时，最后一轮的插入排序将变得非常高效，时间复杂度可以降至`O(n)`。这种方法之所以有效，是因为在排序过程中，数组的无序程度逐步降低，使得后续的排序操作更快完成。

需要注意的是步长的定义，这个决定了每一个分组中比较和交换的时间复杂度。希尔排序的时间复杂度大约在`O(nlogn)` 和 `O(n^2)`之间，最坏情况下和普通的插入排序的时间复杂度是一样的。最坏情况通常出现在选择的增量（gap）与输入数据的排列方式导致在每个子序列中都需要大量的比较和交换。

```c++
void ShellSort(ElemType A[], int n) {
    int dk, i, j;
    // 外层循环处理不同的步长
    for (dk = n / 2; dk >= 1; dk = dk / 2) {
        // 内层循环对每个分组进行插入排序
        // i的作用是确定每个子序列的起点
        for (int i = dk; i < n; i++) {
            if (A[i] < A[i - dk]) {
                A[0] = A[i]; // 临时存储当前元素
                for (j = i - dk; j >= 0 && A[0] < A[j]; j -= dk) {
                    A[j + dk] = A[j]; // 移动元素
                }
                A[j + dk] = A[0]; // 插入到正确位置
            }
        }
    }
}
```

需要注意的是，**希尔排序并不是稳定的排序**，也就是其中相同的对应元素会发生改变。本质上是对插入排序的优化，所以说最坏情况和插入排序挂钩。

### 选择排序

![选择排序](/../3.排序与查找/selectionSort-1721820673447-7.gif)

插入排序一样，选择排序也分为两个部分，已经排序和排序完全的部分。

具体实现是使用双指针算法，假设我们需要排序从小到大的数组，第一个位置用`i`指向，用`j`指向`i`之后的其他数据，在查询的过程中比较`A[i],A[j]`，如果`A[j]<A[i]`则执行交换，交换完成之后`i`前移，重复这个过程直到未排序序列为空。

选择排序的时间复杂度为`o(n^2)`，且选择排序是一种不稳定的排序算法。

```c++
void SelectSort(ElemType A[],int n){
    for(int i = 0;i<n-1;i++)
    {
        // 最小值位置 - 相对于未排序部分来说
        int min = i;
        for(int j = i+1;j<n;j++)
        {
            if(A[j]<A[min]) min = j; // 记录最小值位置
        }
        if(min!=i) swap(A[i],A[min]); // 与最小值位置交换
    }
}
```

#### [堆排序](https://www.cnblogs.com/chengxiao/p/6129630.html)

堆排序是使用完全二叉树对数据进行处理，具体流程是

- 先将所有排序数据组合成一个完全二叉树
- 然后根据要大根堆还是小根堆，对这个二叉树进行重组
- 最后对大根堆和小跟堆进行交换数据，最后用数组顺序输出即可

![img](/../3.排序与查找/1024555-20161217182750011-675658660-1723796455282-9.png)

通常堆都是用数组来模拟的，用数组下标的关系来表示各个节点。具体映射图像是这样的

![img](/../3.排序与查找/1024555-20161217182857323-2092264199-1723796457244-11.png)

那解决堆排序的重点就有两个

- 构成大根堆或者小根堆
- 对大根堆和小跟堆进行调整输出回数组中

以大根堆为例，用数组`A[0]`作为根节点。那么对于这个堆的左节点符合`2i+1`，右节点符合`2i+2`。对于堆中的每一个节点，查找其子节点并进行比较，将较大值置于该节点位置。

```c++
void HeadAdjust(ElemType A[], int k, int len) {
    A[0] = A[k]; // 将根节点的值存入 A[0] 作为临时变量
    for(int i = 2 * k; i <= len; i *= 2) { // 遍历当前节点的子节点
        if(i < len && A[i] < A[i + 1]) i++; // 如果右子节点比左子节点大，选择右子节点
        if(A[0] >= A[i]) break; // 如果根节点比子节点大，停止调整
        else {
            A[k] = A[i]; // 子节点的值上移
            k = i; // 更新 k，使其指向下一个子节点
        }
    }
    A[k] = A[0]; // 将原根节点的值放入最终位置
}
```

然后对大根堆进行调整，实现堆排序

- 在大根堆构造完成后，最大元素位于堆顶（即数组的第一个元素）。
- 将堆顶元素（最大值）与堆的最后一个元素交换，然后减少堆的大小（忽略最后一个元素，因为它已经排好序）。
- 调整剩余的堆，再次进行堆化。

重复上序的操作，就可以实现堆排序.

```c++
void HeapSort(ElemType A[], int len) {
    // Step 1: 构造初始大根堆
    for(int i = len / 2; i > 0; i--) {
        HeadAdjust(A, i, len);
    }

    // Step 2: 进行排序
    for(int i = len; i > 1; i--) {
        swap(A[1], A[i]);   // 将堆顶元素（最大值）交换到数组末尾
        HeadAdjust(A, 1, i - 1); // 调整剩余部分为大根堆
    }
}

void HeadAdjust(ElemType A[], int k, int len) {
    A[0] = A[k];
    for(int i = 2 * k; i <= len; i *= 2) {
        if(i < len && A[i] < A[i + 1]) i++;
        if(A[0] >= A[i]) break;
        else {
            A[k] = A[i];
            k = i;
        }
    }
    A[k] = A[0];
}
```

最后顺序输出的数组，就是排完序的数组。堆排序的时间复杂度为`O(nlogn)`，建立堆的时间花费`O(n)`，对每个堆调整的时间为`O(logn)`。

### 归并排序

![归并排序](/../3.排序与查找/mergeSort-1721820673447-12.gif)

归并排序的核心思想是分治，将一个大问题分为许多小问题再总和起来。由于这些小问题完成的操作都是一样的，所以用递归的操作实现这个排序算法。每一个小块的操作如下

- 先分当前块分为两个部分，分为左子序列和右子序列
- 对左子序列和右子序列分别调用归并排序函数进行处理，直到子序列的长度为1，此时子序列本身就是有序的。
- 当两个子序列都排序完成后，将它们合并为一个有序的序列。在合并的过程中，比较两个子序列的元素，将较小的元素放入到新的序列中，并依次进行，直到所有元素都合并完成。

```c++
//tmp是辅助数组 - q是原数组
int tmp[N],q[N];

void qsort(int q[],int l,int r){
    if(l == r) return; //合并完成
    
    int mid = l+r>>1;
    //分的左边
    qsort(q,l,mid);
    //分的右边
    qsort(q,mid+1,r);
    
    //这一部分不会立即执行 - 需要执行完成上面的分子序列才行。直到每一个元素都分为一个子序列
    //k是并的维护指针
    int i = l,j = mid+1,k = 0;
    
    while(i<=mid && j<=r){
        //i和j不在同一个区间 - 在两个不同的区间
        if(q[i]<q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];
    }
    while(i<=mid) tmp[k++] = q[i++];
    while(j<=r) tmp[k++] = q[j++];
    
    //最后拼回去
    for(int i = l,j = 0;i<=r;i++,j++) q[i] = tmp[j];
    
}
```

归并排序是稳定算法，且其空间复杂度为`O(nlogn)`。每次归并的时间复杂度为`O(n)`，需要执行`logn`次。

### 基数排序

基数排序（Radix sort）是一种非比较型整数排序算法。

原理是将整数**按位数切割成不同的数字**，然后**按每个位数分别比较**。基数排序的方式可以采用LSD（Least significant digital）或MSD（Most significant digital），LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。

- **MSD**：先从高位开始进行排序，在每个关键字上，可采用计数排序
- **LSD**：先从低位开始进行排序，在每个关键字上，可采用桶排序

实现逻辑是：

- 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。
- 从最低位开始，依次进行一次排序。
- 这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。

分步图示说明：设有数组 array = {53, 3, 542, 748, 14, 214, 154, 63, 616}，对其进行基数排序：

![img](/../3.排序与查找/v2-5ae4857fa248035ecec780583c5e3303_720w-1723796493039-14.webp)

在上图中，首先将所有待比较数字统一为统一位数长度，接着从最低位开始，依次进行排序。

- 按照个位数进行排序。
- 按照十位数进行排序。
- 按照百位数进行排序。

排序后，数列就变成了一个有序序列。

> 时间复杂度：O(k*N)
> 空间复杂度：O(k + N)
> 稳定性：稳定

```c++
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];      ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
```

#### 计数排序

![计数排序](/../3.排序与查找/countingSort-1721820673447-15.gif)

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。计数排序的时间复杂度是`o(n+K)`，低时间复杂度但是高空间。

简单说，就是用我们"需要排序的序列的值",创建一个标记数组，只要序列出现过的值，都标记成1，就说明它出现了。但是，这种方法只对数来说比较方便。可以说是数组下标和排序序列有映射关系。

> 算法步骤
> （1）找出待排序的数组中最大和最小的元素
> （2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
> （3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
> （4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1
>
> 但是这种方法排序离散的数据就不靠谱了。

```c++
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 计数排序函数，将排序结果存储在sorted_arr中
void counting_sort(int *arr, int n) {
    int max = 0;

    // 找到数组中的最大值，以确定计数数组的大小
    for (int i = 0; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    // 创建计数数组和排序后的数组
    int *count_arr = (int *)malloc(sizeof(int) * (max + 1));
    int *sorted_arr = (int *)malloc(sizeof(int) * n);

    // 初始化计数数组为0
    for (int i = 0; i <= max; i++) {
        count_arr[i] = 0;
    }

    // 计算每个元素出现的次数
    for (int i = 0; i < n; i++) {
        count_arr[arr[i]]++;
    }

    int index = 0;

    // 从计数数组中构建排序后的数组
    for (int i = 0; i <= max; i++) {
        while (count_arr[i] > 0) {
            sorted_arr[index] = i;
            index++;
            count_arr[i]--;
        }
    }

    free(count_arr);

    // 打印排序后的数组
    printf("sorted_array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", sorted_arr[i]);
    }
    printf("\n");

    free(sorted_arr);
}

int main(int argc, char **argv) {
    int n = 10;
    int *arr = (int *)malloc(sizeof(int) * n);
    srand(time(0));

    // 生成随机数组
    for (int i = 0; i < n; i++) {
        arr[i] = rand() % 100;
    }

    // 打印初始数组
    printf("ini_array: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");

    // 调用计数排序函数
    counting_sort(arr, n);
    free(arr);

    return 0;
}
```

#### 桶排序

元素分布在桶中：

![桶](/../3.排序与查找/Bucket_sort_1.svg_-1721820673447-21.png)

然后，元素在每个桶中排序：

![桶](/../3.排序与查找/Bucket_sort_2.svg_-1721820673447-16.png)

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n;
int a[N], b[N];

int main()
{
    cin >> n;
    // 输入数据
    for (int i = 0; i < n; i++) 
        cin >> a[i];

    // 找到数组中的最大值
    int maxv = *max_element(a, a + n);

    // 统计每个元素出现的次数
    for (int i = 0; i < n; i++)
        b[a[i]]++;

    int j = 0; // 辅助指针j，用于更新原数组a
    // 从0到最大值遍历，按照计数数组b的信息重建原数组a
    for (int i = 0; i <= maxv; i++)
    {
        while (b[i]--) // 每个元素出现的次数减少一个
            a[j++] = i; // 更新原数组
    }

    // 输出排序后的数组
    for (int i = 0; i < n; i++)
        cout << a[i] << ' ';

    return 0;
}
      
```

