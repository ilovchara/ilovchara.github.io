---
title: 挑战算法竞赛
date: 2023-10-28 14:52:40
tags: 算法
categories: 算法
typora-root-url: ./挑战算法竞赛
---

# 前言

写下本文的目的是为了理清现在的思路，由于看的知识点过于多了，很多可能造成了遗忘或者是学习了错误的知识点，这里决定跟随书的思路，理清前面的文章，或者说进一步优化我的文章吧。

然后跟着书上的知识点一步一步走，梳理一下我的思路，不像之前那样乱来了。此外，干爆算法竞赛那篇文章是刷题的文章，之后就要坚持刷下来！！！

## 准备篇

这里书上简单的讲解了一下一些简答的应用题。

![image-20231028150455639](image-20231028150455639.png)

我们的思路就是在约束条件之下，枚举出我们的三角形，约束条件如下:

- 最长棍子长度 < 其余两个棍子之和
- 枚举周长最大

```c++
#include<iostream>
using namespace std;
// 这里假设棍子很多
const int N = 1e5+10;
int a[N];

void selet(){
    //需要的周长
    int ans = 0;
    //这里的逻辑是依次枚举三根 - 依次+1就不会枚举重复
    for(int i = 1;i<=n;i++){
        for(int j = i+1;j<=n;j++){
            for(int k = j+1;k<=n;k++){
                int len = a[i]+a[j]+a[k];
                int ma = max(a[i], max(a[j],a[j]));
                //判断是否符合三角形
                int rest = len-ma;
                //枚举更新
                if(ma<rest) ans = max(ans,len);
            }
        }           
    }
    //输出结果
    printf("%d\n",ans);
}



int main()
{
    int n;
    cin>>n;
    for(int i= 1;i<=n;i++) cin>>a[i];
    cout<<"周长最长的三角形: " << selet() << endl;
    return 0;
    
}
```

这里用的方法就是简单枚举，时间复杂度是`O(n^3)`

![image-20231028154802331](image-20231028154802331.png)

这道题，如果简单看上去我们需要考虑的东西有很多。对于每一个蚂蚁，我们要考虑他相撞的方向，那有n只蚂蚁我们需要考虑的可能性就是2^n。但是仔细看完之后就发现，我们每一个蚂蚁的身份不用考虑，也就是：

- 蚂蚁相遇的时候，可以认为是保持原本的样子通过这条路

  ![image-20231028170842102](image-20231028170842102.png)

那这样就简单了，只需要计算蚂蚁和杆子端点的距离就行。

```c++
#include<iostream>
#include<algorithm>
using namespace std;

const int MAX = 1e5+10;

//长度 + 蚂蚁数量
int L, n;
int x[MAX];

void solve() {
    int minT = 0;
    for(int i = 0; i < n; i++){
        // 左端点为0 - 右端点为L - 这里有点不理解
        minT = max(minT, min(x[i], L - x[i]));
    }
    
    int maxT = 0;
    for(int i = 0; i < n; i++){
        maxT = max(maxT, max(x[i], L - x[i]));
    }
    
    cout << minT << " " << maxT << endl;
}

int main() {
    cin >> L >> n; // 读取杆子长度和蚂蚁数量
    for(int i = 0; i < n; i++) {
        cin >> x[i];
    }
    solve();
    return 0;
}

```

- `min(x[i], L - x[i])`：表示第 `i` 只蚂蚁距离杆子两端的最短距离。
- `max(minT, ...)`：用于更新 `minT` 变量，以保留之前的最大值。

### 二分搜索

在之前也写过有关二分搜索的文章，但其实是拼凑出来的：{% post_link 对数据的简单操作 %}。优化完成！

这里引出二分查找的题目是抽签问题：

![image-20231028183352110](image-20231028183352110.png)

这里开始用的是暴力搜索，也就是：

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;


int main()
{
    int n,m,k[N];
    scanf("%d %d", &n,&m);
    for(int i = 1;i<=n;i++) scanf("%d",&k[i]);
    
    bool f = false;
    //这里是放回的 - 枚举4个数据加和 = m
    for(int a = 0;a<n;a++)
        for(int b = 0;b<n;b++)
            for(int c = 0;c<n;c++)
                for(int d = 0;d<n;d++)
                    if(k[a]+k[b]+k[c]+k[d] == m) f = true;
    
    //输出
    if(f) puts("Yes");
    else puts("No");
    
    return 0;    
}
```

但是这样很慢，时间复杂度达到了`o(n^4)`.

所以说我们使用二分对其进行优化，首先将序列排好序，我们需要凑到的`m`一定是在这个序列里面的，所以说我们就对其进行操作：

![image-20231028195118089](image-20231028195118089.png)

我们需要和`mid`比较的数据，是我们搜索四个数的加和，在这个题目中，由于是放回的抽签就可以达到这个效果，这本书给的代码有问题，所以说这里用双指针算法来做。我们固定一个数据`i`，由于我们数组是排完序的，所以说只需要在这个`i`的左右寻找就行。如果当前这个`i`的值无法满足，就换下一个。这个时间复杂度是 `O(n^2)`

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int Max = 1e5 + 10;

int n, m;
int k[Max];

bool solve()
{
    sort(k, k + n);
    for (int i = 0; i < n; i++)
    {
        int left = i + 1, right = n - 1;
        while (left < right)
        {
            int current_sum = k[i] + k[left] + k[right];
            if (current_sum == m)
            {
                return true;
            }
            else if (current_sum < m)
            {
                left++;
            }
            else
            {
                right--;
            }
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        cin >> k[i];
    }
    if (solve())
    {
        cout << "Yes" << endl;
    }
    else
    {
        cout << "No" << endl;
    }
    return 0;
}

```

但是神奇的是，优化之后的二分法却又可以使用了，这里贴一下代码，优化思路是。我们本来是要找三个部分的，现在我们先找一个部分，举个例子，我们需要找到`M = a+b+c`那么我们先把所有符合`a`的找出来，在接着找`b，c`就容易了。

```c++
#include <iostream>
#include <algorithm>
using namespace std;

const int Max = 1e5 + 10;

int n, m;
int k[Max];

bool b_s(int target, int start, int end, int exclude)
{
    while (start <= end)
    {
        int mid = start + (end - start) / 2;
        if (k[mid] == target && mid != exclude)
        {
            return true;
        }
        else if (k[mid] < target)
        {
            start = mid + 1;
        }
        else
        {
            end = mid - 1;
        }
    }
    return false;
}

bool solve()
{
    sort(k, k + n);
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            int target = m - k[i] - k[j];
            if (b_s(target, 0, n - 1, i) || b_s(target, 0, n - 1, j))
            {
                return true;
            }
        }
    }
    return false;
}

int main()
{
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        cin >> k[i];
    }
    if (solve())
    {
        cout << "Yes" << endl;
    }
    else
    {
        cout << "No" << endl;
    }
    return 0;
}

```

但是不理解课本的内容，需要后期的你来帮忙了！！！！，这里将复杂度降到了`O(n^2log n)`

## 初级篇

说来惭愧，我到现在还是搞不太懂递归的思路。很多博主都说，只需要注重局部，不要深究递归。但是我还是做不到啊！！！

### 递归

递归，说白了就是自己执行自己，使用递归是为了清晰显示函数所执行的形式，这里用最基础的题目讲解（难的我也不会）

阶乘递推式：

```c++
#include<iostream>
using namespace std;

int fact(int n){
    //递归出口
    if(n == 0) return 1;
    //单个fact是提供*n的
    return n*fact(n-1);
}

int main()
{
    int n;
    cin>>n;
    cout<<fact(n)<<endl;
}
```

![image-20231028210454733](image-20231028210454733.png)

这里很好理解，单个fact是提供`*n`的，出口就是`*`到`1`为止。然后介绍递归界的`hello world`斐波那契数列。

```c++
void fib(int n){
    if(n<=1) return n;
    return fib(n-1)+fib(n-2);
}
```

这个函数计算效率很低，当n稍微大一点的时候，这个函数会产生指数级的子函数。

![image-20231028211853826](image-20231028211853826.png)

所以说我们可以用数组来进行优化，每一次计算的值都可以存储到我们的数组中，然后需要用的时候调用，这样只需要`O(1)`的时间。这里其实使用了动态规划的思想，存储我们方程造成的状态。

```c++
int memo[MAX];

int fib(int n){
    if(n<=1) return n;
    if(memo[n] != 0) return memo[n];
    return memo[n] = fib(n-1)+fib(n-2);
}
```

### 栈

很多人都说，用栈来理解递归是十分重要的，但是我还是不太理解。

![image-20231028213249065](image-20231028213249065.png)

栈的结构就是上图那么简单，在c++中，`stl`内置了`stack` 就是栈。

```c++
#include<iostream>
#include<stack>
using namespace std;

int main()
{
    stack<int> a;
    //塞入
    a.push(1);
    a.push(2);
    //弹出
    a.pop();
    //好像也没有什么操作了
    cout<<a.top()<<endl;
}
```

之前对这个栈的实现也写了一下介绍，{% post_link 基本数据结构 %}。这个栈就是后进先出。

### 队列

队列和栈差别就是他是双开门：
![image-20231028213817645](image-20231028213817645.png)

```c++
#include<iostream>
#include<queue>
using namespace std;


int main()
{
	queue<int> q;
	q.push(1);
	q.push(2);
	q.push(3);
	//这里出去的是1
	q.pop();
	return 0;

}
```

反正就是先进先出。

### 深度优先搜索

这个在讲图论的时候研究了一阵子，{% post_link 图论 用二叉树理解递归 %} 。这本书的理解也是使用二叉树来理解递归，简单来说，递归搜索其实就是暴力搜索，我们从第一个状态一步一步转移到我们的目标状态停止，这里其实就很符合我们递归的理念。

![image-20231028215048007](image-20231028215048007.png)

然后书本的例题是这个：

![image-20231028215111892](image-20231028215111892.png)

我们对数组a中的每一个数据进行这样的操作，制作两个分支来决定`a[i]`是否加入到我们最终的`sum`中，就是要么+要么不+嘛,最后判断的数据达到n就停止，输出所有对应的结果。这样的方法其实还有一个名字，叫做搜索（暴力搜索）

```c++
#include<iostream>
using namespace std;
const int Max = 1e5+10;
int a[Max];
int n,k;

bool dfs(int i,int sum){
    if(i == n) return sum == k;
    
    //不加上a[i]
    if(dfs(i+1,sum)) return true;
    //加上
    if(dfs(i+1,sum+a[i])) return true;
    //加上也不行
    return false;
}

void solve(){
    if(dfs(0,0)) puts("Yes");
    else puts("No");
}

int main()
{
    cin>>n>>k;
    for(int i = 0;i<n;i++) cin>>a[i];
    solve();
    
    
}
```

所以说搜索需要我们知道我们需要的运行结果，还有执行时候的状态。 （10.28）
