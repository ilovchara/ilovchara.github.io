---
title: 干爆算法竞赛
date: 2023-08-29 19:51:43
categories: 刷题
typora-root-url: ./干爆算法竞赛
---

# 每日一题

> 用于每日打卡练习

## 重复局面

![image-20230911151152344](image-20230911151152344.png)

思路其实很简单，我们需要找到每一个棋盘的样式是否出现过，棋盘的样式是用字符串数组的形式展示给我们看的：

![image-20230911151349825](image-20230911151349825.png)

只需要将这个输入的字符串映射为`数组的位置,再利用这个位置记录就行`。

```c++
#include<iostream>
#include<cstring>
#include<unordered_map>
using namespce std;

const int N = 110; // 限制的n为100
int n;
unordered_map<string,int> mp; // 将string映射为int
//简单理解就是，将这张地图换个名字

int main()
{
    scanf("%d\n",&n);
    
    for(int i = 1;i<=n;i++){ //处理每一张棋盘
        string x = "";
        for(int j = 1;j<=8;j++){ //将每一张棋盘都浓缩到一个字符串上
            string str;
            cin>>str;
            x+=str;
        }
        //mp这个容器，可以理解为你输入对应的字符串，返回来不同的整形数据给你
        mp[x]++;
        printf("%d\n",mp[x]);
    }
    return 0;    
}
```

> 重点是理解是位置的映射。还有hash表的运用

# 题组

> 这里是题组，用于巩固学过的知识点

## 排序

### 实现快速排序

题目大意如下：将读入的N个数据排序之后输出，要求使用快速排序

> 快速排序的思路是：每次执行从区间中找到一个基准数据。当左指针指向一个大于等于基准元素的元素，或右指针指向一个小于等于基准元素的元素时，停止移动。交换左指针和右指针所指向的元素，然后继续移动指针。
>
> 然后用分治法，将整体区间细分，执行上述操作，直到再也分不了为止。
>
> 下面是具体解释：
>
> 1. 选择一个基准元素（pivot）：从待排序的数组中选择一个元素作为基准。通常情况下，可以选择数组的第一个元素、最后一个元素、中间元素等。
> 2. 分区（Partition）：将数组中的元素分成两部分，左边的元素都小于等于基准元素，右边的元素都大于等于基准元素。这一过程可以通过双指针来实现，一个指针从数组的左端向右移动，一个指针从数组的右端向左移动，直到两个指针相遇。在移动过程中，交换不满足条件的元素，即左指针找到一个大于等于基准元素的元素，右指针找到一个小于等于基准元素的元素，然后交换它们。
> 3. 递归排序：分区操作将数组分成了两个子数组，左侧子数组和右侧子数组。然后，对这两个子数组分别递归地应用快速排序算法。重复这个过程，直到子数组的大小为1或0，此时它们已经有序。
> 4. 合并结果：当递归完成后，整个数组就变成了有序的。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int a[N];

void q_s(int q[],int l,int r){
    if(l>=r) return;
    int i = l-1,j = r+1,x=q[(l+r)>>1];
    
    while(i<j){
        //左边只能小于基准数据
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        //交换遍历到的第一个符合上面循环的值
        if(i<j) swap(q[i],q[j]);
    }
    //递归，对每一个区间都进行这样的操作
    q_s(q,l,j);
    q_s(q,j+1,r);
}


int main()
{
    int n;
    cin>>n;
    for(int i = 1;i<=n;i++) cin>>a[i];
    q_s(a,1,n);
    for(int i = 1;i<=n;i++) cout<<a[i]<<" ";
    return 0;
    
}
```

### 排序+去重

![image-20230911154629103](image-20230911154629103.png)

其实不用看题目，字面意思就是让我们排序+去重。可以使用桶排序对每一次出现的数据进行记录，将多次出现的数据剔除出去即可。

```c++
#include<iostream>
using namespace std;

int main()
{
    //创建一个桶数组 - 用于去除重复的数据
    bool book[1001] = {0};
    
    int n;
    int final = 0;
    
    cin>>n;
    int a[n];
    for(int i = 0;i<n;i++){
        //输入一个数据对其记录
        cin>>a[i];
      	//数据不重复长度为final
        if(book[a[i]] == 0) final++;
        //标记 - 反正只用输出一个就直接标记为1即可
        book[a[i]] = 1;
    }
    cout<<final<<endl;
    for(int i = 1;i<=1001;i++) //按照循序输出我们的值
    	if(book[i] == 1) cout<<i<<" ";
    return 0;
    
    
}
```

> 感觉就是hash映射
