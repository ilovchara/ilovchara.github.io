---
title: 干爆算法竞赛
date: 2023-08-29 19:51:43
categories: 刷题
typora-root-url: ./干爆算法竞赛
---

# 每日一题

> 用于每日打卡练习

## 重复局面

![image-20230911151152344](image-20230911151152344.png)

思路其实很简单，我们需要找到每一个棋盘的样式是否出现过，棋盘的样式是用字符串数组的形式展示给我们看的：

![image-20230911151349825](image-20230911151349825.png)

只需要将这个输入的字符串映射为`数组的位置,再利用这个位置记录就行`。

```c++
#include<iostream>
#include<cstring>
#include<unordered_map>
using namespce std;

const int N = 110; // 限制的n为100
int n;
unordered_map<string,int> mp; // 将string映射为int
//简单理解就是，将这张地图换个名字

int main()
{
    scanf("%d\n",&n);
    
    for(int i = 1;i<=n;i++){ //处理每一张棋盘
        string x = "";
        for(int j = 1;j<=8;j++){ //将每一张棋盘都浓缩到一个字符串上
            string str;
            cin>>str;
            x+=str;
        }
        //mp这个容器，可以理解为你输入对应的字符串，返回来不同的整形数据给你
        mp[x]++;
        printf("%d\n",mp[x]);
    }
    return 0;    
}
```

> 重点是理解是位置的映射。还有hash表的运用

## 重复山脉

![image-20230912103850213](image-20230912103850213.png)

题目意思就是：区间以中间为分界点，其两侧对应的数据差值的绝对值的加和，就是这个区间的不对称值。要求我们`1-n`每个区间的最小不堆成值。

> 这里的`n`约束的是区间的长度，而不是区间两端点的左右位置

如果用暴力：1.一层`n`约束延伸区间长度 2.一层`n`枚举约束区间长度的`区间` 3.一层`n`求取目标值。这样时间复杂度就达到了`o(n^3)` 下面是代码：

```c++
#include<iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;

const int N = 5010;

int n;
int h[N];
int num[N][N];
    
int main()
{
    scanf("%d",&n);
    //记录区间
    for(int i = 1;i<=n;i++) scanf("%d",&h[i]);
    
    printf("0 ");//区间长度为1的时候最小值就是0
    for(int len = 2;len<=n;len++){//枚举区间 - 长度（依靠长度约束区间）
        int ans = 0x3f3f3f3f;
        for(int i = 1;i+len-1<=n;i++){//枚举左端点 - 右端点？
            int l = i,r = i+len-1;
            int res = 0;
            // 作差，直到 l，r 指针相遇为止。 - 小寄巧
            while(l<r){
                res+=abs(h[l]-h[r]);// 计算这两个端点的不对称值。
                l++;
                r--;
            }
            ans = min(ans,res);
        }
        printf("%d ",ans);// 输出当前区间的最小不对称值
    }
    return 0;     
}
```

这种解法会`tle`所以用区间`dp`解决。

-----------------------

区间`dp`是什么:

```c++
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int h[5001],s[5001][5001],ans[5001];

int main()
{
    memset(ans,0x3f,sizeof ans);
    int n;
    cin>>n;
    for(int j = 1;j<=n;j++) cin>>h[j];
    
    for(int j = 2;j<=n;j++){ //限制区间活动范围
        for(int i = 1;i<=n-j+1;i++){//枚举区间端点位置
            //数组记录数据
            s[i][i+j-1] = abs(h[i+j-1]-h[i])+s[i+1][i+j-2];
            //当前约束长度最小值
            ans[j] = min(ans[j],s[i][i+j-1]);
        }
    }
    ans[1] = 0;
    for(int j = 1;j<=n;j++) cout<<ans[j]<<" ";    
    
}
```

> 需要补充的就是，怎么在限制枚举长度内，移动我们的区间。
>
> ```c++
>  for(int len = 2;len<=n;len++){//限制长度
>         int ans = 0x3f3f3f3f;
>         for(int i = 1;i+len-1<=n;i++){//枚举区间
>             int l = i,r = i+len-1;
>             int res = 0;
> ```

## 单词搜索

利用的是`dfs`的搜索,不过有点特殊，是图八个方向的搜索，需要搜索到符合我们单词序列的结果

![image-20230913125717789](image-20230913125717789.png)

需要记住的是八个方向的偏移量，同时可以将两个`dfs`封装在同一个函数中，然后用标识符区分两个`dfs`

```c++
#include<iostream>
#include<cstring>
using namespace std;

//枚举八个方向
//记录单词个数就比较简单
const int N = 110;
char s[N][N];
string w;
int n,m;
int res;

//竖直枚举
int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};
//斜边枚举
int ix[4] = {-1,-1,1,1},iy[4] = {-1,1,1,-1};

//f是标志服 - 用于选择枚举方向
//记录整个搜索完的转弯次数，用k表示
void dfs(int x,int y,int t,int f,int d,int k){
    if(t == w.size()-1 && k<2){
        res++;
        return;
    }
    if(f == -1){ //竖直方向搜索
        for(int i = 0;i<4;i++){
            int a = x+dx[i],b = y+dy[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(s[a][b] == w[t+1]){
                if(t!=0 && i!=d) dfs(a,b,t+1,-1,i,k+1);
                else dfs(a,b,t+1,-1,i,k);
            }
        }
    }
    if(f == 1){ //斜着
        for(int i = 0;i<4;i++){
            int a = x+ix[i],b = y+iy[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(s[a][b] == w[t+1]){
                if(t!=0&&i!=d) dfs(a,b,t+1,1,i,k+1);
                else dfs(a,b,t+1,1,i,k);
            }
        }
    }
    
    
}


int main()
{
    cin>>w;
    cin>>n>>m;
    
    for(int i = 0;i<n;i++)
        for(int j = 0;j<m;j++)
        cin>>s[i][j];
    
    for(int i = 0;i<n;i++)
        for(int j = 0;j<m;j++)
        if(s[i][j] == w[0]){ //两个枚举方向
            dfs(i,j,0,-1,0,0);
            dfs(i,j,0,1,0,0);
        }
    cout<<res<<endl;
    return 0;
    
    
}
```

```c++
//竖直枚举
int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};
//斜边枚举
int ix[4] = {-1,-1,1,1},iy[4] = {-1,1,1,-1};
```

> 难点是`dfs`的构造，分析其中的一个
>
> ```c++
>     if(f == -1){ //竖直方向搜索
>         for(int i = 0;i<4;i++){
>             int a = x+dx[i],b = y+dy[i];
>             if(a<0||a>=n||b<0||b>=m) continue;
>             if(s[a][b] == w[t+1]){
>                 if(t!=0 && i!=d) dfs(a,b,t+1,-1,i,k+1);
>                 else dfs(a,b,t+1,-1,i,k);
>             }
>         }
>     }
> ```
>
> `int a = x+dx[i],b = y+dy[i];`  这里是更新偏移的坐标，就是上下左右
>
> `if(a<0||a>=n||b<0||b>=m) continue;` 不在图内
>
> ![QQ截图20230822172559.png](19_eab4f2a940-QQ截图20230822172559.png)
>
> 拐弯：`if(s[a][b] == w[t+1]){
>                 if(t!=0 && i!=d) dfs(a,b,t+1,-1,i,k+1);
>                 else dfs(a,b,t+1,-1,i,k);
>             }`

# 题组

> 这里是题组，用于巩固学过的知识点

## 排序

### 实现快速排序

题目大意如下：将读入的N个数据排序之后输出，要求使用快速排序

> 快速排序的思路是：每次执行从区间中找到一个基准数据。当左指针指向一个大于等于基准元素的元素，或右指针指向一个小于等于基准元素的元素时，停止移动。交换左指针和右指针所指向的元素，然后继续移动指针。
>
> 然后用分治法，将整体区间细分，执行上述操作，直到再也分不了为止。
>
> 下面是具体解释：
>
> 1. 选择一个基准元素（pivot）：从待排序的数组中选择一个元素作为基准。通常情况下，可以选择数组的第一个元素、最后一个元素、中间元素等。
> 2. 分区（Partition）：将数组中的元素分成两部分，左边的元素都小于等于基准元素，右边的元素都大于等于基准元素。这一过程可以通过双指针来实现，一个指针从数组的左端向右移动，一个指针从数组的右端向左移动，直到两个指针相遇。在移动过程中，交换不满足条件的元素，即左指针找到一个大于等于基准元素的元素，右指针找到一个小于等于基准元素的元素，然后交换它们。
> 3. 递归排序：分区操作将数组分成了两个子数组，左侧子数组和右侧子数组。然后，对这两个子数组分别递归地应用快速排序算法。重复这个过程，直到子数组的大小为1或0，此时它们已经有序。
> 4. 合并结果：当递归完成后，整个数组就变成了有序的。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int a[N];

void q_s(int q[],int l,int r){
    if(l>=r) return;
    int i = l-1,j = r+1,x=q[(l+r)>>1];
    
    while(i<j){
        //左边只能小于基准数据
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        //交换遍历到的第一个符合上面循环的值
        if(i<j) swap(q[i],q[j]);
    }
    //递归，对每一个区间都进行这样的操作
    q_s(q,l,j);
    q_s(q,j+1,r);
}


int main()
{
    int n;
    cin>>n;
    for(int i = 1;i<=n;i++) cin>>a[i];
    q_s(a,1,n);
    for(int i = 1;i<=n;i++) cout<<a[i]<<" ";
    return 0;
    
}
```

### 排序+去重

![image-20230911154629103](image-20230911154629103.png)

其实不用看题目，字面意思就是让我们排序+去重。可以使用桶排序对每一次出现的数据进行记录，将多次出现的数据剔除出去即可。

```c++
#include<iostream>
using namespace std;

int main()
{
    //创建一个桶数组 - 用于去除重复的数据
    bool book[1001] = {0};
    
    int n;
    int final = 0;
    
    cin>>n;
    int a[n];
    for(int i = 0;i<n;i++){
        //输入一个数据对其记录
        cin>>a[i];
      	//数据不重复长度为final
        if(book[a[i]] == 0) final++;
        //标记 - 反正只用输出一个就直接标记为1即可
        book[a[i]] = 1;
    }
    cout<<final<<endl;
    for(int i = 1;i<=1001;i++) //按照循序输出我们的值
    	if(book[i] == 1) cout<<i<<" ";
    return 0;
    
    
}
```

> 感觉就是hash映射
