---
title: 干爆算法竞赛
date: 2023-08-29 19:51:43
categories: 刷题
tags: 刷题
typora-root-url: ./干爆算法竞赛
---

# 每日一题

> 用于每日打卡练习

## 重复局面

![image-20230911151152344](image-20230911151152344.png)

思路其实很简单，我们需要找到每一个棋盘的样式是否出现过，棋盘的样式是用字符串数组的形式展示给我们看的：

![image-20230911151349825](image-20230911151349825.png)

只需要将这个输入的字符串映射为`数组的位置,再利用这个位置记录就行`。

```c++
#include<iostream>
#include<cstring>
#include<unordered_map>
using namespce std;

const int N = 110; // 限制的n为100
int n;
unordered_map<string,int> mp; // 将string映射为int
//简单理解就是，将这张地图换个名字

int main()
{
    scanf("%d\n",&n);
    
    for(int i = 1;i<=n;i++){ //处理每一张棋盘
        string x = "";
        for(int j = 1;j<=8;j++){ //将每一张棋盘都浓缩到一个字符串上
            string str;
            cin>>str;
            x+=str;
        }
        //mp这个容器，可以理解为你输入对应的字符串，返回来不同的整形数据给你
        mp[x]++;
        printf("%d\n",mp[x]);
    }
    return 0;    
}
```

> 重点是理解是位置的映射。还有hash表的运用

## 重复山脉

![image-20230912103850213](image-20230912103850213.png)

题目意思就是：区间以中间为分界点，其两侧对应的数据差值的绝对值的加和，就是这个区间的不对称值。要求我们`1-n`每个区间的最小不堆成值。

> 这里的`n`约束的是区间的长度，而不是区间两端点的左右位置

如果用暴力：1.一层`n`约束延伸区间长度 2.一层`n`枚举约束区间长度的`区间` 3.一层`n`求取目标值。这样时间复杂度就达到了`o(n^3)` 下面是代码：

```c++
#include<iostream>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <cmath>
using namespace std;

const int N = 5010;

int n;
int h[N];
int num[N][N];
    
int main()
{
    scanf("%d",&n);
    //记录区间
    for(int i = 1;i<=n;i++) scanf("%d",&h[i]);
    
    printf("0 ");//区间长度为1的时候最小值就是0
    for(int len = 2;len<=n;len++){//枚举区间 - 长度（依靠长度约束区间）
        int ans = 0x3f3f3f3f;
        for(int i = 1;i+len-1<=n;i++){//枚举左端点 - 右端点？
            int l = i,r = i+len-1;
            int res = 0;
            // 作差，直到 l，r 指针相遇为止。 - 小寄巧
            while(l<r){
                res+=abs(h[l]-h[r]);// 计算这两个端点的不对称值。
                l++;
                r--;
            }
            ans = min(ans,res);
        }
        printf("%d ",ans);// 输出当前区间的最小不对称值
    }
    return 0;     
}
```

这种解法会`tle`所以用区间`dp`解决。

-----------------------

区间`dp`是什么:

```c++
#include<iostream>
#include<cmath>
#include<cstring>
using namespace std;
int h[5001],s[5001][5001],ans[5001];

int main()
{
    memset(ans,0x3f,sizeof ans);
    int n;
    cin>>n;
    for(int j = 1;j<=n;j++) cin>>h[j];
    
    for(int j = 2;j<=n;j++){ //限制区间活动范围
        for(int i = 1;i<=n-j+1;i++){//枚举区间端点位置
            //数组记录数据
            s[i][i+j-1] = abs(h[i+j-1]-h[i])+s[i+1][i+j-2];
            //当前约束长度最小值
            ans[j] = min(ans[j],s[i][i+j-1]);
        }
    }
    ans[1] = 0;
    for(int j = 1;j<=n;j++) cout<<ans[j]<<" ";    
    
}
```

> 需要补充的就是，怎么在限制枚举长度内，移动我们的区间。
>
> ```c++
>  for(int len = 2;len<=n;len++){//限制长度
>         int ans = 0x3f3f3f3f;
>         for(int i = 1;i+len-1<=n;i++){//枚举区间
>             int l = i,r = i+len-1;
>             int res = 0;
> ```

## 单词搜索

利用的是`dfs`的搜索,不过有点特殊，是图八个方向的搜索，需要搜索到符合我们单词序列的结果

![image-20230913125717789](image-20230913125717789.png)

需要记住的是八个方向的偏移量，同时可以将两个`dfs`封装在同一个函数中，然后用标识符区分两个`dfs`

```c++
#include<iostream>
#include<cstring>
using namespace std;

//枚举八个方向
//记录单词个数就比较简单
const int N = 110;
char s[N][N];
string w;
int n,m;
int res;

//竖直枚举
int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};
//斜边枚举
int ix[4] = {-1,-1,1,1},iy[4] = {-1,1,1,-1};

//f是标志服 - 用于选择枚举方向
//记录整个搜索完的转弯次数，用k表示
void dfs(int x,int y,int t,int f,int d,int k){
    if(t == w.size()-1 && k<2){
        res++;
        return;
    }
    if(f == -1){ //竖直方向搜索
        for(int i = 0;i<4;i++){
            int a = x+dx[i],b = y+dy[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(s[a][b] == w[t+1]){
                if(t!=0 && i!=d) dfs(a,b,t+1,-1,i,k+1);
                else dfs(a,b,t+1,-1,i,k);
            }
        }
    }
    if(f == 1){ //斜着
        for(int i = 0;i<4;i++){
            int a = x+ix[i],b = y+iy[i];
            if(a<0||a>=n||b<0||b>=m) continue;
            if(s[a][b] == w[t+1]){
                if(t!=0&&i!=d) dfs(a,b,t+1,1,i,k+1);
                else dfs(a,b,t+1,1,i,k);
            }
        }
    }
    
    
}


int main()
{
    cin>>w;
    cin>>n>>m;
    
    for(int i = 0;i<n;i++)
        for(int j = 0;j<m;j++)
        cin>>s[i][j];
    
    for(int i = 0;i<n;i++)
        for(int j = 0;j<m;j++)
        if(s[i][j] == w[0]){ //两个枚举方向
            dfs(i,j,0,-1,0,0);
            dfs(i,j,0,1,0,0);
        }
    cout<<res<<endl;
    return 0;
    
    
}
```

```c++
//竖直枚举
int dx[4] = {-1,0,1,0},dy[4] = {0,1,0,-1};
//斜边枚举
int ix[4] = {-1,-1,1,1},iy[4] = {-1,1,1,-1};
```

> 难点是`dfs`的构造，分析其中的一个
>
> ```c++
>     if(f == -1){ //竖直方向搜索
>         for(int i = 0;i<4;i++){
>             int a = x+dx[i],b = y+dy[i];
>             if(a<0||a>=n||b<0||b>=m) continue;
>             if(s[a][b] == w[t+1]){
>                 if(t!=0 && i!=d) dfs(a,b,t+1,-1,i,k+1);
>                 else dfs(a,b,t+1,-1,i,k);
>             }
>         }
>     }
> ```
>
> `int a = x+dx[i],b = y+dy[i];`  这里是更新偏移的坐标，就是上下左右
>
> `if(a<0||a>=n||b<0||b>=m) continue;` 不在图内
>
> ![QQ截图20230822172559.png](19_eab4f2a940-QQ截图20230822172559.png)
>
> 拐弯：`if(s[a][b] == w[t+1]){
>                 if(t!=0 && i!=d) dfs(a,b,t+1,-1,i,k+1);
>                 else dfs(a,b,t+1,-1,i,k);
>             }`

## 耕田计划

![image-20230914110029178](image-20230914110029178.png)

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int n,k,total,maxx; // 最大天数限制
int m[N];
//贪心的思路
//思路就是拿资源往最大天数的地方砸 - 然后到资源为0的时候结果就出来了

int main()
{
    //桶数组记录我们的区域耕地天数
    cin>>n>>total>>k;
    for(int i = 0;i<n;i++){
        int t,c;
        cin>>t>>c;
        m[t]+=c;
        maxx = max(maxx,t);
    }
    
    //从最大天速来找
    for(int i = maxx;i>=k;i--){
        //如果投入不够，最终答案输出
        if(total<m[i]){
            cout<<i<<endl;
            return 0;
        }
        total-=m[i];
        //天数为i的 - 用资源变为 i-1
        m[i-1] +=m[i];
        
    }
    cout<<k<<endl;
    return 0;
    
}
```

> 主要思路就是，逆最短板问题。只和最大天数有关，用贪心算法解题即可。
>
> 当然也可以用二分

------------

```c++
#include <iostream>
#include <algorithm>
#include <cstring>
#define x first
#define y second 

using namespace std;

const int N = 1e5 + 10;

typedef long long LL;
typedef pair<int, int> PII;

PII f[N];
int n, k;
LL m;

bool check(int mid)
{
    LL sum = 0;
    for (int i = 0; i < n; i ++)
    {
        if (mid >= f[i].x) continue;
        sum += f[i].y * (f[i].x - mid);
    }

    if (sum > m) return false;
    else return true;
}

int main()
{
    cin >> n >> m >> k;

    int r = 0;
    for (int i = 0; i < n; i ++) 
    {
        int t, c;
        cin >> t >> c;
        if (t > r) r = t;
        f[i] = {t, c};
    }

    int l = k;
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    cout << l << endl;

    return 0;
}
```

## 二进制

![image-20230915204707943](image-20230915204707943.png)

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
#include<cstdio>
using namespace std;

const int N = 1e6+10,mod = 1e6+3;
int n,k;
int q[N],s[N];
long long fact[N],infact[N];
long long qmi(long long a,long long k,long long p){
    long long res = 1;
    while(k){
        if(k&1) res = res*a%p;
        k>>=1;
        a = a*a%p;
    }
    return res;
}

void init()
{
    fact[0] = infact[0] = 1;
    for(int i = 1;i<N;i++){
        fact[i] = fact[i-1]*i%mod;
        infact[i] = infact[i-1]*qmi(i,mod-2,mod)%mod;
    }
}
//逆元求组合数
long long C(long long a,long long b){
    return fact[a]*infact[b]%mod*infact[a-b]%mod;
}

int main()
{
    init();
    scanf("%d%d",&n,&k);
    for(int i = 1;i<=n-k+1;i++) scanf("%d",&q[i]);
    memset(s,-1,sizeof s);
    for(int i = 1;i<=n-k;i++){
        if(q[i]>q[i+1]){
            s[i] = 1;
            s[i+k] = 0;
        }else if(q[i]<q[i+1]){
            s[i] = 0;
            s[i+k] = 1;
        }
    }
    
    for(int i = n;i>=k+1;i--){
        if(s[i]!=-1&&s[i-k] == -1) s[i-k] = s[i];
    }
    
    int a = 0,b = 0;
    for(int i = 1;i<=k;i++){
        if(s[i] == -1) a++;
        else if(s[i] == 1) b++;
    }
    b = q[1]-b;
    printf("%d\n",C(a,b));
    return 0;
    
    
    
    
}

```

> 逆元 - 组合数 - 二进制 - 难不会

# 题组

> 这里是题组，用于巩固学过的知识点

## 排序

### 实现快速排序

题目大意如下：将读入的N个数据排序之后输出，要求使用快速排序

> 快速排序的思路是：每次执行从区间中找到一个基准数据。当左指针指向一个大于等于基准元素的元素，或右指针指向一个小于等于基准元素的元素时，停止移动。交换左指针和右指针所指向的元素，然后继续移动指针。
>
> 然后用分治法，将整体区间细分，执行上述操作，直到再也分不了为止。
>
> 下面是具体解释：
>
> 1. 选择一个基准元素（pivot）：从待排序的数组中选择一个元素作为基准。通常情况下，可以选择数组的第一个元素、最后一个元素、中间元素等。
> 2. 分区（Partition）：将数组中的元素分成两部分，左边的元素都小于等于基准元素，右边的元素都大于等于基准元素。这一过程可以通过双指针来实现，一个指针从数组的左端向右移动，一个指针从数组的右端向左移动，直到两个指针相遇。在移动过程中，交换不满足条件的元素，即左指针找到一个大于等于基准元素的元素，右指针找到一个小于等于基准元素的元素，然后交换它们。
> 3. 递归排序：分区操作将数组分成了两个子数组，左侧子数组和右侧子数组。然后，对这两个子数组分别递归地应用快速排序算法。重复这个过程，直到子数组的大小为1或0，此时它们已经有序。
> 4. 合并结果：当递归完成后，整个数组就变成了有序的。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int a[N];

void q_s(int q[],int l,int r){
    if(l>=r) return;
    int i = l-1,j = r+1,x=q[(l+r)>>1];
    
    while(i<j){
        //左边只能小于基准数据
        do i++;while(q[i]<x);
        do j--;while(q[j]>x);
        //交换遍历到的第一个符合上面循环的值
        if(i<j) swap(q[i],q[j]);
    }
    //递归，对每一个区间都进行这样的操作
    q_s(q,l,j);
    q_s(q,j+1,r);
}


int main()
{
    int n;
    cin>>n;
    for(int i = 1;i<=n;i++) cin>>a[i];
    q_s(a,1,n);
    for(int i = 1;i<=n;i++) cout<<a[i]<<" ";
    return 0;
    
}
```

### 排序+去重

![image-20230911154629103](image-20230911154629103.png)

其实不用看题目，字面意思就是让我们排序+去重。可以使用桶排序对每一次出现的数据进行记录，将多次出现的数据剔除出去即可。

```c++
#include<iostream>
using namespace std;

int main()
{
    //创建一个桶数组 - 用于去除重复的数据
    bool book[1001] = {0};
    
    int n;
    int final = 0;
    
    cin>>n;
    int a[n];
    for(int i = 0;i<n;i++){
        //输入一个数据对其记录
        cin>>a[i];
      	//数据不重复长度为final
        if(book[a[i]] == 0) final++;
        //标记 - 反正只用输出一个就直接标记为1即可
        book[a[i]] = 1;
    }
    cout<<final<<endl;
    for(int i = 1;i<=1001;i++) //按照循序输出我们的值
    	if(book[i] == 1) cout<<i<<" ";
    return 0;
    
    
}
```

> 感觉就是hash映射

## 递归

### 八皇后问题

![image-20230913224836419](image-20230913224836419.png)

```c++
#include<iostream>
#include<cstdio>
using namespace std;

//只需要输出三个样例
int ans[14],check[3][28]={0},sum=0,n;

//当前行放置皇后
void eq(int line){
    //输出出口
    if(line>n){
        sum++;
        if(sum>3) return;
        else{
            for(int i = 1;i<=n;i++) printf("%d ",ans[i]);
            printf("\n");
            return;
        }
    }
    
    for(int i = 1;i<=n;i++){
        //不同行 - 不同对角线 - 不同列
        if((!check[0][i]) && (!check[1][line+i])&&(!check[2][line-i+n]))
        {
            //不太懂这个dfs的运行原理 - 要用文章补充
            ans[line] = i;
            check[0][i] = 1;check[1][line+i]=1;check[2][line-i+n] = 1;
            eq(line+1);
            check[0][i] = 0;check[1][line+i] = 0;check[2][line-i+n] = 0;
        }
    }
    
}


int main()
{
    scanf("%d",&n);
    eq(1);
    printf("%d",sum);
    return 0;
}

```

> 枚举八个方向：八皇后模版
>
> ```c++
> #include <iostream>
> using namespace std;
> const int N = 20;
> int idx, ans[100]; // idx 相当于静态链表里的idx
> char path[8]; //临时储存答案
> bool col[N], dg[N], udg[N]; //列，正对角线，副对角线
> 
> void dfs(int u)
> {
>     //和一般dfs一样，u == 8时结束递归，并记录答案。
>     if (u == 8)
>     {
>         ans[++idx] = atoi(path); //将path转成int类型，并放进ans中
>         return;
>     }
>     for (int i = 0; i < 8; i++)
>         if (!col[i] && !dg[u + i] && !udg[8 - u + i]) //判断第u个皇后，第i + 1列这个点是否可以放
>         {
>             path[u] = i + 1 + '0'; //记录第u个皇后所在列，char类型，必须加'0'
>             col[i] = dg[u + i] = udg[8 - u + i] = true; //修改该点所在列以及对角线
>             dfs(u + 1); //继续递归寻找第 + 1个皇后所处的列
>             col[i] = dg[u + i] = udg[8 - u + i] = false; //回溯
>         }
> }
> 
> int main()
> {
>     dfs(0);
>     int m;
>     cin >> m;
>     while (m--)
>     {
>         int x;
>         cin >> x;
>         cout << ans[x] << endl;
>     }
>     return 0;
> }
> ```
>
> 

### 油滴拓展

![image-20230913201801481](image-20230913201801481.png)

```c++
#include<iostream>
#include<algorithm>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;

const int maxn = 10;
const double PI = 3.1415926535;
bool s[maxn];
//图的坐标？
double x[maxn],y[maxn],r[maxn],xa,ya,xb,yb,ansmax;
int n;

//由于油模碰撞到边界就会停止，只需要知道那个点到边界的最短距离就是半径
//在第一个油模之后，还需要计算点到隔壁油模的最短距离
double cal(int i)
{
    double s1 = min(abs(x[i]-xa),abs(x[i]-xb));
    double s2 = min(abs(y[i]-ya),abs(y[i]-yb));
    double ans = min(s1,s2);
    for(int j = 1;j<=n;j++)
        if(i!=j&&s[j]){
            //勾股定理求解半径
            double d = sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));
            //油模测算
            ans = min(ans,max(d-r[j],0.0));
        }
        return ans;
}

void dfs(int k,double sum){
    if(k>n){
        ansmax = max(ansmax,sum);
        return;
    }
    for(int i = 1;i<=n;i++){
        if(!s[i]){
            r[i] = cal(i);
            //油模延伸的地方标记
            s[i] = 1;
            dfs(k+1,sum+r[i]*r[i]*PI);
            s[i] = 0;
        }
    }
}

int main()
{
    double ss;
    scanf("%d",&n);
    scanf("%lf%lf%lf%lf",&xa,&ya,&xb,&yb);
    ss = abs(xa-xb)*abs(ya-yb);
    for(int i = 1;i<=n;i++)
        scanf("%lf%lf",&x[i],&y[i]);
    dfs(1,0);
    printf("%d",int(ss-ansmax+0.5));
    return 0;
    
    
}
```

