---
title: 数据结构 - 基础算法介绍
date: 2023-04-26 08:20:07
description: 介绍一下基础的算法类型，刚搞好博客的时候做的，供自己参考
categories: 算法
typora-root-url: 基础算法介绍
---

## 基础算法

## 时间复杂度和空间复杂度的基本估计

![时间复杂度](时间复杂度.png)

## 基本算法思想说明

下面简单介绍一下各种算法的思想，每个思想都会举一个例题包括一个模版，并不会太仔细。本文以算法竞赛入门指南和大佬的博客作为参考。**标注：只看不练是傻蛋**

### [枚举](https://algo.itcharge.cn/09.Algorithm-Base/01.Enumeration-Algorithm/01.Enumeration-Algorithm/)

**枚举算法（Enumeration Algorithm）**：也称为穷举算法，指的是按照问题本身的性质，一一列举出该问题所有可能的解，并在逐一列举的过程中，将它们逐一与目标状态进行比较以得出满足问题要求的解。在列举的过程中，既不能遗漏也不能重复。

由于枚举算法要通过列举问题的所有状态来得到满足条件的解，因此，在问题规模变大时，其效率一般是比较低的。但是枚举算法也有自己特有的优点：

1. 多数情况下容易编程实现，也容易调试。

2. 建立在考察大量状态、甚至是穷举所有状态的基础上，所以算法的正确性比较容易证明。

   > 所以，枚举算法通常用于求解问题规模比较小的问题，或者作为求解问题的一个子算法出现，通过枚举一些信息并进行保存，而这些消息的有无对主算法效率的高低有着较大影响。

枚举思想说直白点就是暴力解题法，将所有的情况枚举出来，取得我们需要的结果即可。但是枚举也是需要技巧的，我们在运用的时候需要控制枚举的范围，可以节省一些时间。

下面用一道题说明枚举算法：

**案例：[百鸡问题](https://blog.csdn.net/xinzhilinger/article/details/109266058)**

> 有鸡翁一，值钱伍；鸡母一，值钱三；鸡鶵三，值钱一。凡百钱买鸡百只，问鸡翁、母、鶵各几何？

**对本问题分析，三种鸡的数量关系满足：**

```c++
nub（公鸡）+nub（母鸡）+nub（小鸡）=100
nub（公鸡）* 5+nub（母鸡）* 3+nub（小鸡）=100
```

按照中学的逻辑，两个方程无法求出三个变量。但在程序中，我们可以对一个变量进行约束，去改变另外两个变量的值，来达到我们求出另外两个变量的结果。下面是具体的程序。

> 三个变量只有两个公式如何求解呢，这个时候只能固定一个变量，然后求另外两个变量，枚举法就是基于这样的思想，对于所有可能性进行遍历

```c++
#include<iostream>
using namespace std;

void GetC()
{
 int n,m,k; //公鸡 - 母鸡 - 小鸡 
 //公鸡上限20 因为 20*5 = 100 - 这里体现了枚举的有穷性
 for(n = 0;n<=20;n++)
 //母鸡上限33 
  for(m = 0;m<=33;m++){
   k = 100-n-m;
   //有一种符合输出一种 
   if(n*15+9*m+k*1==300) cout<<n<<" "<<m<<" "<<k<<endl; 
  }
 } 


int main()
{
 //目的求出三种鸡的个数
 GetC();
 return 0; 
 } 
```

> 枚举是没有规律的情况下来使用，所以就很难来推算什么情况来使用是合适的，不过总的来说，枚举还是适用于那些量级比较小的，循环使用痕迹比较重的情况

### [模拟](https://juejin.cn/post/6961403096085823501)

说白了 模拟题就是应用题 给出一个项目让你实现它，写模拟题时，遵循以下的建议有可能会提升做题速度：

> 在动手写代码之前，在草纸上尽可能地写好要实现的流程。
> 在代码中，尽量把每个部分模块化，写成函数、结构体或类。
> 对于一些可能重复用到的概念，可以统一转化，方便处理：如，某题给你 "YY-MM-DD 时：分" 把它抽取到一个函数，处理成秒，会减少概念混淆。
> 调试时分块调试。模块化的好处就是可以方便的单独调某一部分。
> 写代码的时候一定要思路清晰，不要想到什么写什么，要按照落在纸上的步骤写。

下面用一道题说明模拟：

**案例：Z字形变换**

```js
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。

比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下：

P   A   H   N
A P L S I I G
Y   I   R
之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。

请你实现这个将字符串进行指定行数变换的函数：

string convert(string s, int numRows);
```

这道题目是非常典型的模拟算法题，介绍内容给到我们：输入、转变的条件、期待的结果，甚至连解题的思路都给我们提供了。不信？我们来看看：

> 输入是一个字符串和一个行数，从上往下排列。
>
> 到了尾行时进行翻转，从左到右斜向上排列，到了顶行时再次翻转，再从上往下排列。
>
> 重复过程2，到了字符串尾部时，结束翻转。

按照整理完成的思路实现代码即可

```c++
#include <iostream>
#include <vector>
#include <string>
using namespace std; 
string convert(string s, int numRows) {
    //只有一列 - 输出
    if (numRows == 1) {
        return s;
    }
 //翻转的规律
    int roundNum = 2 * (numRows - 1);
    //标注当前行，flag标注移动方向
    int nowRow = 0;
    bool flag = true;
    // 声明一个长度为行数的字符串数组，用于存储每一行的字符
    vector<string> finalArr(numRows, "");

    for (int i = 0; i < s.length(); i++) {
        // 当到首行时，翻转flag，从上往下排列
        if (i % roundNum == 0) {
            flag = true;
        }
        // 当到尾行时，翻转flag，从下往上排列
        if (i % roundNum == numRows - 1) {
            flag = false;
        }
   // 把对应的行的内容填充到行数组中
        finalArr[nowRow] += s[i];
        // 行数根据flag进行上移或下移
        nowRow = flag ? (nowRow + 1) : (nowRow - 1);
    }
 // 将行数组中的字符串拼接后返回
    string result;
    for (const string& row : finalArr) {
        result += row;
    }
    return result;
}

int main() {
    string s = "PAYPALISHIRING";
    int numRows = 3;
    string converted = convert(s, numRows);
    cout << converted << endl;
    return 0;
}
 
```

这里是大佬给的解释，建议直接点标题看一下大佬的解析

![image-20230826215420723](image-20230826215420723-1693058064666-1.png)

### [递归](https://zhuanlan.zhihu.com/p/635141199)

递归是一种编程技术，它通过在函数内部反复调用自身来解决问题。当一个程序调用自己时，这就称为递归调用。递归可以有助于简化某些算法的实现和理解。在递归过程中，每个调用都会将一些数据保存在栈上，直到递归结束后才能被处理并弹出栈。

递归通常有两个部分：基本情况和递归情况。基本情况是在函数执行之前判断是否需要递归，如果不需要，则直接返回结果。递归情况是函数需要递归时，它会调用自身，但是传入的参数通常会有所不同，以便最终能够达到基本情况而结束递归。

虽然递归可以使代码更加简洁，但是需要注意的是，在一些情况下，它可能会导致性能问题或者栈溢出等问题。因此，在编写递归代码时，需要仔细考虑算法的边界条件和递归深度等因素。

**递归函数**

递归函数是一种函数，它在其定义中调用自身。通常情况下，递归函数包含两个部分：基本情况和递归情况。

基本情况是指在递归函数中需要判断是否需要终止递归的条件。当满足这个条件时，递归就会停止。

递归情况是指在递归函数中需要调用自身的情况。在每次调用时，函数的参数都应该有所不同，以便最终能够达到基本情况而停止递归。

递归函数通常用于处理树形结构、图形结构或其他类型的嵌套结构数据。例如，在二叉树中查找某一个值，就可以使用递归函数来实现。

下面用一道题说明递归：

**案例：斐波那契数列**

斐波那契数列是一个经典的数学问题，由0和1开始，之后的每一项都是其前面两项的和。也就是说，斐波那契数列的前几个数是：0、1、1、2、3、5、8、13、21、34……依次类推。

斐波那契数列在自然界中有很多应用，比如植物的叶子排列、蜂窝的构造等等。除此之外，在计算机科学领域内，斐波那契数列也有着广泛的应用，例如在排序算法、密码学等领域。

斐波那契数列的通项公式是：F(n) = F(n-1) + F(n-2)，其中F(0)=0，F(1)=1。根据这个公式可以使用递归函数或循环语句来实现求斐波那契数列的第n项。

```c++
//实现斐波那契数列
int fbnq(int n){
    if(n==0) return 0;
    else if(n==1) return 1;
    
    return fbnq(n-1)+fbnq(n-2);
}
```

### [贪心](https://imzhanghao.com/2020/04/15/5-classic-algorithms-2-greedy-algorithm/)

运用贪心算法求解问题时，会将问题分为若干个子问题，可以将其想象成俄罗斯套娃，利用贪心的原则从内向外依次求出当前子问题的最优解，也就是该算法不会直接从整体考虑问题，而是想要达到局部最优。只有内部的子问题求得最优解，才能继续解决包含该子问题的下一个子问题，所以前一个子问题的最优解会是下一个子问题最优解的一部分，重复这个操作直到堆叠出该问题的最优解。

贪心算法最关键的部分在于贪心策略的选择，贪心选择的意思是对于所求问题的整体最优解可以通过一系列的局部最优选择求得。而必须注意的是，贪心选择必须具备无后效性，也就是某个状态不会影响之前求得的局部最优解。

运动贪心算法解决相应问题时会比较简单和高效，省去了寻找全局最优解很多不必要的穷举操作，由于贪心算法问题并没有固定的贪心策略，所以唯一的难点就是找到带求解问题的贪心策略，但毕竟熟能生巧嘛，算法的基本思想总是固定不变的。

下面用一道题说明贪心：

**案例：活动时间安排问题**

设有n个活动的集合`E={1, 2, …, n}`，其中，每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。

每个活动i都有一个要求使用该资源的起始时间`si`和一个结束时间`fi`，且`si < fi`。如果选择了活动i，则它在半开时间区间`[si, fi)`内占用资源。若区间`[si, fi)`与区间`[sj, fj)`不相交，则称活动i与活动j是相容的。也就是说，当 `si ≥ fj`或 `sj ≥ fi` 时，活动 i 与活动 j 相容。

活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。

![活动时间安排问题](活动时间安排问题.jpg)

上图为每个活动的开始和结束时间，我们的任务就是设计程序输出哪些活动可以占用会议室！

**求解思路**
将活动按照结束时间进行从小到大排序。然后用i代表第i个活动，s[i]代表第i个活动开始时间，f[i]代表第i个活动的结束时间。按照从小到大排序，挑选出结束时间尽量早的活动，并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。事实上系统一次检查活动i是否与当前已选择的所有活动相容。若相容活动i加入已选择活动的集合中，否则，不选择活动i，而继续下一活动与集合A中活动的相容性。若活动i与之相容，则i成为最近加入集合A的活动，并取代活动j的位置。

下面给出求解活动安排问题的贪心算法，各活动的起始时间和结束时间存储于数组s和f中，且按结束时间的非减序排列。如果所给的活动未按此序排列，可以用O(nlogn)的时间重排。

```c++
#include <iostream>
using namespace std;

void GreedyChoose(int len,int *s,int *f,bool *flag);

int main(int argc, char* argv[]) {
  int s[11] ={1,3,0,5,3,5,6,8,8,2,12};
  int f[11] ={4,5,6,7,8,9,10,11,12,13,14};

  bool mark[11] = {0};

  GreedyChoose(11,s,f,mark);
  for(int i=0;i<11;i++)
    if (mark[i])
      cout<<i<<" ";
  system("pause");
  return 0;
}

void GreedyChoose(int len,int *s,int *f,bool *flag) {
  flag[0] = true;
  int j = 0;
  for(int i=1;i<len;++i)
    if (s[i] >= f[j]) {
      flag[i] = true;
      j = i;
    }
}
```

### [排序](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

#### 排序的时间复杂度分析

![sort](sort.png)

![排序数据比较](排序数据比较.png)

#### 冒泡排序操作

![冒泡排序](冒泡排序.gif)

```c++
/*冒泡排序
 冒泡排序的时间复杂度是 o(n^2),这个复杂度是由冒泡排序的操作约束的。冒泡排序的原理是，选择我们序列中的一个值，对其进行这样的操作：
 -将当前这个值和下一个数据对比，如果当前这个值大于下一个数据，交换；否则，下一个值作为新的交换值代替之前的值执行交换程序。直到最后，没有数据进行比对，退出程序。
*/
// 菜鸟 - 比较相邻的元素。如果第一个比第二个大，就交换他们两个。对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
    
//代码    
#include <iostream>
using namespace std;
template<typename T> //整数或浮点数皆可使用,若要使用类(class)或结构体(struct)时必须重载大于(>)运算符
void bubble_sort(T arr[], int len) {
        int i, j;
        for (i = 0; i < len - 1; i++)
                for (j = 0; j < len - 1 - i; j++)
                        if (arr[j] > arr[j + 1])
                                swap(arr[j], arr[j + 1]);
}
int main() {
        int arr[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };
        int len = (int) sizeof(arr) / sizeof(*arr);
        bubble_sort(arr, len);
        for (int i = 0; i < len; i++)
                cout << arr[i] << ' ';
        cout << endl;
        float arrf[] = { 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 };
        len = (float) sizeof(arrf) / sizeof(*arrf);
        bubble_sort(arrf, len);
        for (int i = 0; i < len; i++)
                cout << arrf[i] << ' '<<endl;
        return 0;
}    
```

#### 选择排序操作

![选择排序](selectionSort.gif)

```c++
//选择排序的时间复杂度是o(n^2) - 是因为选择排序需要进行 n-1 轮比较，每轮比较需要比较 n-i 次，所以总共需要比较 (n-1) + (n-2) + … + 1 = n(n-1)/2 次，因此时间复杂度为 O(n²)。

/* 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置。再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。就是每次选中一个未排序序列的起点，然后在未排序序列中，找到一个“最小值”直到遍历完区间之后，将其标记未排序序列（区间缩小），重复直到全为排序区间，退出程序。*/
    
//代码
template<typename T> //整數或浮點數皆可使用，若要使用物件（class）時必須設定大於（>）的運算子功能
void selection_sort(std::vector<T>& arr) {
        for (int i = 0; i < arr.size() - 1; i++) {
                int min = i;
                for (int j = i + 1; j < arr.size(); j++)
                        if (arr[j] < arr[min])
                                min = j;
                std::swap(arr[i], arr[min]);
        }
}     
```

#### 插入排序操作

![插入排序](insertionSort.gif)

```c++
//插入排序的复杂度是 o(n^2) 每一个数据最多要比较（n-1)次，所以说n*(n-1) = n^2

 /*将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）
 它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。*/
        
//和打扑克牌是一个道理，开始的时候我们只有一张牌（假设），我们将这张牌当做一个有序序列，每次加入新的牌的时候和有序序列进行比较插入，按照插入的规则（从小到大 还是 从大到小）进行判断插入。（感觉就是和选择排序是相反的，从无序中抽数据和有序序列进行比对）

//代码
void insertion_sort(int arr[],int len){
        for(int i=1;i<len;i++){
                int key=arr[i];
                int j=i-1;
                while((j>=0) && (key<arr[j])){
                        arr[j+1]=arr[j];
                        j--;
                }
                arr[j+1]=key;
        }
}
```

#### [希尔排序操作](https://blog.csdn.net/qq_43473694/article/details/112197066)

![希尔排序](Sorting_shellsort_anim.gif)

```c++
//希尔排序的时间复杂度是：O(n^1.3） 在最坏情况之下是o(n^2) - 因为是基于插入排序
 /*希尔排序：先追求部分元素有序，然后逼近全局有序！希尔排序是基于插入排序的以下两点性质而提出改进方法的：
 - 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；
 - 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；
 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；按增量序列个数 k，对序列进行 k 趟排序；每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。*/
        
//代码
template<typename T>
void shell_sort(T array[], int length) {
    int h = 1;
    while (h < length / 3) {
        h = 3 * h + 1;
    }
    while (h >= 1) {
        for (int i = h; i < length; i++) {
            for (int j = i; j >= h && array[j] < array[j - h]; j -= h) {
                std::swap(array[j], array[j - h]);
            }
        }
        h = h / 3;
    }
}   
```

#### 归并排序

![归并排序](mergeSort.gif)

```c++
/*
 归并排序的时间复杂度是 o(log n),归并排序的算法思想是：分治法。 将大问题分解成许多的子问题，在将子问题合并成为我们的大问题
 
 实现方法:
自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）自下而上的迭代
申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；设定两个指针，最初位置分别为两个已经排序序列的起始位置；比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；重复步骤 3 直到某一指针达到序列尾；将另一序列剩下的所有元素直接复制到合并序列尾。 */

//非递归
template<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(<)的運算子功能
void merge_sort(T arr[], int len) {
    T *a = arr;
    T *b = new T[len];
    for (int seg = 1; seg < len; seg += seg) {
        for (int start = 0; start < len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 < end1 && start2 < end2)
                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
            while (start1 < end1)
                b[k++] = a[start1++];
            while (start2 < end2)
                b[k++] = a[start2++];
        }
        T *temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        for (int i = 0; i < len; i++)
            b[i] = a[i];
        b = a;
    }
    delete[] b;
}

//递归
template<typename T> // 整數或浮點數皆可使用,若要使用物件(class)時必須設定"小於"(<)的運算子功能
void merge_sort(T arr[], int len) {
    T *a = arr;
    T *b = new T[len];
    for (int seg = 1; seg < len; seg += seg) {
        for (int start = 0; start < len; start += seg + seg) {
            int low = start, mid = min(start + seg, len), high = min(start + seg + seg, len);
            int k = low;
            int start1 = low, end1 = mid;
            int start2 = mid, end2 = high;
            while (start1 < end1 && start2 < end2)
                b[k++] = a[start1] < a[start2] ? a[start1++] : a[start2++];
            while (start1 < end1)
                b[k++] = a[start1++];
            while (start2 < end2)
                b[k++] = a[start2++];
        }
        T *temp = a;
        a = b;
        b = temp;
    }
    if (a != arr) {
        for (int i = 0; i < len; i++)
            b[i] = a[i];
        b = a;
    }
    delete[] b;
}
```

#### 快速排序

![快速排序](quickSort.gif)

```c++
//快速排序的时间复杂度是o(nlog n),一般而言是比其他nlogn排序是要快的

 /*从数列中挑出一个元素，称为 "基准"（pivot）;
 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，"该基准就处于数列的中间位置"。这个称为分区（partition）操作；
    递归（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；*/

//就是由基准分成两部分，再由两部分的基准分成另外两部分，以此类推。 - 直到所有部分都符合基准，即可退出。
        
//代码        
//严蔚敏《数据结构》标准分割函数
 int Paritition1(int A[], int low, int high) {
   int pivot = A[low];
   while (low < high) {
     while (low < high && A[high] >= pivot) {
       --high;
     }
     A[low] = A[high];
     while (low < high && A[low] <= pivot) {
       ++low;
     }
     A[high] = A[low];
   }
   A[low] = pivot;
   return low;
 }

 void QuickSort(int A[], int low, int high) //快排母函数
 {
   if (low < high) {
     int pivot = Paritition1(A, low, high);
     QuickSort(A, low, pivot - 1);
     QuickSort(A, pivot + 1, high);
   }
 }
```

#### 堆排序

![堆排序](heapSort.gif)

![堆排序](https://www.runoob.com/wp-content/uploads/2019/03/Sorting_heapsort_anim.gif)

```c++
/*
//堆排序 - 是利用数据结构中的堆的性质设计的算法，它的时间复杂度是o(nlogn)
 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；
//算法步骤
 创建一个堆 H[0……n-1]；
 把堆首（最大值）和堆尾互换；
 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；
 重复步骤 2，直到堆的尺寸为 1。
*/
//代码
#include <iostream>
#include <algorithm>
using namespace std;

void max_heapify(int arr[], int start, int end) {
    // 建立父節點指標和子節點指標
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end) { // 若子節點指標在範圍內才做比較
        if (son + 1 <= end && arr[son] < arr[son + 1]) // 先比較兩個子節點大小，選擇最大的
            son++;
        if (arr[dad] > arr[son]) // 如果父節點大於子節點代表調整完畢，直接跳出函數
            return;
        else { // 否則交換父子內容再繼續子節點和孫節點比較
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len) {
    // 初始化，i從最後一個父節點開始調整
    for (int i = len / 2 - 1; i >= 0; i--)
        max_heapify(arr, i, len - 1);
    // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢
    for (int i = len - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main() {
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    for (int i = 0; i < len; i++)
        cout << arr[i] << ' ';
    cout << endl;
    return 0;
}
```

#### 计数排序

![计数排序](countingSort.gif)

```c++
//计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。
//计数排序的时间复杂度是o(n+K)
/*
简单说，就是用我们"需要排序的序列的值",创建一个标记数组，只要序列出现过的值，都标记成1，就说明它出现了。但是，这种方法只对数来说比较方便。 - 可以说是数组下标和排序序列有映射关系
      
算法步骤
（1）找出待排序的数组中最大和最小的元素
（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

 */
//代码（c）
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void print_arr(int *arr, int n) {
        int i;
        printf("%d", arr[0]);
        for (i = 1; i < n; i++)
                printf(" %d", arr[i]);
        printf("\n");
}

void counting_sort(int *ini_arr, int *sorted_arr, int n) {
        int *count_arr = (int *) malloc(sizeof(int) * 100);
        int i, j, k;
        for (k = 0; k < 100; k++)
                count_arr[k] = 0;
        for (i = 0; i < n; i++)
                count_arr[ini_arr[i]]++;
        for (k = 1; k < 100; k++)
                count_arr[k] += count_arr[k - 1];
        for (j = n; j > 0; j--)
                sorted_arr[--count_arr[ini_arr[j - 1]]] = ini_arr[j - 1];
        free(count_arr);
}

int main(int argc, char **argv) {
        int n = 10;
        int i;
        int *arr = (int *) malloc(sizeof(int) * n);
        int *sorted_arr = (int *) malloc(sizeof(int) * n);
        srand(time(0));
        for (i = 0; i < n; i++)
                arr[i] = rand() % 100;
        printf("ini_array: ");
        print_arr(arr, n);
        counting_sort(arr, sorted_arr, n);
        printf("sorted_array: ");
        print_arr(sorted_arr, n);
        free(arr);
        free(sorted_arr);
        return 0;
}        


```

#### 桶排序 - 不懂

元素分布在桶中：

![桶](Bucket_sort_1.svg_.png)

然后，元素在每个桶中排序：

![桶](Bucket_sort_2.svg_.png)

```c++
//桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
//为了使桶排序更加高效，我们需要做到这两点：在额外空间充足的情况下，尽量增大桶的数量使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中
/*计数排序每个位置只能装一种数据，而桶排序中，可以装入一个范围（集合）的数据是这个样子吗 - 感觉类似于哈希表*/
        
        
//代码
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 100010;

int n;
int a[N], b[N];

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ ) cin >> a[i];
    int maxv = *max_element(a, a + n);
    for (int i = 0; i < n; i ++ ) b[a[i]] ++ ;
    for (int i = 0, j = 0; i <= maxv; i ++ )
        while (b[i] -- ) a[j ++ ] = i;
    for (int i = 0; i < n; i ++ ) cout << a[i] << ' ';
    return 0;
}        
```

#### 基数排序 - 不懂

![基数排序](radixSort.gif)

```c++
//基数排序：根据键值的每位数字来分配桶；
//基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。


//代码
int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
    int maxData = data[0];              ///< 最大数
    /// 先求出最大数，再求其位数，这样有原先依次每个数判断其位数，稍微优化点。
    for (int i = 1; i < n; ++i)
    {
        if (maxData < data[i])
            maxData = data[i];
    }
    int d = 1;
    int p = 10;
    while (maxData >= p)
    {
        //p *= 10; // Maybe overflow
        maxData /= 10;
        ++d;
    }
    return d;
/*    int d = 1; //保存最大的位数
    int p = 10;
    for(int i = 0; i < n; ++i)
    {
        while(data[i] >= p)
        {
            p *= 10;
            ++d;
        }
    }
    return d;*/
}
void radixsort(int data[], int n) //基数排序
{
    int d = maxbit(data, n);
    int *tmp = new int[n];
    int *count = new int[10]; //计数器
    int i, j, k;
    int radix = 1;
    for(i = 1; i <= d; i++) //进行d次排序
    {
        for(j = 0; j < 10; j++)
            count[j] = 0; //每次分配前清空计数器
        for(j = 0; j < n; j++)
        {
            k = (data[j] / radix) % 10; //统计每个桶中的记录数
            count[k]++;
        }
        for(j = 1; j < 10; j++)
            count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
        for(j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中
        {
            k = (data[j] / radix) % 10;
            tmp[count[k] - 1] = data[j];
            count[k]--;
        }
        for(j = 0; j < n; j++) //将临时数组的内容复制到data中
            data[j] = tmp[j];
        radix = radix * 10;
    }
    delete []tmp;
    delete []count;
}
```
