---
title: 数据结构 - 对数据的基本操作
date: 2023-04-26 20:50:57
description: "简单讲讲运用数组实现的几个算法"
typora-root-url: 对数据的简单操作
categories: 算法
tags: 数据结构
---

## 对数据的常见操作

### [前缀和](https://blog.csdn.net/weixin_45629285/article/details/111146240)

前缀和，是一个序列的前n项和，可以理解为高中的数列的前n项和。

![png](.png)

如果给你一个数组，要求你求出这个数组中某段区间的和，我们可以用遍历区间的方式来求和，下面是求得区间和的朴素算法。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int main()
{
 int a[N];
    for(int i = 1;i<=n;i++) cin>>a[i];
    //记录和
    int ans;
    
    //输入两个区间
    int l,r;
    cin>>l>>r;
    //累加
    for(int i = l;i<=r;i++) ans+=a[i];
    cout<<ans;
}
```

但是这样做，如果求多个区间和就要多次遍历，这样时间复杂度会很高，索性我们在输入数据的同时，构造前缀和数组`S[]`使得每一个`S[]`数组的下标表示一段从1开始(也可以从数组下标0开始)的连续的区间和，下面是代码。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int main()
{
    int a[N],S[N];
    
    //构造前缀和数组
    for(int i = 1;i<=n;i++){
        cin>>a[i];
        s[i] += s[i-1]+a[i];
    }    
    
}
```

当我们需要求得一个区间的和的时候，可以利用前缀和的思想，例如给一个数组`a[5] = {1,2,3,4,5}`，要求区间`2-3`的和。由`S[]`数组的性质我们可以得到，`S[3]-S[1] = a[2]+a[3](展开就知道了)`，所以说对于任意的区间`[l,r]`,有`区间和 = S[r] - S[l-1]`,下面是根据推断得到的代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a[N], s[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
 //构造前缀和
    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i]; 

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]); // 区间和的计算
    }

    return 0;
}
```

这样就实现了前缀和算法。

### 二维前缀和

一维前缀和是在一维数组构造的，二维前缀和是在二维数组构造的。一维前缀和求的是区间和，二位前缀和求的是矩阵和，在构造二维前缀和之前，我们先构造y一个简单的矩阵和来看看，下面是朴素算法

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int main()
{
    int a[N][N];
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=n;j++)
            cin>>a[i][j];
    //输入区间坐标
    int x1,y1;
    int x2,y2;
    
    int ans;
    for(int i = x1;i<=x2;i++)
        for(int j = x2;j<=x2;j++)
            ans+=a[i][j];
    cout<<ans;    
    return 0;
}
```

![二维前缀和](二维前缀和.png)

我们只用图形来理解，如果我们需要求得红色区间的值应该怎么做。直接用最大的蓝色矩阵减去绿色和紫色小条就行。减去完发现多减了一个`a[i][j]`,加上即可，如下图所示。

![二维前缀和分解](二维前缀和分解.png)

从上图的结论中我们很容易看出，整个外围蓝色矩形面积`s[i][j]` = 绿色面积`s[i - 1][j]` + 紫色面积`s[i][j - 1]` - 重复加的红色的面积`s[i - 1][j - 1]` + 小方块的面积`a[i][j]`;

**因此得出二维前缀和预处理公式**（求得从`11`开始的子矩阵的所有和）

`s[i][j] = s[i - 1][j] + s[i][j - 1 ] + a[i] [j] - s[i - 1][j - 1]`

**接下来回归问题**(求子矩阵的和)去求以`(x1,y1)`为左上角和以`(x2,y2)`为右下角的矩阵的元素的和。

![求起点不同的子矩阵](求起点不同的子矩阵.png)

**紫色面积**是指 `(1, 1)`左上角到`(x1 - 1, y2)`右下角的矩形面积 ，**黄色面积**是指`(1, 1)`左上角到`(x2, y1 - 1)`右下角的矩形面积；

**不难推出：**

![分解子矩阵](分解子矩阵.png)

绿色矩形的面积 = `整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]`

因此二维前缀和的结论为：

**`以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]`**

下面是例题代码

![image-20230827153429879](image-20230827153429879.png)

```c++
#include <iostream>
using namespace std;
const int N = 1010;
int n, m, q;
int s[N][N];
int main()
{
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &s[i][j]);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
    while (q -- )
    {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }
    return 0;
}
```

[一维差分](https://blog.csdn.net/weixin_45629285/article/details/111146240)

![差分](差分.png)

类似于数学中的求导和积分，差分可以看成前缀和的逆运算。

差分数组：

首先给定一个原数组`a：a[1], a[2], a[3],,,,,, a[n];`

然后我们构造一个数组`b ： b[1], b[2], b[3],,,,,, b[i];`

使得 `a[i] = b[1] + b[2] + b[3] + ,,,,,, + b[i]`

也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个**`a[i]都是b数组中从头开始的一段区间和`**。

考虑如何构造差分b数组？

最为直接的方法

如下：

![差分1](差分1.png)

我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到 a 数组 。

知道了差分数组有什么用呢？ 别着急，慢慢往下看。

话说有这么一个问题：

给定区间`[l, r ]，让我们把a数组中的[l, r] 区间中的每一个数都加上c,即 a[l] + c , a[l + 1] + c , a[l + 2] + c ,,,,,, a[r] + c;`

暴力做法是`for循环l到r区间`，时间复杂度`O(n)`，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成`O(n * m)`。有没有更高效的做法吗? 考虑差分做法，(差分数组派上用场了)。

始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。

首先让差分b数组中的 `b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l + 1] + c,,,,,, a[n] + c`;

然后我们打个补丁，`b[r + 1] - c, 通过前缀和运算，a数组变成 a[r + 1] - c,a[r + 2] - c,,,,,,,a[n] - c`;

为啥还要打个补丁？

我们画个图理解一下这个公式的由来:

![差分构成](差分构成.png)

`b[l] + c`，效果使得a数组中` a[l] `及以后的数都加上了c(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 `b[r + 1] - c`,让a数组中`a[r + 1]`及往后的区间再减去c(绿色部分)，这样对于`a[r]` 以后区间的数相当于没有发生改变。

因此我们得出一维差分结论：给a数组中的`[ l, r]` 区间中的每一个数都加上c,只需对差分数组b做 `b[l] + = c, b[r+1] - = c`。时间复杂度为O(1), 大大提高了效率。

![在这里插入图片描述](20201217172005485.png)

![image-20230827155704438](image-20230827155704438.png)

```c++
//模版代码
#include<iostream>
using namespace std;
const int N = 1e5+10;
int a[N],b[N],c[N];
int n,m;
//构造差分数组的函数
void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}

int main()
{
    cin>>n>>m;
    //输入构造差分数组的原数组
    for(int i = 1;i<=n;i++) cin>>a[i];
    //构造差分序列 - b就是差分数组
    for(int i = 1;i<=n;i++) insert(i,i,a[i]);
    
    while(m--)
    {
        int l,r,c;
        cin>>l>>r>>c;
        //插入更改的值
        insert(l,r,c);
    }
    //这里是析出原数组
    for(int i = 1;i<=n;i++) c[i] = c[i-1]+b[i];
    //输出
    for(int i = 1;i<=n;i++) cout<<c[i]<<" ";
    
    
}
```

### 二维差分

如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。

a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组

原数组：`a[i][j]`

我们去构造差分数组： `b[i][j]`

使得a数组中`a[i][j]`是b数组左上角`(1,1)`到右下角`(i,j)`所包围矩形元素的和。

如何构造b数组呢？

其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。

同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由`O(n*n)`的时间复杂度优化成`O(1)`

已知原数组a中被选中的子矩阵为 以`(x1,y1)`为左上角，以`(x2,y2)`为右下角所围成的矩形区域;

始终要记得，**a数组是b数组的前缀和数组，比如对`b`数组的`b[i][j]`的修改，会影响到`a`数组中从`a[i][j]`及往后的每一个数。**

假定我们已经构造好了`b`数组，类比一维差分，我们执行以下操作
来使被选中的子矩阵中的每个元素的值加上`c`

`b[x1][y1] + = c ;`

`b[x1][y2+1] - = c;`

`b[x2+1][y1] - = c;`

`b[x2+1][y2+1] + = c;`

每次对`b`数组执行以上操作，等价于：

```c++
for(int i = x1;i <= x2;i++)
  for(int j = y1;j <= y2;j++)
    a[i][j] += c;
```

![二维差分](二维差分.png)

`b[x1][y1] += c;` 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。
`b[x1,][y2 + 1] -= c;` 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。
`b[x2 + 1][y1] -= c;` 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。
`b[x2 + 1][y2 + 1] += c;` 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。

![二维差分分解](二维差分分解.png)

**我们将上述操作封装成一个插入函数:**

```c++
void insert(int x1,int y1,int x2,int y2,int c)
{     //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```

我们可以先假想`a`数组为空，那么`b`数组一开始也为空，但是实际上`a`数组并不为空，因此我们每次让以`(i,j)`为左上角到以`(i,j)`为右下角面积内元素(其实就是一个小方格的面积)去插入 `c = a[i][j]`，等价于原数组`a中(i,j) 到(i,j)`范围内 加上了 `a[i][j]`,因此执行`n*m`次插入操作，就成功构建了差分b数组.

**这叫做曲线救国。**

```c++
 for(int i = 1;i <= n;i++)
  {
      for(int j = 1;j <= m;j++)
      {
          insert(i, j, i, j, a[i][j]);    //构建差分数组
      }
  }
```

当然关于二维差分操作也有直接的构造方法，**公式如下：**

```c++
b[i][j] = a[i][j] − a[i − 1][j] − a[i][j − 1] + a[i −1 ][j − 1]
```

二维差分数组的构造同一维差分思维相同，因次在这里就不再展开叙述了。

![1](20201217172035975.png)

![image-20230827161505699](image-20230827161505699.png)

```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e3 + 10;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main()
{
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            insert(i, j, i, j, a[i][j]);      //构建差分数组
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  //二维前缀和
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            printf("%d ", b[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

### [双指针](https://www.cnblogs.com/huansky/p/13508533.html)

双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（*快慢指针*）或者相反方向（*对撞指针*）的指针进行扫描，从而达到相应的目的。

换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。

#### 对撞指针

对撞指针是指在数组中，将指向最左侧的索引定义为`左指针(left)`，最右侧的定义为`右指针(right)`，然后从两头向中间进行数组遍历。

> 对撞数组适用于连续数组和字符串，也就是说当你遇到题目给定连续数组和字符床时，应该第一时间想到用对撞指针解题。

```c++
//伪代码
function fn (list) {
  var left = 0;
  var right = list.length - 1;

  //遍历数组
  while (left <= right) {
    left++;
    // 一些条件判断 和处理
    ... ...
    right--;
  }
}

//对撞指针能够解决：：1.二分查找 2.两数之和 II - 输入有序数组 3.反转字符串 4.反转字符串中的元音字母 5.回文字符串
```

![image-20230828114701956](image-20230828114701956.png)

```c++
//实现函数
void reS(char s[]){
    int length = strlen(s); // 计算数组长度
    if(length == 0 || length == 1) return;
    int left = 0;
    int right = length - 1;
    while(left < right){
        // 交换数据
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp; 
        left++; 
        right--; 
    }
    return;
}
```

#### 快慢指针

快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为`快指针（fast）`和`慢指针（slow）`，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。

> 一般快慢指针用于维护区间

```c++
//伪代码
slow = head;
fast = head;
while (fast != NULL && fast->next != NULL) {
    slow = slow->next;
    fast = fast->next->next;
    if (slow == fast) {
        return true;
    }
}
return false;

//快慢指针能够解决：链表中倒数第k个节点  1.链表的中间节点 2.链表是否有环 3.链表环的长度 4.链表环的起点
//判断链表是否有环
bool hasCycle(ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }
    ListNode *slow = head; // 慢指针
    ListNode *fast = head->next; // 快指针
    while (slow != fast) { // 当快慢指针不相遇时
        if (fast == NULL || fast->next == NULL) { // 如果快指针到达链表尾部，说明链表没有环
            return false;
        }
        slow = slow->next; // 慢指针走一步
        fast = fast->next->next; // 快指针走两步
    }
    return true; // 如果快慢指针相遇，说明链表有环
}
```

快慢指针案例：**[滑动窗口](https://www.cnblogs.com/huansky/p/13488234.html)**

```c++

```

### [哈希表的实现方法](https://zhuanlan.zhihu.com/p/496515259)

[散列表](https://www.cnblogs.com/lisen10/p/10876344.html)（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。

我们知道，数组的最大特点就是：寻址容易，插入和删除困难；而链表正好相反，寻址困难，而插入和删除操作容易。那么如果能够结合两者的优点，做出一种寻址、插入和删除操作同样快速容易的数据结构，那该有多好。这就是哈希表创建的基本思想，而实际上哈希表也实现了这样的一个“夙愿”，哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。

哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。

> map<a,b>: a经过哈希函数变为b，产生映射关系
>
> hash表本质是数组，讲一个散列的数据集中到一个数组上，用最少资源按照一定的逻辑存储我们的数据
>
> 说人话就是大范围关键字存储改为小范围关键字存储

哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。

> 哈希函数相当于排列规则，我们可以依靠这个排列规则排列键的顺序，同时也可以用这个排列规则寻找我们的值.
>
> 如果用日常生活来举例的话，哈希表就像是我们的字典目录一样。

哈希表和哈希函数的标准定义：若关键字为k，则其值存放在h(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为哈希函数，按这个思想建立的表为哈希表。

设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。
但是，一般散列函数都面临着冲突的问题。两个不同的关键字，由于散列函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该散列函数的同义词(Synonym)。

![散列表原理](v2-34a5a0d0cbff54649d0175f5126214cc_720w.webp)

哈希表的实现就是映射函数构造，看某个元素具体属于哪一个类别。如何构造我们要考虑两个问题：

- n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小。
- 无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突。

#### **[直接定位法](https://www.xiuxingstudio.com/computer/%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95/4195.html)**

`Hash(key) = a·key + b (a、b为常数)`

**优点**：以关键码key的某个线性函数值为哈希地址，不会产生冲突.

**缺点**：要占用连续地址空间，空间效率低。

**例：**关键码集合为`{100，300，500，700，800，900}`， 选取哈希函数为`Hash(key)=key/100`， 则存储结构（哈希表）如下：

![img](1622171-20190525161418247-402666349.png)

这种方法计算最简单，且**不会产生冲突**。**适合于关键字分布基本连续的情况**，**如果关键字分布不连续，空位较多，则会造成存储空间的浪费**。

举一个例子，假设有一个记录了从 1 岁到 100 岁的人口数字统计表。其中年龄为关键字，哈希函数取关键字自身，如下表所示。

![哈希函数（一）-直接定址法、除留余数法、平方取中法](webp.png)

比如想要查询 25 岁的人有多少，则只要查询表中第 25 项即可。

> 这种方法一般不使用，除非是我们查询的表比较简单的情况之下。

#### **除留余数法**

`Hash(key) = key mod p (p是一个整数)`

**特点**：以关键码除以p的余数作为哈希地址。

**关键**：如何选取合适的p？

**技巧**：若设计的哈希表长为m，则一般取p≤m且为质数 （也可以是不包含小于20质因子的合数）。

> 取p≤m且为质数是为了少开区间，mod质数是为了输出不同区间的值，让数据更加散乱。
>
> 这种方法是最常见构造散列表的方法

#### 乘余取整法

`Hash(key) = [B*( A*key mod 1 ) ]`下取整 `(A、B均为常数，且0<A<1，B为整数)`

**特点：**以关键码key乘以A，取其小数部分，然后再放大B倍并取整，作为哈希地址。

**例：**欲以学号最后两位作为地址，则哈希函数应为： `H(k)=100*(0.01*k % 1 )`其实也可以用法2实现：`H(k)=k % 100`

这也是一种简单且常用的哈希函数方法。其关键点在于`p` 的选择。**根据经验而言，一般 `p` 取素数或者 `m`，这样可以尽可能的减少冲突。**

比如我们需要将 7 个数 [432, 5, 128, 193, 92, 111, 88] 存储在 11 个区块中（长度为 11 的数组），通过除留余数法将这 7 个数应分别位于如下地址：

![哈希函数（一）-直接定址法、除留余数法、平方取中法](webp-1693208563347-31.png)

比如432，对11取余数，余数为3，放在03位置

#### **数字分析法**

**特点：**某关键字的某几位组合成哈希地址。所选的位应当是：各种符号在该位上出现的频率大致相同。

例：有一组（例如80个）关键码，其样式如下：

![img](./1622171-20190525162109183-1593077689.png)

#### **平方取中法**

**特点：**对关键码平方后，按哈希表大小，取中间的若干位作为哈希地址。

**理由**：因为中间几位与数据的每一位都相关。

**例**：2589的平方值为6702921，可以取中间的029为地址。

#### **折叠法**

**特点：**将关键码自左到右分成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。

**适用于**：每一位上各符号出现概率大致相同的情况。

法1：移位法 ── 将各部分的最后一位对齐相加。

法2：间界叠加法──从一端向另一端沿分割界来回折叠后，最后一位对齐相加。

**例：**元素`42751896, 用法1： 427＋518＋96=1041   用法2： 427 518 96—> 724+518+69 =1311`

### 哈希表优化冲突

Hash表解决冲突的方法主要有以下几种：

> 开放定址法（开地址法）、 链地址法（拉链法）、 再哈希法（双哈希函数法）、 建立一个公共溢出区，而最常用的就是**开发定址法**和**链地址法**。

#### **[开放寻址法](https://www.cnblogs.com/east7/p/12594894.html)**

 **开放寻址法**：又称开放定址法，当哈希碰撞发生时，从发生碰撞的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。这个空闲单元又称为开放单元或者空白单元。

> 就是映射的位置有数了，就在这个位置的下一个位置存储，如果还有继续查找下一个位置以此类推。

 查找时，如果探查到空白单元，即表中无待查的关键字，则查找失败。开放寻址法需要的表长度要大于等于所需要存放的元素数量，非常适用于装载因子较小（小于0.5）的散列表。

 开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记，直到有下个元素插入才能真正删除该元素。

​    可以把开放寻址法想象成一个停车问题。若当前车位已经有车，则继续往前开，直到找到一个空停车位。

![img](1208468-20200329205724302-384212505.png)

**设计思路：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。

**含义：**一旦冲突，就找附近（下一个）空地址存入。

 开放寻址法的基本函数是：

```c++
Hi(key)=(H(key) + f(i)) MOD m, i=0,1,2,…, k(k<=m-1)，
```

> 其中，**m** 为散列表长度，一般为素数；
>
> **H(key)** 为散列函数，用于计算索引，key为关键字值；
>
> **f(i)** 为增量序列，用于解决冲突，且`f(0) = 0`，i为已经尝试计算索引的次数。
>
> 当散列值`H0(key)`发生冲突时，再计算`H1(key)`……，直到不冲突为止。

实现步骤

> 得到给定的 `key`；
>
> 根据函数计算得 `hashValue`；
>
> 若不冲突，则把关键字值存入下标为`hashValue`的桶；
>
> 若冲突，则使 i++ ，也就是往后找，直到找到第一个空桶并填入当前key。若到了尾部则循环到前面。

##### **线性探查法**

 冲突函数：是`i`的一次多项式，典型取法为`f(i)=i`。

​    线行探查法(Linear Probing)是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。

​    对于一个散列表，在散列过程中，某些元素形成一些区块，这种现象称作`一次聚集（primary clustering）`。就是说，散列到区块中的任何关键字都需要多次探测才可以解决哈希碰撞，然后，把该关键字添加到相应区块的桶中。

下面是一道[例题](https://blog.csdn.net/ChenYiRan123456/article/details/128570110)用线性探查实现开放寻址法

![image-20230829145845885](./image-20230829145845885.png)

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 200003, null = 0x3f3f3f3f;

int h[N];

int find(int x)
{
    int t = (x % N + N) % N;
    //开放寻址法就是 挨个找，找不到就算，找到了就返回呗
    while (h[t] != null && h[t] != x)//没到尽头和不为我们的目标值
    {
        t ++ ;
        if (t == N) t = 0;//指针回位
    }
    return t;
}

int main()
{
    memset(h, 0x3f, sizeof h);

    int n;
    scanf("%d", &n);

    while (n -- )
    {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if (*op == 'I') h[find(x)] = x;
        else
        {
            if (h[find(x)] == null) puts("No");
            else puts("Yes");
        }
    }

    return 0;
}

```

#### [拉链法](https://www.acwing.com/solution/content/30169/)

**基本思想**：将具有相同哈希地址的记录链成一个单链表，m个哈希地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。

**注：**有冲突的元素可以插在表尾,也可以插在表头

**例**：设`{ 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89 }`的哈希函数为： `Hash(key)=key mod 11`， 用拉链法处理冲突，则建表如下图所示。

![img](1622171-20190525164856289-1731976151.png)

```c++
/*拉链法实现上诉题目*/
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1e5 + 3;  // 取大于1e5的第一个质数，取质数冲突的概率最小 可以百度

//* 开一个槽 h
int h[N], e[N], ne[N], idx;  //邻接表

void insert(int x) {
    // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}

bool find(int x) {
    //用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i]) {
        if (e[i] == x) {
            return true;
        }
    }
    return false;
}

int n;

int main() {
    cin >> n;

    memset(h, -1, sizeof h);  //将槽先清空 空指针一般用 -1 来表示

    while (n--) {
        string op;
        int x;
        cin >> op >> x;
        if (op == "I") {
            insert(x);
        } else {
            if (find(x)) {
                puts("Yes");
            } else {
                puts("No");
            }
        }
    }
    return 0;
}

```

#### 双散列*

​     冲突函数：`f(i) = i * hash2(key)`，典型取法是令`hash2(key)=PRIME – (key ％ PRIME)`，其中 PRIME 是小于散列表大小的质数。

​    双散列（`double hashing`）使用两个散列函数`H(key)和hash2(key)`。`hash2(key)`也以关键字为自变量，产生一个`l至m-1`之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)。

​    无论是线性探测还是二次探测，当装载因子过高时，哈希表能否动态增长？

​    要扩充哈希表，首先必须找下一个新的且够大(大约2倍)的质数，然后必须考虑重哈希的成本。我们不可能原封不动的拷贝，必须要检验旧表格中的每个元素，计算其在新表格中的位置，然后再插入到新表格中。

#### 平方探查法*

​    冲突函数：是i的二次多项式，典型取法为f(i)=i^2。

​    平方探测法（Quadratic Probing）即是发生冲突时，用发生冲突的单元H(key), 加上 1²、 2²等，即H(key) + 1²，H(key) + 2²，H(key) + 3²...直到找到空闲单元。f(i)也可以构造为：±i^2,i=1,2,3,...,k。

​    在实际操作中，平方探测法不能探查到全部剩余的桶。不过在实际应用中，散列表如果大小是素数，并且至少有一半是空的，那么，总能够插入一个新的关键字。若探查到一半桶仍未找一个空闲的，表明此散列表太满，应该重哈希。平方探测法是解决线性探测中一次聚集问题的解决方法，但是，她引入了被称为二次聚集的问题——散列到同一个桶的那些元素将探测到相同的备选桶。下面的技术将会排除这个遗憾，不过要付出计算一个附加的哈希函数的代价。

### [字符串哈希](https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811)*

```c++
//字符串hash
 构造唯一数据表示字符串，可以理解为 f(x) = y。就是通过某种方法转化，使得两个毫无相关的数据产生关系。但是为了将映射关系进行一一对应，也就是，一个字符串对应一个数字，那么一个数字也对应一个字符串。
 用字符串Hash的目的是，我们如果要比较一个字符串，我们不直接比较字符串，而是比较它对应映射的数字，这样子就知道两个“子串”是否相等。从而达到，子串的Hash值的时间为 O(1)，进而可以利用“空间换时间”来节省时间复杂的。
    我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。不用担心，接下来的内容正要讲解。//我们只需要用到数字来匹配数据，这样对数字操作就可以得到我们想要的操作了
```

#### 构造字符串hash

```c++
//简单例子
 假如给你一个数字1166，形式上你只知道它只是1和6的组合，但你知道它代表的实际大1*10^3+1*10^2+6*10^1+6*10^0。
 同理，给你一个字符串，要把它转换为数字，就可以先把每一个字符都先对应一个数字，然后把它们按照顺序乘以进制（Base）的幂进行相加，然后这个数可能很大，所以一般会取余数（MOD）。    
//具体操作
    根据上面的理解，其实将字符串映射成数字，和我们平时的将一个 某Base进制数，变为一个十进制数，相类似。//把字符串当成 某种进制的数据，把字符串拆成很多位，然后对每一个位置的字符都进行哈希操作，再用进制的乘法操作将他们拼接起来。
 我们先定义以下：
 给定一个字符串 S = s1s2s3...sn，对于每一个si就是一个字母，那么我们规定
         idx(si) = si-'a'+1 （当然也可以直接用其ASCII值）
 构造字符串Hash总共有三种方法。每一种方法，主要都是用使用 Base 和 MOD（都要求是素数），一般都是 Base  < MOD，同时将Base和MOD尽量取大即可，这种情况下，冲突（即不同字符串却有着相同的hash值）的概率是很低的

//1.自然溢出方法 - 后面还有
 对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 unsigned long long 整数的自然溢出
```

```c++
//怎么构建我们的字符串前缀
  1.将整个数组 当做是一个p进制的数。 通过这样的方式，将我们的字符串变成数字进行操作（本质上 字符串也是数字） - 但是我们这个数组转化完成可能会非常大 那么我们就mod一个大的数据 - 通过这样的方法映射到小区间中 //取模会重复怎么办 还是说随机存储
    2.字符串哈希完全不考虑冲突的情况 
    3. p = 131 or 13331 - Q = 2e64 这样可以忽略冲突 （溢出等价于 mod 2e64）
```

![image-20230226201946750](字符串哈希.png)

标准流程

![原理](字符串hash1.png)

![原理2](字符串hash2.png)

```c++
//相当于将字符型映射为整型（本来就是 将字符串映射成一个p进制的数据 - p一般为质数）
typedef unsigned long long ULL;
const int P = 131;
// p[i] = P^i, h[i] = s[1~i]的hash值
ULL p[N],h[N];

//预处理
void init()
{
    //字符串长度就是对应的进制 p^n - 也可以说是长度是项数的个数
    p[0] = 1,h[0] = 0;
    for(int i = 1;i<=n;i++){
        p[i] = p[i-1]*P; //P是进制
        h[i] = h[i-1]*P+s[i];//s是对应字符的ASCII值是吧
    }
}
//计算s[l~r]的哈希值
ULL get(int l,int r)
{
    return h[r]-h[l-1]*p[r-l+1];
}
//判断两个子串是否相等
bool substr(int l1,int r1,int l2,int r2){
    return get(l1,r1) == get(l2,r2);
}

//总结：字符串哈希使用来解决字符串匹配，查找去重的问题的。
```

![原理3](字符串hash原理3.png)

### 高精度

#### **高精度加法计算**

> 如果我们要将一个很大的数据与一个很小的数据相加应该怎么办，你可能会想，直接加就行了嘛，10000+1=10001，很简单。但是，在计算机中，我们使用的数据类型在计算的时候，往往会将小的数据忽略掉，也就是`1e99+1 = 1e99`,而1就不见了。我们需要的是保持精度的情况下进行加法，这个时候我们可以利用我们的线性表，数组来实现这个保留精度的加法。A+B（这里的情况是一个大的数据加上另一个大的数据）。
>
> 依照上面的说法，我们就开辟两个字符串数组（比较好分离数据），一个a【】存A这个数据，一个b【】存B这个数据。但为了方便接下来的操作，我们还是开辟两个Vector(向量：是个容器)，然后将输入的a,b中的数据导入到我们的vector中，这个时候注意一个细节。
>
> 我们插入的数据是要倒着插入的，举个例子：123456789，这是一个大的数据，倒着插入意味着个位在数组（容器）的前面（之后的数据以此类推）。在数组中就变成了987654321，这样做的好处是进位不用移动数组中的元素，你看我们的目的是要计算这些大数据的加和，在加和的过程中免不了会产生进位，如果用123456789，进一位的话就要移动整个数组，就十分复杂。如果反过来，我们只需要在进的那位尾插一个数据就行。
>
> 同时，计算方法其实就和我们手工计算的差不多，对位计算加上进位即可，举个例子：1+9 = 10，其实就是十位上面+进位 t=1 = 10,就是这样。

代码实现

```c++
//C = A+B c是我们要实现的结果
vector<int> add(vector<int> &A,vector<int> &B)
{
    vector<int> C;//这是结果
    
    int t = 0//进位
    for(int i = 0;i<A.size()||i<B.size();i++)//只要没遍历完最长的就继续
    {
        //下面实现的是 t在i这个位置的值，然后%10就是这个位置剩下的值，/10就是进位的值保留到i+1（下一位）
        if(i<A.size()) t+=A[i];
        if(i<B.size()) t+=B[i];
        C.push_back(t%10);//将对应位置的数据插入结果
        t/=10;
    }
    if(t) C.push_back(1);//进大位，出来t/10还有剩，那肯定进位了（我们是倒叙输入的嘛）
    return C;
}
//倒叙输入
int main()  
{
    string a,b;
    vector<int> A,B;
    cin>>a>>b;//自己输入两个大的数据
    //为啥是size-1，就是0到i有i-1个数据嘛
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//倒着插入
    for(int i = b.size()-1;i>=0;i--) B.push_back(b[i] - '0');
    //自动判断是啥类型
    auto C = add(A,B);//调用模板
    //输出
    for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
    return 0;
    
}


```

#### **高精度减法计算**

  减法的计算其实和加法差不多，但是我们需要满足一些条件；`1.A>=B` 不满足就要交换两个数据的值（加上负号）2.向前借位是`+10`（对于当前位数）所以说方向就很明确了，加上一个判断A,B大小的关系，对 t 改一下就行。

```c++
bool cmp(vector<int> &A,vector<int> &B)
{
    if(A.size()!=B.size()) return A.size()>B.size();
    for(int i = A.size()-1;i>=0;i--)
        if(A[i]!=B[i]) return A[i]>B[i];
    return true;
}

//C = A-B c是我们要实现的结果
vector<int> sub(vector<int> &A,vector<int> &B)/模板
{
    vector<int> C;//这是结果
    for(int i = 0,t = 0;i<A.size()||i<B.size();i++)//只要没遍历完最长的就继续
    {
  t = A[i] - t;//t是借位的
        if(i<B.size()) t -= B[i];
        C.push_back((t+10)%10);//这里的t有两种情况，一种减完之<0，那就需要借位+10.一种是减完之后>=0，不需要借位。这个时候，(t+10)%10这两种情况都满足，举个例子：1.你减完之后变成了-9，那就是要借一位，就是-9+10 = 1,1%10还是1.2.你减完之后，还剩下9，那么9%10还是9.
        if(t<0) t = 1;
        else t = 0;
    }
    while(C.size() > 1&&C.back()== 0) C.pop_back();
    return C;

}
//倒叙输入
int main()  
{
    string a,b;
    vector<int> A,B;
    cin>>a>>b;//自己输入两个大的数据
    //为啥是size-1，就是0到i有i-1个数据嘛
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//倒着插入
    for(int i = b.size()-1;i>=0;i--) B.push_back(b[i] - '0');
    
    //用上面的判断，计算A-B 或者 B-A
    if(cmp(A,B))
    {
        auto C = sub(A,B);
        for(int i = C.size()-1;i>=0;i --) printf("%d",C[i]);
    }
    else
    {
        auto C = sub(B,A);//B>A
        printf("-");
        for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
    }
    return 0;
    
}

```

#### 高精度乘法计算

大数据乘小数据

 在人工计算乘法的时候，我们一般是一位一位的计算，例如：`123乘12`，那么一般是2 `*123+10* 123`。但是这样其实比较繁琐，我们在计算高精度的时候，可以把这两个数据中的小数据，单独拿出来做一个整体，就上面那个来说，就变成了`1 *12* 100+2 *12* 10+3 *12* 1`，竖式就由两个变成一个了。

 同时，在计算的时候，每一个位的位数t也需要注意，举个例子：`123456789*12`，这里的 （第一位）a = 9,进位就变成了 `t = 9* 12/10`，输入到结果C的就变成了 (第一位)`C = 9*12%10`，这样就定下来了。下面是代码演示。

```c++
vector<int> mul(vector<int> &A,int b)//b比较小就直接用int表示（整体）
{
    vector<int> C;
    int t = 0;
    for(int i = 0;i<A.size()||t;i++)
    {
        if(i<A.size()) t+=A[i]*b;//遍历位置乘完的数据
        c.push_back(t%10);//插进去计算完成之后这个位置的具体数
        t/=10;//进位
        
    }
    return C;
    
}
//插入数据
int main()
{
    string a;//数据大用字符串存储
    int b;
    cin>>a>>b;
    vector<int> A;
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//这里是把字符串转化成具体的数，由ASCII决定的，在字符'0'代表的是48
    auto C = mul(A,b);//调用容器
    
    for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
}
```

#### 高精度除法计算

大数据除小数据（一般用的不多）

在人工计算除法的时候，一般是从大到小位去除的。但是，一个题目难免会出现加减乘除多种运算，所以说我们还是尾插大数据把。具体做法和乘法差不多，就是把小的看成整体（平常我们算除法是这样）下面是代码演示。

```c++
vector<int> div(vector<int> &A,int b,int &r)//b是小的
{
 vector<int> C;
    r=0;
    for(int i = A.size()-1;i>=0;i--)
    {
        r = r*10+A[i];//计算的时候，和我们把上一位除不了移下来算是一个样子的
        C.push_back(r/b);//余数插入结果中
        r%=b;//除完之后的余数
        
    }
    reverse(C.begin(),C.end());//翻转
    while(C.size()>1&&C.back() == 0) C.pop_back();//去除前端0
    return C;
}
//插入数据
int main()
{
    string a;//数据大用字符串存储
    int b;
    cin>>a>>b;
    vector<int> A;
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//这里是把字符串转化成具体的数，由ASCII决定的，在字符'0'代表的是48
    int r;
    auto C = div(A,b,r);//调用容器
    
    for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
}
```
