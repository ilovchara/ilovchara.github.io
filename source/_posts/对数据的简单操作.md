---
title: 数据结构 - 对数据的基本操作
date: 2023-04-26 20:50:57
description: "简单讲讲运用数组实现的几个算法"
typora-root-url: 对数据的简单操作
categories: 算法
---

## 对数据的简单操作

```c++
1.高精度
2.简单字符串匹配问题
3.数组运用
```

### [前缀和-差分](https://blog.csdn.net/weixin_45629285/article/details/111146240)

#### 前缀和

![前缀和](.png)

```c++
//前缀和是指某序列的前n项和，可以把它理解为数学上的数列的前n项和，而差分可以看成前缀和的逆运算。合理的使用前缀和与差分，可以将某些复杂的问题简单化。
 前缀和可以解决区间和的问题，可以理解一个s数组，下标表示我们的数组a（构造前缀和的数组）元素个数的加和。

//用朴素方法解决："输入一个长度为n的整数序列。接下来再输入m个询问，每个询问输入一对l, r。对于每个询问，输出原序列中从第l个数到第r个数的和"
//代码
const int N = 1e5 + 10;
int a[N];
int n,m;
scanf("%d%d", &n, &m);
for(int i = 1; i <= n; i++) scanf("%d", &a[i]);
while(m--)
{
    int l, r;
    int sum = 0;
    scanf("%d%d", &l, &r);
    for(int i = l; i <= r; i++)
    { 
        sum += a[i];
    }
    printf("%d\n",sum);
}
//时间复杂度为O(n * m) - 两个循环，每次都要重新计算sum的值

//用前缀和 可以将复杂度降低点到o(n+m)

//我们给一个递增的数组
1 2 3 4 5 6 7 8 9
//这个数组 如果我要求 前面4项的和你怎么求
//  自然而然 a1+...+a4 是吧
那么我们可以构造一个数组 来实现这种类似的功能
cin>>a[i]; //伪代码省略操作  
int sum[];
for(int i = 0;i<s.size();i++) sum[i] = sum[i-1]+a[i]; 这样就可以实现了
//这样子 sum 中存储的数据 都是对应i值的前n项和

const int N = 1e5 + 10;
int sum[N], a[N]; //sum[i]=a[1]+a[2]+a[3].....a[i];
for(int i = 1;i <= n; i++)
{ 
    sum[i] = sum[i - 1] + a[i]; //一次性全部算出来 - 只用一个循环的时间   
}

//说白了，就是一个提前把所有数据处理出来，一个没有
```

#### 差分

![差分](差分.png)

![差分1](差分1.png)

```c++
//差分数组：
 首先给定一个原数组a：a[1], a[2], a[3],,,,,, a[n];
 然后我们构造一个数组b ： b[1], b[2], b[3],,,,,, b[i];
 使得 a[i] = b[1] + b[2] + b[3] + ,,,,,, + b[i]
    //i表示a[i]需要i个b数组元素构成
//也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个a[i]都是b数组中从头开始的一段区间和。
```

![差分构成](差分构成.png)

```c++
 b[l] + c，效果使得a数组中 a[l] 及以后的数都加上了c(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 b[r + 1] - c,让a数组中 a[r + 1]及往后的区间再减去c(绿色部分)，这样对于a[r] 以后区间的数相当于没有发生改变。
 因此我们得出一维差分结论：给a数组中的[ l, r] 区间中的每一个数都加上c,只需对差分数组b做 b[l] + = c, b[r+1] - = c 。时间复杂度为O(1), 大大提高了效率。
```

```c++
//差分是解决 - 在数组中的某一个区间中插入或者剔除一个值的问题
 我们设原数组是：a[i]
    b数组的一部分:b[i] = a[i]-a[i-1];
 那么就有： (b[i]+c) = (a[i]+c)-(a[i-1]+c);//这样恒成立
    (b[i]-c) = (a[i]-c)-(a[i]-c);
//所以我们就要在区间中构造一个这样的b[i] - insert函数
 insert(int l,int r,int c)
    {
        b[l]+=c;
        b[r+1]-=c;//这里是为了构造 b[i] = a[i]-a[i-1]; - 每次都超减一位
    }
//梳理
 for(int i = 1;i<=n;i++) cin>>a[i];//这里是输入我们目的处理的数据
    for(int i = 1;i<=n;i++) insert(i,i,a[i]);//这里是构造差分数组 - 构造完的由b数组存储
 while(m--)
    {
        int l,r,c;
        cin>>l>>r>>c;
        insert(l,r,c);//这里就是对我们的差分数组处理数据 - 最终结果就是b数组
    }
//输出结果
    for(int i = 1;i<=n;i++) c[i] = c[i-1]+b[i];//b数组的所有元素加起来就是a数组
 //也就  b[i] = a[i] - a[i-1] 那么把b数组前缀和起来之后就是构造的a数组的序列
 //就是  差分数组整合就是构造差分数组的原序列
    for(int i = 1;i<=n;i++) cout<<c[i]<<" ";
```

```c++
//模版代码
#include<iostream>
using namespace std;
const int N = 1e5+10;
int a[N],b[N],c[N];
int n,m;
//构造差分数组的函数
void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}

int main()
{
    cin>>n>>m;
    //输入构造差分数组的原数组
    for(int i = 1;i<=n;i++) cin>>a[i];
    //构造差分序列 - b就是差分数组
    for(int i = 1;i<=n;i++) insert(i,i,a[i]);
    
    while(m--)
    {
        int l,r,c;
        cin>>l>>r>>c;
        //插入更改的值
        insert(l,r,c);
    }
    //这里是析出原数组
    for(int i = 1;i<=n;i++) c[i] = c[i-1]+b[i];
    //输出
    for(int i = 1;i<=n;i++) cout<<c[i]<<" ";
    
    
}
```

### 二维前缀和-二维差分

#### 二维前缀和

![二维前缀和](二维前缀和.png)

![二维前缀和分解](二维前缀和分解.png)

![二维前缀和预处理](二维前缀和预处理.png)

```c++
//利用了容斥原理 - 将我们需要的区间分离出来
 同一维前缀和一样，我们先来定义一个二维数组s[][] , s[i][j] 表示二维数组中，左上角(1, 1)到右下角(i, j)所包围的矩阵元素的和。接下来推导二维前缀和的公式。//但是，要是起点不定怎么办呢~~~
     紫色面积是指(1, 1)左上角到(i, j - 1)右下角的矩形面积, 绿色面积是指(1, 1)左上角到(i - 1, j )右下角的矩形面积。每一个颜色的矩形面积都代表了它所包围元素的和。
     从图中我们很容易看出，整个外围蓝色矩形面积s[i][j] = 绿色面积s[i - 1][j] + 紫色面积s[i][j - 1] - 重复加的红色的面积s[i - 1][j - 1] + 小方块的面积a[i][j];
 因此得出二维前缀和预处理公式 s[i][j] = s[i - 1][j] + s[i][j - 1 ] + a[i] [j] - s[i - 1][j - 1]
```

![求起点不同的子矩阵](求起点不同的子矩阵.png)

![分解子矩阵](分解子矩阵.png)

```c++
//接下来回归问题去求以(x1,y1)为左上角和以(x2,y2)为右下角的矩阵的元素的和。
 紫色面积是指 (1, 1)左上角到(x1 - 1, y2)右下角的矩形面积 ，黄色面积是指(1, 1)左上角到(x2, y1 - 1)右下角的矩形面积；
 绿色矩形的面积 = 整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]
    因此二维前缀和的结论为：
    以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]
```

#### 二维差分 - 不太懂

![二维差分](二维差分.png)

```c++
//如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。
 a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组
  原数组： a[i][j]
  我们去构造差分数组： b[i][j]
 使得a数组中a[i][j]是b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。
//如何构造b数组呢？
 其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。
 同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由O(n*n)的时间复杂度优化成O(1)
 已知原数组a中被选中的子矩阵为 以(x1,y1)为左上角，以(x2,y2)为右下角所围成的矩形区域;
 始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i][j]的修改，会影响到a数组中从a[i][j]及往后的每一个数。
 假定我们已经构造好了b数组，类比一维差分，我们执行以下操作来使被选中的子矩阵中的每个元素的值加上c：
  b[x1][y1] + = c ;
  b[x1,][y2+1] - = c;
  b[x2+1][y1] - = c;
  b[x2+1][y2+1] + = c;
```

![二维差分分解](二维差分分解.png)

```c++
b[x1][y1] += c ; 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。
b[x1,][y2 + 1] -= c ; 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。
b[x2 + 1][y1] -= c ; 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。
b[x2 + 1][y2 + 1] += c; 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。
    
//封装插入函数
void insert(int x1,int y1,int x2,int y2,int c)
{  //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
//构造
for(int i = 1;i <= n;i++)
  {
      for(int j = 1;j <= m;j++)
      {
          insert(i, j, i, j, a[i][j]);    //构建差分数组
      }
  }

//理解
 我们可以先假想a数组为空，那么b数组一开始也为空，但是实际上a数组并不为空，因此我们每次让以(i,j)为左上角到以(i,j)为右下角面积内元素(其实就是一个小方格的面积)去插入 c = a[i][j] ，等价于原数组a中(i,j) 到(i,j)范围内 加上了 a[i][j] ,因此执行 n*m次插入操作，就成功构建了差分b数组.
```

### [双指针维护区间](https://zhuanlan.zhihu.com/p/71643340)

```c++
//什么是双指针（对撞指针、快慢指针）
 双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（快慢指针）或者相反方向（对撞指针）的指针进行扫描，从而达到相应的目的。换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。
```

#### 对撞指针

```c++
//对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。
/* 对撞指针是指在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。*/
        
//伪代码
function fn (list) {
  var left = 0;
  var right = list.length - 1;

  //遍历数组
  while (left <= right) {
    left++;
    // 一些条件判断 和处理
    ... ...
    right--;
  }
}

//对撞指针能够解决：：1.二分查找 2.两数之和 II - 输入有序数组 3.反转字符串 4.反转字符串中的元音字母 5.回文字符串
```

#### 快慢指针

```c++
/*快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为快指针（fast）和慢指针（slow），两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。*/

//伪代码
slow = head;
fast = head;
while (fast != NULL && fast->next != NULL) {
    slow = slow->next;
    fast = fast->next->next;
    if (slow == fast) {
        return true;
    }
}
return false;

//快慢指针能够解决：链表中倒数第k个节点  1.链表的中间节点 2.链表是否有环 3.链表环的长度 4.链表环的起点
//判断链表是否有环
bool hasCycle(ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }
    ListNode *slow = head; // 慢指针
    ListNode *fast = head->next; // 快指针
    while (slow != fast) { // 当快慢指针不相遇时
        if (fast == NULL || fast->next == NULL) { // 如果快指针到达链表尾部，说明链表没有环
            return false;
        }
        slow = slow->next; // 慢指针走一步
        fast = fast->next->next; // 快指针走两步
    }
    return true; // 如果快慢指针相遇，说明链表有环
}
```

### 散列表

#### [哈希表](https://zhuanlan.zhihu.com/p/144296454)

```c++
//哈希表是散列表 - 可以理解为哈希是映射的因子（我瞎编），哈希表本质上就是两个不同的数据集合映射的过程
简介：
 哈希表也叫散列表，哈希表是一种数据结构，它提供了快速的插入操作和查找操作，无论哈希表总中有多少条数据，插入和查找的时间复杂度都是为O(1)，因为哈希表的查找速度非常快，所以在很多程序中都有使用哈希表，例如拼音检查器。
    哈希表采用的是一种转换思想，其中一个中要的概念是如何将「键」或者「关键字」转换成数组下标？在哈希表中，这个过程有哈希函数来完成，但是并不是每个「键」或者「关键字」都需要通过哈希函数来将其转换成数组下标，有些「键」或者「关键字」可以直接作为数组的下标。我们先来通过一个例子来理解这句话。//数字和数字有映射关系，数字和字符要创造映射关系（虽然说字符也是数字，但是他们并没有映射关系：例如 1 - 1有映射，1 - 10086 没有，所以说我们需要用哈希创造他们的映射关系 - 是这样吗？） 
 我们上学的时候，大家都会有一个学号「1-n号」中的一个号码，如果我们用哈希表来存放班级里面学生信息的话，我们利用学号作为「键」或者「关键字」，这个「键」或者「关键字」就可以直接作为数据的下标，不需要通过哈希函数进行转化。如果我们需要安装学生姓名作为「键」或者「关键字」，这时候我们就需要哈希函数来帮我们转换成数组的下标。//键对应关键字 - 这就是映射关系
    
//哈希函数
    哈希函数的作用是帮我们把非int的「键」或者「关键字」转化成int，可以用来做数组的下标。比如我们上面说的将学生的姓名作为「键」或者「关键字」，这是就需要哈希函数来完成，下图是哈希函数的转换示意图。//就是将数据离散化是吧
```

![hash](hash.jpg)

```c++
//哈希函数的写法有很多中，我们来看看「HashMap」中的哈希函数
 static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

//「HashMap」中利用了「hashCode」来完成这个转换。哈希函数不管怎么实现，都应该满足下面三个基本条件：

//散列函数计算得到的散列值是一个非负整数
 如果 key1 = key2，那 hash(key1) == hash(key2)
 如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)  
 第一点：因为数组的下标是从0开始，所以哈希函数生成的哈希值也应该是非负数
 第二点：同一个key生成的哈希值应该是一样的，因为我们需要通过key查找哈希表中的数据//因为key是查找散列表中的值，如果两个相等的key映射的位置不同的话，那么我们就无法查找散列表的值
 第三点：看起来非常合理，但是两个不一样的值通过哈希函数之后可能才生相同的值，因为我们把巨大的空间转出成较小的数组空间时，不能保证每个数字都映射到数组空白处。所以这里就会才生冲突，在哈希表中我们称之为哈希冲突//数据足够大的时候，映射的格子不够多，那么就会出现哈希冲突 - 原因是因为映射关系这个本质，我们只是把一一对应离散化了，还是可能出现重复的

//哈希冲突
     哈希冲突是不可避免的，我们常用解决哈希冲突的方法有两种「开放地址法」和「链表法」
```

#### 链表查找

 在开放地址法中，若数据不能直接存放在哈希函数计算出来的数组下标时，就需要寻找其他位置来存放。在开放地址法中有三种方式来寻找其他的位置，分别是「线性探测」、「二次探测」、「再哈希法」

##### 线性探查

```c++
//线性探查  
  在线性探测哈希表中，数据的插入是线性的查找空白单元，例如我们将数88经过哈希函数后得到的数组下标是16，但是在数组下标为16的地方已经存在元素，那么就找17,17还存在元素就找18，一直往下找，直到找到空白地方存放元素。我们来看下面这张图 
    我们向哈希表中添加一个元素钱多多，钱多多经过哈希函数后得到的数组下标为0，但是在0的位置已经有张三了，所以下标往前移，直到下标4才为空，所以就将元素钱多多添加到数组下标为4的地方。//有位填数，没位向下搜索空白的位置 
//代码
//哈希函数 - size一般是质数？
int hash(int key) {
    return (key % size);
}
//插入
void insert(Student student) {
    int key = student.getKey();
    int hashVal = hash(key);
    while (array[hashVal] != NULL && array[hashVal].getKey() != -1) {
        ++hashVal;
        //超过数组大小 - 从第一个开始找
        hashVal %= size;
    }
    array[hashVal] = student;
}
int main() {
    LinearProbingHash hash = LinearProbingHash(10);
    Student student = Student(1,"张三");
    Student student1 = Student(2,"王强");
    Student student2 = Student(5,"张伟");
    Student student3 = Student(11,"宝强");
    hash.insert(student);
    hash.insert(student1);
    hash.insert(student2);
    hash.insert(student3);
    hash.disPlayTable();
}

//查找
Student* find(int key){
    int hashVal = hash(key);
    while (array[hashVal] !=nullptr){
        if (array[hashVal]->getKey() == key){
            return array[hashVal];
        }
        ++hashVal;
        hashVal %=size;
    }

    return nullptr;
}
```

![线性探查](线性探查.webp)

```c++
//线性筛查删除
 线性探测哈希表的删除相对来说比较复杂一点，我们不能简单的把这一项数据删除，让它变成空，为什么呢？
 线性探测哈希表在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定哈希表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。？
 因此我们需要一个特殊的数据来顶替这个被删除的数据，因为我们的学生学号都是正数，所以我们用学号等于-1来代表被删除的数据。
//后果
 这样会带来一个问题，如何在线性探测哈希表中做了多次操作，会导致哈希表中充满了学号为-1的数据项，使的哈希表的效率下降，所以很多哈希表中没有提供删除操作，即使提供了删除操作的，也尽量少使用删除函数。

public Student delete(int key){
    int hashVal = hash(key);
    while (array[hashVal] !=null){
        if (array[hashVal].getKey() == key){
            Student temp = array[hashVal];
            array[hashVal]= noStudent;
            return temp;
        }
        ++hashVal;
        hashVal %=size;
    }
    return null;
}        
```

![hash删除](hash删除.webp)

##### 二次筛查

```c++
//当然 二次筛查也不是完美的操作 
 在线性探测哈希表中，数据会发生聚集，一旦聚集形成，它就会变的越来越大，那些哈希函数后落在聚集范围内的数据项，都需要一步一步往后移动，并且插入到聚集的后面，因此聚集变的越大，聚集增长的越快。这个就像我们在逛超市一样，当某个地方人很多时，人只会越来越多，大家都只是想知道这里在干什么。
 二次探测是防止聚集产生的一种尝试，思想是探测相隔较远的单元，而不是和原始位置相邻的单元。在线性探测中，如果哈希函数得到的原始下标是x,线性探测就是x+1,x+2,x+3......，以此类推，而在二次探测中，探测过程是x+1,x+4,x+9,x+16,x+25......,以此类推，到原始距离的步数平方，为了方便理解，我们来看下面这张图//就是，我们通过记录前面的探查，可以减少探查的次数
 还是使用线性探测中的例子，在线性探测中，我们从原始探测位置每次往后推一位，最后找到空位置，在线性探测中我们找到钱多多的存储位置需要经过4步。在二次探测中，每次是原始距离步数的平方，所以我们只需要两次就找到钱多多的存储位置。
 二次探测消除了线性探测的聚集问题，这种聚集问题叫做原始聚集，然而，二次探测也产生了新的聚集问题，之所以会产生新的聚集问题，是因为所有映射到同一位置的关键字在寻找空位时，探测的位置都是一样的。
 比如讲1、11、21、31、41依次插入到哈希表中，它们映射的位置都是1，那么11需要以一为步长探测，21需要以四为步长探测，31需要为九为步长探测，41需要以十六为步长探测，只要有一项映射到1的位置，就需要更长的步长来探测，这个现象叫做二次聚集。
```

![img](https://pic2.zhimg.com/80/v2-0f9eb8694b479a0a5a034251a2b93135_720w.webp)

##### 双哈希

```c++
//双哈希是为了消除原始聚集和二次聚集问题，不管是线性探测还是二次探测，每次的探测步长都是固定的。双哈希是除了第一个哈希函数外再增加一个哈希函数用来根据关键字生成探测步长，这样即使第一个哈希函数映射到了数组的同一下标，但是探测步长不一样，这样就能够解决聚集的问题。
第二个哈希函数必须具备如下特点:
  1.和第一个哈希函数不一样
         2.不能输出为0，因为步长为0，每次探测都是指向同一个位置，将进入死循环，经过试验得出stepSize = constant-(key%constant);形式的哈希函数效果非常好，constant是一个质数并且小于数组容量
//我们将上面的添加改变成双哈希探测，示意图如下：           
```

![双哈希](双哈希.webp)

```c++
//双哈希
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int h[N],nxt[N],idx;
int find(int x){
    int t=(x%N+N)%N; // 计算哈希值
    for(int i=h[t];~i;i=nxt[i]) // 遍历哈希表中的链表
        if(e[i]==x)return 1; // 如果找到了键 x，返回 1
    return 0; // 否则返回 0
}
void insert(int x){
    int t=(x%N+N)%N; // 计算哈希值
    e[idx]=x;nxt[idx]=h[t];h[t]=idx++; // 将键值对插入到哈希表中
}
int main(){
    memset(h,-1,sizeof h); // 初始化哈希表为空
    int n;cin>>n;
    while(n--){
        char op;cin>>op;
        int x;cin>>x;
        if(op=='I')insert(x); // 如果是插入操作，将键 x 插入到哈希表中
        else{
            if(find(x))puts("Yes"); // 如果键 x 在哈希表中，输出 Yes
            else puts("No"); // 否则输出 No
        }
    }
    return 0;
}
```

##### 拉链法

![拉链](拉链法.png)

```c++
#include <stdio.h>

const int N = 1e5 + 3;          // 选取的质数为100003
int h[N], e[N], ne[N], idx;     // 构建邻接表

void insert(int x){             // 头插法
    int k = (x % N + N) % N;    // 除留余数法
    e[idx] = x;   ne[idx] = h[k];   h[k] = idx++;
}

bool query(int k){              // 查找
    int n = (k % N + N) % N;
    for(int i = h[n]; i != -1; i = ne[i]){
        if(e[i] == k)
            return true;
    }
    return false;
}

int main(){
    int m;      scanf("%d", &m);
    // 初始化邻接表
    for(int i = 0; i <= N; i++)       h[i] = -1;    
    
    while(m--){
        char op[2];     scanf("%s", op);
        int x;          scanf("%d", &x);
        
        if(*op == 'I')  insert(x);
        else{
            if(query(x))        puts("Yes");
            else                puts("No");
        }
    }

    return 0;
}
```

#### 字符串哈希

> [字符串哈希](https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811)

```c++
//字符串hash
 构造唯一数据表示字符串，可以理解为 f(x) = y。就是通过某种方法转化，使得两个毫无相关的数据产生关系。但是为了将映射关系进行一一对应，也就是，一个字符串对应一个数字，那么一个数字也对应一个字符串。
 用字符串Hash的目的是，我们如果要比较一个字符串，我们不直接比较字符串，而是比较它对应映射的数字，这样子就知道两个“子串”是否相等。从而达到，子串的Hash值的时间为 O(1)，进而可以利用“空间换时间”来节省时间复杂的。
    我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。不用担心，接下来的内容正要讲解。//我们只需要用到数字来匹配数据，这样对数字操作就可以得到我们想要的操作了
```

##### 构造字符串hash

```c++
//简单例子
 假如给你一个数字1166，形式上你只知道它只是1和6的组合，但你知道它代表的实际大1*10^3+1*10^2+6*10^1+6*10^0。
 同理，给你一个字符串，要把它转换为数字，就可以先把每一个字符都先对应一个数字，然后把它们按照顺序乘以进制（Base）的幂进行相加，然后这个数可能很大，所以一般会取余数（MOD）。    
//具体操作
    根据上面的理解，其实将字符串映射成数字，和我们平时的将一个 某Base进制数，变为一个十进制数，相类似。//把字符串当成 某种进制的数据，把字符串拆成很多位，然后对每一个位置的字符都进行哈希操作，再用进制的乘法操作将他们拼接起来。
 我们先定义以下：
 给定一个字符串 S = s1s2s3...sn，对于每一个si就是一个字母，那么我们规定
         idx(si) = si-'a'+1 （当然也可以直接用其ASCII值）
 构造字符串Hash总共有三种方法。每一种方法，主要都是用使用 Base 和 MOD（都要求是素数），一般都是 Base  < MOD，同时将Base和MOD尽量取大即可，这种情况下，冲突（即不同字符串却有着相同的hash值）的概率是很低的

//1.自然溢出方法 - 后面还有
 对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 unsigned long long 整数的自然溢出
```

```c++
//怎么构建我们的字符串前缀
  1.将整个数组 当做是一个p进制的数。 通过这样的方式，将我们的字符串变成数字进行操作（本质上 字符串也是数字） - 但是我们这个数组转化完成可能会非常大 那么我们就mod一个大的数据 - 通过这样的方法映射到小区间中 //取模会重复怎么办 还是说随机存储
    2.字符串哈希完全不考虑冲突的情况 
    3. p = 131 or 13331 - Q = 2e64 这样可以忽略冲突 （溢出等价于 mod 2e64）
```

![image-20230226201946750](字符串哈希.png)

标准流程

![原理](字符串hash1.png)

![原理2](字符串hash2.png)

```c++
//相当于将字符型映射为整型（本来就是 将字符串映射成一个p进制的数据 - p一般为质数）
typedef unsigned long long ULL;
const int P = 131;
// p[i] = P^i, h[i] = s[1~i]的hash值
ULL p[N],h[N];

//预处理
void init()
{
    //字符串长度就是对应的进制 p^n - 也可以说是长度是项数的个数
    p[0] = 1,h[0] = 0;
    for(int i = 1;i<=n;i++){
        p[i] = p[i-1]*P; //P是进制
        h[i] = h[i-1]*P+s[i];//s是对应字符的ASCII值是吧
    }
}
//计算s[l~r]的哈希值
ULL get(int l,int r)
{
    return h[r]-h[l-1]*p[r-l+1];
}
//判断两个子串是否相等
bool substr(int l1,int r1,int l2,int r2){
    return get(l1,r1) == get(l2,r2);
}

//总结：字符串哈希使用来解决字符串匹配，查找去重的问题的。
```

![原理3](字符串hash原理3.png)

### 高精度

#### **高精度加法计算**

> 如果我们要将一个很大的数据与一个很小的数据相加应该怎么办，你可能会想，直接加就行了嘛，10000+1=10001，很简单。但是，在计算机中，我们使用的数据类型在计算的时候，往往会将小的数据忽略掉，也就是`1e99+1 = 1e99`,而1就不见了。我们需要的是保持精度的情况下进行加法，这个时候我们可以利用我们的线性表，数组来实现这个保留精度的加法。A+B（这里的情况是一个大的数据加上另一个大的数据）。
>
>   依照上面的说法，我们就开辟两个字符串数组（比较好分离数据），一个a【】存A这个数据，一个b【】存B这个数据。但为了方便接下来的操作，我们还是开辟两个Vector(向量：是个容器)，然后将输入的a,b中的数据导入到我们的vector中，这个时候注意一个细节。
>
>   我们插入的数据是要倒着插入的，举个例子：123456789，这是一个大的数据，倒着插入意味着个位在数组（容器）的前面（之后的数据以此类推）。在数组中就变成了987654321，这样做的好处是进位不用移动数组中的元素，你看我们的目的是要计算这些大数据的加和，在加和的过程中免不了会产生进位，如果用123456789，进一位的话就要移动整个数组，就十分复杂。如果反过来，我们只需要在进的那位尾插一个数据就行。
>
>   同时，计算方法其实就和我们手工计算的差不多，对位计算加上进位即可，举个例子：1+9 = 10，其实就是十位上面+进位 t=1 = 10,就是这样。

代码实现

```c++
//C = A+B c是我们要实现的结果
vector<int> add(vector<int> &A,vector<int> &B)
{
    vector<int> C;//这是结果
    
    int t = 0//进位
    for(int i = 0;i<A.size()||i<B.size();i++)//只要没遍历完最长的就继续
    {
        //下面实现的是 t在i这个位置的值，然后%10就是这个位置剩下的值，/10就是进位的值保留到i+1（下一位）
        if(i<A.size()) t+=A[i];
        if(i<B.size()) t+=B[i];
        C.push_back(t%10);//将对应位置的数据插入结果
        t/=10;
    }
    if(t) C.push_back(1);//进大位，出来t/10还有剩，那肯定进位了（我们是倒叙输入的嘛）
    return C;
}
//倒叙输入
int main()  
{
    string a,b;
    vector<int> A,B;
    cin>>a>>b;//自己输入两个大的数据
    //为啥是size-1，就是0到i有i-1个数据嘛
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//倒着插入
    for(int i = b.size()-1;i>=0;i--) B.push_back(b[i] - '0');
    //自动判断是啥类型
    auto C = add(A,B);//调用模板
    //输出
    for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
    return 0;
    
}


```

#### **高精度减法计算**

  减法的计算其实和加法差不多，但是我们需要满足一些条件；`1.A>=B` 不满足就要交换两个数据的值（加上负号）2.向前借位是`+10`（对于当前位数）所以说方向就很明确了，加上一个判断A,B大小的关系，对 t 改一下就行。

```c++
bool cmp(vector<int> &A,vector<int> &B)
{
    if(A.size()!=B.size()) return A.size()>B.size();
    for(int i = A.size()-1;i>=0;i--)
        if(A[i]!=B[i]) return A[i]>B[i];
    return true;
}

//C = A-B c是我们要实现的结果
vector<int> sub(vector<int> &A,vector<int> &B)/模板
{
    vector<int> C;//这是结果
    for(int i = 0,t = 0;i<A.size()||i<B.size();i++)//只要没遍历完最长的就继续
    {
  t = A[i] - t;//t是借位的
        if(i<B.size()) t -= B[i];
        C.push_back((t+10)%10);//这里的t有两种情况，一种减完之<0，那就需要借位+10.一种是减完之后>=0，不需要借位。这个时候，(t+10)%10这两种情况都满足，举个例子：1.你减完之后变成了-9，那就是要借一位，就是-9+10 = 1,1%10还是1.2.你减完之后，还剩下9，那么9%10还是9.
        if(t<0) t = 1;
        else t = 0;
    }
    while(C.size() > 1&&C.back()== 0) C.pop_back();
    return C;

}
//倒叙输入
int main()  
{
    string a,b;
    vector<int> A,B;
    cin>>a>>b;//自己输入两个大的数据
    //为啥是size-1，就是0到i有i-1个数据嘛
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//倒着插入
    for(int i = b.size()-1;i>=0;i--) B.push_back(b[i] - '0');
    
    //用上面的判断，计算A-B 或者 B-A
    if(cmp(A,B))
    {
        auto C = sub(A,B);
        for(int i = C.size()-1;i>=0;i --) printf("%d",C[i]);
    }
    else
    {
        auto C = sub(B,A);//B>A
        printf("-");
        for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
    }
    return 0;
    
}

```

#### 高精度乘法计算

大数据乘小数据

 在人工计算乘法的时候，我们一般是一位一位的计算，例如：`123乘12`，那么一般是2 `*123+10* 123`。但是这样其实比较繁琐，我们在计算高精度的时候，可以把这两个数据中的小数据，单独拿出来做一个整体，就上面那个来说，就变成了`1 *12* 100+2 *12* 10+3 *12* 1`，竖式就由两个变成一个了。

 同时，在计算的时候，每一个位的位数t也需要注意，举个例子：`123456789*12`，这里的 （第一位）a = 9,进位就变成了 `t = 9* 12/10`，输入到结果C的就变成了 (第一位)`C = 9*12%10`，这样就定下来了。下面是代码演示。

```c++
vector<int> mul(vector<int> &A,int b)//b比较小就直接用int表示（整体）
{
    vector<int> C;
    int t = 0;
    for(int i = 0;i<A.size()||t;i++)
    {
        if(i<A.size()) t+=A[i]*b;//遍历位置乘完的数据
        c.push_back(t%10);//插进去计算完成之后这个位置的具体数
        t/=10;//进位
        
    }
    return C;
    
}
//插入数据
int main()
{
    string a;//数据大用字符串存储
    int b;
    cin>>a>>b;
    vector<int> A;
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//这里是把字符串转化成具体的数，由ASCII决定的，在字符'0'代表的是48
    auto C = mul(A,b);//调用容器
    
    for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
}
```

#### 高精度除法计算

大数据除小数据（一般用的不多）

在人工计算除法的时候，一般是从大到小位去除的。但是，一个题目难免会出现加减乘除多种运算，所以说我们还是尾插大数据把。具体做法和乘法差不多，就是把小的看成整体（平常我们算除法是这样）下面是代码演示。

```c++
vector<int> div(vector<int> &A,int b,int &r)//b是小的
{
 vector<int> C;
    r=0;
    for(int i = A.size()-1;i>=0;i--)
    {
        r = r*10+A[i];//计算的时候，和我们把上一位除不了移下来算是一个样子的
        C.push_back(r/b);//余数插入结果中
        r%=b;//除完之后的余数
        
    }
    reverse(C.begin(),C.end());//翻转
    while(C.size()>1&&C.back() == 0) C.pop_back();//去除前端0
    return C;
}
//插入数据
int main()
{
    string a;//数据大用字符串存储
    int b;
    cin>>a>>b;
    vector<int> A;
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i] - '0');//这里是把字符串转化成具体的数，由ASCII决定的，在字符'0'代表的是48
    int r;
    auto C = div(A,b,r);//调用容器
    
    for(int i = C.size()-1;i>=0;i--) printf("%d",C[i]);
}
```
