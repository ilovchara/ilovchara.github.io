---
title: 数据结构 - 对数据的基本操作
date: 2023-04-26 20:50:57
description: "简单讲讲运用数组实现的几个算法"
typora-root-url: 对数据的简单操作
categories: 算法
tags: 数据结构
---

## 对数据的常见操作

### [前缀和](https://blog.csdn.net/weixin_45629285/article/details/111146240)

前缀和，是一个序列的前n项和，可以理解为高中的数列的前n项和。如果给你一个数组，要求你求出这个数组中某段区间的和，我们可以用遍历区间的方式来求和，下面是求得区间和的朴素算法。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int main()
{
 	int a[N];
    for(int i = 1;i<=n;i++) cin>>a[i];
    //记录和
    int ans;
    
    //输入两个区间
    int l,r;
    cin>>l>>r;
    //累加
    for(int i = l;i<=r;i++) ans+=a[i];
    cout<<ans;
}
```

但是这样做，如果求多个区间和就要多次遍历，这样时间复杂度会很高，索性我们在输入数据的同时，构造前缀和数组`S[]`使得每一个`S[]`数组的下标表示一段从1开始(也可以从数组下标0开始)的连续的区间和，下面是代码。

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int main()
{
    int a[N],S[N];
    
    //构造前缀和数组
    for(int i = 1;i<=n;i++){
        cin>>a[i];
        s[i] += s[i-1]+a[i];
    }    
    
}
```

当我们需要求得一个区间的和的时候，可以利用前缀和的思想，例如给一个数组`a[5] = {1,2,3,4,5}`，要求区间`2-3`的和。由`S[]`数组的性质我们可以得到，`S[3]-S[1] = a[2]+a[3](展开就知道了)`，所以说对于任意的区间`[l,r]`,有`区间和 = S[r] - S[l-1]`,下面是根据推断得到的代码

```c++
#include <iostream>

using namespace std;

const int N = 100010;

int n, m;
int a[N], s[N];

int main()
{
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i ++ ) scanf("%d", &a[i]);
    //构造前缀和
    for (int i = 1; i <= n; i ++ ) s[i] = s[i - 1] + a[i]; 

    while (m -- )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        printf("%d\n", s[r] - s[l - 1]); // 区间和的计算
    }

    return 0;
}
```

### 二维前缀和

一维前缀和是在一维数组构造的，二维前缀和是在二维数组构造的。一维前缀和求的是区间和，二位前缀和求的是矩阵和，在构造二维前缀和之前，我们先构造y一个简单的矩阵和来看看，下面是朴素算法

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int main()
{
    int a[N][N];
    for(int i = 1;i<=n;i++)
        for(int j = 1;j<=n;j++)
            cin>>a[i][j];
    //输入区间坐标
    int x1,y1;
    int x2,y2;
    
    int ans;
    for(int i = x1;i<=x2;i++)
        for(int j = x2;j<=x2;j++)
            ans+=a[i][j];
    cout<<ans;    
    return 0;
}
```

![二维前缀和](二维前缀和.png)

我们只用图形来理解，如果我们需要求得红色区间的值应该怎么做。直接用最大的蓝色矩阵减去绿色和紫色小条就行。减去完发现多减了一个`a[i][j]`,加上即可，如下图所示。

![二维前缀和分解](二维前缀和分解.png)

从上图的结论中我们很容易看出，整个外围蓝色矩形面积`s[i][j]` = 绿色面积`s[i - 1][j]` + 紫色面积`s[i][j - 1]` - 重复加的红色的面积`s[i - 1][j - 1]` + 小方块的面积`a[i][j]`

**因此得出二维前缀和预处理公式**（求得从`11`开始的子矩阵的所有和）

`s[i][j] = s[i - 1][j] + s[i][j - 1 ] + a[i] [j] - s[i - 1][j - 1]`

**接下来回归问题**(求子矩阵的和)去求以`(x1,y1)`为左上角和以`(x2,y2)`为右下角的矩阵的元素的和。

![求起点不同的子矩阵](求起点不同的子矩阵.png)

**紫色面积**是指 `(1, 1)`左上角到`(x1 - 1, y2)`右下角的矩形面积 ，**黄色面积**是指`(1, 1)`左上角到`(x2, y1 - 1)`右下角的矩形面积。

**不难推出：**

![分解子矩阵](分解子矩阵.png)

绿色矩形的面积 = `整个外围面积s[x2, y2] - 黄色面积s[x2, y1 - 1] - 紫色面积s[x1 - 1, y2] + 重复减去的红色面积 s[x1 - 1, y1 - 1]`

因此二维前缀和的结论为：

**`以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
s[x2, y2] - s[x1 - 1, y2] - s[x2, y1 - 1] + s[x1 - 1, y1 - 1]`**

下面是例题代码

![image-20230827153429879](image-20230827153429879.png)

```c++
#include <iostream>
using namespace std;
const int N = 1010;
int n, m, q;
int s[N][N];
int main()
{
    scanf("%d%d%d", &n, &m, &q);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            scanf("%d", &s[i][j]);
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= m; j ++ )
            s[i][j] += s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1];
    while (q -- )
    {
        int x1, y1, x2, y2;
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }
    return 0;
}
```

[一维差分](https://blog.csdn.net/weixin_45629285/article/details/111146240)

![差分](差分.png)

类似于数学中的求导和积分，差分可以看成前缀和的逆运算。

差分数组：

首先给定一个原数组`a：a[1], a[2], a[3],,,,,, a[n];`

然后我们构造一个数组`b ： b[1], b[2], b[3],,,,,, b[i];`

使得 `a[i] = b[1] + b[2] + b[3] + ,,,,,, + b[i]`

也就是说，a数组是b数组的前缀和数组，反过来我们把b数组叫做a数组的差分数组。换句话说，每一个**`a[i]都是b数组中从头开始的一段区间和`**。

考虑如何构造差分b数组？最为直接的方法

如下：

![差分1](差分1.png)

我们只要有b数组，通过前缀和运算，就可以在O(n) 的时间内得到 a 数组 。知道了差分数组有什么用呢？ 别着急，慢慢往下看。

话说有这么一个问题：

给定区间`[l, r ]，让我们把a数组中的[l, r] 区间中的每一个数都加上c,即 a[l] + c , a[l + 1] + c , a[l + 2] + c ,,,,,, a[r] + c;`

暴力做法是`for循环l到r区间`，时间复杂度`O(n)`，如果我们需要对原数组执行m次这样的操作，时间复杂度就会变成`O(n * m)`。有没有更高效的做法吗? 考虑差分做法，(差分数组派上用场了)。

始终要记得，a数组是b数组的前缀和数组，比如对b数组的b[i]的修改，会影响到a数组中从a[i]及往后的每一个数。

首先让差分b数组中的 `b[l] + c ,通过前缀和运算，a数组变成 a[l] + c ,a[l + 1] + c,,,,,, a[n] + c`;

然后我们打个补丁，`b[r + 1] - c, 通过前缀和运算，a数组变成 a[r + 1] - c,a[r + 2] - c,,,,,,,a[n] - c`;

为啥还要打个补丁？

我们画个图理解一下这个公式的由来:

![差分构成](差分构成.png)

`b[l] + c`，效果使得a数组中` a[l] `及以后的数都加上了c(红色部分)，但我们只要求l到r 区间加上 c, 因此还需要执行 `b[r + 1] - c`,让a数组中`a[r + 1]`及往后的区间再减去c(绿色部分)，这样对于`a[r]` 以后区间的数相当于没有发生改变。

因此我们得出一维差分结论：给a数组中的`[ l, r]` 区间中的每一个数都加上c,只需对差分数组b做 `b[l] + = c, b[r+1] - = c`。时间复杂度为O(1), 大大提高了效率。

![在这里插入图片描述](20201217172005485.png)

![image-20230827155704438](image-20230827155704438.png)

```c++
//模版代码
#include<iostream>
using namespace std;
const int N = 1e5+10;
int a[N],b[N],c[N];
int n,m;
//构造差分数组的函数
void insert(int l,int r,int c)
{
    b[l]+=c;
    b[r+1]-=c;
}

int main()
{
    cin>>n>>m;
    //输入构造差分数组的原数组
    for(int i = 1;i<=n;i++) cin>>a[i];
    //构造差分序列 - b就是差分数组
    for(int i = 1;i<=n;i++) insert(i,i,a[i]);
    
    while(m--)
    {
        int l,r,c;
        cin>>l>>r>>c;
        //插入更改的值
        insert(l,r,c);
    }
    //这里是析出原数组
    for(int i = 1;i<=n;i++) c[i] = c[i-1]+b[i];
    //输出
    for(int i = 1;i<=n;i++) cout<<c[i]<<" ";
    
    
}
```

### 二维差分

如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上c,是否也可以达到O(1)的时间复杂度。答案是可以的，考虑二维差分。

a[][]数组是b[][]数组的前缀和数组，那么b[][]是a[][]的差分数组

原数组：`a[i][j]`

我们去构造差分数组： `b[i][j]`

使得a数组中`a[i][j]`是b数组左上角`(1,1)`到右下角`(i,j)`所包围矩形元素的和。

如何构造b数组呢？

其实关于差分数组，我们并不用考虑其构造方法，因为我们使用差分操作在对原数组进行修改的过程中，实际上就可以构造出差分数组。

同一维差分，我们构造二维差分数组目的是为了 让原二维数组a中所选中子矩阵中的每一个元素加上c的操作，可以由`O(n*n)`的时间复杂度优化成`O(1)`

已知原数组a中被选中的子矩阵为 以`(x1,y1)`为左上角，以`(x2,y2)`为右下角所围成的矩形区域;

始终要记得，**a数组是b数组的前缀和数组，比如对`b`数组的`b[i][j]`的修改，会影响到`a`数组中从`a[i][j]`及往后的每一个数。**

假定我们已经构造好了`b`数组，类比一维差分，我们执行以下操作
来使被选中的子矩阵中的每个元素的值加上`c`

`b[x1][y1] + = c ;`

`b[x1][y2+1] - = c;`

`b[x2+1][y1] - = c;`

`b[x2+1][y2+1] + = c;`

每次对`b`数组执行以上操作，等价于：

```c++
for(int i = x1;i <= x2;i++)
  for(int j = y1;j <= y2;j++)
      a[i][j] += c;
```

![二维差分](二维差分.png)

`b[x1][y1] += c;` 对应图1 ,让整个a数组中蓝色矩形面积的元素都加上了c。
`b[x1,][y2 + 1] -= c;` 对应图2 ,让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。
`b[x2 + 1][y1] -= c;` 对应图3 ,让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。
`b[x2 + 1][y2 + 1] += c;` 对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，才能使其恢复。

![二维差分分解](二维差分分解.png)

**我们将上述操作封装成一个插入函数:**

```c++
void insert(int x1,int y1,int x2,int y2,int c)
{     
    //对b数组执行插入操作，等价于对a数组中的(x1,y1)到(x2,y2)之间的元素都加上了c
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
```

我们可以先假想`a`数组为空，那么`b`数组一开始也为空，但是实际上`a`数组并不为空，因此我们每次让以`(i,j)`为左上角到以`(i,j)`为右下角面积内元素(其实就是一个小方格的面积)去插入 `c = a[i][j]`，等价于原数组`a中(i,j) 到(i,j)`范围内 加上了 `a[i][j]`,因此执行`n*m`次插入操作，就成功构建了差分b数组.

**这叫做曲线救国。**

```c++
 for(int i = 1;i <= n;i++)
  {
      for(int j = 1;j <= m;j++)
      {
          insert(i, j, i, j, a[i][j]);    //构建差分数组
      }
  }
```

当然关于二维差分操作也有直接的构造方法，**公式如下：**

```c++
b[i][j] = a[i][j] − a[i − 1][j] − a[i][j − 1] + a[i −1 ][j − 1]
```

二维差分数组的构造同一维差分思维相同，因次在这里就不再展开叙述了。

![1](20201217172035975.png)

![image-20230827161505699](image-20230827161505699.png)

```c++
#include<iostream>
#include<cstdio>
using namespace std;
const int N = 1e3 + 10;
int a[N][N], b[N][N];
void insert(int x1, int y1, int x2, int y2, int c)
{
    b[x1][y1] += c;
    b[x2 + 1][y1] -= c;
    b[x1][y2 + 1] -= c;
    b[x2 + 1][y2 + 1] += c;
}
int main()
{
    int n, m, q;
    cin >> n >> m >> q;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            insert(i, j, i, j, a[i][j]);      //构建差分数组
        }
    }
    while (q--)
    {
        int x1, y1, x2, y2, c;
        cin >> x1 >> y1 >> x2 >> y2 >> c;
        insert(x1, y1, x2, y2, c);
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            //二维前缀和
            b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1];  
        }
    }
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            printf("%d ", b[i][j]);
        }
        printf("\n");
    }
    return 0;
}
```

### [双指针](https://www.cnblogs.com/huansky/p/13508533.html)

双指针，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（*快慢指针*）或者相反方向（*对撞指针*）的指针进行扫描，从而达到相应的目的。换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。

#### 对撞指针

对撞指针是指在数组中，将指向最左侧的索引定义为`左指针(left)`，最右侧的定义为`右指针(right)`，然后从两头向中间进行数组遍历。

> 对撞数组适用于连续数组和字符串，也就是说当你遇到题目给定连续数组和字符床时，应该第一时间想到用对撞指针解题。

```c++
//伪代码
function fn (list) {
  var left = 0;
  var right = list.length - 1;

  //遍历数组
  while (left <= right) {
    left++;
    // 一些条件判断 和处理
    ... ...
    right--;
  }
}

//对撞指针能够解决：：1.二分查找 2.两数之和 II - 输入有序数组 3.反转字符串 4.反转字符串中的元音字母 5.回文字符串
```

![image-20230828114701956](image-20230828114701956.png)

```c++
//实现函数
void reS(char s[]){
    int length = strlen(s); // 计算数组长度
    if(length == 0 || length == 1) return;
    int left = 0;
    int right = length - 1;
    while(left < right){
        // 交换数据
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp; 
        left++; 
        right--; 
    }
    return;
}
```

#### 快慢指针

快慢指针也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为`快指针（fast）`和`慢指针（slow）`，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如 fast 每次增长两个，slow 每次增长一个。

> 一般快慢指针用于维护区间

```c++
//伪代码
slow = head;
fast = head;
while (fast != NULL && fast->next != NULL) {
    slow = slow->next;
    fast = fast->next->next;
    if (slow == fast) {
        return true;
    }
}
return false;

//快慢指针能够解决：链表中倒数第k个节点  1.链表的中间节点 2.链表是否有环 3.链表环的长度 4.链表环的起点
//判断链表是否有环
bool hasCycle(ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }
    ListNode *slow = head; // 慢指针
    ListNode *fast = head->next; // 快指针
    while (slow != fast) { // 当快慢指针不相遇时
        if (fast == NULL || fast->next == NULL) { // 如果快指针到达链表尾部，说明链表没有环
            return false;
        }
        slow = slow->next; // 慢指针走一步
        fast = fast->next->next; // 快指针走两步
    }
    return true; // 如果快慢指针相遇，说明链表有环
}
```

快慢指针案例：**[滑动窗口](https://www.cnblogs.com/huansky/p/13488234.html)**

```c++

```

## [哈希表](https://zhuanlan.zhihu.com/p/496515259)*

### 哈希表的实现

> 实现方法可以看看，实际上用的是`stl`中的`hash`，可以直接理解成 `输入数据 -> f(x) ->映射为另一数据`，不需要太过于纠结怎么实现的原理

[散列表](https://www.cnblogs.com/lisen10/p/10876344.html)（Hash Table）是一种特殊的数据结构，它最大的特点就是可以快速实现查找、插入和删除。我们知道，数组的最大特点就是：寻址容易，插入和删除困难；而链表正好相反，寻址困难，而插入和删除操作容易。那么如果能够结合两者的优点，做出一种寻址、插入和删除操作同样快速容易的数据结构，那该有多好。这就是哈希表创建的基本思想，而实际上哈希表也实现了这样的一个“夙愿”，哈希表就是这样一个集查找、插入和删除操作于一身的数据结构。哈希表（Hash Table）：也叫散列表，是根据关键码值（key-value）而直接进行访问的数据结构，也就是我们常用到的map。

> map<a,b>: a经过哈希函数变为b，产生映射关系
>
> hash表本质是数组，讲一个散列的数据集中到一个数组上，用最少资源按照一定的逻辑存储我们的数据
>
> 说人话就是大范围关键字存储改为小范围关键字存储

哈希函数：也称为是散列函数，是Hash表的映射函数，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数能使对一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。

> 哈希函数相当于排列规则，我们可以依靠这个排列规则排列键的顺序，同时也可以用这个排列规则寻找我们的值.
>
> 如果用日常生活来举例的话，哈希表就像是我们的字典目录一样。

哈希表和哈希函数的标准定义：若关键字为k，则其值存放在h(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为哈希函数，按这个思想建立的表为哈希表。

设计出一个简单、均匀、存储利用率高的散列函数是散列技术中最关键的问题。
但是，一般散列函数都面临着冲突的问题。两个不同的关键字，由于散列函数值相同，因而被映射到同一表位置上。该现象称为冲突(Collision)或碰撞。发生冲突的两个关键字称为该散列函数的同义词(Synonym)。

![散列表原理](v2-34a5a0d0cbff54649d0175f5126214cc_720w.webp)

哈希表的实现就是映射函数构造，看某个元素具体属于哪一个类别。如何构造我们要考虑两个问题：

- n个数据原仅占用n个地址，虽然散列查找是以空间换时间，但仍希望散列的地址空间尽量小。
- 无论用什么方法存储，目的都是尽量均匀地存放元素，以避免冲突。

### **[直接定位法](https://www.xiuxingstudio.com/computer/%E7%A8%8B%E5%BA%8F%E7%AE%97%E6%B3%95/4195.html)**

`Hash(key) = a·key + b (a、b为常数)`

**优点**：以关键码key的某个线性函数值为哈希地址，不会产生冲突.

**缺点**：要占用连续地址空间，空间效率低。

**例：**关键码集合为`{100，300，500，700，800，900}`， 选取哈希函数为`Hash(key)=key/100`， 则存储结构（哈希表）如下：

![img](1622171-20190525161418247-402666349.png)

这种方法计算最简单，且**不会产生冲突**。**适合于关键字分布基本连续的情况**，**如果关键字分布不连续，空位较多，则会造成存储空间的浪费**。

举一个例子，假设有一个记录了从 1 岁到 100 岁的人口数字统计表。其中年龄为关键字，哈希函数取关键字自身，如下表所示。

![哈希函数（一）-直接定址法、除留余数法、平方取中法](webp.png)

比如想要查询 25 岁的人有多少，则只要查询表中第 25 项即可。

> 这种方法一般不使用，除非是我们查询的表比较简单的情况之下。

#### **除留余数法**

`Hash(key) = key mod p (p是一个整数)`

**特点**：以关键码除以p的余数作为哈希地址。

**关键**：如何选取合适的p？

**技巧**：若设计的哈希表长为m，则一般取p≤m且为质数 （也可以是不包含小于20质因子的合数）。

> 取p≤m且为质数是为了少开区间，mod质数是为了输出不同区间的值，让数据更加散乱。
>
> 这种方法是最常见构造散列表的方法

#### 乘余取整法

`Hash(key) = [B*( A*key mod 1 ) ]`下取整 `(A、B均为常数，且0<A<1，B为整数)`

**特点：**以关键码key乘以A，取其小数部分，然后再放大B倍并取整，作为哈希地址。

**例：**欲以学号最后两位作为地址，则哈希函数应为： `H(k)=100*(0.01*k % 1 )`其实也可以用法2实现：`H(k)=k % 100`

这也是一种简单且常用的哈希函数方法。其关键点在于`p` 的选择。**根据经验而言，一般 `p` 取素数或者 `m`，这样可以尽可能的减少冲突。**

比如我们需要将 7 个数 [432, 5, 128, 193, 92, 111, 88] 存储在 11 个区块中（长度为 11 的数组），通过除留余数法将这 7 个数应分别位于如下地址：

![哈希函数（一）-直接定址法、除留余数法、平方取中法](webp-1693208563347-31.png)

比如432，对11取余数，余数为3，放在03位置

#### **数字分析法**

**特点：**某关键字的某几位组合成哈希地址。所选的位应当是：各种符号在该位上出现的频率大致相同。

例：有一组（例如80个）关键码，其样式如下：

![img](./1622171-20190525162109183-1593077689.png)

#### **平方取中法**

**特点：**对关键码平方后，按哈希表大小，取中间的若干位作为哈希地址。

**理由**：因为中间几位与数据的每一位都相关。

**例**：2589的平方值为6702921，可以取中间的029为地址。

#### **折叠法**

**特点：**将关键码自左到右分成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。

**适用于**：每一位上各符号出现概率大致相同的情况。

法1：移位法 ── 将各部分的最后一位对齐相加。

法2：间界叠加法──从一端向另一端沿分割界来回折叠后，最后一位对齐相加。

**例：**元素`42751896, 用法1： 427＋518＋96=1041   用法2： 427 518 96—> 724+518+69 =1311`

### 哈希表优化冲突*

Hash表解决冲突的方法主要有以下几种：

> 开放定址法（开地址法）、 链地址法（拉链法）、 再哈希法（双哈希函数法）、 建立一个公共溢出区，而最常用的就是**开发定址法**和**链地址法**。

#### **[开放寻址法](https://www.cnblogs.com/east7/p/12594894.html)**

 **开放寻址法**：又称开放定址法，当哈希碰撞发生时，从发生碰撞的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。这个空闲单元又称为开放单元或者空白单元。

> 就是映射的位置有数了，就在这个位置的下一个位置存储，如果还有继续查找下一个位置以此类推。

 查找时，如果探查到空白单元，即表中无待查的关键字，则查找失败。开放寻址法需要的表长度要大于等于所需要存放的元素数量，非常适用于装载因子较小（小于0.5）的散列表。

 开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记，直到有下个元素插入才能真正删除该元素。

​    可以把开放寻址法想象成一个停车问题。若当前车位已经有车，则继续往前开，直到找到一个空停车位。

![img](1208468-20200329205724302-384212505.png)

**设计思路：**有冲突时就去寻找下一个空的哈希地址，只要哈希表足够大，空的哈希地址总能找到，并将数据元素存入。

**含义：**一旦冲突，就找附近（下一个）空地址存入。

 开放寻址法的基本函数是：

```c++
Hi(key)=(H(key) + f(i)) MOD m, i=0,1,2,…, k(k<=m-1)，
```

> 其中，**m** 为散列表长度，一般为素数；
>
> **H(key)** 为散列函数，用于计算索引，key为关键字值；
>
> **f(i)** 为增量序列，用于解决冲突，且`f(0) = 0`，i为已经尝试计算索引的次数。
>
> 当散列值`H0(key)`发生冲突时，再计算`H1(key)`……，直到不冲突为止。

实现步骤

> 得到给定的 `key`；
>
> 根据函数计算得 `hashValue`；
>
> 若不冲突，则把关键字值存入下标为`hashValue`的桶；
>
> 若冲突，则使 i++ ，也就是往后找，直到找到第一个空桶并填入当前key。若到了尾部则循环到前面。

##### **线性探查法**

 冲突函数：是`i`的一次多项式，典型取法为`f(i)=i`。

​    线行探查法(Linear Probing)是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。

​    对于一个散列表，在散列过程中，某些元素形成一些区块，这种现象称作`一次聚集（primary clustering）`。就是说，散列到区块中的任何关键字都需要多次探测才可以解决哈希碰撞，然后，把该关键字添加到相应区块的桶中。

下面是一道[例题](https://blog.csdn.net/ChenYiRan123456/article/details/128570110)用线性探查实现开放寻址法

![image-20230829145845885](./image-20230829145845885.png)

```c++
#include <cstring>
#include <iostream>

using namespace std;

const int N = 200003, null = 0x3f3f3f3f;

int h[N];

int find(int x)
{
    int t = (x % N + N) % N;
    //开放寻址法就是 挨个找，找不到就算，找到了就返回呗
    while (h[t] != null && h[t] != x)//没到尽头和不为我们的目标值
    {
        t ++ ;
        if (t == N) t = 0;//指针回位
    }
    return t;
}

int main()
{
    memset(h, 0x3f, sizeof h);

    int n;
    scanf("%d", &n);

    while (n -- )
    {
        char op[2];
        int x;
        scanf("%s%d", op, &x);
        if (*op == 'I') h[find(x)] = x;
        else
        {
            if (h[find(x)] == null) puts("No");
            else puts("Yes");
        }
    }

    return 0;
}

```

#### [拉链法](https://www.acwing.com/solution/content/30169/)

**基本思想**：将具有相同哈希地址的记录链成一个单链表，m个哈希地址就设m个单链表，然后用一个数组将m个单链表的表头指针存储起来，形成一个动态的结构。

**注：**有冲突的元素可以插在表尾,也可以插在表头

**例**：设`{ 47, 7, 29, 11, 16, 92, 22, 8, 3, 50, 37, 89 }`的哈希函数为： `Hash(key)=key mod 11`， 用拉链法处理冲突，则建表如下图所示。

![img](1622171-20190525164856289-1731976151.png)

```c++
/*拉链法实现上诉题目*/
#include <cstring>
#include <iostream>

using namespace std;

const int N = 1e5 + 3;  // 取大于1e5的第一个质数，取质数冲突的概率最小 可以百度

//* 开一个槽 h
int h[N], e[N], ne[N], idx;  //邻接表

void insert(int x) {
    // c++中如果是负数 那他取模也是负的 所以 加N 再 %N 就一定是一个正数
    int k = (x % N + N) % N;
    e[idx] = x;
    ne[idx] = h[k];
    h[k] = idx++;
}

bool find(int x) {
    //用上面同样的 Hash函数 讲x映射到 从 0-1e5 之间的数
    int k = (x % N + N) % N;
    for (int i = h[k]; i != -1; i = ne[i]) {
        if (e[i] == x) {
            return true;
        }
    }
    return false;
}

int n;

int main() {
    cin >> n;

    memset(h, -1, sizeof h);  //将槽先清空 空指针一般用 -1 来表示

    while (n--) {
        string op;
        int x;
        cin >> op >> x;
        if (op == "I") {
            insert(x);
        } else {
            if (find(x)) {
                puts("Yes");
            } else {
                puts("No");
            }
        }
    }
    return 0;
}

```

#### 双散列*

冲突函数：`f(i) = i * hash2(key)`，典型取法是令`hash2(key)=PRIME – (key ％ PRIME)`，其中 PRIME 是小于散列表大小的质数。

双散列（`double hashing`）使用两个散列函数`H(key)和hash2(key)`。`hash2(key)`也以关键字为自变量，产生一个`l至m-1`之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)。

无论是线性探测还是二次探测，当装载因子过高时，哈希表能否动态增长？

要扩充哈希表，首先必须找下一个新的且够大(大约2倍)的质数，然后必须考虑重哈希的成本。我们不可能原封不动的拷贝，必须要检验旧表格中的每个元素，计算其在新表格中的位置，然后再插入到新表格中。

#### 平方探查法*

冲突函数：是i的二次多项式，典型取法为f(i)=i^2。

平方探测法`（Quadratic Probing）`即是发生冲突时，用发生冲突的单元`H(key)`, 加上 `1²、 2²等，即H(key) + 1²，H(key) + 2²，H(key) + 3²...直到找到空闲单元。f(i)也可以构造为：±i^2,i=1,2,3,...,k`。

在实际操作中，平方探测法不能探查到全部剩余的桶。不过在实际应用中，散列表如果大小是素数，并且至少有一半是空的，那么，总能够插入一个新的关键字。若探查到一半桶仍未找一个空闲的，表明此散列表太满，应该重哈希。平方探测法是解决线性探测中一次聚集问题的解决方法，但是，她引入了被称为二次聚集的问题——散列到同一个桶的那些元素将探测到相同的备选桶。下面的技术将会排除这个遗憾，不过要付出计算一个附加的哈希函数的代价。

### [字符串哈希](https://www.bilibili.com/video/BV1Ha411E7re/?spm_id_from=333.999.0.0&vd_source=731595967596af37618c926a191e7811)*( 草稿 )

```c++
//字符串hash
 构造唯一数据表示字符串，可以理解为 f(x) = y。就是通过某种方法转化，使得两个毫无相关的数据产生关系。但是为了将映射关系进行一一对应，也就是，一个字符串对应一个数字，那么一个数字也对应一个字符串。
 用字符串Hash的目的是，我们如果要比较一个字符串，我们不直接比较字符串，而是比较它对应映射的数字，这样子就知道两个“子串”是否相等。从而达到，子串的Hash值的时间为 O(1)，进而可以利用“空间换时间”来节省时间复杂的。
    我们希望这个映射是一个单射，所以问题就是如何构造这个Hash函数，使得他们成为一个单射。不用担心，接下来的内容正要讲解。//我们只需要用到数字来匹配数据，这样对数字操作就可以得到我们想要的操作了
```

#### 构造字符串hash

```c++
//简单例子
 假如给你一个数字1166，形式上你只知道它只是1和6的组合，但你知道它代表的实际大1*10^3+1*10^2+6*10^1+6*10^0。
 同理，给你一个字符串，要把它转换为数字，就可以先把每一个字符都先对应一个数字，然后把它们按照顺序乘以进制（Base）的幂进行相加，然后这个数可能很大，所以一般会取余数（MOD）。    
//具体操作
    根据上面的理解，其实将字符串映射成数字，和我们平时的将一个 某Base进制数，变为一个十进制数，相类似。//把字符串当成 某种进制的数据，把字符串拆成很多位，然后对每一个位置的字符都进行哈希操作，再用进制的乘法操作将他们拼接起来。
 我们先定义以下：
 给定一个字符串 S = s1s2s3...sn，对于每一个si就是一个字母，那么我们规定
         idx(si) = si-'a'+1 （当然也可以直接用其ASCII值）
 构造字符串Hash总共有三种方法。每一种方法，主要都是用使用 Base 和 MOD（都要求是素数），一般都是 Base  < MOD，同时将Base和MOD尽量取大即可，这种情况下，冲突（即不同字符串却有着相同的hash值）的概率是很低的

//1.自然溢出方法 - 后面还有
 对于自然溢出方法，我们定义 Base ，而MOD对于自然溢出方法，就是 unsigned long long 整数的自然溢出
```

```c++
//怎么构建我们的字符串前缀
  1.将整个数组 当做是一个p进制的数。 通过这样的方式，将我们的字符串变成数字进行操作（本质上 字符串也是数字） - 但是我们这个数组转化完成可能会非常大 那么我们就mod一个大的数据 - 通过这样的方法映射到小区间中 //取模会重复怎么办 还是说随机存储
    2.字符串哈希完全不考虑冲突的情况 
    3. p = 131 or 13331 - Q = 2e64 这样可以忽略冲突 （溢出等价于 mod 2e64）
```

![image-20230226201946750](字符串哈希.png)

标准流程

![原理](字符串hash1.png)

![原理2](字符串hash2.png)

```c++
//相当于将字符型映射为整型（本来就是 将字符串映射成一个p进制的数据 - p一般为质数）
typedef unsigned long long ULL;
const int P = 131;
// p[i] = P^i, h[i] = s[1~i]的hash值
ULL p[N],h[N];

//预处理
void init()
{
    //字符串长度就是对应的进制 p^n - 也可以说是长度是项数的个数
    p[0] = 1,h[0] = 0;
    for(int i = 1;i<=n;i++){
        p[i] = p[i-1]*P; //P是进制
        h[i] = h[i-1]*P+s[i];//s是对应字符的ASCII值是吧
    }
}
//计算s[l~r]的哈希值
ULL get(int l,int r)
{
    return h[r]-h[l-1]*p[r-l+1];
}
//判断两个子串是否相等
bool substr(int l1,int r1,int l2,int r2){
    return get(l1,r1) == get(l2,r2);
}

//总结：字符串哈希使用来解决字符串匹配，查找去重的问题的。
```

![原理3](字符串hash原理3.png)

## [高精度](https://oi-wiki.org/math/bignum/)

在平常的实现中，高精度数字利用字符串表示，每一个字符表示数字的一个十进制位。因此可以说，高精度数值计算实际上是一种特别的字符串处理。

读入字符串时，数字最高位在字符串首（下标小的位置）。但是习惯上，下标最小的位置存放的是数字的 **最低位**，即存储反转的字符串。这么做的原因在于，数字的长度可能发生变化，但我们希望同样权值位始终保持对齐（例如，希望所有的个位都在下标 `[0]`，所有的十位都在下标 `[1]`……）；同时，加、减、乘的运算一般都从个位开始进行（回想小学的竖式运算），这都给了「反转存储」以充分的理由。（还有一个很重要的点，倒序可以消除前导0）

### 存储与读入

我们读入的数据是一个很长很长的数字，我们可以用字符串存储或者使用数组存储。下面是读入模板：

```c++
//初始化
void clear(int a[]){
    for(int i = 0;i< LEN;++i) a[i] = 0;
}

//读取数据
void read(int a[]){
    static char s[LEN+1];
	//输入字符串
    scanf("%s",s);    
    clear(a);
    //长度
    int len = strlen(s);
    //数据字符最小位置 - 转化
    for(int i = 0;i<len;++i) a[len-i-1] = s[i] - '0';
}
```

打印模版

```c++
//打印数据
void print(int a[]){
	int i;
    for(i = LEN - 1;i>=1;--i) if(a[i] != 0) break;
    //putchar 打印一个字符 这里传入的是int所以说要转化为char
    for(;i>=0;--i) putchar(a[i] + '0');
    putchar('\n');
}
```

### **高精度加法计算**

```c++
#include<cstdio>
#include<cstring>

static const int LEN = 1004;

int a[LEN],b[LEN],c[LEN];

void clear(int a[])
{
    for(int i = 0;i<=LEN;++i) a[i] = 0;
}

void read(int a[]){
    //用字符数组存储
    static char s[LEN+1];
    scanf("%s",s); //这里输入可以连续存入？
    
    //插入的数组 - 清理一下
    clear(a);
    int len = strlen(s);
    //转化为整数 - 高位在右低位在左
    for(int i = 0;i<len;++i) a[len-i-1] = s[i] - '0';    
}

void print(int a[]){
	int i;
    //打印低到高位置
    for(i = LEN - 1;i>=1;--i) if(a[i]!=0) break;
    //这里的i已经初始化为LEN-1了
    for(;i>=0;--i) putchar(a[i] + '0');
    putchar("\n");
}

void add(int a[],int b[],int c){
    clear(c);
    //先+再处理
    for(int i = 0;i<LEN-1;++i){
        c[i] += a[i]+b[i];
        //处理，进1
        if(c[i]>=10){
            c[i+1] += 1; 
            c[i]-=10;
        }
    }
}

int main(){
    read(a);
    read(b);
    
    add(a,b,c);
    print(c);
    return 0;
}
```

### **高精度减法计算**

减法和加法一样，只不过进位变为了借位。

```c++
void sub(int a[], int b[], int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    // 逐位相减
    c[i] += a[i] - b[i];
    if (c[i] < 0) {
      // 借位
      c[i + 1] -= 1;
      c[i] += 10;
    }
  }
}
```

不过需要注意，竖式计算的减法，需要上面大于下面：

```c++
#include <cstdio>
#include <cstring>

static const int LEN = 1004;

int a[LEN], b[LEN], c[LEN];

void clear(int a[]) {
  for (int i = 0; i < LEN; ++i) a[i] = 0;
}

void read(int a[]) {
  static char s[LEN + 1];
  scanf("%s", s);

  clear(a);

  int len = strlen(s);
  for (int i = 0; i < len; ++i) a[len - i - 1] = s[i] - '0';
}

void print(int a[]) {
  int i;
  for (i = LEN - 1; i >= 1; --i)
    if (a[i] != 0) break;
  for (; i >= 0; --i) putchar(a[i] + '0');
  putchar('\n');
}

void sub(int a[], int b[], int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    c[i] += a[i] - b[i];
    if (c[i] < 0) {
      c[i + 1] -= 1;
      c[i] += 10;
    }
  }
}

int main() {
   read(a);
   read(b);
   //需要判断谁在上面
   if(a>b) sub(a, b, c);
   else sub(b,a,c);  
   print(c);
   return 0;
}
```

### 高精度乘法计算

有两种情况，一种是`小数据*大数据`，另一种就是`大数据*大数据`。如果是第一种，直接把小的数据当成一个值，直接乘`大数据`，再对`大精度`的每一位的处理就行。

![img](multiplication-short.png)

```c++
void mul_short(int a[], int b, int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    // 直接把 a 的第 i 位数码乘以乘数，加入结果
    c[i] += a[i] * b;

    if (c[i] >= 10) {
      // 处理进位
      // c[i] / 10 即除法的商数成为进位的增量值
      c[i + 1] += c[i] / 10;
      // 而 c[i] % 10 即除法的余数成为在当前位留下的值
      c[i] %= 10;
    }
  }
}
```

这种方法，需要`a,b`两个数据不在同一数量级，如果在同一数量级会导致数据溢出。

![img](multiplication-long.png)

第二种方法是竖式乘法，竖式乘法的本质是计算若干个`a*bi*10^i`的和，例如计算`1337 * 42`其实是`1337*2*10^0 + 1337*4*10^1`。

```c++
void mul(int a[], int b[], int c[]) {
  clear(c);

  for (int i = 0; i < LEN - 1; ++i) {
    // 这里直接计算结果中的从低到高第 i 位，且一并处理了进位
    // 第 i 次循环为 c[i] 加上了所有满足 p + q = i 的 a[p] 与 b[q] 的乘积之和
    // 这样做的效果和直接进行上图的运算最后求和是一样的，只是更加简短的一种实现方式
    for (int j = 0; j <= i; ++j) c[i] += a[j] * b[i - j];
	//乘完一轮处理一下
    if (c[i] >= 10) {
      c[i + 1] += c[i] / 10;
      c[i] %= 10;
    }
  }
}
```

### 高精度除法计算*

![img](division.png)

```c++
// 被除数 a 以下标 last_dg 为最低位，是否可以再减去除数 b 而保持非负
// len 是除数 b 的长度，避免反复计算
bool greater_eq(int a[], int b[], int last_dg, int len) {
  // 有可能被除数剩余的部分比除数长，这个情况下最多多出 1 位，故如此判断即可
  if (a[last_dg + len] != 0) return true;
  // 从高位到低位，逐位比较
  for (int i = len - 1; i >= 0; --i) {
    if (a[last_dg + i] > b[i]) return true;
    if (a[last_dg + i] < b[i]) return false;
  }
  // 相等的情形下也是可行的
  return true;
}

void div(int a[], int b[], int c[], int d[]) {
  clear(c);
  clear(d);

  int la, lb;
  for (la = LEN - 1; la > 0; --la)
    if (a[la - 1] != 0) break;
  for (lb = LEN - 1; lb > 0; --lb)
    if (b[lb - 1] != 0) break;
  if (lb == 0) {
    puts("> <");
    return;
  }  // 除数不能为零

  // c 是商
  // d 是被除数的剩余部分，算法结束后自然成为余数
  for (int i = 0; i < la; ++i) d[i] = a[i];
  for (int i = la - lb; i >= 0; --i) {
    // 计算商的第 i 位
    while (greater_eq(d, b, i, lb)) {
      // 若可以减，则减
      // 这一段是一个高精度减法
      for (int j = 0; j < lb; ++j) {
        d[i + j] -= b[j];
        if (d[i + j] < 0) {
          d[i + j + 1] -= 1;
          d[i + j] += 10;
        }
      }
      // 使商的这一位增加 1
      c[i] += 1;
      // 返回循环开头，重新检查
    }
  }
}

```

## 压位高精度

 Karatsuba 乘法和快速除法算法。

## [二分](https://zhuanlan.zhihu.com/p/143879079)

二分查找的思路很简单，我们需要找的数据都是在数组中嘛，只要将这个数组分为两个部分，然后在左边找不到就到右边找，然后再把剩下的数组分为两部分，以此类推。但是需要注意一些细节，Knuth 大佬（发明 KMP 算法的那位）都说二分查找：**思路很简单，细节是魔鬼**

二分查找采用双指针的形式，来对我们数组序列进行遍历。二分查找只使用于排好序的数组，不适用于其他。掌握二分查找的关键是，要明白数组是怎么分成两部分，两部分的边界是什么组成的。

### 暴力

暴力就是按照对应序列一个一个找，直到找到目标为止，没有找到就返回`-1`

```c++
int a[N];
int ans;
for(int i = 1;i<N;i++){
    if(a[i] == ans) return true;
	else break;
}
if(a[N]!=ans) return false;    
```

这可以用蓝红划分数组来解释，假设我们数组开始全是灰色(没有被遍历)，设计一个蓝色指针指向数组的最左边，从左往右扫到蓝红边界，知道扫到目标值。

![image-20230923182039153](./image-20230923182039153.png)

然后也同样，也可以在最右边设计一个红色指针，从右往左扫直到扫到蓝红边界，直到扫到我们的目标值。

![image-20230923182210667](./image-20230923182210667.png)

这样的算法是十分低效的，原因是因为指针移动速度缓慢，每次只能在数组中搜索到一个值的信息。

### 二分细节

在上面，我们用蓝红表示二分数组中两个不同的区域：

![image-20230923181905524](./image-20230923181905524.png)

如果我们在数组中间发现一个指针为蓝色，那么很显然这个指针之前的颜色全为蓝色：

![image-20230923182618450](./image-20230923182618450.png)

同样的我们在右侧发现了一个红色区域块，就可以推断出其右侧区域都是红色

![image-20230923184049459](./image-20230923184049459.png)

通过这样不断操作，直到找到我们的蓝红边界：

![image-20230923184222698](./image-20230923184222698.png)

我们为什么要找蓝红边界，因为二分有几个常见的问题需要我们解决，假设ans是我们需要找到的二分值，对这个值我们有如下问题：

- 找到第一个`>=ans`的元素
- 找到最后一个`<ans`的元素
- 找到第一个`>ans`的元素
- 找到最后一个`<=ans`的元素

对于这个值暂时不去讨论，我们先搞定拓展红蓝色的代码：

```c++
//伪代码
l = -1,r = N;
while(l+1!=r){//直到达到边界
    m = (l+R)/2; //这里需要向下取整？
    if(isBlue(m)) l = m; //蓝色边界蔓延至我们的m
    else r = m; //反之就红色边界蔓延
    return l or r //缩小到最后就是我们要找的目标值
}
```

开始`l`指针指向蓝色区域，`r`指针指向红色区域，循环直到达到边界，**保持`l,r`颜色不发生改变**，遍历结束`l,r`就达到了蓝红边界处。二分查找的时间复杂度是`o(log n)`,也就是一直在折半。

为什么`l`区域初始化为`-1`，这是因为我们需要再数组中分蓝和红区域，如果将`l`初始化为1，恰好数组中全是红色区域，这样就矛盾了。同理，`r`也不可以取`r-1`这个位置，也会导致矛盾。

![image-20230923224009827](./image-20230923224009827.png)

同时验证一下m是否都在数组中，因为`l`最小值是`-1`,`r`最小值是`1`(这里r最小智是因为 `l+1 = r` 如果`r = 0`那么就会直接跳出循环) ，所以说m的最小值也就为 `(1 + 1 )/2= 0`。以此类推，`l`的最大值应该是`N-2`（`N1`跳出循环体循环），那么`r`的最大值也是为`N`(边界嘛)。所以说最大值是`(N-2+N-1)/2 = N/2` 

![image-20230923224046736](./image-20230923224046736.png)

更新指针的时候，都是指向蓝红边界的位置，如果我们改变为`l = m+1`会导致区域发生错误，我们就用更新为`m和r`的模版就行，不会搞乱自己。

![image-20230923224929897](./image-20230923224929897.png)

死循环问题：全部问题都会归类为第一种退出循环的方式

![image-20230923225144185](./image-20230923225144185.png)

![image-20230923225235883](./image-20230923225235883.png)

```c++
//判断值 用m比对我们需要的值 - 需要的值是在左边还是在右边
isBlue(m)

//伪代码
l = -1,r = N;
while(l+1!=r){//直到达到边界
    m = (l+R)/2; //这里需要向下取整？
    if(isBlue(m)) l = m; //蓝色边界蔓延至我们的m
    else r = m; //反之就红色边界蔓延
    return l or r //缩小到最后就是我们要找的目标值
}
```

模版代码：

```c++
#include<iostream>
using namespace std;

const int N = 1e5+10;
int q[N];

int main()
{
    int n,m,k;
    cin>>n>>m;
    for(int i = 0;i<n;i++) cin>>q[i];
    
    //l和r是两个不同的区域蔓延的
    
    while(m--){
        //最开始出现 - 最后出现的位置 - 从0开始计数
        cin>>k;
        //红蓝区域
        int l = -1,r = n+1;
        while(l+1<r){
            int mid = (l+r)/2;
            if(q[mid]>=k) r= mid;
            else l = mid;
        }
        if(q[r] == k){
            //红色区域将二分点包括了
            cout<<r<<" ";
            r = n;
            //找到二分边界
            while(l+1<r){
                int mid = (l+r)/2;
                if(q[mid]<=k) l = mid;
                else r = mid;
            }
            //蓝色区域将二分点包括了
            cout<<l<<endl;
        }
        else out<<"-1 -1"<<endl;
    }
    
    
}
```

### `STL`中的二分

`stl`中，有基于二分查找原理所构造的函数体：

`lower_bound()`函数用于在指定区域内查找不小于目标值的第一个元素，也就是查找和目标值相等或者比目标值大的数据。用法：

```c++
//在[first,last]中查找不小于val的元素
ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last,const T& val);
//在 [first, last) 区域内查找第一个不符合 comp 规则的元素
ForwardIterator lower_bound (ForwardIterator first, ForwardIterator last, const T& val, Compare comp);
```

`upper_bound()`函数，用于指向查找范围内大于目标值的第一个元素，用法：

```c++
//查找[first, last)区域中第一个大于 val 的元素。
ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last,const T& val);
//查找[first, last)区域中第一个不符合 comp 规则的元素
ForwardIterator upper_bound (ForwardIterator first, ForwardIterator last, const T& val, Compare comp);
```

## [二分答案](https://zhuanlan.zhihu.com/p/616523429)

二分答案可以简单的分为两个部分：

- 求取我们最大化的答案

- 求取最小化答案

用简单例题来说明二分：

> 现在有n组货物需要通过卡车运送，每组货物的量可以用一个整数ai表示。我们用数组a=[a1, a2, ..., an]表示n组货物的量。每量卡车的运载量为一个固定的整数k。运送货物时，如果某一组货的量ai超过了卡车的运载量k，这组货可以被分到多量卡车上进行运送。但是，不同组的货不能混装到同一辆卡车上。换句话说，一辆卡车只能运送一组货的一部分，即使它没有满载也不能同时运送另一组货。问题为：如果想要同时运送所有的n组货物，至少需要多少量卡车？

也就是说，只需要将货车容量作为基准值，然后让总数整除，然后需要的卡车数 = 总数整除 +1就行。这道题其实可以不用二分，但是我们也可以稍微用二分的思想来解决这个问题，假设我们可以派出的车辆为 `0 - 无限`，我们需要找到的答案就在这个区间之内，找到的条件就用这个`ceil(ai / n)`，在这个答案的右边，无论派出的车辆为何值，都可以符合我们的问题，在左边无论车辆为何值，都不可能符合我们的问题，这就是简单的二分答案思想，我们需要找的就是这个二分点。

![img](./v2-91b59a74480a54e2579855a80cb9ffb4_720w.webp)

当然，正如写这篇[博客](https://zhuanlan.zhihu.com/p/616523429)的博主所说，这样的问题其实不用二分，只要我们找到指定值就行，但是只要把条件一改，这道题就变得难了起来：

> 其它条件不变。现在我们希望所有的货物可以用至多m辆卡车来运送。问：当卡车的运载量最少为多少时可以满足这一要求？保证m>=n（否则一定无解）。

由博主定义的，我们用C(x)表示**【当卡车运载量为x时，可以用至多m辆卡车来运送】**。那么，题目的要求就等价于，求使得C(x)=True的最小的x。不难发现：

- 如果`C(x)=True`，那么对于任意大于x的值x'，都有`C(x')=True`。这点很好证明：如果在运载量为x的时候，我们能够找到一种方案用至多m辆车完成运送，那么当运载量变为更大的x'时，我们依旧可以采用上述方案来运输，相当于把每辆车多出来的x'-x这部分运载量闲置不用。这显然也是一种用至多m辆车完成运送的方案。
- 类似的，如果C(x)=False，那么对于任意小于x的值x'，都有C(x')=False。证明是类似的。

按照博主的设置

- 设置范围：我们需要求出的在m辆卡车之内运送，所以说区间就应该定为`0-m`，这里设置为`m`的目的是为了留出蓝红区间，大家应该懂得。

- 假设范围中间值为`mid`，用`mid`验证条件是高了还是低了，例如当前这个`mid`可以满足我们的需求：`【当卡车运载量为x时，可以用至多m辆卡车来运送】`，也就是红色区域蔓延过来了，那么我们就往蓝色区域继续蔓延，看看前面是不是还能更省卡车和容量。同理如果不符合，就蓝色区域蔓延，原理是一样的，但是左右逻辑是不一样的（一个是符合了找最低，一个是不符合找符合）。

- 然后缩小区间，直到找到`红蓝边界点`即可。

> 可以理解，`l`从左到右是蓝，`r`从右到左是红

这一二分算法的关键在于第2步中是否能够高效的“验证mid是否满足条件”。给定运载量求卡车数量是简单的：给定运载量为mid，我们可以轻松的求出至少需要多少量卡车。如果这个数量小于等于m，则mid满足要求，否则不满足要求。

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>

using namespace std;

int calcMinVolume(vector<int> a, int m) {
    int l = 0;
    int r = *max_element(a.begin(), a.end());

    while (l != r - 1) {
        int mid = (l + r) / 2;
        int sum = 0;
        
        for (int e : a) {
            sum += ceil((double)e / mid);
        }
        
        if (sum <= m) {
            r = mid;
        } else {
            l = mid;
        }
    }
	//这里求的是最少，也就是从
    return r;
}

int main() {
    vector<int> a = {2, 3, 5, 7, 8};
    int m = 9;

    int result = calcMinVolume(a, m);
    cout << "Minimum volume: " << result << endl;

    return 0;
}
```

通过上边的例题，我们可以看出来，二分答案法适合解决满足以下性质的问题：

- 问题的目标是，给定条件C(x)，求满足条件C(x)的某个最小值t（其实也有可能是求最大值，但是求最大值和求最小值是对偶问题，所以本文就以求最小值来表述了）。
- 目标的最小值t是一个分界点。小于t的值都不满足条件C(x)，大于等于t的值都满足条件C(x)。
- 可以比较容易的确定一个粗略的初始范围，使得分界点t一定处于这一初始范围内。这个范围哪怕很大也没有关系，因为我们会用二分法来缩小这个范围，这是很快的。
- 给定一个值t'，可以比较容易的验证t'是否满足条件C(x)。

## [快速读取](https://blog.csdn.net/m0_56494923/article/details/124568375)

