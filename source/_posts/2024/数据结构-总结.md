---
title: 数据结构 - 总结
date: 2024-04-16 15:06:52
tags: 算法
categories: 算法
typora-root-url: ./数据结构-总结
---

# 数据结构

> 对于我在大学中学习的数据结构做一个总结，之前走了太多的弯路。同时也记录一下考研数据结构的内容。用的教材是王道的。

## 第一章 - 绪论

### 数据基本概念

> 按照教材的原文，在其中补充我的理解，还有课后习题会写出相应的代码。

![image-20240416152423854](/image-20240416152423854.png)

![image-20240416152415165](/image-20240416152415165.png)

这两段需要记住的只有最后一句话，**算法的设计取决于选定的逻辑结构，算法的实现依赖于采用的存储结果.**

对于数据类型来说，抽象数据结构是由不同类来创建的。例如我有一个动物类，创建了一个抽象的类型，这个类型用于调用这个动物类的一些方法。

![image-20240416172232460](image-20240416172232460.png)

线性结构和非线性结构的区别就是：线性结构从开头走到结尾只有一条路。非线性可以有多条路。同时也可以用对应关系来理解。

![image-20240416172426064](image-20240416172426064.png)

![image-20240416172435984](image-20240416172435984.png)

![image-20240416172444116](image-20240416172444116.png)

需要记住的是这些存储的优点和缺点

- 顺序存储结构的有点是**实现随机存储**，缺点是声明存储单元时需要一整块内存区域

- 链式存储优点是**可以利用所有区域的存储资源**，缺点是使用了指针占用了其他的存储资源，而且储存逻辑也是线性的

- 索引存储的有点是查找速度快，类似于字典。缺点是附加了索引值`index`，增加值或者减去值都需要修改索引表

- 散列，通过映射的方法将数据压缩存储。优点是检索，可以理解为字典，缺点是设计散列函数麻烦，可能会引发哈希冲突。

  

![image-20240416172936957](image-20240416172936957.png)

![image-20240416173003841](image-20240416173003841.png)

第一题选D，数据结构可以理解为抽象数据类型声明的对象。这里可以简单理解为数据结构是抽象数据类型声明的实例

![image-20240416173626552](image-20240416173626552.png)

第二题选A，树可以由一个起点走不同的路到达终点，所以说它是非线性数据结构

![image-20240416173825424](image-20240416173825424.png)

逻辑结构指数据元素之间的相互关系，但是不考虑它们在计算机内存中的存储方式。这题选C.哈希表不是逻辑结构，是一种散列结构。**哈希表的核心思想是将数据元素存储在数组中，通过哈希函数将数据元素的关键字映射到数组的索引位置，从而实现快速的数据查找和访问。**

![image-20240416174333361](image-20240416174333361.png)

这题选D，栈是抽象数据结构也就是类。这里标注一下，在程序中我们声明一个变量需要标注其数据结构，所有可以声明的变量类似于(c语言内没有内置栈)

```c#
Stack<int> a = new Stack<int>();
```

![image-20240416213310338](image-20240416213310338.png)

选择A，这道题不是很懂

![image-20240416213540779](image-20240416213540779.png)

![image-20240416213604170](image-20240416213604170.png)

选择C，这个可以用链表的存储结构来解释。链表通常有两个属性来决定，一个是指向下一个值的地址，一个是当前地址的值。**所以说存储的不单单有值，而且也有两个数据之间的关系。**

![image-20240416213802402](image-20240416213802402.png)

选A，刚开始选的是C。后面发现错误了，每一个值的存储位置是连续的，不同值的存储位置可能不一样所以说就不连续。

![image-20240416214034174](image-20240416214034174.png)

- 对于数据结构来说，我们先搞清楚逻辑结构和物理结构是什么。逻辑结构是对于数据对象之间的关系，如果数据对象是一对一的关系，例如数组的索引与在数组中数据的排序对应。还有一对多图关系。还有数据的等级相同的集合关系，还有对应的层次类似于文件夹和文件的关系。物理结构是存储在内存中的位置关系，例如数组在内存是声明一块的内存用于存储数据，链表则是利用指针收集零散的位置来存储我们的数据。回到问题本身，对于两种不同的数据结构，他们的逻辑结构和物理结构可能相同，例如二叉树和二叉排序树，**但是在最终的输出和时间复杂度却不相同，原因是他们所赋予的逻辑结构和数据的运算任务不同。**

![image-20240416220127179](image-20240416220127179.png)

- 例如，线性表可以用顺序存储方式实现也就是数组，也可以用链式存储方式也就是链表。他们在插入和删除元素的时候，时间复杂度不一样。对于链表来说，插入和删除很困难，这是由于有地址的存在，需要让这个指针有意义就需要更改指向位置。这里我之前[写过](https://wniee.cn/2023/04/27/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/?highlight=%E9%93%BE%E8%A1%A8)

![image-20240416220529051](image-20240416220529051.png)

### 算法评价

![image-20240416221100022](image-20240416221100022.png)

概念性的东西只能背了。简单过一遍就行

![image-20240416221144299](image-20240416221144299.png)

占时间复杂度最多的就是循环，更多的就是递归。

![image-20240416221237259](image-20240416221237259.png)

![image-20240416221551144](image-20240416221551144.png)

接下来的空间复杂度就要估算数据结构的大小了

![image-20240416221636077](image-20240416221636077.png)

开始做题：

![image-20240416221652875](image-20240416221652875.png)

选择B和C，第二题不用多说，时间复杂度是简单估算大概要花多少时间。第一题，**算法是解决问题或执行任务的明确、有序且有效的计算过程。也就是问题求解步骤的描述**

![image-20240416222126754](image-20240416222126754.png)

`i`会在每次循环的时候翻倍，直接看到最后一次循环，设最后一次循环的`i`的值为`K`，则退出循环的时候应该有`2^k > n` 也就是 `k > log n`

**所以说选择D，但是教材选择C我这里是觉得教材错了**

![image-20240416223324046](image-20240416223324046.png)

直接跳到最后一次循环，设最后一次循环的`i`的值是`K = i^3`。所以说退出循环需要，`i^3 <=n` 所以说选择C

![image-20240416223702501](image-20240416223702501.png)

不看最后的执行表达式，直接看两个循环的关系，也即是看`i和j`。对于`i`整个循环长度是 `n`。对于`j`来说，它的长度是`1+2+3+...+n`，这个等差数列我们学过，它趋向于`(n^2+n) / 2` 。最终执行语句的次数的等级就是`n^2`。

![image-20240416225213671](image-20240416225213671.png)

![image-20240416225851691](image-20240416225851691.png)

这道题不太懂（biaoji）

![image-20240416230028955](image-20240416230028955.png)

![image-20240416230432110](image-20240416230432110.png)

纯概念的东西。(biaoji)

![image-20240416230541741](image-20240416230541741.png)

![image-20240416230724092](image-20240416230724092.png)

设总执行次数为`t`，则有`2^(t+1)<n/2` 然后取对数就行。总算会算了。精髓就是用总执行次数替换循环条件位置的x

![image-20240416231106099](image-20240416231106099.png)

![image-20240417211755555](image-20240417211755555.png)

整数阶乘，执行了n次也就是n的时间复杂度选择B

![image-20240417213148292](image-20240417213148292.png)

选择D，循环判断，每次判断两个链表中的变量谁大谁小，然后放入到新的链表中，执行的次数与最大的链表长度相关。下面是简单的代码：

```c++
#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> mergeLists(const std::vector<int>& list1, const std::vector<int>& list2) {
    std::vector<int> mergedList;
    int i = 0, j = 0;

    // 从后往前遍历两个降序列表，将较大的元素依次插入到合并后的列表中
    while (i < list1.size() && j < list2.size()) {
        if (list1[i] > list2[j]) {
            mergedList.push_back(list1[i]);
            i++;
        } else {
            mergedList.push_back(list2[j]);
            j++;
        }
    }

    // 将剩余的元素依次插入到合并后的列表中
    while (i < list1.size()) {
        mergedList.push_back(list1[i]);
        i++;
    }
    while (j < list2.size()) {
        mergedList.push_back(list2[j]);
        j++;
    }

    // 将合并后的列表反转，得到升序列表
    std::reverse(mergedList.begin(), mergedList.end());

    return mergedList;
}

int main() {
    // 示例输入
    std::vector<int> list1 = {10, 8, 6, 4, 2};
    std::vector<int> list2 = {9, 7, 5, 3, 1};

    // 合并两个降序列表为一个升序列表
    std::vector<int> mergedList = mergeLists(list1, list2);

    // 输出合并后的列表
    std::cout << "合并完成的链表为: ";
    for (int num : mergedList) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

![image-20240417222328418](image-20240417222328418.png)

bu，内层循环变量与外层循环无关！首先计算外层的循环次数，设置循环次数为`t`，则`k = 2^t <= n`，所以说循环次数`t<=logn`。内层循环`n`，所以说二者相乘选择C

![image-20240417222539376](image-20240417222539376.png)

![image-20240417223400969](image-20240417223400969.png)

等价于`sum++`，设`t`为退出循环的次数，`sum`运行的次数是`n(n+1)/2`.循环次数满足`(1+t)*t/2<n`，所以说选择C。就像解方程，需要求得满足这个不等式，找出`Sum`这个值增大到退出循环时候的方程是什么即可。

![image-20240417224222547](image-20240417224222547.png)

buhui

![image-20240417224529491](image-20240417224529491.png)

![image-20240417224554251](image-20240417224554251.png)

![image-20240417224821670](image-20240417224821670.png)

明天找这个重点

![image-20240417224833946](image-20240417224833946.png)

我有点找不到重点，还是得总结规律

![image-20240417224908140](image-20240417224908140.png)

## 第二章 - 线性表

### 定义与基本操作

说白了，线性表就是数组，定义有前驱元素和后驱元素。

![image-20240505214019262](/image-20240505214019262.png)

![image-20240505214209504](/image-20240505214209504.png)

```

```

做题：

![image-20240505214708567](/image-20240505214708567.png)

- 01 选择c，线性表是表示数据元素一对一的相邻关系的数据结构
- 02 选择b，字符表示序列的关系
- 03 选择a，前驱元素表示该元素前一个元素

![image-20240505215045120](/image-20240505215045120.png)

- 04 选择a，只有一个元素没有前后元素关系之分

### 线性表顺序表示

在创建线性表的时候，会在内存中开辟一片连续的空间，来记录数组中的数据。

> 线性表存储有两种结构：顺序存储，线性存储

![image-20240505215620139](/image-20240505215620139.png)

下面写一个程序直观的看数组的占位地址情况

```c
#include<stdio.h>

const int N = 10;
int main()
{
	int a[N];
	
	for(int i = 0;i<N;i++)
	{
		// 打印每一个位置的地址 - 看看是否连续 
		printf("数组的地址：%p\n",(void *)&a[i]);
			
	}
	return 0;
} 
```

输出的结果证明确实是连续的，这里的数组用的数据结构是`int`，大小是四个字节，所以输出的地址码会递增四个字节。

![image-20240505220734777](/image-20240505220734777.png)

线性表是一种抽象的数据结构，可以用基础的数据结构去声明它。书上用的是结构体去创建一个顺序表的结构，我们简单用c来实现这个线性表(其实就是链表)

![image-20240505221004182](/image-20240505221004182.png)

```c++
#include <iostream>
using namespace std;

const int MAX_SIZE = 100; // 假设链表最大节点数为100

class LinkedList {
private:
 int data[MAX_SIZE]; // 存储节点的值
 int next[MAX_SIZE]; // 存储节点之间的连接关系
 int head; // 头指针，表示链表的头节点的索引
 int size; // 链表的当前大小

public:
 LinkedList() : head(-1), size(0) {
     // 初始化连接关系数组，表示链表为空
     for (int i = 0; i < MAX_SIZE; i++) {
         next[i] = -1;
     }
 }

 void insert(int value) {
     // 创建新节点，并将新节点的值存入数组
     data[size] = value;

     if (head == -1) {
         // 如果链表为空，将头指针指向新节点
         head = size;
     } else {
         // 如果链表不为空，将新节点插入到链表的头部
         next[size] = head;
         head = size;
     }

     size++; // 链表大小加1
 }

 void remove(int value) {
     int current = head;
     int prev = -1;

     while (current != -1) {
         if (data[current] == value) {
             if (prev == -1) {
                 head = next[current];
             } else {
                 next[prev] = next[current];
             }

             // 将当前节点从链表中移除
             // 此处可以根据实际情况进行资源回收，但为了简化示例，不做处理
             data[current] = 0;
             next[current] = -1;
             return;
         }

         prev = current;
         current = next[current];
     }
 }

 void display() {
     int current = head;

     while (current != -1) {
         // 打印当前节点的值
         cout << data[current] << endl;

         // 更新 current 指向下一个节点
         current = next[current];
     }

     cout << endl;
 }
};

int main() {
 LinkedList list;

 list.insert(3);
 list.insert(5);
 list.insert(7);

 list.display(); // 输出：7 5 3

 list.remove(5);

 list.display(); // 输出：7 3

 return 0;
}

```

**考点**，顺序表的优点

![image-20240505222900240](/image-20240505222900240.png)

好像写的都是伪代码

![image-20240505222943549](/image-20240505222943549.png)

这里实现的好像是伪代码，没有试过在试卷上写代码。

![image-20240505223353928](/image-20240505223353928.png)

顺序表适合插入数据，只需要链接插入点的两个地址关系就行。但是对于查找数据不太方便。所以说就将之升级为哈希表。

![image-20240505223440797](/image-20240505223440797.png)

顺序表是数组，删除一个数据十分麻烦。

![image-20240505223823525](/image-20240505223823525.png)

![image-20240505223833191](/image-20240505223833191.png)

查找一个数据对于数组比较简单，二分和很多查找都可以运用。但是对于链表就只能一个一个找了。

![image-20240505224038033](/image-20240505224038033.png)

做题：

![image-20240505224349267](/image-20240505224349267.png)

- 01 A 密度大表示用了一整块内存空间
- 02 C 线性表的顺序结构，就是数组
- 03 A 线性表包括顺序结构和线性结构，线性结构是靠逻辑联系起来的

![image-20240505224841719](/image-20240505224841719.png)

- 04 C 随机存储是在o(1)的时间访问下标为i的元素，花的时间和顺序表的元素个数n
- 05 B
- 06 D 顺序表可以按照序号随机存取

![image-20240505225405088](/image-20240505225405088.png)

- A 这个其实不太理解，估计是数组可以方便更改值
- C 数组删除一个节点的值是很复杂的，连续空间就要调动后面的数据。
- C 数组是连续存储的，在输出数据的时候顺序扫描就行，链表是逻辑存储需要找到对应的内存地址然后输出数据，多了一步找到数据。交换数据的时候改变数组内部数据就行，如果是链表的话还要改变其内部的元素存储逻辑（也就是当前数据的下一个数是什么还有上一个数是什么）

![image-20240505230717205](/image-20240505230717205.png)

- C
- C
- C 2
- B 1
- D
- D

![image-20240505231349861](/image-20240505231349861.png)

由于不知道是不是用伪代码实现，这里还是看答案比较好b（￣▽￣）d　，好像确实使用伪代码来实现。

![image-20240505231623885](/image-20240505231623885.png)

 ------今天到此结束-----
