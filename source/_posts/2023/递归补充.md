---
title: 递归补充
date: 2023-09-14 11:25:24
tags: 算法
categories: 算法
typora-root-url: ./递归补充
hidden: true
---

## [递归搜索](https://juejin.cn/post/6844904008595816462)

前面我们所讲的递归，只局限于图的遍历，其实递归可以用来补充条件搜索，讲概念我们应该懂了，递归就是重复调用同一个函数。

以阶层函数为例,如下, 在 factorial 函数中存在着 factorial(n - 1) 的调用，所以此函数是递归函数

```c++
public int factorial(int n) {
    if (n < =1) {
        return 1;
    }
    return n * factorial(n - 1)
}
```

> 进一步剖析「递归」，先有「递」再有「归」，「递」的意思是将问题拆解成子问题来解决， 子问题再拆解成子子问题，...，直到被拆解的子问题无需再拆分成更细的子问题（即可以求解），「归」是说最小的子问题解决了，那么它的上一层子问题也就解决了，上一层的子问题解决了，上上层子问题自然也就解决了,....,直到最开始的问题解决,文字说可能有点抽象，那我们就以阶层 f(6) 为例来看下它的「递」和「归」。
>
> ![img](v2-2dd5924b0c0aae21f92cf468861101dd_720w.webp)
>
> 求解问题`f(6), 由于 f(6) = n * f(5), 所以 f(6) 需要拆解成 f(5) 子问题进行求解，同理 f(5) = n * f(4) ,也需要进一步拆分,... ,直到 f(1), 这是「递」，f(1) 解决了，由于 f(2) = 2 f(1) = 2 也解决了,.... f(n)到最后也解决了`，这是「归」，所以递归的本质是能把问题拆分成具有**相同解决思路**的子问题，。。。直到最后被拆解的子问题再也不能拆分，解决了最小粒度可求解的子问题后，在「归」的过程中自然顺其自然地解决了最开始的问题。
>
> **`归是展开的方程式子合并成一个值，或者各自执行。可以理解+是链接`**

## 递归剪枝

## 递归例题

![image-20230915215507142](image-20230915215507142.png)

最基础的例题，需要将输入的数据枚举排列。

```c++
#include<iostream>
using namespace std;

const int N = 10;
int path[N],st[N];
int n;

void dfs(int u){
    if(u>n){
        //u枚举的是位置
        for(int i = 1;i<=n;i++) cout<<path[i]<<" ";
        cout<<endl;
    }
    //枚举所有的数
    for(int i = 1;i<=n;i++){
        //记录数据使用
        if(!st[i]){
            st[i] = 1;
            path[u] = i;
            dfs(u+1); //枚举数组位置 - 3个位置沾满
            st[i] = 0;
        }
    }
}

int main()
{
    
    cin>>n;
    dfs(1);
    
}
```

> 枚举数 + 枚举位置 = 二维
